{"ast":null,"code":"import { Line } from './line.mjs';\nimport { Polygon } from './polygon.mjs';\nimport { Rect } from './rect.mjs';\nimport { types } from './types.mjs';\nexport function exists(shape1, shape2, shape1opt, shape2opt) {\n  switch (shape1.type) {\n    case types.Line:\n      {\n        switch (shape2.type) {\n          case types.Line:\n            {\n              return lineWithLine(shape1, shape2);\n            }\n        }\n        break;\n      }\n    case types.Ellipse:\n      {\n        switch (shape2.type) {\n          case types.Line:\n            {\n              return ellipseWithLine(shape1, shape2);\n            }\n          case types.Ellipse:\n            {\n              return ellipseWithEllipse(shape1, shape2);\n            }\n        }\n        break;\n      }\n    case types.Rect:\n      {\n        switch (shape2.type) {\n          case types.Line:\n            {\n              return rectWithLine(shape1, shape2);\n            }\n          case types.Ellipse:\n            {\n              return rectWithEllipse(shape1, shape2);\n            }\n          case types.Rect:\n            {\n              return rectWithRect(shape1, shape2);\n            }\n        }\n        break;\n      }\n    case types.Polyline:\n      {\n        switch (shape2.type) {\n          case types.Line:\n            {\n              return polylineWithLine(shape1, shape2);\n            }\n          case types.Ellipse:\n            {\n              return polylineWithEllipse(shape1, shape2);\n            }\n          case types.Rect:\n            {\n              return polylineWithRect(shape1, shape2);\n            }\n          case types.Polyline:\n            {\n              return polylineWithPolyline(shape1, shape2);\n            }\n        }\n        break;\n      }\n    case types.Polygon:\n      {\n        switch (shape2.type) {\n          case types.Line:\n            {\n              return polygonWithLine(shape1, shape2);\n            }\n          case types.Ellipse:\n            {\n              return polygonWithEllipse(shape1, shape2);\n            }\n          case types.Rect:\n            {\n              return polygonWithRect(shape1, shape2);\n            }\n          case types.Polyline:\n            {\n              return polygonWithPolyline(shape1, shape2);\n            }\n          case types.Polygon:\n            {\n              return polygonWithPolygon(shape1, shape2);\n            }\n        }\n        break;\n      }\n    case types.Path:\n      {\n        switch (shape2.type) {\n          case types.Line:\n            {\n              return pathWithLine(shape1, shape2, shape1opt);\n            }\n          case types.Ellipse:\n            {\n              return pathWithEllipse(shape1, shape2, shape1opt);\n            }\n          case types.Rect:\n            {\n              return pathWithRect(shape1, shape2, shape1opt);\n            }\n          case types.Polyline:\n            {\n              return pathWithPolyline(shape1, shape2, shape1opt);\n            }\n          case types.Polygon:\n            {\n              return pathWithPolygon(shape1, shape2, shape1opt);\n            }\n          case types.Path:\n            {\n              return pathWithPath(shape1, shape2, shape1opt, shape2opt);\n            }\n        }\n        break;\n      }\n  }\n  // None of the cases above\n  switch (shape2.type) {\n    case types.Ellipse:\n    case types.Rect:\n    case types.Polyline:\n    case types.Polygon:\n    case types.Path:\n      {\n        return exists(shape2, shape1, shape2opt, shape1opt);\n      }\n    default:\n      {\n        throw Error(`The intersection for ${shape1} and ${shape2} could not be found.`);\n      }\n  }\n}\n\n/* Line */\n\nexport function lineWithLine(line1, line2) {\n  const x1 = line1.start.x;\n  const y1 = line1.start.y;\n  const x2 = line1.end.x;\n  const y2 = line1.end.y;\n  const x3 = line2.start.x;\n  const y3 = line2.start.y;\n  const x4 = line2.end.x;\n  const y4 = line2.end.y;\n  const s1x = x2 - x1;\n  const s1y = y2 - y1;\n  const s2x = x4 - x3;\n  const s2y = y4 - y3;\n  const s3x = x1 - x3;\n  const s3y = y1 - y3;\n  const p = s1x * s2y - s2x * s1y;\n  const s = (s1x * s3y - s1y * s3x) / p;\n  const t = (s2x * s3y - s2y * s3x) / p;\n  return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n}\n\n/* Ellipse */\n\nexport function ellipseWithLine(ellipse, line) {\n  const rex = ellipse.a;\n  const rey = ellipse.b;\n  const xe = ellipse.x;\n  const ye = ellipse.y;\n  const x1 = line.start.x - xe;\n  const x2 = line.end.x - xe;\n  const y1 = line.start.y - ye;\n  const y2 = line.end.y - ye;\n  const rex_2 = rex * rex;\n  const rey_2 = rey * rey;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const A = dx * dx / rex_2 + dy * dy / rey_2;\n  const B = 2 * x1 * dx / rex_2 + 2 * y1 * dy / rey_2;\n  const C = x1 * x1 / rex_2 + y1 * y1 / rey_2 - 1;\n  const D = B * B - 4 * A * C;\n  if (D === 0) {\n    const t = -B / 2 / A;\n    return t >= 0 && t <= 1;\n  } else if (D > 0) {\n    const sqrt = Math.sqrt(D);\n    const t1 = (-B + sqrt) / 2 / A;\n    const t2 = (-B - sqrt) / 2 / A;\n    return t1 >= 0 && t1 <= 1 || t2 >= 0 && t2 <= 1;\n  }\n  return false;\n}\nexport function ellipseWithEllipse(ellipse1, ellipse2) {\n  return _ellipsesIntersection(ellipse1, 0, ellipse2, 0);\n}\n\n/* Rect */\n\nexport function rectWithLine(rect, line) {\n  const {\n    start,\n    end\n  } = line;\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  if (start.x > x + width && end.x > x + width || start.x < x && end.x < x || start.y > y + height && end.y > y + height || start.y < y && end.y < y) {\n    return false;\n  }\n  if (rect.containsPoint(line.start) || rect.containsPoint(line.end)) {\n    return true;\n  }\n  return lineWithLine(rect.topLine(), line) || lineWithLine(rect.rightLine(), line) || lineWithLine(rect.bottomLine(), line) || lineWithLine(rect.leftLine(), line);\n}\nexport function rectWithEllipse(rect, ellipse) {\n  if (!rectWithRect(rect, Rect.fromEllipse(ellipse))) return false;\n  return polygonWithEllipse(Polygon.fromRect(rect), ellipse);\n}\nexport function rectWithRect(rect1, rect2) {\n  return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;\n}\n\n/* Polyline */\n\nexport function polylineWithLine(polyline, line) {\n  return _polylineWithLine(polyline, line, {\n    interior: false\n  });\n}\nexport function polylineWithEllipse(polyline, ellipse) {\n  return _polylineWithEllipse(polyline, ellipse, {\n    interior: false\n  });\n}\nexport function polylineWithRect(polyline, rect) {\n  return _polylineWithRect(polyline, rect, {\n    interior: false\n  });\n}\nexport function polylineWithPolyline(polyline1, polyline2) {\n  return _polylineWithPolyline(polyline1, polyline2, {\n    interior: false\n  });\n}\n\n/* Polygon */\n\nexport function polygonWithLine(polygon, line) {\n  return _polylineWithLine(polygon, line, {\n    interior: true\n  });\n}\nexport function polygonWithEllipse(polygon, ellipse) {\n  return _polylineWithEllipse(polygon, ellipse, {\n    interior: true\n  });\n}\nexport function polygonWithRect(polygon, rect) {\n  return _polylineWithRect(polygon, rect, {\n    interior: true\n  });\n}\nexport function polygonWithPolyline(polygon, polyline) {\n  return _polylineWithPolyline(polygon, polyline, {\n    interior: true\n  });\n}\nexport function polygonWithPolygon(polygon1, polygon2) {\n  return _polylineWithPolygon(polygon1, polygon2, {\n    interior: true\n  });\n}\n\n/* Path */\n\nexport function pathWithLine(path, line, pathOpt) {\n  return path.getSubpaths().some(subpath => {\n    const [polyline] = subpath.toPolylines(pathOpt);\n    const {\n      type\n    } = subpath.getSegment(-1);\n    if (type === 'Z') {\n      return polygonWithLine(polyline, line);\n    } else {\n      return polylineWithLine(polyline, line);\n    }\n  });\n}\nexport function pathWithEllipse(path, ellipse, pathOpt) {\n  return path.getSubpaths().some(subpath => {\n    const [polyline] = subpath.toPolylines(pathOpt);\n    const {\n      type\n    } = subpath.getSegment(-1);\n    if (type === 'Z') {\n      return polygonWithEllipse(polyline, ellipse);\n    } else {\n      return polylineWithEllipse(polyline, ellipse);\n    }\n  });\n}\nexport function pathWithRect(path, rect, pathOpt) {\n  return pathWithPolygon(path, Polygon.fromRect(rect), pathOpt);\n}\nexport function pathWithPolyline(path, polyline, pathOpt) {\n  return _pathWithPolyline(path, polyline, pathOpt, {\n    interior: false\n  });\n}\nexport function pathWithPolygon(path, polygon, pathOpt) {\n  return _pathWithPolyline(path, polygon, pathOpt, {\n    interior: true\n  });\n}\nexport function pathWithPath(path1, path2, pathOpt1, pathOpt2) {\n  return path1.getSubpaths().some(subpath => {\n    const [polyline1] = subpath.toPolylines(pathOpt1);\n    const {\n      type\n    } = subpath.getSegment(-1);\n    if (type === 'Z') {\n      return pathWithPolygon(path2, polyline1, pathOpt2);\n    } else {\n      return pathWithPolyline(path2, polyline1, pathOpt2);\n    }\n  });\n}\nfunction _polylineWithLine(polyline, line, opt = {}) {\n  const {\n    interior = false\n  } = opt;\n  let thisPoints;\n  if (interior) {\n    if (polyline.containsPoint(line.start)) {\n      // If any point of the polyline lies inside this polygon (interior = true)\n      // there is an intersection (we've chosen the start point)\n      return true;\n    }\n    const {\n      start,\n      end,\n      points\n    } = polyline;\n    thisPoints = end.equals(start) ? points : [...points, start];\n  } else {\n    thisPoints = polyline.points;\n  }\n  const {\n    length\n  } = thisPoints;\n  const segment = new Line();\n  for (let i = 0; i < length - 1; i++) {\n    segment.start = thisPoints[i];\n    segment.end = thisPoints[i + 1];\n    if (lineWithLine(line, segment)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction _polylineWithEllipse(polyline, ellipse, opt = {}) {\n  const {\n    start,\n    end,\n    points\n  } = polyline;\n  if (ellipse.containsPoint(start)) {\n    return true;\n  }\n  let thisPoints;\n  const {\n    interior = false\n  } = opt;\n  if (interior) {\n    if (polyline.containsPoint(ellipse.center())) {\n      // If any point of the ellipse lies inside this polygon (interior = true)\n      // there is an intersection (we've chosen the center point)\n      return true;\n    }\n    thisPoints = end.equals(start) ? points : [...points, start];\n  } else {\n    thisPoints = points;\n  }\n  const {\n    length\n  } = thisPoints;\n  const segment = new Line();\n  for (let i = 0; i < length - 1; i++) {\n    segment.start = thisPoints[i];\n    segment.end = thisPoints[i + 1];\n    if (ellipseWithLine(ellipse, segment)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction _polylineWithRect(polyline, rect, opt) {\n  const polygon = Polygon.fromRect(rect);\n  return _polylineWithPolygon(polyline, polygon, opt);\n}\nfunction _pathWithPolyline(path, polyline1, pathOpt, opt) {\n  return path.getSubpaths().some(subpath => {\n    const [polyline2] = subpath.toPolylines(pathOpt);\n    const {\n      type\n    } = subpath.getSegment(-1);\n    if (type === 'Z') {\n      return _polylineWithPolygon(polyline1, polyline2, opt);\n    } else {\n      return _polylineWithPolyline(polyline1, polyline2, opt);\n    }\n  });\n}\nfunction _polylineWithPolyline(polyline1, polyline2, opt = {}) {\n  const {\n    interior = false\n  } = opt;\n  let thisPolyline;\n  if (interior) {\n    const {\n      start\n    } = polyline2;\n    if (polyline1.containsPoint(start)) {\n      // If any point of the polyline lies inside this polygon (interior = true)\n      // there is an intersection (we've chosen the start point)\n      return true;\n    }\n    thisPolyline = polyline1.clone().close();\n  } else {\n    thisPolyline = polyline1;\n  }\n  const otherPoints = polyline2.points;\n  const {\n    length\n  } = otherPoints;\n  const segment = new Line();\n  for (let i = 0; i < length - 1; i++) {\n    segment.start = otherPoints[i];\n    segment.end = otherPoints[i + 1];\n    if (polylineWithLine(thisPolyline, segment)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction _polylineWithPolygon(polyline, polygon, opt) {\n  return polygon.containsPoint(polyline.start) || _polylineWithPolyline(polyline, polygon.clone().close(), opt);\n}\nfunction _ellipsesIntersection(e1, w1, e2, w2) {\n  const {\n    cos,\n    sin\n  } = Math;\n  const sinW1 = sin(w1);\n  const cosW1 = cos(w1);\n  const sinW2 = sin(w2);\n  const cosW2 = cos(w2);\n  const sinW1s = sinW1 * sinW1;\n  const cosW1s = cosW1 * cosW1;\n  const sinCos1 = sinW1 * cosW1;\n  const sinW2s = sinW2 * sinW2;\n  const cosW2s = cosW2 * cosW2;\n  const sinCos2 = sinW2 * cosW2;\n  const a1s = e1.a * e1.a;\n  const b1s = e1.b * e1.b;\n  const a2s = e2.a * e2.a;\n  const b2s = e2.b * e2.b;\n  const A1 = a1s * sinW1s + b1s * cosW1s;\n  const A2 = a2s * sinW2s + b2s * cosW2s;\n  const B1 = a1s * cosW1s + b1s * sinW1s;\n  const B2 = a2s * cosW2s + b2s * sinW2s;\n  let C1 = 2 * (b1s - a1s) * sinCos1;\n  let C2 = 2 * (b2s - a2s) * sinCos2;\n  let D1 = -2 * A1 * e1.x - C1 * e1.y;\n  let D2 = -2 * A2 * e2.x - C2 * e2.y;\n  let E1 = -C1 * e1.x - 2 * B1 * e1.y;\n  let E2 = -C2 * e2.x - 2 * B2 * e2.y;\n  const F1 = A1 * e1.x * e1.x + B1 * e1.y * e1.y + C1 * e1.x * e1.y - a1s * b1s;\n  const F2 = A2 * e2.x * e2.x + B2 * e2.y * e2.y + C2 * e2.x * e2.y - a2s * b2s;\n  C1 = C1 / 2;\n  C2 = C2 / 2;\n  D1 = D1 / 2;\n  D2 = D2 / 2;\n  E1 = E1 / 2;\n  E2 = E2 / 2;\n  const l3 = det3([[A1, C1, D1], [C1, B1, E1], [D1, E1, F1]]);\n  const l0 = det3([[A2, C2, D2], [C2, B2, E2], [D2, E2, F2]]);\n  const l2 = 0.33333333 * (det3([[A2, C1, D1], [C2, B1, E1], [D2, E1, F1]]) + det3([[A1, C2, D1], [C1, B2, E1], [D1, E2, F1]]) + det3([[A1, C1, D2], [C1, B1, E2], [D1, E1, F2]]));\n  const l1 = 0.33333333 * (det3([[A1, C2, D2], [C1, B2, E2], [D1, E2, F2]]) + det3([[A2, C1, D2], [C2, B1, E2], [D2, E1, F2]]) + det3([[A2, C2, D1], [C2, B2, E1], [D2, E2, F1]]));\n  const delta1 = det2([[l3, l2], [l2, l1]]);\n  const delta2 = det2([[l3, l1], [l2, l0]]);\n  const delta3 = det2([[l2, l1], [l1, l0]]);\n  const dP = det2([[2 * delta1, delta2], [delta2, 2 * delta3]]);\n  if (dP > 0 && (l1 > 0 || l2 > 0)) {\n    return false;\n  }\n  return true;\n}\nfunction det2(m) {\n  return m[0][0] * m[1][1] - m[0][1] * m[1][0];\n}\nfunction det3(m) {\n  return m[0][0] * m[1][1] * m[2][2] - m[0][0] * m[1][2] * m[2][1] - m[0][1] * m[1][0] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[1][0] * m[2][1] - m[0][2] * m[1][1] * m[2][0];\n}","map":{"version":3,"names":["Line","Polygon","Rect","types","exists","shape1","shape2","shape1opt","shape2opt","type","lineWithLine","Ellipse","ellipseWithLine","ellipseWithEllipse","rectWithLine","rectWithEllipse","rectWithRect","Polyline","polylineWithLine","polylineWithEllipse","polylineWithRect","polylineWithPolyline","polygonWithLine","polygonWithEllipse","polygonWithRect","polygonWithPolyline","polygonWithPolygon","Path","pathWithLine","pathWithEllipse","pathWithRect","pathWithPolyline","pathWithPolygon","pathWithPath","Error","line1","line2","x1","start","x","y1","y","x2","end","y2","x3","y3","x4","y4","s1x","s1y","s2x","s2y","s3x","s3y","p","s","t","ellipse","line","rex","a","rey","b","xe","ye","rex_2","rey_2","dx","dy","A","B","C","D","sqrt","Math","t1","t2","ellipse1","ellipse2","_ellipsesIntersection","rect","width","height","containsPoint","topLine","rightLine","bottomLine","leftLine","fromEllipse","fromRect","rect1","rect2","polyline","_polylineWithLine","interior","_polylineWithEllipse","_polylineWithRect","polyline1","polyline2","_polylineWithPolyline","polygon","polygon1","polygon2","_polylineWithPolygon","path","pathOpt","getSubpaths","some","subpath","toPolylines","getSegment","_pathWithPolyline","path1","path2","pathOpt1","pathOpt2","opt","thisPoints","points","equals","length","segment","i","center","thisPolyline","clone","close","otherPoints","e1","w1","e2","w2","cos","sin","sinW1","cosW1","sinW2","cosW2","sinW1s","cosW1s","sinCos1","sinW2s","cosW2s","sinCos2","a1s","b1s","a2s","b2s","A1","A2","B1","B2","C1","C2","D1","D2","E1","E2","F1","F2","l3","det3","l0","l2","l1","delta1","det2","delta2","delta3","dP","m"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/g/intersection.mjs"],"sourcesContent":["import { Line } from './line.mjs';\nimport { Polygon } from './polygon.mjs';\nimport { Rect } from './rect.mjs';\nimport { types } from './types.mjs';\n\nexport function exists(shape1, shape2, shape1opt, shape2opt) {\n    switch (shape1.type) {\n        case types.Line: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return lineWithLine(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Ellipse: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return ellipseWithLine(shape1, shape2);\n                }\n                case types.Ellipse: {\n                    return ellipseWithEllipse(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Rect: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return rectWithLine(shape1, shape2);\n                }\n                case types.Ellipse: {\n                    return rectWithEllipse(shape1, shape2);\n                }\n                case types.Rect: {\n                    return rectWithRect(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Polyline: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return polylineWithLine(shape1, shape2);\n                }\n                case types.Ellipse: {\n                    return polylineWithEllipse(shape1, shape2);\n                }\n                case types.Rect: {\n                    return polylineWithRect(shape1, shape2);\n                }\n                case types.Polyline: {\n                    return polylineWithPolyline(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Polygon: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return polygonWithLine(shape1, shape2);\n                }\n                case types.Ellipse: {\n                    return polygonWithEllipse(shape1, shape2);\n                }\n                case types.Rect: {\n                    return polygonWithRect(shape1, shape2);\n                }\n                case types.Polyline: {\n                    return polygonWithPolyline(shape1, shape2);\n                }\n                case types.Polygon: {\n                    return polygonWithPolygon(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case types.Path: {\n            switch (shape2.type) {\n                case types.Line: {\n                    return pathWithLine(shape1, shape2, shape1opt);\n                }\n                case types.Ellipse: {\n                    return pathWithEllipse(shape1, shape2, shape1opt);\n                }\n                case types.Rect: {\n                    return pathWithRect(shape1, shape2, shape1opt);\n                }\n                case types.Polyline: {\n                    return pathWithPolyline(shape1, shape2, shape1opt);\n                }\n                case types.Polygon: {\n                    return pathWithPolygon(shape1, shape2, shape1opt);\n                }\n                case types.Path: {\n                    return pathWithPath(shape1, shape2, shape1opt, shape2opt);\n                }\n            }\n            break;\n        }\n    }\n    // None of the cases above\n    switch (shape2.type) {\n        case types.Ellipse:\n        case types.Rect:\n        case types.Polyline:\n        case types.Polygon:\n        case types.Path: {\n            return exists(shape2, shape1, shape2opt, shape1opt);\n        }\n        default: {\n            throw Error(`The intersection for ${shape1} and ${shape2} could not be found.`);\n        }\n    }\n}\n\n/* Line */\n\nexport function lineWithLine(line1, line2) {\n    const x1 = line1.start.x;\n    const y1 = line1.start.y;\n    const x2 = line1.end.x;\n    const y2 = line1.end.y;\n    const x3 = line2.start.x;\n    const y3 = line2.start.y;\n    const x4 = line2.end.x;\n    const y4 = line2.end.y;\n    const s1x = x2 - x1;\n    const s1y = y2 - y1;\n    const s2x = x4 - x3;\n    const s2y = y4 - y3;\n    const s3x = x1 - x3;\n    const s3y = y1 - y3;\n    const p = s1x * s2y - s2x * s1y;\n    const s = (s1x * s3y - s1y * s3x) / p;\n    const t = (s2x * s3y - s2y * s3x) / p;\n    return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n}\n\n/* Ellipse */\n\nexport function ellipseWithLine(ellipse, line) {\n    const rex = ellipse.a;\n    const rey = ellipse.b;\n    const xe = ellipse.x;\n    const ye = ellipse.y;\n    const x1 = line.start.x - xe;\n    const x2 = line.end.x - xe;\n    const y1 = line.start.y - ye;\n    const y2 = line.end.y - ye;\n    const rex_2 = rex * rex;\n    const rey_2 = rey * rey;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const A = dx * dx / rex_2 + dy * dy / rey_2;\n    const B = 2 * x1 * dx / rex_2 + 2 * y1 * dy / rey_2;\n    const C = x1 * x1 / rex_2 + y1 * y1 / rey_2 - 1;\n    const D = B * B - 4 * A * C;\n    if (D === 0) {\n        const t = -B / 2 / A;\n        return t >= 0 && t <= 1;\n    } else if (D > 0) {\n        const sqrt = Math.sqrt(D);\n        const t1 = (-B + sqrt) / 2 / A;\n        const t2 = (-B - sqrt) / 2 / A;\n        return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);\n    }\n    return false;\n}\n\nexport function ellipseWithEllipse(ellipse1, ellipse2) {\n    return _ellipsesIntersection(ellipse1, 0, ellipse2, 0);\n}\n\n/* Rect */\n\nexport function rectWithLine(rect, line) {\n    const { start, end } = line;\n    const { x, y, width, height } = rect;\n    if (\n        (start.x > x + width && end.x > x + width)\n        || (start.x < x && end.x < x)\n        || (start.y > y + height && end.y > y + height)\n        || (start.y < y && end.y < y)\n    ) {\n        return false;\n    }\n    if (rect.containsPoint(line.start) || rect.containsPoint(line.end)) {\n        return true;\n    }\n    return lineWithLine(rect.topLine(), line)\n        || lineWithLine(rect.rightLine(), line)\n        || lineWithLine(rect.bottomLine(), line)\n        || lineWithLine(rect.leftLine(), line);\n}\n\nexport function rectWithEllipse(rect, ellipse) {\n    if (!rectWithRect(rect, Rect.fromEllipse(ellipse))) return false;\n    return polygonWithEllipse(Polygon.fromRect(rect), ellipse);\n}\n\nexport function rectWithRect(rect1, rect2) {\n    return rect1.x < rect2.x + rect2.width\n        && rect1.x + rect1.width > rect2.x\n        && rect1.y < rect2.y + rect2.height\n        && rect1.y + rect1.height > rect2.y;\n}\n\n/* Polyline */\n\nexport function polylineWithLine(polyline, line) {\n    return _polylineWithLine(polyline, line, { interior: false });\n}\n\nexport function polylineWithEllipse(polyline, ellipse) {\n    return _polylineWithEllipse(polyline, ellipse, { interior: false });\n}\n\nexport function polylineWithRect(polyline, rect) {\n    return _polylineWithRect(polyline, rect, { interior: false });\n}\n\nexport function polylineWithPolyline(polyline1, polyline2) {\n    return _polylineWithPolyline(polyline1, polyline2, { interior: false });\n}\n\n/* Polygon */\n\nexport function polygonWithLine(polygon, line) {\n    return _polylineWithLine(polygon, line, { interior: true });\n}\n\nexport function polygonWithEllipse(polygon, ellipse) {\n    return _polylineWithEllipse(polygon, ellipse, { interior: true });\n}\n\nexport function polygonWithRect(polygon, rect) {\n    return _polylineWithRect(polygon, rect, { interior: true });\n}\n\nexport function polygonWithPolyline(polygon, polyline) {\n    return _polylineWithPolyline(polygon, polyline, { interior: true });\n}\n\nexport function polygonWithPolygon(polygon1, polygon2) {\n    return _polylineWithPolygon(polygon1, polygon2, { interior: true });\n}\n\n/* Path */\n\nexport function pathWithLine(path, line, pathOpt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return polygonWithLine(polyline, line);\n        } else {\n            return polylineWithLine(polyline, line);\n        }\n    });\n}\n\nexport function pathWithEllipse(path, ellipse, pathOpt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return polygonWithEllipse(polyline, ellipse);\n        } else {\n            return polylineWithEllipse(polyline, ellipse);\n        }\n    });\n}\n\nexport function pathWithRect(path, rect, pathOpt) {\n    return pathWithPolygon(path, Polygon.fromRect(rect), pathOpt);\n}\n\nexport function pathWithPolyline(path, polyline, pathOpt) {\n    return _pathWithPolyline(path, polyline, pathOpt, { interior: false });\n}\n\nexport function pathWithPolygon(path, polygon, pathOpt) {\n    return _pathWithPolyline(path, polygon, pathOpt, { interior: true });\n}\n\nexport function pathWithPath(path1, path2, pathOpt1, pathOpt2) {\n    return path1.getSubpaths().some(subpath => {\n        const [polyline1] = subpath.toPolylines(pathOpt1);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return pathWithPolygon(path2, polyline1, pathOpt2);\n        } else {\n            return pathWithPolyline(path2, polyline1, pathOpt2);\n        }\n    });\n}\n\nfunction _polylineWithLine(polyline, line, opt = {}) {\n    const { interior = false } = opt;\n    let thisPoints;\n    if (interior) {\n        if (polyline.containsPoint(line.start)) {\n            // If any point of the polyline lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the start point)\n            return true;\n        }\n        const { start, end, points } = polyline;\n        thisPoints = end.equals(start) ? points : [...points, start];\n    } else {\n        thisPoints = polyline.points;\n    }\n    const { length } = thisPoints;\n    const segment = new Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = thisPoints[i];\n        segment.end = thisPoints[i + 1];\n        if (lineWithLine(line, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithEllipse(polyline, ellipse, opt = {}) {\n    const { start, end, points } = polyline;\n    if (ellipse.containsPoint(start)) {\n        return true;\n    }\n    let thisPoints;\n    const { interior = false } = opt;\n    if (interior) {\n        if (polyline.containsPoint(ellipse.center())) {\n            // If any point of the ellipse lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the center point)\n            return true;\n        }\n        thisPoints = end.equals(start) ? points : [...points, start];\n    } else {\n        thisPoints = points;\n    }\n\n    const { length } = thisPoints;\n    const segment = new Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = thisPoints[i];\n        segment.end = thisPoints[i + 1];\n        if (ellipseWithLine(ellipse, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithRect(polyline, rect, opt) {\n    const polygon = Polygon.fromRect(rect);\n    return _polylineWithPolygon(polyline, polygon, opt);\n}\n\nfunction _pathWithPolyline(path, polyline1, pathOpt, opt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline2] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return _polylineWithPolygon(polyline1, polyline2, opt);\n        } else {\n            return _polylineWithPolyline(polyline1, polyline2, opt);\n        }\n    });\n}\n\nfunction _polylineWithPolyline(polyline1, polyline2, opt = {}) {\n    const { interior = false } = opt;\n    let thisPolyline;\n    if (interior) {\n        const { start } = polyline2;\n        if (polyline1.containsPoint(start)) {\n            // If any point of the polyline lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the start point)\n            return true;\n        }\n        thisPolyline = polyline1.clone().close();\n    } else {\n        thisPolyline = polyline1;\n    }\n    const otherPoints = polyline2.points;\n    const { length } = otherPoints;\n    const segment = new Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = otherPoints[i];\n        segment.end = otherPoints[i + 1];\n        if (polylineWithLine(thisPolyline, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithPolygon(polyline, polygon, opt) {\n    return polygon.containsPoint(polyline.start) || _polylineWithPolyline(polyline, polygon.clone().close(), opt);\n}\n\nfunction _ellipsesIntersection(e1, w1, e2, w2) {\n    const { cos, sin } = Math;\n    const sinW1 = sin(w1);\n    const cosW1 = cos(w1);\n    const sinW2 = sin(w2);\n    const cosW2 = cos(w2);\n    const sinW1s = sinW1 * sinW1;\n    const cosW1s = cosW1 * cosW1;\n    const sinCos1 = sinW1 * cosW1;\n    const sinW2s = sinW2 * sinW2;\n    const cosW2s = cosW2 * cosW2;\n    const sinCos2 = sinW2 * cosW2;\n    const a1s = e1.a * e1.a;\n    const b1s = e1.b * e1.b;\n    const a2s = e2.a * e2.a;\n    const b2s = e2.b * e2.b;\n    const A1 = a1s * sinW1s + b1s * cosW1s;\n    const A2 = a2s * sinW2s + b2s * cosW2s;\n    const B1 = a1s * cosW1s + b1s * sinW1s;\n    const B2 = a2s * cosW2s + b2s * sinW2s;\n    let C1 = 2 * (b1s - a1s) * sinCos1;\n    let C2 = 2 * (b2s - a2s) * sinCos2;\n    let D1 = (-2 * A1 * e1.x - C1 * e1.y);\n    let D2 = (-2 * A2 * e2.x - C2 * e2.y);\n    let E1 = (-C1 * e1.x - 2 * B1 * e1.y);\n    let E2 = (-C2 * e2.x - 2 * B2 * e2.y);\n    const F1 = A1 * e1.x * e1.x + B1 * e1.y * e1.y + C1 * e1.x * e1.y - a1s * b1s;\n    const F2 = A2 * e2.x * e2.x + B2 * e2.y * e2.y + C2 * e2.x * e2.y - a2s * b2s;\n\n    C1 = C1 / 2;\n    C2 = C2 / 2;\n    D1 = D1 / 2;\n    D2 = D2 / 2;\n    E1 = E1 / 2;\n    E2 = E2 / 2;\n\n    const l3 = det3([\n        [A1, C1, D1],\n        [C1, B1, E1],\n        [D1, E1, F1]\n    ]);\n    const l0 = det3([\n        [A2, C2, D2],\n        [C2, B2, E2],\n        [D2, E2, F2]\n    ]);\n    const l2 = 0.33333333 * (det3([\n        [A2, C1, D1],\n        [C2, B1, E1],\n        [D2, E1, F1]\n    ]) + det3([\n        [A1, C2, D1],\n        [C1, B2, E1],\n        [D1, E2, F1]\n    ]) + det3([\n        [A1, C1, D2],\n        [C1, B1, E2],\n        [D1, E1, F2]\n    ]));\n    const l1 = 0.33333333 * (det3([\n        [A1, C2, D2],\n        [C1, B2, E2],\n        [D1, E2, F2]\n    ]) + det3([\n        [A2, C1, D2],\n        [C2, B1, E2],\n        [D2, E1, F2]\n    ]) + det3([\n        [A2, C2, D1],\n        [C2, B2, E1],\n        [D2, E2, F1]\n    ]));\n\n    const delta1 = det2([\n        [l3, l2],\n        [l2, l1]\n    ]);\n    const delta2 = det2([\n        [l3, l1],\n        [l2, l0]\n    ]);\n    const delta3 = det2([\n        [l2, l1],\n        [l1, l0]\n    ]);\n\n    const dP = det2([\n        [2 * delta1, delta2],\n        [delta2, 2 * delta3]\n    ]);\n\n    if (dP > 0 && (l1 > 0 || l2 > 0)) {\n        return false;\n    }\n    return true;\n}\n\nfunction det2(m) {\n    return m[0][0] * m[1][1] - m[0][1] * m[1][0];\n}\n\nfunction det3(m) {\n    return m[0][0] * m[1][1] * m[2][2] -\n        m[0][0] * m[1][2] * m[2][1] -\n        m[0][1] * m[1][0] * m[2][2] +\n        m[0][1] * m[1][2] * m[2][0] +\n        m[0][2] * m[1][0] * m[2][1] -\n        m[0][2] * m[1][1] * m[2][0];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}