{"ast":null,"code":"import * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\nimport { Model } from '../mvc/Model.mjs';\nimport { Collection } from '../mvc/Collection.mjs';\nimport { wrappers, wrapWith } from '../util/wrappers.mjs';\nimport { cloneCells } from '../util/index.mjs';\nconst GraphCells = Collection.extend({\n  initialize: function (models, opt) {\n    // Set the optional namespace where all model classes are defined.\n    if (opt.cellNamespace) {\n      this.cellNamespace = opt.cellNamespace;\n    } else {\n      /* eslint-disable no-undef */\n      this.cellNamespace = typeof joint !== 'undefined' && util.has(joint, 'shapes') ? joint.shapes : null;\n      /* eslint-enable no-undef */\n    }\n    this.graph = opt.graph;\n  },\n  model: function (attrs, opt) {\n    const collection = opt.collection;\n    const namespace = collection.cellNamespace;\n    const {\n      type\n    } = attrs;\n\n    // Find the model class based on the `type` attribute in the cell namespace\n    const ModelClass = util.getByPath(namespace, type, '.');\n    if (!ModelClass) {\n      throw new Error(`dia.Graph: Could not find cell constructor for type: '${type}'. Make sure to add the constructor to 'cellNamespace'.`);\n    }\n    const cell = new ModelClass(attrs, opt);\n    // Add a reference to the graph. It is necessary to do this here because this is the earliest place\n    // where a new model is created from a plain JS object. For other objects, see `joint.dia.Graph>>_prepareCell()`.\n    if (!opt.dry) {\n      cell.graph = collection.graph;\n    }\n    return cell;\n  },\n  // `comparator` makes it easy to sort cells based on their `z` index.\n  comparator: function (model) {\n    return model.get('z') || 0;\n  }\n});\nexport const Graph = Model.extend({\n  initialize: function (attrs, opt) {\n    opt = opt || {};\n\n    // Passing `cellModel` function in the options object to graph allows for\n    // setting models based on attribute objects. This is especially handy\n    // when processing JSON graphs that are in a different than JointJS format.\n    var cells = new GraphCells([], {\n      model: opt.cellModel,\n      cellNamespace: opt.cellNamespace,\n      graph: this\n    });\n    Model.prototype.set.call(this, 'cells', cells);\n\n    // Make all the events fired in the `cells` collection available.\n    // to the outside world.\n    cells.on('all', this.trigger, this);\n\n    // JointJS automatically doesn't trigger re-sort if models attributes are changed later when\n    // they're already in the collection. Therefore, we're triggering sort manually here.\n    this.on('change:z', this._sortOnChangeZ, this);\n\n    // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n    // for fast graph queries. All changes that affect the structure of the graph\n    // must be reflected in the `al` object. This object provides fast answers to\n    // questions such as \"what are the neighbours of this node\" or \"what\n    // are the sibling links of this link\".\n\n    // Outgoing edges per node. Note that we use a hash-table for the list\n    // of outgoing edges for a faster lookup.\n    // [nodeId] -> Object [edgeId] -> true\n    this._out = {};\n    // Ingoing edges per node.\n    // [nodeId] -> Object [edgeId] -> true\n    this._in = {};\n    // `_nodes` is useful for quick lookup of all the elements in the graph, without\n    // having to go through the whole cells array.\n    // [node ID] -> true\n    this._nodes = {};\n    // `_edges` is useful for quick lookup of all the links in the graph, without\n    // having to go through the whole cells array.\n    // [edgeId] -> true\n    this._edges = {};\n    this._batches = {};\n    cells.on('add', this._restructureOnAdd, this);\n    cells.on('remove', this._restructureOnRemove, this);\n    cells.on('reset', this._restructureOnReset, this);\n    cells.on('change:source', this._restructureOnChangeSource, this);\n    cells.on('change:target', this._restructureOnChangeTarget, this);\n    cells.on('remove', this._removeCell, this);\n  },\n  _sortOnChangeZ: function () {\n    this.get('cells').sort();\n  },\n  _restructureOnAdd: function (cell) {\n    if (cell.isLink()) {\n      this._edges[cell.id] = true;\n      var {\n        source,\n        target\n      } = cell.attributes;\n      if (source.id) {\n        (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n      }\n      if (target.id) {\n        (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n      }\n    } else {\n      this._nodes[cell.id] = true;\n    }\n  },\n  _restructureOnRemove: function (cell) {\n    if (cell.isLink()) {\n      delete this._edges[cell.id];\n      var {\n        source,\n        target\n      } = cell.attributes;\n      if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n        delete this._out[source.id][cell.id];\n      }\n      if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n        delete this._in[target.id][cell.id];\n      }\n    } else {\n      delete this._nodes[cell.id];\n    }\n  },\n  _restructureOnReset: function (cells) {\n    // Normalize into an array of cells. The original `cells` is GraphCells mvc collection.\n    cells = cells.models;\n    this._out = {};\n    this._in = {};\n    this._nodes = {};\n    this._edges = {};\n    cells.forEach(this._restructureOnAdd, this);\n  },\n  _restructureOnChangeSource: function (link) {\n    var prevSource = link.previous('source');\n    if (prevSource.id && this._out[prevSource.id]) {\n      delete this._out[prevSource.id][link.id];\n    }\n    var source = link.attributes.source;\n    if (source.id) {\n      (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n    }\n  },\n  _restructureOnChangeTarget: function (link) {\n    var prevTarget = link.previous('target');\n    if (prevTarget.id && this._in[prevTarget.id]) {\n      delete this._in[prevTarget.id][link.id];\n    }\n    var target = link.get('target');\n    if (target.id) {\n      (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n    }\n  },\n  // Return all outbound edges for the node. Return value is an object\n  // of the form: [edgeId] -> true\n  getOutboundEdges: function (node) {\n    return this._out && this._out[node] || {};\n  },\n  // Return all inbound edges for the node. Return value is an object\n  // of the form: [edgeId] -> true\n  getInboundEdges: function (node) {\n    return this._in && this._in[node] || {};\n  },\n  toJSON: function () {\n    // JointJS does not recursively call `toJSON()` on attributes that are themselves models/collections.\n    // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n    var json = Model.prototype.toJSON.apply(this, arguments);\n    json.cells = this.get('cells').toJSON();\n    return json;\n  },\n  fromJSON: function (json, opt) {\n    if (!json.cells) {\n      throw new Error('Graph JSON must contain cells array.');\n    }\n    return this.set(json, opt);\n  },\n  set: function (key, val, opt) {\n    var attrs;\n\n    // Handle both `key`, value and {key: value} style arguments.\n    if (typeof key === 'object') {\n      attrs = key;\n      opt = val;\n    } else {\n      (attrs = {})[key] = val;\n    }\n\n    // Make sure that `cells` attribute is handled separately via resetCells().\n    if (attrs.hasOwnProperty('cells')) {\n      this.resetCells(attrs.cells, opt);\n      attrs = util.omit(attrs, 'cells');\n    }\n\n    // The rest of the attributes are applied via original set method.\n    return Model.prototype.set.call(this, attrs, opt);\n  },\n  clear: function (opt) {\n    opt = util.assign({}, opt, {\n      clear: true\n    });\n    var collection = this.get('cells');\n    if (collection.length === 0) return this;\n    this.startBatch('clear', opt);\n\n    // The elements come after the links.\n    var cells = collection.sortBy(function (cell) {\n      return cell.isLink() ? 1 : 2;\n    });\n    do {\n      // Remove all the cells one by one.\n      // Note that all the links are removed first, so it's\n      // safe to remove the elements without removing the connected\n      // links first.\n      cells.shift().remove(opt);\n    } while (cells.length > 0);\n    this.stopBatch('clear');\n    return this;\n  },\n  _prepareCell: function (cell, opt) {\n    var attrs;\n    if (cell instanceof Model) {\n      attrs = cell.attributes;\n      if (!cell.graph && (!opt || !opt.dry)) {\n        // An element can not be member of more than one graph.\n        // A cell stops being the member of the graph after it's explicitly removed.\n        cell.graph = this;\n      }\n    } else {\n      // In case we're dealing with a plain JS object, we have to set the reference\n      // to the `graph` right after the actual model is created. This happens in the `model()` function\n      // of `joint.dia.GraphCells`.\n      attrs = cell;\n    }\n    if (!util.isString(attrs.type)) {\n      throw new TypeError('dia.Graph: cell type must be a string.');\n    }\n    return cell;\n  },\n  minZIndex: function () {\n    var firstCell = this.get('cells').first();\n    return firstCell ? firstCell.get('z') || 0 : 0;\n  },\n  maxZIndex: function () {\n    var lastCell = this.get('cells').last();\n    return lastCell ? lastCell.get('z') || 0 : 0;\n  },\n  addCell: function (cell, opt) {\n    if (Array.isArray(cell)) {\n      return this.addCells(cell, opt);\n    }\n    if (cell instanceof Model) {\n      if (!cell.has('z')) {\n        cell.set('z', this.maxZIndex() + 1);\n      }\n    } else if (cell.z === undefined) {\n      cell.z = this.maxZIndex() + 1;\n    }\n    this.get('cells').add(this._prepareCell(cell, opt), opt || {});\n    return this;\n  },\n  addCells: function (cells, opt) {\n    if (cells.length === 0) return this;\n    cells = util.flattenDeep(cells);\n    opt.maxPosition = opt.position = cells.length - 1;\n    this.startBatch('add', opt);\n    cells.forEach(function (cell) {\n      this.addCell(cell, opt);\n      opt.position--;\n    }, this);\n    this.stopBatch('add', opt);\n    return this;\n  },\n  // When adding a lot of cells, it is much more efficient to\n  // reset the entire cells collection in one go.\n  // Useful for bulk operations and optimizations.\n  resetCells: function (cells, opt) {\n    var preparedCells = util.toArray(cells).map(function (cell) {\n      return this._prepareCell(cell, opt);\n    }, this);\n    this.get('cells').reset(preparedCells, opt);\n    return this;\n  },\n  removeCells: function (cells, opt) {\n    if (cells.length) {\n      this.startBatch('remove');\n      util.invoke(cells, 'remove', opt);\n      this.stopBatch('remove');\n    }\n    return this;\n  },\n  _removeCell: function (cell, collection, options) {\n    options = options || {};\n    if (!options.clear) {\n      // Applications might provide a `disconnectLinks` option set to `true` in order to\n      // disconnect links when a cell is removed rather then removing them. The default\n      // is to remove all the associated links.\n      if (options.disconnectLinks) {\n        this.disconnectLinks(cell, options);\n      } else {\n        this.removeLinks(cell, options);\n      }\n    }\n    // Silently remove the cell from the cells collection. Silently, because\n    // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n    // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n    // would be triggered on the graph model.\n    this.get('cells').remove(cell, {\n      silent: true\n    });\n    if (cell.graph === this) {\n      // Remove the element graph reference only if the cell is the member of this graph.\n      cell.graph = null;\n    }\n  },\n  // Get a cell by `id`.\n  getCell: function (id) {\n    return this.get('cells').get(id);\n  },\n  getCells: function () {\n    return this.get('cells').toArray();\n  },\n  getElements: function () {\n    return this.get('cells').toArray().filter(cell => cell.isElement());\n  },\n  getLinks: function () {\n    return this.get('cells').toArray().filter(cell => cell.isLink());\n  },\n  getFirstCell: function () {\n    return this.get('cells').first();\n  },\n  getLastCell: function () {\n    return this.get('cells').last();\n  },\n  // Get all inbound and outbound links connected to the cell `model`.\n  getConnectedLinks: function (model, opt) {\n    opt = opt || {};\n    var indirect = opt.indirect;\n    var inbound = opt.inbound;\n    var outbound = opt.outbound;\n    if (inbound === undefined && outbound === undefined) {\n      inbound = outbound = true;\n    }\n\n    // the final array of connected link models\n    var links = [];\n    // a hash table of connected edges of the form: [edgeId] -> true\n    // used for quick lookups to check if we already added a link\n    var edges = {};\n    if (outbound) {\n      addOutbounds(this, model);\n    }\n    if (inbound) {\n      addInbounds(this, model);\n    }\n    function addOutbounds(graph, model) {\n      util.forIn(graph.getOutboundEdges(model.id), function (_, edge) {\n        // skip links that were already added\n        // (those must be self-loop links)\n        // (because they are inbound and outbound edges of the same two elements)\n        if (edges[edge]) return;\n        var link = graph.getCell(edge);\n        links.push(link);\n        edges[edge] = true;\n        if (indirect) {\n          if (inbound) addInbounds(graph, link);\n          if (outbound) addOutbounds(graph, link);\n        }\n      }.bind(graph));\n      if (indirect && model.isLink()) {\n        var outCell = model.getTargetCell();\n        if (outCell && outCell.isLink()) {\n          if (!edges[outCell.id]) {\n            links.push(outCell);\n            addOutbounds(graph, outCell);\n          }\n        }\n      }\n    }\n    function addInbounds(graph, model) {\n      util.forIn(graph.getInboundEdges(model.id), function (_, edge) {\n        // skip links that were already added\n        // (those must be self-loop links)\n        // (because they are inbound and outbound edges of the same two elements)\n        if (edges[edge]) return;\n        var link = graph.getCell(edge);\n        links.push(link);\n        edges[edge] = true;\n        if (indirect) {\n          if (inbound) addInbounds(graph, link);\n          if (outbound) addOutbounds(graph, link);\n        }\n      }.bind(graph));\n      if (indirect && model.isLink()) {\n        var inCell = model.getSourceCell();\n        if (inCell && inCell.isLink()) {\n          if (!edges[inCell.id]) {\n            links.push(inCell);\n            addInbounds(graph, inCell);\n          }\n        }\n      }\n    }\n\n    // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n    if (opt.deep) {\n      var embeddedCells = model.getEmbeddedCells({\n        deep: true\n      });\n\n      // in the first round, we collect all the embedded elements\n      var embeddedElements = {};\n      embeddedCells.forEach(function (cell) {\n        if (cell.isElement()) {\n          embeddedElements[cell.id] = true;\n        }\n      });\n      embeddedCells.forEach(function (cell) {\n        if (cell.isLink()) return;\n        if (outbound) {\n          util.forIn(this.getOutboundEdges(cell.id), function (exists, edge) {\n            if (!edges[edge]) {\n              var edgeCell = this.getCell(edge);\n              var {\n                source,\n                target\n              } = edgeCell.attributes;\n              var sourceId = source.id;\n              var targetId = target.id;\n\n              // if `includeEnclosed` option is falsy, skip enclosed links\n              if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {\n                return;\n              }\n              links.push(this.getCell(edge));\n              edges[edge] = true;\n            }\n          }.bind(this));\n        }\n        if (inbound) {\n          util.forIn(this.getInboundEdges(cell.id), function (exists, edge) {\n            if (!edges[edge]) {\n              var edgeCell = this.getCell(edge);\n              var {\n                source,\n                target\n              } = edgeCell.attributes;\n              var sourceId = source.id;\n              var targetId = target.id;\n\n              // if `includeEnclosed` option is falsy, skip enclosed links\n              if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {\n                return;\n              }\n              links.push(this.getCell(edge));\n              edges[edge] = true;\n            }\n          }.bind(this));\n        }\n      }, this);\n    }\n    return links;\n  },\n  getNeighbors: function (model, opt) {\n    opt || (opt = {});\n    var inbound = opt.inbound;\n    var outbound = opt.outbound;\n    if (inbound === undefined && outbound === undefined) {\n      inbound = outbound = true;\n    }\n    var neighbors = this.getConnectedLinks(model, opt).reduce(function (res, link) {\n      var {\n        source,\n        target\n      } = link.attributes;\n      var loop = link.hasLoop(opt);\n\n      // Discard if it is a point, or if the neighbor was already added.\n      if (inbound && util.has(source, 'id') && !res[source.id]) {\n        var sourceElement = this.getCell(source.id);\n        if (sourceElement.isElement()) {\n          if (loop || sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model))) {\n            res[source.id] = sourceElement;\n          }\n        }\n      }\n\n      // Discard if it is a point, or if the neighbor was already added.\n      if (outbound && util.has(target, 'id') && !res[target.id]) {\n        var targetElement = this.getCell(target.id);\n        if (targetElement.isElement()) {\n          if (loop || targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model))) {\n            res[target.id] = targetElement;\n          }\n        }\n      }\n      return res;\n    }.bind(this), {});\n    if (model.isLink()) {\n      if (inbound) {\n        var sourceCell = model.getSourceCell();\n        if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n          neighbors[sourceCell.id] = sourceCell;\n        }\n      }\n      if (outbound) {\n        var targetCell = model.getTargetCell();\n        if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n          neighbors[targetCell.id] = targetCell;\n        }\n      }\n    }\n    return util.toArray(neighbors);\n  },\n  getCommonAncestor: function /* cells */\n  () {\n    var cellsAncestors = Array.from(arguments).map(function (cell) {\n      var ancestors = [];\n      var parentId = cell.get('parent');\n      while (parentId) {\n        ancestors.push(parentId);\n        parentId = this.getCell(parentId).get('parent');\n      }\n      return ancestors;\n    }, this);\n    cellsAncestors = cellsAncestors.sort(function (a, b) {\n      return a.length - b.length;\n    });\n    var commonAncestor = util.toArray(cellsAncestors.shift()).find(function (ancestor) {\n      return cellsAncestors.every(function (cellAncestors) {\n        return cellAncestors.includes(ancestor);\n      });\n    });\n    return this.getCell(commonAncestor);\n  },\n  // Find the whole branch starting at `element`.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n  getSuccessors: function (element, opt) {\n    opt = opt || {};\n    var res = [];\n    // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n    this.search(element, function (el) {\n      if (el !== element) {\n        res.push(el);\n      }\n    }, util.assign({}, opt, {\n      outbound: true\n    }));\n    return res;\n  },\n  cloneCells: cloneCells,\n  // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n  // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n  // Return a map of the form: [original cell ID] -> [clone].\n  cloneSubgraph: function (cells, opt) {\n    var subgraph = this.getSubgraph(cells, opt);\n    return this.cloneCells(subgraph);\n  },\n  // Return `cells` and all the connected links that connect cells in the `cells` array.\n  // If `opt.deep` is `true`, return all the cells including all their embedded cells\n  // and all the links that connect any of the returned cells.\n  // For example, for a single shallow element, the result is that very same element.\n  // For two elements connected with a link: `A --- L ---> B`, the result for\n  // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n  getSubgraph: function (cells, opt) {\n    opt = opt || {};\n    var subgraph = [];\n    // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n    var cellMap = {};\n    var elements = [];\n    var links = [];\n    util.toArray(cells).forEach(function (cell) {\n      if (!cellMap[cell.id]) {\n        subgraph.push(cell);\n        cellMap[cell.id] = cell;\n        if (cell.isLink()) {\n          links.push(cell);\n        } else {\n          elements.push(cell);\n        }\n      }\n      if (opt.deep) {\n        var embeds = cell.getEmbeddedCells({\n          deep: true\n        });\n        embeds.forEach(function (embed) {\n          if (!cellMap[embed.id]) {\n            subgraph.push(embed);\n            cellMap[embed.id] = embed;\n            if (embed.isLink()) {\n              links.push(embed);\n            } else {\n              elements.push(embed);\n            }\n          }\n        });\n      }\n    });\n    links.forEach(function (link) {\n      // For links, return their source & target (if they are elements - not points).\n      var {\n        source,\n        target\n      } = link.attributes;\n      if (source.id && !cellMap[source.id]) {\n        var sourceElement = this.getCell(source.id);\n        subgraph.push(sourceElement);\n        cellMap[sourceElement.id] = sourceElement;\n        elements.push(sourceElement);\n      }\n      if (target.id && !cellMap[target.id]) {\n        var targetElement = this.getCell(target.id);\n        subgraph.push(this.getCell(target.id));\n        cellMap[targetElement.id] = targetElement;\n        elements.push(targetElement);\n      }\n    }, this);\n    elements.forEach(function (element) {\n      // For elements, include their connected links if their source/target is in the subgraph;\n      var links = this.getConnectedLinks(element, opt);\n      links.forEach(function (link) {\n        var {\n          source,\n          target\n        } = link.attributes;\n        if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n          subgraph.push(link);\n          cellMap[link.id] = link;\n        }\n      });\n    }, this);\n    return subgraph;\n  },\n  // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n  getPredecessors: function (element, opt) {\n    opt = opt || {};\n    var res = [];\n    // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n    this.search(element, function (el) {\n      if (el !== element) {\n        res.push(el);\n      }\n    }, util.assign({}, opt, {\n      inbound: true\n    }));\n    return res;\n  },\n  // Perform search on the graph.\n  // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n  // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // `iteratee` is a function of the form `function(element) {}`.\n  // If `iteratee` explicitly returns `false`, the searching stops.\n  search: function (element, iteratee, opt) {\n    opt = opt || {};\n    if (opt.breadthFirst) {\n      this.bfs(element, iteratee, opt);\n    } else {\n      this.dfs(element, iteratee, opt);\n    }\n  },\n  // Breadth-first search.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n  // `iteratee` is a function of the form `function(element, distance) {}`.\n  // where `element` is the currently visited element and `distance` is the distance of that element\n  // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n  // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n  // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n  // If `iteratee` explicitly returns `false`, the searching stops.\n  bfs: function (element, iteratee, opt = {}) {\n    const visited = {};\n    const distance = {};\n    const queue = [];\n    queue.push(element);\n    distance[element.id] = 0;\n    while (queue.length > 0) {\n      var next = queue.shift();\n      if (visited[next.id]) continue;\n      visited[next.id] = true;\n      if (iteratee.call(this, next, distance[next.id]) === false) continue;\n      const neighbors = this.getNeighbors(next, opt);\n      for (let i = 0, n = neighbors.length; i < n; i++) {\n        const neighbor = neighbors[i];\n        distance[neighbor.id] = distance[next.id] + 1;\n        queue.push(neighbor);\n      }\n    }\n  },\n  // Depth-first search.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n  // `iteratee` is a function of the form `function(element, distance) {}`.\n  // If `iteratee` explicitly returns `false`, the search stops.\n  dfs: function (element, iteratee, opt = {}) {\n    const visited = {};\n    const distance = {};\n    const queue = [];\n    queue.push(element);\n    distance[element.id] = 0;\n    while (queue.length > 0) {\n      const next = queue.pop();\n      if (visited[next.id]) continue;\n      visited[next.id] = true;\n      if (iteratee.call(this, next, distance[next.id]) === false) continue;\n      const neighbors = this.getNeighbors(next, opt);\n      const lastIndex = queue.length;\n      for (let i = 0, n = neighbors.length; i < n; i++) {\n        const neighbor = neighbors[i];\n        distance[neighbor.id] = distance[next.id] + 1;\n        queue.splice(lastIndex, 0, neighbor);\n      }\n    }\n  },\n  // Get all the roots of the graph. Time complexity: O(|V|).\n  getSources: function () {\n    var sources = [];\n    util.forIn(this._nodes, function (exists, node) {\n      if (!this._in[node] || util.isEmpty(this._in[node])) {\n        sources.push(this.getCell(node));\n      }\n    }.bind(this));\n    return sources;\n  },\n  // Get all the leafs of the graph. Time complexity: O(|V|).\n  getSinks: function () {\n    var sinks = [];\n    util.forIn(this._nodes, function (exists, node) {\n      if (!this._out[node] || util.isEmpty(this._out[node])) {\n        sinks.push(this.getCell(node));\n      }\n    }.bind(this));\n    return sinks;\n  },\n  // Return `true` if `element` is a root. Time complexity: O(1).\n  isSource: function (element) {\n    return !this._in[element.id] || util.isEmpty(this._in[element.id]);\n  },\n  // Return `true` if `element` is a leaf. Time complexity: O(1).\n  isSink: function (element) {\n    return !this._out[element.id] || util.isEmpty(this._out[element.id]);\n  },\n  // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n  isSuccessor: function (elementA, elementB) {\n    var isSuccessor = false;\n    this.search(elementA, function (element) {\n      if (element === elementB && element !== elementA) {\n        isSuccessor = true;\n        return false;\n      }\n    }, {\n      outbound: true\n    });\n    return isSuccessor;\n  },\n  // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n  isPredecessor: function (elementA, elementB) {\n    var isPredecessor = false;\n    this.search(elementA, function (element) {\n      if (element === elementB && element !== elementA) {\n        isPredecessor = true;\n        return false;\n      }\n    }, {\n      inbound: true\n    });\n    return isPredecessor;\n  },\n  // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n  // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n  // for more details.\n  // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n  // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n  isNeighbor: function (elementA, elementB, opt) {\n    opt = opt || {};\n    var inbound = opt.inbound;\n    var outbound = opt.outbound;\n    if (inbound === undefined && outbound === undefined) {\n      inbound = outbound = true;\n    }\n    var isNeighbor = false;\n    this.getConnectedLinks(elementA, opt).forEach(function (link) {\n      var {\n        source,\n        target\n      } = link.attributes;\n\n      // Discard if it is a point.\n      if (inbound && util.has(source, 'id') && source.id === elementB.id) {\n        isNeighbor = true;\n        return false;\n      }\n\n      // Discard if it is a point, or if the neighbor was already added.\n      if (outbound && util.has(target, 'id') && target.id === elementB.id) {\n        isNeighbor = true;\n        return false;\n      }\n    });\n    return isNeighbor;\n  },\n  // Disconnect links connected to the cell `model`.\n  disconnectLinks: function (model, opt) {\n    this.getConnectedLinks(model).forEach(function (link) {\n      link.set(link.attributes.source.id === model.id ? 'source' : 'target', {\n        x: 0,\n        y: 0\n      }, opt);\n    });\n  },\n  // Remove links connected to the cell `model` completely.\n  removeLinks: function (model, opt) {\n    util.invoke(this.getConnectedLinks(model), 'remove', opt);\n  },\n  // Find all elements at given point\n  findModelsFromPoint: function (p) {\n    return this.getElements().filter(el => el.getBBox({\n      rotate: true\n    }).containsPoint(p));\n  },\n  // Find all elements in given area\n  findModelsInArea: function (rect, opt = {}) {\n    const r = new g.Rect(rect);\n    const {\n      strict = false\n    } = opt;\n    const method = strict ? 'containsRect' : 'intersect';\n    return this.getElements().filter(el => r[method](el.getBBox({\n      rotate: true\n    })));\n  },\n  // Find all elements under the given element.\n  findModelsUnderElement: function (element, opt = {}) {\n    const {\n      searchBy = 'bbox'\n    } = opt;\n    const bbox = element.getBBox().rotateAroundCenter(element.angle());\n    const elements = searchBy === 'bbox' ? this.findModelsInArea(bbox) : this.findModelsFromPoint(util.getRectPoint(bbox, searchBy));\n    // don't account element itself or any of its descendants\n    return elements.filter(el => element.id !== el.id && !el.isEmbeddedIn(element));\n  },\n  // Return bounding box of all elements.\n  getBBox: function () {\n    return this.getCellsBBox(this.getCells());\n  },\n  // Return the bounding box of all cells in array provided.\n  getCellsBBox: function (cells, opt = {}) {\n    const {\n      rotate = true\n    } = opt;\n    return util.toArray(cells).reduce(function (memo, cell) {\n      const rect = cell.getBBox({\n        rotate\n      });\n      if (!rect) return memo;\n      if (memo) {\n        return memo.union(rect);\n      }\n      return rect;\n    }, null);\n  },\n  translate: function (dx, dy, opt) {\n    // Don't translate cells that are embedded in any other cell.\n    var cells = this.getCells().filter(function (cell) {\n      return !cell.isEmbedded();\n    });\n    util.invoke(cells, 'translate', dx, dy, opt);\n    return this;\n  },\n  resize: function (width, height, opt) {\n    return this.resizeCells(width, height, this.getCells(), opt);\n  },\n  resizeCells: function (width, height, cells, opt) {\n    // `getBBox` method returns `null` if no elements provided.\n    // i.e. cells can be an array of links\n    var bbox = this.getCellsBBox(cells);\n    if (bbox) {\n      var sx = Math.max(width / bbox.width, 0);\n      var sy = Math.max(height / bbox.height, 0);\n      util.invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n    }\n    return this;\n  },\n  startBatch: function (name, data) {\n    data = data || {};\n    this._batches[name] = (this._batches[name] || 0) + 1;\n    return this.trigger('batch:start', util.assign({}, data, {\n      batchName: name\n    }));\n  },\n  stopBatch: function (name, data) {\n    data = data || {};\n    this._batches[name] = (this._batches[name] || 0) - 1;\n    return this.trigger('batch:stop', util.assign({}, data, {\n      batchName: name\n    }));\n  },\n  hasActiveBatch: function (name) {\n    const batches = this._batches;\n    let names;\n    if (arguments.length === 0) {\n      names = Object.keys(batches);\n    } else if (Array.isArray(name)) {\n      names = name;\n    } else {\n      names = [name];\n    }\n    return names.some(batch => batches[batch] > 0);\n  }\n}, {\n  validations: {\n    multiLinks: function (graph, link) {\n      // Do not allow multiple links to have the same source and target.\n      var {\n        source,\n        target\n      } = link.attributes;\n      if (source.id && target.id) {\n        var sourceModel = link.getSourceCell();\n        if (sourceModel) {\n          var connectedLinks = graph.getConnectedLinks(sourceModel, {\n            outbound: true\n          });\n          var sameLinks = connectedLinks.filter(function (_link) {\n            var {\n              source: _source,\n              target: _target\n            } = _link.attributes;\n            return _source && _source.id === source.id && (!_source.port || _source.port === source.port) && _target && _target.id === target.id && (!_target.port || _target.port === target.port);\n          });\n          if (sameLinks.length > 1) {\n            return false;\n          }\n        }\n      }\n      return true;\n    },\n    linkPinning: function (_graph, link) {\n      var {\n        source,\n        target\n      } = link.attributes;\n      return source.id && target.id;\n    }\n  }\n});\nwrapWith(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], wrappers.cells);","map":{"version":3,"names":["util","g","Model","Collection","wrappers","wrapWith","cloneCells","GraphCells","extend","initialize","models","opt","cellNamespace","joint","has","shapes","graph","model","attrs","collection","namespace","type","ModelClass","getByPath","Error","cell","dry","comparator","get","Graph","cells","cellModel","prototype","set","call","on","trigger","_sortOnChangeZ","_out","_in","_nodes","_edges","_batches","_restructureOnAdd","_restructureOnRemove","_restructureOnReset","_restructureOnChangeSource","_restructureOnChangeTarget","_removeCell","sort","isLink","id","source","target","attributes","forEach","link","prevSource","previous","prevTarget","getOutboundEdges","node","getInboundEdges","toJSON","json","apply","arguments","fromJSON","key","val","hasOwnProperty","resetCells","omit","clear","assign","length","startBatch","sortBy","shift","remove","stopBatch","_prepareCell","isString","TypeError","minZIndex","firstCell","first","maxZIndex","lastCell","last","addCell","Array","isArray","addCells","z","undefined","add","flattenDeep","maxPosition","position","preparedCells","toArray","map","reset","removeCells","invoke","options","disconnectLinks","removeLinks","silent","getCell","getCells","getElements","filter","isElement","getLinks","getFirstCell","getLastCell","getConnectedLinks","indirect","inbound","outbound","links","edges","addOutbounds","addInbounds","forIn","_","edge","push","bind","outCell","getTargetCell","inCell","getSourceCell","deep","embeddedCells","getEmbeddedCells","embeddedElements","exists","edgeCell","sourceId","targetId","includeEnclosed","getNeighbors","neighbors","reduce","res","loop","hasLoop","sourceElement","isEmbeddedIn","targetElement","sourceCell","targetCell","getCommonAncestor","cellsAncestors","from","ancestors","parentId","a","b","commonAncestor","find","ancestor","every","cellAncestors","includes","getSuccessors","element","search","el","cloneSubgraph","subgraph","getSubgraph","cellMap","elements","embeds","embed","getPredecessors","iteratee","breadthFirst","bfs","dfs","visited","distance","queue","next","i","n","neighbor","pop","lastIndex","splice","getSources","sources","isEmpty","getSinks","sinks","isSource","isSink","isSuccessor","elementA","elementB","isPredecessor","isNeighbor","x","y","findModelsFromPoint","p","getBBox","rotate","containsPoint","findModelsInArea","rect","r","Rect","strict","method","findModelsUnderElement","searchBy","bbox","rotateAroundCenter","angle","getRectPoint","getCellsBBox","memo","union","translate","dx","dy","isEmbedded","resize","width","height","resizeCells","sx","Math","max","sy","origin","name","data","batchName","hasActiveBatch","batches","names","Object","keys","some","batch","validations","multiLinks","sourceModel","connectedLinks","sameLinks","_link","_source","_target","port","linkPinning","_graph"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/dia/Graph.mjs"],"sourcesContent":["import * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\nimport { Model } from '../mvc/Model.mjs';\nimport { Collection } from '../mvc/Collection.mjs';\nimport { wrappers, wrapWith } from '../util/wrappers.mjs';\nimport { cloneCells } from '../util/index.mjs';\n\nconst GraphCells = Collection.extend({\n\n    initialize: function(models, opt) {\n\n        // Set the optional namespace where all model classes are defined.\n        if (opt.cellNamespace) {\n            this.cellNamespace = opt.cellNamespace;\n        } else {\n            /* eslint-disable no-undef */\n            this.cellNamespace = typeof joint !== 'undefined' && util.has(joint, 'shapes') ? joint.shapes : null;\n            /* eslint-enable no-undef */\n        }\n\n\n        this.graph = opt.graph;\n    },\n\n    model: function(attrs, opt) {\n\n        const collection = opt.collection;\n        const namespace = collection.cellNamespace;\n        const { type } = attrs;\n\n        // Find the model class based on the `type` attribute in the cell namespace\n        const ModelClass = util.getByPath(namespace, type, '.');\n        if (!ModelClass) {\n            throw new Error(`dia.Graph: Could not find cell constructor for type: '${type}'. Make sure to add the constructor to 'cellNamespace'.`);\n        }\n\n        const cell = new ModelClass(attrs, opt);\n        // Add a reference to the graph. It is necessary to do this here because this is the earliest place\n        // where a new model is created from a plain JS object. For other objects, see `joint.dia.Graph>>_prepareCell()`.\n        if (!opt.dry) {\n            cell.graph = collection.graph;\n        }\n\n        return cell;\n    },\n\n    // `comparator` makes it easy to sort cells based on their `z` index.\n    comparator: function(model) {\n\n        return model.get('z') || 0;\n    }\n});\n\n\nexport const Graph = Model.extend({\n\n    initialize: function(attrs, opt) {\n\n        opt = opt || {};\n\n        // Passing `cellModel` function in the options object to graph allows for\n        // setting models based on attribute objects. This is especially handy\n        // when processing JSON graphs that are in a different than JointJS format.\n        var cells = new GraphCells([], {\n            model: opt.cellModel,\n            cellNamespace: opt.cellNamespace,\n            graph: this\n        });\n        Model.prototype.set.call(this, 'cells', cells);\n\n        // Make all the events fired in the `cells` collection available.\n        // to the outside world.\n        cells.on('all', this.trigger, this);\n\n        // JointJS automatically doesn't trigger re-sort if models attributes are changed later when\n        // they're already in the collection. Therefore, we're triggering sort manually here.\n        this.on('change:z', this._sortOnChangeZ, this);\n\n        // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n        // for fast graph queries. All changes that affect the structure of the graph\n        // must be reflected in the `al` object. This object provides fast answers to\n        // questions such as \"what are the neighbours of this node\" or \"what\n        // are the sibling links of this link\".\n\n        // Outgoing edges per node. Note that we use a hash-table for the list\n        // of outgoing edges for a faster lookup.\n        // [nodeId] -> Object [edgeId] -> true\n        this._out = {};\n        // Ingoing edges per node.\n        // [nodeId] -> Object [edgeId] -> true\n        this._in = {};\n        // `_nodes` is useful for quick lookup of all the elements in the graph, without\n        // having to go through the whole cells array.\n        // [node ID] -> true\n        this._nodes = {};\n        // `_edges` is useful for quick lookup of all the links in the graph, without\n        // having to go through the whole cells array.\n        // [edgeId] -> true\n        this._edges = {};\n\n        this._batches = {};\n\n        cells.on('add', this._restructureOnAdd, this);\n        cells.on('remove', this._restructureOnRemove, this);\n        cells.on('reset', this._restructureOnReset, this);\n        cells.on('change:source', this._restructureOnChangeSource, this);\n        cells.on('change:target', this._restructureOnChangeTarget, this);\n        cells.on('remove', this._removeCell, this);\n    },\n\n    _sortOnChangeZ: function() {\n\n        this.get('cells').sort();\n    },\n\n    _restructureOnAdd: function(cell) {\n\n        if (cell.isLink()) {\n            this._edges[cell.id] = true;\n            var { source, target } = cell.attributes;\n            if (source.id) {\n                (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n            }\n            if (target.id) {\n                (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n            }\n        } else {\n            this._nodes[cell.id] = true;\n        }\n    },\n\n    _restructureOnRemove: function(cell) {\n\n        if (cell.isLink()) {\n            delete this._edges[cell.id];\n            var { source, target } = cell.attributes;\n            if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n                delete this._out[source.id][cell.id];\n            }\n            if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n                delete this._in[target.id][cell.id];\n            }\n        } else {\n            delete this._nodes[cell.id];\n        }\n    },\n\n    _restructureOnReset: function(cells) {\n\n        // Normalize into an array of cells. The original `cells` is GraphCells mvc collection.\n        cells = cells.models;\n\n        this._out = {};\n        this._in = {};\n        this._nodes = {};\n        this._edges = {};\n\n        cells.forEach(this._restructureOnAdd, this);\n    },\n\n    _restructureOnChangeSource: function(link) {\n\n        var prevSource = link.previous('source');\n        if (prevSource.id && this._out[prevSource.id]) {\n            delete this._out[prevSource.id][link.id];\n        }\n        var source = link.attributes.source;\n        if (source.id) {\n            (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n        }\n    },\n\n    _restructureOnChangeTarget: function(link) {\n\n        var prevTarget = link.previous('target');\n        if (prevTarget.id && this._in[prevTarget.id]) {\n            delete this._in[prevTarget.id][link.id];\n        }\n        var target = link.get('target');\n        if (target.id) {\n            (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n        }\n    },\n\n    // Return all outbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getOutboundEdges: function(node) {\n\n        return (this._out && this._out[node]) || {};\n    },\n\n    // Return all inbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getInboundEdges: function(node) {\n\n        return (this._in && this._in[node]) || {};\n    },\n\n    toJSON: function() {\n\n        // JointJS does not recursively call `toJSON()` on attributes that are themselves models/collections.\n        // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n        var json = Model.prototype.toJSON.apply(this, arguments);\n        json.cells = this.get('cells').toJSON();\n        return json;\n    },\n\n    fromJSON: function(json, opt) {\n\n        if (!json.cells) {\n\n            throw new Error('Graph JSON must contain cells array.');\n        }\n\n        return this.set(json, opt);\n    },\n\n    set: function(key, val, opt) {\n\n        var attrs;\n\n        // Handle both `key`, value and {key: value} style arguments.\n        if (typeof key === 'object') {\n            attrs = key;\n            opt = val;\n        } else {\n            (attrs = {})[key] = val;\n        }\n\n        // Make sure that `cells` attribute is handled separately via resetCells().\n        if (attrs.hasOwnProperty('cells')) {\n            this.resetCells(attrs.cells, opt);\n            attrs = util.omit(attrs, 'cells');\n        }\n\n        // The rest of the attributes are applied via original set method.\n        return Model.prototype.set.call(this, attrs, opt);\n    },\n\n    clear: function(opt) {\n\n        opt = util.assign({}, opt, { clear: true });\n\n        var collection = this.get('cells');\n\n        if (collection.length === 0) return this;\n\n        this.startBatch('clear', opt);\n\n        // The elements come after the links.\n        var cells = collection.sortBy(function(cell) {\n            return cell.isLink() ? 1 : 2;\n        });\n\n        do {\n\n            // Remove all the cells one by one.\n            // Note that all the links are removed first, so it's\n            // safe to remove the elements without removing the connected\n            // links first.\n            cells.shift().remove(opt);\n\n        } while (cells.length > 0);\n\n        this.stopBatch('clear');\n\n        return this;\n    },\n\n    _prepareCell: function(cell, opt) {\n\n        var attrs;\n        if (cell instanceof Model) {\n            attrs = cell.attributes;\n            if (!cell.graph && (!opt || !opt.dry)) {\n                // An element can not be member of more than one graph.\n                // A cell stops being the member of the graph after it's explicitly removed.\n                cell.graph = this;\n            }\n        } else {\n            // In case we're dealing with a plain JS object, we have to set the reference\n            // to the `graph` right after the actual model is created. This happens in the `model()` function\n            // of `joint.dia.GraphCells`.\n            attrs = cell;\n        }\n\n        if (!util.isString(attrs.type)) {\n            throw new TypeError('dia.Graph: cell type must be a string.');\n        }\n\n        return cell;\n    },\n\n    minZIndex: function() {\n\n        var firstCell = this.get('cells').first();\n        return firstCell ? (firstCell.get('z') || 0) : 0;\n    },\n\n    maxZIndex: function() {\n\n        var lastCell = this.get('cells').last();\n        return lastCell ? (lastCell.get('z') || 0) : 0;\n    },\n\n    addCell: function(cell, opt) {\n\n        if (Array.isArray(cell)) {\n\n            return this.addCells(cell, opt);\n        }\n\n        if (cell instanceof Model) {\n\n            if (!cell.has('z')) {\n                cell.set('z', this.maxZIndex() + 1);\n            }\n\n        } else if (cell.z === undefined) {\n\n            cell.z = this.maxZIndex() + 1;\n        }\n\n        this.get('cells').add(this._prepareCell(cell, opt), opt || {});\n\n        return this;\n    },\n\n    addCells: function(cells, opt) {\n\n        if (cells.length === 0) return this;\n\n        cells = util.flattenDeep(cells);\n        opt.maxPosition = opt.position = cells.length - 1;\n\n        this.startBatch('add', opt);\n        cells.forEach(function(cell) {\n            this.addCell(cell, opt);\n            opt.position--;\n        }, this);\n        this.stopBatch('add', opt);\n\n        return this;\n    },\n\n    // When adding a lot of cells, it is much more efficient to\n    // reset the entire cells collection in one go.\n    // Useful for bulk operations and optimizations.\n    resetCells: function(cells, opt) {\n\n        var preparedCells = util.toArray(cells).map(function(cell) {\n            return this._prepareCell(cell, opt);\n        }, this);\n        this.get('cells').reset(preparedCells, opt);\n\n        return this;\n    },\n\n    removeCells: function(cells, opt) {\n\n        if (cells.length) {\n\n            this.startBatch('remove');\n            util.invoke(cells, 'remove', opt);\n            this.stopBatch('remove');\n        }\n\n        return this;\n    },\n\n    _removeCell: function(cell, collection, options) {\n\n        options = options || {};\n\n        if (!options.clear) {\n            // Applications might provide a `disconnectLinks` option set to `true` in order to\n            // disconnect links when a cell is removed rather then removing them. The default\n            // is to remove all the associated links.\n            if (options.disconnectLinks) {\n\n                this.disconnectLinks(cell, options);\n\n            } else {\n\n                this.removeLinks(cell, options);\n            }\n        }\n        // Silently remove the cell from the cells collection. Silently, because\n        // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n        // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n        // would be triggered on the graph model.\n        this.get('cells').remove(cell, { silent: true });\n\n        if (cell.graph === this) {\n            // Remove the element graph reference only if the cell is the member of this graph.\n            cell.graph = null;\n        }\n    },\n\n    // Get a cell by `id`.\n    getCell: function(id) {\n\n        return this.get('cells').get(id);\n    },\n\n    getCells: function() {\n\n        return this.get('cells').toArray();\n    },\n\n    getElements: function() {\n\n        return this.get('cells').toArray().filter(cell => cell.isElement());\n    },\n\n    getLinks: function() {\n\n        return this.get('cells').toArray().filter(cell => cell.isLink());\n    },\n\n    getFirstCell: function() {\n\n        return this.get('cells').first();\n    },\n\n    getLastCell: function() {\n\n        return this.get('cells').last();\n    },\n\n    // Get all inbound and outbound links connected to the cell `model`.\n    getConnectedLinks: function(model, opt) {\n\n        opt = opt || {};\n\n        var indirect = opt.indirect;\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if ((inbound === undefined) && (outbound === undefined)) {\n            inbound = outbound = true;\n        }\n\n        // the final array of connected link models\n        var links = [];\n        // a hash table of connected edges of the form: [edgeId] -> true\n        // used for quick lookups to check if we already added a link\n        var edges = {};\n\n        if (outbound) {\n            addOutbounds(this, model);\n        }\n        if (inbound) {\n            addInbounds(this, model);\n        }\n\n        function addOutbounds(graph, model) {\n            util.forIn(graph.getOutboundEdges(model.id), function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }.bind(graph));\n            if (indirect && model.isLink()) {\n                var outCell = model.getTargetCell();\n                if (outCell && outCell.isLink()) {\n                    if (!edges[outCell.id]) {\n                        links.push(outCell);\n                        addOutbounds(graph, outCell);\n                    }\n                }\n            }\n        }\n\n        function addInbounds(graph, model) {\n            util.forIn(graph.getInboundEdges(model.id), function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }.bind(graph));\n            if (indirect && model.isLink()) {\n                var inCell = model.getSourceCell();\n                if (inCell && inCell.isLink()) {\n                    if (!edges[inCell.id]) {\n                        links.push(inCell);\n                        addInbounds(graph, inCell);\n                    }\n                }\n            }\n        }\n\n        // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n        if (opt.deep) {\n\n            var embeddedCells = model.getEmbeddedCells({ deep: true });\n\n            // in the first round, we collect all the embedded elements\n            var embeddedElements = {};\n            embeddedCells.forEach(function(cell) {\n                if (cell.isElement()) {\n                    embeddedElements[cell.id] = true;\n                }\n            });\n\n            embeddedCells.forEach(function(cell) {\n                if (cell.isLink()) return;\n                if (outbound) {\n                    util.forIn(this.getOutboundEdges(cell.id), function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed\n                                && (sourceId && embeddedElements[sourceId])\n                                && (targetId && embeddedElements[targetId])) {\n                                return;\n                            }\n\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }.bind(this));\n                }\n                if (inbound) {\n                    util.forIn(this.getInboundEdges(cell.id), function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed\n                                && (sourceId && embeddedElements[sourceId])\n                                && (targetId && embeddedElements[targetId])) {\n                                return;\n                            }\n\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }.bind(this));\n                }\n            }, this);\n        }\n\n        return links;\n    },\n\n    getNeighbors: function(model, opt) {\n\n        opt || (opt = {});\n\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if (inbound === undefined && outbound === undefined) {\n            inbound = outbound = true;\n        }\n\n        var neighbors = this.getConnectedLinks(model, opt).reduce(function(res, link) {\n\n            var { source, target } = link.attributes;\n            var loop = link.hasLoop(opt);\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (inbound && util.has(source, 'id') && !res[source.id]) {\n\n                var sourceElement = this.getCell(source.id);\n                if (sourceElement.isElement()) {\n                    if (loop || (sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model)))) {\n                        res[source.id] = sourceElement;\n                    }\n                }\n            }\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && util.has(target, 'id') && !res[target.id]) {\n\n                var targetElement = this.getCell(target.id);\n                if (targetElement.isElement()) {\n                    if (loop || (targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model)))) {\n                        res[target.id] = targetElement;\n                    }\n                }\n            }\n\n            return res;\n        }.bind(this), {});\n\n        if (model.isLink()) {\n            if (inbound) {\n                var sourceCell = model.getSourceCell();\n                if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n                    neighbors[sourceCell.id] = sourceCell;\n                }\n            }\n            if (outbound) {\n                var targetCell = model.getTargetCell();\n                if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n                    neighbors[targetCell.id] = targetCell;\n                }\n            }\n        }\n\n        return util.toArray(neighbors);\n    },\n\n    getCommonAncestor: function(/* cells */) {\n\n        var cellsAncestors = Array.from(arguments).map(function(cell) {\n\n            var ancestors = [];\n            var parentId = cell.get('parent');\n\n            while (parentId) {\n\n                ancestors.push(parentId);\n                parentId = this.getCell(parentId).get('parent');\n            }\n\n            return ancestors;\n\n        }, this);\n\n        cellsAncestors = cellsAncestors.sort(function(a, b) {\n            return a.length - b.length;\n        });\n\n        var commonAncestor = util.toArray(cellsAncestors.shift()).find(function(ancestor) {\n            return cellsAncestors.every(function(cellAncestors) {\n                return cellAncestors.includes(ancestor);\n            });\n        });\n\n        return this.getCell(commonAncestor);\n    },\n\n    // Find the whole branch starting at `element`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getSuccessors: function(element, opt) {\n\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, util.assign({}, opt, { outbound: true }));\n        return res;\n    },\n\n    cloneCells: cloneCells,\n    // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n    // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n    // Return a map of the form: [original cell ID] -> [clone].\n    cloneSubgraph: function(cells, opt) {\n\n        var subgraph = this.getSubgraph(cells, opt);\n        return this.cloneCells(subgraph);\n    },\n\n    // Return `cells` and all the connected links that connect cells in the `cells` array.\n    // If `opt.deep` is `true`, return all the cells including all their embedded cells\n    // and all the links that connect any of the returned cells.\n    // For example, for a single shallow element, the result is that very same element.\n    // For two elements connected with a link: `A --- L ---> B`, the result for\n    // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n    getSubgraph: function(cells, opt) {\n\n        opt = opt || {};\n\n        var subgraph = [];\n        // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n        var cellMap = {};\n        var elements = [];\n        var links = [];\n\n        util.toArray(cells).forEach(function(cell) {\n            if (!cellMap[cell.id]) {\n                subgraph.push(cell);\n                cellMap[cell.id] = cell;\n                if (cell.isLink()) {\n                    links.push(cell);\n                } else {\n                    elements.push(cell);\n                }\n            }\n\n            if (opt.deep) {\n                var embeds = cell.getEmbeddedCells({ deep: true });\n                embeds.forEach(function(embed) {\n                    if (!cellMap[embed.id]) {\n                        subgraph.push(embed);\n                        cellMap[embed.id] = embed;\n                        if (embed.isLink()) {\n                            links.push(embed);\n                        } else {\n                            elements.push(embed);\n                        }\n                    }\n                });\n            }\n        });\n\n        links.forEach(function(link) {\n            // For links, return their source & target (if they are elements - not points).\n            var { source, target } = link.attributes;\n            if (source.id && !cellMap[source.id]) {\n                var sourceElement = this.getCell(source.id);\n                subgraph.push(sourceElement);\n                cellMap[sourceElement.id] = sourceElement;\n                elements.push(sourceElement);\n            }\n            if (target.id && !cellMap[target.id]) {\n                var targetElement = this.getCell(target.id);\n                subgraph.push(this.getCell(target.id));\n                cellMap[targetElement.id] = targetElement;\n                elements.push(targetElement);\n            }\n        }, this);\n\n        elements.forEach(function(element) {\n            // For elements, include their connected links if their source/target is in the subgraph;\n            var links = this.getConnectedLinks(element, opt);\n            links.forEach(function(link) {\n                var { source, target } = link.attributes;\n                if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n                    subgraph.push(link);\n                    cellMap[link.id] = link;\n                }\n            });\n        }, this);\n\n        return subgraph;\n    },\n\n    // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getPredecessors: function(element, opt) {\n\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, util.assign({}, opt, { inbound: true }));\n        return res;\n    },\n\n    // Perform search on the graph.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n    // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // `iteratee` is a function of the form `function(element) {}`.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    search: function(element, iteratee, opt) {\n\n        opt = opt || {};\n        if (opt.breadthFirst) {\n            this.bfs(element, iteratee, opt);\n        } else {\n            this.dfs(element, iteratee, opt);\n        }\n    },\n\n    // Breadth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // where `element` is the currently visited element and `distance` is the distance of that element\n    // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n    // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n    // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    bfs: function(element, iteratee, opt = {}) {\n\n        const visited = {};\n        const distance = {};\n        const queue = [];\n\n        queue.push(element);\n        distance[element.id] = 0;\n\n        while (queue.length > 0) {\n            var next = queue.shift();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            for (let i = 0, n = neighbors.length; i < n; i++) {\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.push(neighbor);\n            }\n        }\n    },\n\n    // Depth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // If `iteratee` explicitly returns `false`, the search stops.\n    dfs: function(element, iteratee, opt = {}) {\n\n        const visited = {};\n        const distance = {};\n        const queue = [];\n\n        queue.push(element);\n        distance[element.id] = 0;\n\n        while (queue.length > 0) {\n            const next = queue.pop();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            const lastIndex = queue.length;\n            for (let i = 0, n = neighbors.length; i < n; i++) {\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.splice(lastIndex, 0, neighbor);\n            }\n        }\n    },\n\n    // Get all the roots of the graph. Time complexity: O(|V|).\n    getSources: function() {\n\n        var sources = [];\n        util.forIn(this._nodes, function(exists, node) {\n            if (!this._in[node] || util.isEmpty(this._in[node])) {\n                sources.push(this.getCell(node));\n            }\n        }.bind(this));\n        return sources;\n    },\n\n    // Get all the leafs of the graph. Time complexity: O(|V|).\n    getSinks: function() {\n\n        var sinks = [];\n        util.forIn(this._nodes, function(exists, node) {\n            if (!this._out[node] || util.isEmpty(this._out[node])) {\n                sinks.push(this.getCell(node));\n            }\n        }.bind(this));\n        return sinks;\n    },\n\n    // Return `true` if `element` is a root. Time complexity: O(1).\n    isSource: function(element) {\n\n        return !this._in[element.id] || util.isEmpty(this._in[element.id]);\n    },\n\n    // Return `true` if `element` is a leaf. Time complexity: O(1).\n    isSink: function(element) {\n\n        return !this._out[element.id] || util.isEmpty(this._out[element.id]);\n    },\n\n    // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n    isSuccessor: function(elementA, elementB) {\n\n        var isSuccessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isSuccessor = true;\n                return false;\n            }\n        }, { outbound: true });\n        return isSuccessor;\n    },\n\n    // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n    isPredecessor: function(elementA, elementB) {\n\n        var isPredecessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isPredecessor = true;\n                return false;\n            }\n        }, { inbound: true });\n        return isPredecessor;\n    },\n\n    // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n    // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n    // for more details.\n    // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n    // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n    isNeighbor: function(elementA, elementB, opt) {\n\n        opt = opt || {};\n\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if ((inbound === undefined) && (outbound === undefined)) {\n            inbound = outbound = true;\n        }\n\n        var isNeighbor = false;\n\n        this.getConnectedLinks(elementA, opt).forEach(function(link) {\n\n            var { source, target } = link.attributes;\n\n            // Discard if it is a point.\n            if (inbound && util.has(source, 'id') && (source.id === elementB.id)) {\n                isNeighbor = true;\n                return false;\n            }\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && util.has(target, 'id') && (target.id === elementB.id)) {\n                isNeighbor = true;\n                return false;\n            }\n        });\n\n        return isNeighbor;\n    },\n\n    // Disconnect links connected to the cell `model`.\n    disconnectLinks: function(model, opt) {\n\n        this.getConnectedLinks(model).forEach(function(link) {\n\n            link.set((link.attributes.source.id === model.id ? 'source' : 'target'), { x: 0, y: 0 }, opt);\n        });\n    },\n\n    // Remove links connected to the cell `model` completely.\n    removeLinks: function(model, opt) {\n\n        util.invoke(this.getConnectedLinks(model), 'remove', opt);\n    },\n\n    // Find all elements at given point\n    findModelsFromPoint: function(p) {\n        return this.getElements().filter(el => el.getBBox({ rotate: true }).containsPoint(p));\n    },\n\n    // Find all elements in given area\n    findModelsInArea: function(rect, opt = {}) {\n        const r = new g.Rect(rect);\n        const { strict = false } = opt;\n        const method = strict ? 'containsRect' : 'intersect';\n        return this.getElements().filter(el => r[method](el.getBBox({ rotate: true })));\n    },\n\n    // Find all elements under the given element.\n    findModelsUnderElement: function(element, opt = {}) {\n        const { searchBy = 'bbox' } = opt;\n        const bbox = element.getBBox().rotateAroundCenter(element.angle());\n        const elements = (searchBy === 'bbox')\n            ? this.findModelsInArea(bbox)\n            : this.findModelsFromPoint(util.getRectPoint(bbox, searchBy));\n        // don't account element itself or any of its descendants\n        return elements.filter(el => element.id !== el.id && !el.isEmbeddedIn(element));\n    },\n\n    // Return bounding box of all elements.\n    getBBox: function() {\n\n        return this.getCellsBBox(this.getCells());\n    },\n\n    // Return the bounding box of all cells in array provided.\n    getCellsBBox: function(cells, opt = {}) {\n        const { rotate = true } = opt;\n        return util.toArray(cells).reduce(function(memo, cell) {\n            const rect = cell.getBBox({ rotate });\n            if (!rect) return memo;\n            if (memo) {\n                return memo.union(rect);\n            }\n            return rect;\n        }, null);\n    },\n\n    translate: function(dx, dy, opt) {\n\n        // Don't translate cells that are embedded in any other cell.\n        var cells = this.getCells().filter(function(cell) {\n            return !cell.isEmbedded();\n        });\n\n        util.invoke(cells, 'translate', dx, dy, opt);\n\n        return this;\n    },\n\n    resize: function(width, height, opt) {\n\n        return this.resizeCells(width, height, this.getCells(), opt);\n    },\n\n    resizeCells: function(width, height, cells, opt) {\n\n        // `getBBox` method returns `null` if no elements provided.\n        // i.e. cells can be an array of links\n        var bbox = this.getCellsBBox(cells);\n        if (bbox) {\n            var sx = Math.max(width / bbox.width, 0);\n            var sy = Math.max(height / bbox.height, 0);\n            util.invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n        }\n\n        return this;\n    },\n\n    startBatch: function(name, data) {\n\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) + 1;\n\n        return this.trigger('batch:start', util.assign({}, data, { batchName: name }));\n    },\n\n    stopBatch: function(name, data) {\n\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) - 1;\n\n        return this.trigger('batch:stop', util.assign({}, data, { batchName: name }));\n    },\n\n    hasActiveBatch: function(name) {\n\n        const batches = this._batches;\n        let names;\n\n        if (arguments.length === 0) {\n            names = Object.keys(batches);\n        } else if (Array.isArray(name)) {\n            names = name;\n        } else {\n            names = [name];\n        }\n\n        return names.some((batch) => batches[batch] > 0);\n    }\n\n}, {\n\n    validations: {\n\n        multiLinks: function(graph, link) {\n\n            // Do not allow multiple links to have the same source and target.\n            var { source, target } = link.attributes;\n\n            if (source.id && target.id) {\n\n                var sourceModel = link.getSourceCell();\n                if (sourceModel) {\n\n                    var connectedLinks = graph.getConnectedLinks(sourceModel, { outbound: true });\n                    var sameLinks = connectedLinks.filter(function(_link) {\n\n                        var { source: _source, target: _target } = _link.attributes;\n                        return _source && _source.id === source.id &&\n                            (!_source.port || (_source.port === source.port)) &&\n                            _target && _target.id === target.id &&\n                            (!_target.port || (_target.port === target.port));\n\n                    });\n\n                    if (sameLinks.length > 1) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        },\n\n        linkPinning: function(_graph, link) {\n            var { source, target } = link.attributes;\n            return source.id && target.id;\n        }\n    }\n\n});\n\nwrapWith(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], wrappers.cells);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}