{"ast":null,"code":"import { assign, isPlainObject, isObject, isPercentage, breakText } from '../../util/util.mjs';\nimport { isCalcAttribute, evalCalcAttribute } from './calc.mjs';\nimport $ from '../../mvc/Dom/index.mjs';\nimport V from '../../V/index.mjs';\nfunction isTextInUse(_value, _node, attrs) {\n  return attrs.text !== undefined;\n}\nconst textAttributesNS = {\n  'line-height': {\n    qualify: isTextInUse\n  },\n  'text-vertical-anchor': {\n    qualify: isTextInUse\n  },\n  'text-path': {\n    qualify: isTextInUse\n  },\n  'annotations': {\n    qualify: isTextInUse\n  },\n  'eol': {\n    qualify: isTextInUse\n  },\n  'display-empty': {\n    qualify: isTextInUse\n  },\n  'text': {\n    qualify: function (_text, _node, attrs) {\n      const textWrap = attrs['text-wrap'];\n      return !textWrap || !isPlainObject(textWrap);\n    },\n    set: function (text, refBBox, node, attrs) {\n      const cacheName = 'joint-text';\n      const cache = $.data.get(node, cacheName);\n      const lineHeight = attrs['line-height'];\n      const textVerticalAnchor = attrs['text-vertical-anchor'];\n      const displayEmpty = attrs['display-empty'];\n      const fontSize = attrs['font-size'];\n      const annotations = attrs.annotations;\n      const eol = attrs.eol;\n      const x = attrs.x;\n      let textPath = attrs['text-path'];\n      // Update the text only if there was a change in the string\n      // or any of its attributes.\n      const textHash = JSON.stringify([text, lineHeight, annotations, textVerticalAnchor, eol, displayEmpty, textPath, x, fontSize]);\n      if (cache === undefined || cache !== textHash) {\n        // Chrome bug:\n        // <tspan> positions defined as `em` are not updated\n        // when container `font-size` change.\n        if (fontSize) node.setAttribute('font-size', fontSize);\n        // Text Along Path Selector\n        if (isObject(textPath)) {\n          const pathSelector = textPath.selector;\n          if (typeof pathSelector === 'string') {\n            const pathNode = this.findNode(pathSelector);\n            if (pathNode instanceof SVGPathElement) {\n              textPath = assign({\n                'xlink:href': '#' + pathNode.id\n              }, textPath);\n            }\n          }\n        }\n        V(node).text('' + text, {\n          lineHeight,\n          annotations,\n          textPath,\n          x,\n          textVerticalAnchor,\n          eol,\n          displayEmpty\n        });\n        $.data.set(node, cacheName, textHash);\n      }\n    }\n  },\n  'text-wrap': {\n    qualify: isPlainObject,\n    set: function (value, refBBox, node, attrs) {\n      var size = {};\n      // option `width`\n      var width = value.width || 0;\n      if (isPercentage(width)) {\n        size.width = refBBox.width * parseFloat(width) / 100;\n      } else if (isCalcAttribute(width)) {\n        size.width = Number(evalCalcAttribute(width, refBBox));\n      } else {\n        if (value.width === null) {\n          // breakText() requires width to be specified.\n          size.width = Infinity;\n        } else if (width <= 0) {\n          size.width = refBBox.width + width;\n        } else {\n          size.width = width;\n        }\n      }\n      // option `height`\n      var height = value.height || 0;\n      if (isPercentage(height)) {\n        size.height = refBBox.height * parseFloat(height) / 100;\n      } else if (isCalcAttribute(height)) {\n        size.height = Number(evalCalcAttribute(height, refBBox));\n      } else {\n        if (value.height === null) {\n          // if height is not specified breakText() does not\n          // restrict the height of the text.\n        } else if (height <= 0) {\n          size.height = refBBox.height + height;\n        } else {\n          size.height = height;\n        }\n      }\n      // option `text`\n      var wrappedText;\n      var text = value.text;\n      if (text === undefined) text = attrs.text;\n      if (text !== undefined) {\n        const breakTextFn = value.breakText || breakText;\n        wrappedText = breakTextFn('' + text, size, {\n          'font-weight': attrs['font-weight'],\n          'font-size': attrs['font-size'],\n          'font-family': attrs['font-family'],\n          'lineHeight': attrs['line-height'],\n          'letter-spacing': attrs['letter-spacing']\n        }, {\n          // Provide an existing SVG Document here\n          // instead of creating a temporary one over again.\n          svgDocument: this.paper.svg,\n          ellipsis: value.ellipsis,\n          hyphen: value.hyphen,\n          separator: value.separator,\n          maxLineCount: value.maxLineCount,\n          preserveSpaces: value.preserveSpaces\n        });\n      } else {\n        wrappedText = '';\n      }\n      textAttributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n    }\n  },\n  'title': {\n    qualify: function (title, node) {\n      // HTMLElement title is specified via an attribute (i.e. not an element)\n      return node instanceof SVGElement;\n    },\n    set: function (title, refBBox, node) {\n      var cacheName = 'joint-title';\n      var cache = $.data.get(node, cacheName);\n      if (cache === undefined || cache !== title) {\n        $.data.set(node, cacheName, title);\n        if (node.tagName === 'title') {\n          // The target node is a <title> element.\n          node.textContent = title;\n          return;\n        }\n        // Generally <title> element should be the first child element of its parent.\n        var firstChild = node.firstElementChild;\n        if (firstChild && firstChild.tagName === 'title') {\n          // Update an existing title\n          firstChild.textContent = title;\n        } else {\n          // Create a new title\n          var titleNode = document.createElementNS(node.namespaceURI, 'title');\n          titleNode.textContent = title;\n          node.insertBefore(titleNode, firstChild);\n        }\n      }\n    }\n  }\n};\nexport default textAttributesNS;","map":{"version":3,"names":["assign","isPlainObject","isObject","isPercentage","breakText","isCalcAttribute","evalCalcAttribute","$","V","isTextInUse","_value","_node","attrs","text","undefined","textAttributesNS","qualify","_text","textWrap","set","refBBox","node","cacheName","cache","data","get","lineHeight","textVerticalAnchor","displayEmpty","fontSize","annotations","eol","x","textPath","textHash","JSON","stringify","setAttribute","pathSelector","selector","pathNode","findNode","SVGPathElement","id","value","size","width","parseFloat","Number","Infinity","height","wrappedText","breakTextFn","svgDocument","paper","svg","ellipsis","hyphen","separator","maxLineCount","preserveSpaces","call","title","SVGElement","tagName","textContent","firstChild","firstElementChild","titleNode","document","createElementNS","namespaceURI","insertBefore"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/dia/attributes/text.mjs"],"sourcesContent":["import { assign, isPlainObject, isObject, isPercentage, breakText } from '../../util/util.mjs';\nimport { isCalcAttribute, evalCalcAttribute } from './calc.mjs';\nimport $ from '../../mvc/Dom/index.mjs';\nimport V from '../../V/index.mjs';\n\nfunction isTextInUse(_value, _node, attrs) {\n    return (attrs.text !== undefined);\n}\n\nconst textAttributesNS = {\n\n    'line-height': {\n        qualify: isTextInUse\n    },\n\n    'text-vertical-anchor': {\n        qualify: isTextInUse\n    },\n\n    'text-path': {\n        qualify: isTextInUse\n    },\n\n    'annotations': {\n        qualify: isTextInUse\n    },\n\n    'eol': {\n        qualify: isTextInUse\n    },\n\n    'display-empty': {\n        qualify: isTextInUse\n    },\n\n    'text': {\n        qualify: function(_text, _node, attrs) {\n            const textWrap = attrs['text-wrap'];\n            return !textWrap || !isPlainObject(textWrap);\n        },\n        set: function(text, refBBox, node, attrs) {\n            const cacheName = 'joint-text';\n            const cache = $.data.get(node, cacheName);\n            const lineHeight = attrs['line-height'];\n            const textVerticalAnchor = attrs['text-vertical-anchor'];\n            const displayEmpty = attrs['display-empty'];\n            const fontSize = attrs['font-size'];\n            const annotations = attrs.annotations;\n            const eol = attrs.eol;\n            const x = attrs.x;\n            let textPath = attrs['text-path'];\n            // Update the text only if there was a change in the string\n            // or any of its attributes.\n            const textHash = JSON.stringify([text, lineHeight, annotations, textVerticalAnchor, eol, displayEmpty, textPath, x, fontSize]);\n            if (cache === undefined || cache !== textHash) {\n                // Chrome bug:\n                // <tspan> positions defined as `em` are not updated\n                // when container `font-size` change.\n                if (fontSize) node.setAttribute('font-size', fontSize);\n                // Text Along Path Selector\n                if (isObject(textPath)) {\n                    const pathSelector = textPath.selector;\n                    if (typeof pathSelector === 'string') {\n                        const pathNode = this.findNode(pathSelector);\n                        if (pathNode instanceof SVGPathElement) {\n                            textPath = assign({ 'xlink:href': '#' + pathNode.id }, textPath);\n                        }\n                    }\n                }\n                V(node).text('' + text, {\n                    lineHeight,\n                    annotations,\n                    textPath,\n                    x,\n                    textVerticalAnchor,\n                    eol,\n                    displayEmpty\n                });\n                $.data.set(node, cacheName, textHash);\n            }\n        }\n    },\n\n    'text-wrap': {\n        qualify: isPlainObject,\n        set: function(value, refBBox, node, attrs) {\n            var size = {};\n            // option `width`\n            var width = value.width || 0;\n            if (isPercentage(width)) {\n                size.width = refBBox.width * parseFloat(width) / 100;\n            } else if (isCalcAttribute(width)) {\n                size.width = Number(evalCalcAttribute(width, refBBox));\n            } else {\n                if (value.width === null) {\n                    // breakText() requires width to be specified.\n                    size.width = Infinity;\n                } else if (width <= 0) {\n                    size.width = refBBox.width + width;\n                } else {\n                    size.width = width;\n                }\n            }\n            // option `height`\n            var height = value.height || 0;\n            if (isPercentage(height)) {\n                size.height = refBBox.height * parseFloat(height) / 100;\n            } else if (isCalcAttribute(height)) {\n                size.height = Number(evalCalcAttribute(height, refBBox));\n            } else {\n                if (value.height === null) {\n                    // if height is not specified breakText() does not\n                    // restrict the height of the text.\n                } else if (height <= 0) {\n                    size.height = refBBox.height + height;\n                } else {\n                    size.height = height;\n                }\n            }\n            // option `text`\n            var wrappedText;\n            var text = value.text;\n            if (text === undefined) text = attrs.text;\n            if (text !== undefined) {\n                const breakTextFn = value.breakText || breakText;\n                wrappedText = breakTextFn('' + text, size, {\n                    'font-weight': attrs['font-weight'],\n                    'font-size': attrs['font-size'],\n                    'font-family': attrs['font-family'],\n                    'lineHeight': attrs['line-height'],\n                    'letter-spacing': attrs['letter-spacing']\n                }, {\n                    // Provide an existing SVG Document here\n                    // instead of creating a temporary one over again.\n                    svgDocument: this.paper.svg,\n                    ellipsis: value.ellipsis,\n                    hyphen: value.hyphen,\n                    separator: value.separator,\n                    maxLineCount: value.maxLineCount,\n                    preserveSpaces: value.preserveSpaces\n                });\n            } else {\n                wrappedText = '';\n            }\n            textAttributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n        }\n    },\n\n    'title': {\n        qualify: function(title, node) {\n            // HTMLElement title is specified via an attribute (i.e. not an element)\n            return node instanceof SVGElement;\n        },\n        set: function(title, refBBox, node) {\n            var cacheName = 'joint-title';\n            var cache = $.data.get(node, cacheName);\n            if (cache === undefined || cache !== title) {\n                $.data.set(node, cacheName, title);\n                if (node.tagName === 'title') {\n                    // The target node is a <title> element.\n                    node.textContent = title;\n                    return;\n                }\n                // Generally <title> element should be the first child element of its parent.\n                var firstChild = node.firstElementChild;\n                if (firstChild && firstChild.tagName === 'title') {\n                    // Update an existing title\n                    firstChild.textContent = title;\n                } else {\n                    // Create a new title\n                    var titleNode = document.createElementNS(node.namespaceURI, 'title');\n                    titleNode.textContent = title;\n                    node.insertBefore(titleNode, firstChild);\n                }\n            }\n        }\n    },\n};\n\nexport default textAttributesNS;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}