{"ast":null,"code":"/*\n    Point is the most basic object consisting of x/y coordinate.\n\n    Possible instantiations are:\n    * `Point(10, 20)`\n    * `new Point(10, 20)`\n    * `Point('10 20')`\n    * `Point(Point(10, 20))`\n*/\nimport { normalizeAngle, random, snapToGrid, toDeg, toRad } from './geometry.helpers.mjs';\nimport { bearing } from './line.bearing.mjs';\nimport { squaredLength } from './line.squaredLength.mjs';\nimport { length } from './line.length.mjs';\nimport { types } from './types.mjs';\nconst {\n  abs,\n  cos,\n  sin,\n  sqrt,\n  min,\n  max,\n  atan2,\n  round,\n  pow,\n  PI\n} = Math;\nexport const Point = function (x, y) {\n  if (!(this instanceof Point)) {\n    return new Point(x, y);\n  }\n  if (typeof x === 'string') {\n    var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\n    x = parseFloat(xy[0]);\n    y = parseFloat(xy[1]);\n  } else if (Object(x) === x) {\n    y = x.y;\n    x = x.x;\n  }\n  this.x = x === undefined ? 0 : x;\n  this.y = y === undefined ? 0 : y;\n};\n\n// Alternative constructor, from polar coordinates.\n// @param {number} Distance.\n// @param {number} Angle in radians.\n// @param {point} [optional] Origin.\nPoint.fromPolar = function (distance, angle, origin) {\n  origin = new Point(origin);\n  var x = abs(distance * cos(angle));\n  var y = abs(distance * sin(angle));\n  var deg = normalizeAngle(toDeg(angle));\n  if (deg < 90) {\n    y = -y;\n  } else if (deg < 180) {\n    x = -x;\n    y = -y;\n  } else if (deg < 270) {\n    x = -x;\n  }\n  return new Point(origin.x + x, origin.y + y);\n};\n\n// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\nPoint.random = function (x1, x2, y1, y2) {\n  return new Point(random(x1, x2), random(y1, y2));\n};\nPoint.prototype = {\n  type: types.Point,\n  chooseClosest: function (points) {\n    var n = points.length;\n    if (n === 1) return new Point(points[0]);\n    var closest = null;\n    var minSqrDistance = Infinity;\n    for (var i = 0; i < n; i++) {\n      var p = new Point(points[i]);\n      var sqrDistance = this.squaredDistance(p);\n      if (sqrDistance < minSqrDistance) {\n        closest = p;\n        minSqrDistance = sqrDistance;\n      }\n    }\n    return closest;\n  },\n  // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n  // otherwise return point itself.\n  // (see Squeak Smalltalk, Point>>adhereTo:)\n  adhereToRect: function (r) {\n    if (r.containsPoint(this)) {\n      return this;\n    }\n    this.x = min(max(this.x, r.x), r.x + r.width);\n    this.y = min(max(this.y, r.y), r.y + r.height);\n    return this;\n  },\n  // Compute the angle between vector from me to p1 and the vector from me to p2.\n  // ordering of points p1 and p2 is important!\n  // theta function's angle convention:\n  // returns angles between 0 and 180 when the angle is counterclockwise\n  // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n  // returns NaN if any of the points p1, p2 is coincident with this point\n  angleBetween: function (p1, p2) {\n    var angleBetween = this.equals(p1) || this.equals(p2) ? NaN : this.theta(p2) - this.theta(p1);\n    if (angleBetween < 0) {\n      angleBetween += 360; // correction to keep angleBetween between 0 and 360\n    }\n    return angleBetween;\n  },\n  // Return the bearing between me and the given point.\n  bearing: function (point) {\n    return bearing(this, point);\n  },\n  // Returns change in angle from my previous position (-dx, -dy) to my new position\n  // relative to ref point.\n  changeInAngle: function (dx, dy, ref) {\n    // Revert the translation and measure the change in angle around x-axis.\n    return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n  },\n  clone: function () {\n    return new Point(this);\n  },\n  // Returns the cross product of this point relative to two other points\n  // this point is the common point\n  // point p1 lies on the first vector, point p2 lies on the second vector\n  // watch out for the ordering of points p1 and p2!\n  // positive result indicates a clockwise (\"right\") turn from first to second vector\n  // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n  // zero indicates that the first and second vector are collinear\n  // note that the above directions are reversed from the usual answer on the Internet\n  // that is because we are in a left-handed coord system (because the y-axis points downward)\n  cross: function (p1, p2) {\n    return p1 && p2 ? (p2.x - this.x) * (p1.y - this.y) - (p2.y - this.y) * (p1.x - this.x) : NaN;\n  },\n  difference: function (dx, dy) {\n    if (Object(dx) === dx) {\n      dy = dx.y;\n      dx = dx.x;\n    }\n    return new Point(this.x - (dx || 0), this.y - (dy || 0));\n  },\n  // Returns distance between me and point `p`.\n  distance: function (p) {\n    return length(this, p);\n  },\n  // Returns the dot product of this point with given other point\n  dot: function (p) {\n    return p ? this.x * p.x + this.y * p.y : NaN;\n  },\n  equals: function (p) {\n    return !!p && this.x === p.x && this.y === p.y;\n  },\n  // Linear interpolation\n  lerp: function (p, t) {\n    var x = this.x;\n    var y = this.y;\n    return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n  },\n  magnitude: function () {\n    return sqrt(this.x * this.x + this.y * this.y) || 0.01;\n  },\n  // Returns a manhattan (taxi-cab) distance between me and point `p`.\n  manhattanDistance: function (p) {\n    return abs(p.x - this.x) + abs(p.y - this.y);\n  },\n  // Move point on line starting from ref ending at me by\n  // distance distance.\n  move: function (ref, distance) {\n    var theta = toRad(new Point(ref).theta(this));\n    var offset = this.offset(cos(theta) * distance, -sin(theta) * distance);\n    return offset;\n  },\n  // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n  normalize: function (length) {\n    var scale = (length || 1) / this.magnitude();\n    return this.scale(scale, scale);\n  },\n  // Offset me by the specified amount.\n  offset: function (dx, dy) {\n    if (Object(dx) === dx) {\n      dy = dx.y;\n      dx = dx.x;\n    }\n    this.x += dx || 0;\n    this.y += dy || 0;\n    return this;\n  },\n  // Returns a point that is the reflection of me with\n  // the center of inversion in ref point.\n  reflection: function (ref) {\n    return new Point(ref).move(this, this.distance(ref));\n  },\n  // Rotate point by angle around origin.\n  // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n  rotate: function (origin, angle) {\n    if (angle === 0) return this;\n    origin = origin || new Point(0, 0);\n    angle = toRad(normalizeAngle(-angle));\n    var cosAngle = cos(angle);\n    var sinAngle = sin(angle);\n    var x = cosAngle * (this.x - origin.x) - sinAngle * (this.y - origin.y) + origin.x;\n    var y = sinAngle * (this.x - origin.x) + cosAngle * (this.y - origin.y) + origin.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  round: function (precision) {\n    let f = 1; // case 0\n    if (precision) {\n      switch (precision) {\n        case 1:\n          f = 10;\n          break;\n        case 2:\n          f = 100;\n          break;\n        case 3:\n          f = 1000;\n          break;\n        default:\n          f = pow(10, precision);\n          break;\n      }\n    }\n    this.x = round(this.x * f) / f;\n    this.y = round(this.y * f) / f;\n    return this;\n  },\n  // Scale point with origin.\n  scale: function (sx, sy, origin) {\n    origin = origin && new Point(origin) || new Point(0, 0);\n    this.x = origin.x + sx * (this.x - origin.x);\n    this.y = origin.y + sy * (this.y - origin.y);\n    return this;\n  },\n  snapToGrid: function (gx, gy) {\n    this.x = snapToGrid(this.x, gx);\n    this.y = snapToGrid(this.y, gy || gx);\n    return this;\n  },\n  squaredDistance: function (p) {\n    return squaredLength(this, p);\n  },\n  // Compute the angle between me and `p` and the x axis.\n  // (cartesian-to-polar coordinates conversion)\n  // Return theta angle in degrees.\n  theta: function (p) {\n    p = new Point(p);\n\n    // Invert the y-axis.\n    var y = -(p.y - this.y);\n    var x = p.x - this.x;\n    var rad = atan2(y, x); // defined for all 0 corner cases\n\n    // Correction for III. and IV. quadrant.\n    if (rad < 0) {\n      rad = 2 * PI + rad;\n    }\n    return 180 * rad / PI;\n  },\n  toJSON: function () {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  },\n  // Converts rectangular to polar coordinates.\n  // An origin can be specified, otherwise it's 0@0.\n  toPolar: function (o) {\n    o = o && new Point(o) || new Point(0, 0);\n    var x = this.x;\n    var y = this.y;\n    this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n    this.y = toRad(o.theta(new Point(x, y)));\n    return this;\n  },\n  toString: function () {\n    return this.x + '@' + this.y;\n  },\n  serialize: function () {\n    return this.x + ',' + this.y;\n  },\n  update: function (x, y) {\n    if (Object(x) === x) {\n      y = x.y;\n      x = x.x;\n    }\n    this.x = x || 0;\n    this.y = y || 0;\n    return this;\n  },\n  // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n  // Returns NaN if p is at 0,0.\n  vectorAngle: function (p) {\n    var zero = new Point(0, 0);\n    return zero.angleBetween(this, p);\n  }\n};\nPoint.prototype.translate = Point.prototype.offset;\n\n// For backwards compatibility:\nexport const point = Point;","map":{"version":3,"names":["normalizeAngle","random","snapToGrid","toDeg","toRad","bearing","squaredLength","length","types","abs","cos","sin","sqrt","min","max","atan2","round","pow","PI","Math","Point","x","y","xy","split","indexOf","parseFloat","Object","undefined","fromPolar","distance","angle","origin","deg","x1","x2","y1","y2","prototype","type","chooseClosest","points","n","closest","minSqrDistance","Infinity","i","p","sqrDistance","squaredDistance","adhereToRect","r","containsPoint","width","height","angleBetween","p1","p2","equals","NaN","theta","point","changeInAngle","dx","dy","ref","clone","offset","cross","difference","dot","lerp","t","magnitude","manhattanDistance","move","normalize","scale","reflection","rotate","cosAngle","sinAngle","precision","f","sx","sy","gx","gy","rad","toJSON","toPolar","o","toString","serialize","update","vectorAngle","zero","translate"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/g/point.mjs"],"sourcesContent":["/*\n    Point is the most basic object consisting of x/y coordinate.\n\n    Possible instantiations are:\n    * `Point(10, 20)`\n    * `new Point(10, 20)`\n    * `Point('10 20')`\n    * `Point(Point(10, 20))`\n*/\nimport { normalizeAngle, random, snapToGrid, toDeg, toRad } from './geometry.helpers.mjs';\nimport { bearing } from './line.bearing.mjs';\nimport { squaredLength } from './line.squaredLength.mjs';\nimport { length } from './line.length.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    abs,\n    cos,\n    sin,\n    sqrt,\n    min,\n    max,\n    atan2,\n    round,\n    pow,\n    PI\n} = Math;\n\nexport const Point = function(x, y) {\n\n    if (!(this instanceof Point)) {\n        return new Point(x, y);\n    }\n\n    if (typeof x === 'string') {\n        var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\n        x = parseFloat(xy[0]);\n        y = parseFloat(xy[1]);\n\n    } else if (Object(x) === x) {\n        y = x.y;\n        x = x.x;\n    }\n\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n};\n\n// Alternative constructor, from polar coordinates.\n// @param {number} Distance.\n// @param {number} Angle in radians.\n// @param {point} [optional] Origin.\nPoint.fromPolar = function(distance, angle, origin) {\n\n    origin = new Point(origin);\n    var x = abs(distance * cos(angle));\n    var y = abs(distance * sin(angle));\n    var deg = normalizeAngle(toDeg(angle));\n\n    if (deg < 90) {\n        y = -y;\n\n    } else if (deg < 180) {\n        x = -x;\n        y = -y;\n\n    } else if (deg < 270) {\n        x = -x;\n    }\n\n    return new Point(origin.x + x, origin.y + y);\n};\n\n// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\nPoint.random = function(x1, x2, y1, y2) {\n\n    return new Point(random(x1, x2), random(y1, y2));\n};\n\nPoint.prototype = {\n\n    type: types.Point,\n\n    chooseClosest: function(points) {\n\n        var n = points.length;\n        if (n === 1) return new Point(points[0]);\n        var closest = null;\n        var minSqrDistance = Infinity;\n        for (var i = 0; i < n; i++) {\n            var p = new Point(points[i]);\n            var sqrDistance = this.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                closest = p;\n                minSqrDistance = sqrDistance;\n            }\n        }\n        return closest;\n    },\n\n    // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n    // otherwise return point itself.\n    // (see Squeak Smalltalk, Point>>adhereTo:)\n    adhereToRect: function(r) {\n\n        if (r.containsPoint(this)) {\n            return this;\n        }\n\n        this.x = min(max(this.x, r.x), r.x + r.width);\n        this.y = min(max(this.y, r.y), r.y + r.height);\n        return this;\n    },\n\n    // Compute the angle between vector from me to p1 and the vector from me to p2.\n    // ordering of points p1 and p2 is important!\n    // theta function's angle convention:\n    // returns angles between 0 and 180 when the angle is counterclockwise\n    // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n    // returns NaN if any of the points p1, p2 is coincident with this point\n    angleBetween: function(p1, p2) {\n\n        var angleBetween = (this.equals(p1) || this.equals(p2)) ? NaN : (this.theta(p2) - this.theta(p1));\n\n        if (angleBetween < 0) {\n            angleBetween += 360; // correction to keep angleBetween between 0 and 360\n        }\n\n        return angleBetween;\n    },\n\n    // Return the bearing between me and the given point.\n    bearing: function(point) {\n        return bearing(this, point);\n    },\n\n    // Returns change in angle from my previous position (-dx, -dy) to my new position\n    // relative to ref point.\n    changeInAngle: function(dx, dy, ref) {\n\n        // Revert the translation and measure the change in angle around x-axis.\n        return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n    },\n\n    clone: function() {\n\n        return new Point(this);\n    },\n\n    // Returns the cross product of this point relative to two other points\n    // this point is the common point\n    // point p1 lies on the first vector, point p2 lies on the second vector\n    // watch out for the ordering of points p1 and p2!\n    // positive result indicates a clockwise (\"right\") turn from first to second vector\n    // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n    // zero indicates that the first and second vector are collinear\n    // note that the above directions are reversed from the usual answer on the Internet\n    // that is because we are in a left-handed coord system (because the y-axis points downward)\n    cross: function(p1, p2) {\n\n        return (p1 && p2) ? (((p2.x - this.x) * (p1.y - this.y)) - ((p2.y - this.y) * (p1.x - this.x))) : NaN;\n    },\n\n    difference: function(dx, dy) {\n\n        if ((Object(dx) === dx)) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n\n        return new Point(this.x - (dx || 0), this.y - (dy || 0));\n    },\n\n    // Returns distance between me and point `p`.\n    distance: function(p) {\n        return length(this, p);\n    },\n\n    // Returns the dot product of this point with given other point\n    dot: function(p) {\n\n        return p ? (this.x * p.x + this.y * p.y) : NaN;\n    },\n\n    equals: function(p) {\n\n        return !!p &&\n            this.x === p.x &&\n            this.y === p.y;\n    },\n\n    // Linear interpolation\n    lerp: function(p, t) {\n\n        var x = this.x;\n        var y = this.y;\n        return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n    },\n\n    magnitude: function() {\n\n        return sqrt((this.x * this.x) + (this.y * this.y)) || 0.01;\n    },\n\n    // Returns a manhattan (taxi-cab) distance between me and point `p`.\n    manhattanDistance: function(p) {\n\n        return abs(p.x - this.x) + abs(p.y - this.y);\n    },\n\n    // Move point on line starting from ref ending at me by\n    // distance distance.\n    move: function(ref, distance) {\n\n        var theta = toRad((new Point(ref)).theta(this));\n        var offset = this.offset(cos(theta) * distance, -sin(theta) * distance);\n        return offset;\n    },\n\n    // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n    normalize: function(length) {\n\n        var scale = (length || 1) / this.magnitude();\n        return this.scale(scale, scale);\n    },\n\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n\n        if ((Object(dx) === dx)) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n\n        this.x += dx || 0;\n        this.y += dy || 0;\n        return this;\n    },\n\n    // Returns a point that is the reflection of me with\n    // the center of inversion in ref point.\n    reflection: function(ref) {\n\n        return (new Point(ref)).move(this, this.distance(ref));\n    },\n\n    // Rotate point by angle around origin.\n    // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n    rotate: function(origin, angle) {\n\n        if (angle === 0) return this;\n\n        origin = origin || new Point(0, 0);\n\n        angle = toRad(normalizeAngle(-angle));\n        var cosAngle = cos(angle);\n        var sinAngle = sin(angle);\n\n        var x = (cosAngle * (this.x - origin.x)) - (sinAngle * (this.y - origin.y)) + origin.x;\n        var y = (sinAngle * (this.x - origin.x)) + (cosAngle * (this.y - origin.y)) + origin.y;\n\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        return this;\n    },\n\n    // Scale point with origin.\n    scale: function(sx, sy, origin) {\n\n        origin = (origin && new Point(origin)) || new Point(0, 0);\n        this.x = origin.x + sx * (this.x - origin.x);\n        this.y = origin.y + sy * (this.y - origin.y);\n        return this;\n    },\n\n    snapToGrid: function(gx, gy) {\n\n        this.x = snapToGrid(this.x, gx);\n        this.y = snapToGrid(this.y, gy || gx);\n        return this;\n    },\n\n    squaredDistance: function(p) {\n        return squaredLength(this, p);\n    },\n\n    // Compute the angle between me and `p` and the x axis.\n    // (cartesian-to-polar coordinates conversion)\n    // Return theta angle in degrees.\n    theta: function(p) {\n\n        p = new Point(p);\n\n        // Invert the y-axis.\n        var y = -(p.y - this.y);\n        var x = p.x - this.x;\n        var rad = atan2(y, x); // defined for all 0 corner cases\n\n        // Correction for III. and IV. quadrant.\n        if (rad < 0) {\n            rad = 2 * PI + rad;\n        }\n\n        return 180 * rad / PI;\n    },\n\n    toJSON: function() {\n\n        return { x: this.x, y: this.y };\n    },\n\n    // Converts rectangular to polar coordinates.\n    // An origin can be specified, otherwise it's 0@0.\n    toPolar: function(o) {\n\n        o = (o && new Point(o)) || new Point(0, 0);\n        var x = this.x;\n        var y = this.y;\n        this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n        this.y = toRad(o.theta(new Point(x, y)));\n        return this;\n    },\n\n    toString: function() {\n\n        return this.x + '@' + this.y;\n    },\n\n    serialize: function() {\n\n        return this.x + ',' + this.y;\n    },\n\n    update: function(x, y) {\n\n        if ((Object(x) === x)) {\n            y = x.y;\n            x = x.x;\n        }\n\n        this.x = x || 0;\n        this.y = y || 0;\n        return this;\n    },\n\n    // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n    // Returns NaN if p is at 0,0.\n    vectorAngle: function(p) {\n\n        var zero = new Point(0, 0);\n        return zero.angleBetween(this, p);\n    }\n};\n\nPoint.prototype.translate = Point.prototype.offset;\n\n// For backwards compatibility:\nexport const point = Point;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}