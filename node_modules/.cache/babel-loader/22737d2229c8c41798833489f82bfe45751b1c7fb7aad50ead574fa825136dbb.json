{"ast":null,"code":"export function parsePoints(svgString) {\n  // Step 1: Discard surrounding spaces\n  const trimmedString = svgString.trim();\n  if (trimmedString === '') return [];\n  const points = [];\n\n  // Step 2: Split at commas (+ their surrounding spaces) or at multiple spaces\n  // ReDoS mitigation: Have an anchor at the beginning of each alternation\n  // Note: This doesn't simplify double (or more) commas - causes empty coords\n  // This regex is used by `split()`, so it doesn't need to use /g\n  const coords = trimmedString.split(/\\b\\s*,\\s*|,\\s*|\\s+/);\n  const numCoords = coords.length;\n  for (let i = 0; i < numCoords; i += 2) {\n    // Step 3: Convert each coord to number\n    // Note: If the coord cannot be converted to a number, it will be `NaN`\n    // Note: If the coord is empty (\"\", e.g. from \",,\" input), it will be `0`\n    // Note: If we end up with an odd number of coords, the last point's second coord will be `NaN`\n    points.push({\n      x: +coords[i],\n      y: +coords[i + 1]\n    });\n  }\n  return points;\n}\nexport function clonePoints(points) {\n  const numPoints = points.length;\n  if (numPoints === 0) return [];\n  const newPoints = [];\n  for (let i = 0; i < numPoints; i++) {\n    const point = points[i].clone();\n    newPoints.push(point);\n  }\n  return newPoints;\n}\n\n// Returns a convex-hull polyline from this polyline.\n// Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n// Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n// Minimal polyline is found (only vertices of the hull are reported, no collinear points).\nexport function convexHull(points) {\n  const {\n    abs\n  } = Math;\n  var i;\n  var n;\n  var numPoints = points.length;\n  if (numPoints === 0) return []; // if points array is empty\n\n  // step 1: find the starting point - point with the lowest y (if equality, highest x)\n  var startPoint;\n  for (i = 0; i < numPoints; i++) {\n    if (startPoint === undefined) {\n      // if this is the first point we see, set it as start point\n      startPoint = points[i];\n    } else if (points[i].y < startPoint.y) {\n      // start point should have lowest y from all points\n      startPoint = points[i];\n    } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n      // if two points have the lowest y, choose the one that has highest x\n      // there are no points to the right of startPoint - no ambiguity about theta 0\n      // if there are several coincident start point candidates, first one is reported\n      startPoint = points[i];\n    }\n  }\n\n  // step 2: sort the list of points\n  // sorting by angle between line from startPoint to point and the x-axis (theta)\n\n  // step 2a: create the point records = [point, originalIndex, angle]\n  var sortedPointRecords = [];\n  for (i = 0; i < numPoints; i++) {\n    var angle = startPoint.theta(points[i]);\n    if (angle === 0) {\n      angle = 360; // give highest angle to start point\n      // the start point will end up at end of sorted list\n      // the start point will end up at beginning of hull points list\n    }\n    var entry = [points[i], i, angle];\n    sortedPointRecords.push(entry);\n  }\n\n  // step 2b: sort the list in place\n  sortedPointRecords.sort(function (record1, record2) {\n    // returning a negative number here sorts record1 before record2\n    // if first angle is smaller than second, first angle should come before second\n\n    var sortOutput = record1[2] - record2[2]; // negative if first angle smaller\n    if (sortOutput === 0) {\n      // if the two angles are equal, sort by originalIndex\n      sortOutput = record2[1] - record1[1]; // negative if first index larger\n      // coincident points will be sorted in reverse-numerical order\n      // so the coincident points with lower original index will be considered first\n    }\n    return sortOutput;\n  });\n\n  // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n  if (sortedPointRecords.length > 2) {\n    var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n    sortedPointRecords.unshift(startPointRecord);\n  }\n\n  // step 3a: go through sorted points in order and find those with right turns\n  // we want to get our results in clockwise order\n  var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n  var hullPointRecords = []; // stack of records with right turns - hull point candidates\n\n  var currentPointRecord;\n  var currentPoint;\n  var lastHullPointRecord;\n  var lastHullPoint;\n  var secondLastHullPointRecord;\n  var secondLastHullPoint;\n  while (sortedPointRecords.length !== 0) {\n    currentPointRecord = sortedPointRecords.pop();\n    currentPoint = currentPointRecord[0];\n\n    // check if point has already been discarded\n    // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n    if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {\n      // this point had an incorrect turn at some previous iteration of this loop\n      // this disqualifies it from possibly being on the hull\n      continue;\n    }\n    var correctTurnFound = false;\n    while (!correctTurnFound) {\n      if (hullPointRecords.length < 2) {\n        // not enough points for comparison, just add current point\n        hullPointRecords.push(currentPointRecord);\n        correctTurnFound = true;\n      } else {\n        lastHullPointRecord = hullPointRecords.pop();\n        lastHullPoint = lastHullPointRecord[0];\n        secondLastHullPointRecord = hullPointRecords.pop();\n        secondLastHullPoint = secondLastHullPointRecord[0];\n        var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n        if (crossProduct < 0) {\n          // found a right turn\n          hullPointRecords.push(secondLastHullPointRecord);\n          hullPointRecords.push(lastHullPointRecord);\n          hullPointRecords.push(currentPointRecord);\n          correctTurnFound = true;\n        } else if (crossProduct === 0) {\n          // the three points are collinear\n          // three options:\n          // there may be a 180 or 0 degree angle at lastHullPoint\n          // or two of the three points are coincident\n          var THRESHOLD = 1e-10; // we have to take rounding errors into account\n          var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n          if (abs(angleBetween - 180) < THRESHOLD) {\n            // rounding around 180 to 180\n            // if the cross product is 0 because the angle is 180 degrees\n            // discard last hull point (add to insidePoints)\n            //insidePoints.unshift(lastHullPoint);\n            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n            // reenter second-to-last hull point (will be last at next iter)\n            hullPointRecords.push(secondLastHullPointRecord);\n            // do not do anything with current point\n            // correct turn not found\n          } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n            // if the cross product is 0 because two points are the same\n            // discard last hull point (add to insidePoints)\n            //insidePoints.unshift(lastHullPoint);\n            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n            // reenter second-to-last hull point (will be last at next iter)\n            hullPointRecords.push(secondLastHullPointRecord);\n            // do not do anything with current point\n            // correct turn not found\n          } else if (abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {\n            // rounding around 0 and 360 to 0\n            // if the cross product is 0 because the angle is 0 degrees\n            // remove last hull point from hull BUT do not discard it\n            // reenter second-to-last hull point (will be last at next iter)\n            hullPointRecords.push(secondLastHullPointRecord);\n            // put last hull point back into the sorted point records list\n            sortedPointRecords.push(lastHullPointRecord);\n            // we are switching the order of the 0deg and 180deg points\n            // correct turn not found\n          }\n        } else {\n          // found a left turn\n          // discard last hull point (add to insidePoints)\n          //insidePoints.unshift(lastHullPoint);\n          insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n          // reenter second-to-last hull point (will be last at next iter of loop)\n          hullPointRecords.push(secondLastHullPointRecord);\n          // do not do anything with current point\n          // correct turn not found\n        }\n      }\n    }\n  }\n  // at this point, hullPointRecords contains the output points in clockwise order\n  // the points start with lowest-y,highest-x startPoint, and end at the same point\n\n  // step 3b: remove duplicated startPointRecord from the end of the array\n  if (hullPointRecords.length > 2) {\n    hullPointRecords.pop();\n  }\n\n  // step 4: find the lowest originalIndex record and put it at the beginning of hull\n  var lowestHullIndex; // the lowest originalIndex on the hull\n  var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n  n = hullPointRecords.length;\n  for (i = 0; i < n; i++) {\n    var currentHullIndex = hullPointRecords[i][1];\n    if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n      lowestHullIndex = currentHullIndex;\n      indexOfLowestHullIndexRecord = i;\n    }\n  }\n  var hullPointRecordsReordered = [];\n  if (indexOfLowestHullIndexRecord > 0) {\n    var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n    var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n    hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n  } else {\n    hullPointRecordsReordered = hullPointRecords;\n  }\n  var hullPoints = [];\n  n = hullPointRecordsReordered.length;\n  for (i = 0; i < n; i++) {\n    hullPoints.push(hullPointRecordsReordered[i][0]);\n  }\n  return hullPoints;\n}","map":{"version":3,"names":["parsePoints","svgString","trimmedString","trim","points","coords","split","numCoords","length","i","push","x","y","clonePoints","numPoints","newPoints","point","clone","convexHull","abs","Math","n","startPoint","undefined","sortedPointRecords","angle","theta","entry","sort","record1","record2","sortOutput","startPointRecord","unshift","insidePoints","hullPointRecords","currentPointRecord","currentPoint","lastHullPointRecord","lastHullPoint","secondLastHullPointRecord","secondLastHullPoint","pop","hasOwnProperty","correctTurnFound","crossProduct","cross","THRESHOLD","angleBetween","equals","lowestHullIndex","indexOfLowestHullIndexRecord","currentHullIndex","hullPointRecordsReordered","newFirstChunk","slice","newSecondChunk","concat","hullPoints"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/g/points.mjs"],"sourcesContent":["export function parsePoints(svgString) {\n\n    // Step 1: Discard surrounding spaces\n    const trimmedString = svgString.trim();\n    if (trimmedString === '') return [];\n\n    const points = [];\n\n    // Step 2: Split at commas (+ their surrounding spaces) or at multiple spaces\n    // ReDoS mitigation: Have an anchor at the beginning of each alternation\n    // Note: This doesn't simplify double (or more) commas - causes empty coords\n    // This regex is used by `split()`, so it doesn't need to use /g\n    const coords = trimmedString.split(/\\b\\s*,\\s*|,\\s*|\\s+/);\n\n    const numCoords = coords.length;\n    for (let i = 0; i < numCoords; i += 2) {\n        // Step 3: Convert each coord to number\n        // Note: If the coord cannot be converted to a number, it will be `NaN`\n        // Note: If the coord is empty (\"\", e.g. from \",,\" input), it will be `0`\n        // Note: If we end up with an odd number of coords, the last point's second coord will be `NaN`\n        points.push({ x: +coords[i], y: +coords[i + 1] });\n    }\n    return points;\n}\n\nexport function clonePoints(points) {\n    const numPoints = points.length;\n    if (numPoints === 0) return [];\n    const newPoints = [];\n    for (let i = 0; i < numPoints; i++) {\n        const point = points[i].clone();\n        newPoints.push(point);\n    }\n    return newPoints;\n}\n\n// Returns a convex-hull polyline from this polyline.\n// Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n// Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n// Minimal polyline is found (only vertices of the hull are reported, no collinear points).\nexport function convexHull(points) {\n\n    const { abs } = Math;\n\n    var i;\n    var n;\n\n    var numPoints = points.length;\n    if (numPoints === 0) return []; // if points array is empty\n\n    // step 1: find the starting point - point with the lowest y (if equality, highest x)\n    var startPoint;\n    for (i = 0; i < numPoints; i++) {\n        if (startPoint === undefined) {\n            // if this is the first point we see, set it as start point\n            startPoint = points[i];\n\n        } else if (points[i].y < startPoint.y) {\n            // start point should have lowest y from all points\n            startPoint = points[i];\n\n        } else if ((points[i].y === startPoint.y) && (points[i].x > startPoint.x)) {\n            // if two points have the lowest y, choose the one that has highest x\n            // there are no points to the right of startPoint - no ambiguity about theta 0\n            // if there are several coincident start point candidates, first one is reported\n            startPoint = points[i];\n        }\n    }\n\n    // step 2: sort the list of points\n    // sorting by angle between line from startPoint to point and the x-axis (theta)\n\n    // step 2a: create the point records = [point, originalIndex, angle]\n    var sortedPointRecords = [];\n    for (i = 0; i < numPoints; i++) {\n\n        var angle = startPoint.theta(points[i]);\n        if (angle === 0) {\n            angle = 360; // give highest angle to start point\n            // the start point will end up at end of sorted list\n            // the start point will end up at beginning of hull points list\n        }\n\n        var entry = [points[i], i, angle];\n        sortedPointRecords.push(entry);\n    }\n\n    // step 2b: sort the list in place\n    sortedPointRecords.sort(function(record1, record2) {\n        // returning a negative number here sorts record1 before record2\n        // if first angle is smaller than second, first angle should come before second\n\n        var sortOutput = record1[2] - record2[2];  // negative if first angle smaller\n        if (sortOutput === 0) {\n            // if the two angles are equal, sort by originalIndex\n            sortOutput = record2[1] - record1[1]; // negative if first index larger\n            // coincident points will be sorted in reverse-numerical order\n            // so the coincident points with lower original index will be considered first\n        }\n\n        return sortOutput;\n    });\n\n    // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n    if (sortedPointRecords.length > 2) {\n        var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n        sortedPointRecords.unshift(startPointRecord);\n    }\n\n    // step 3a: go through sorted points in order and find those with right turns\n    // we want to get our results in clockwise order\n    var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n    var hullPointRecords = []; // stack of records with right turns - hull point candidates\n\n    var currentPointRecord;\n    var currentPoint;\n    var lastHullPointRecord;\n    var lastHullPoint;\n    var secondLastHullPointRecord;\n    var secondLastHullPoint;\n    while (sortedPointRecords.length !== 0) {\n\n        currentPointRecord = sortedPointRecords.pop();\n        currentPoint = currentPointRecord[0];\n\n        // check if point has already been discarded\n        // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n        if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {\n            // this point had an incorrect turn at some previous iteration of this loop\n            // this disqualifies it from possibly being on the hull\n            continue;\n        }\n\n        var correctTurnFound = false;\n        while (!correctTurnFound) {\n\n            if (hullPointRecords.length < 2) {\n                // not enough points for comparison, just add current point\n                hullPointRecords.push(currentPointRecord);\n                correctTurnFound = true;\n\n            } else {\n                lastHullPointRecord = hullPointRecords.pop();\n                lastHullPoint = lastHullPointRecord[0];\n                secondLastHullPointRecord = hullPointRecords.pop();\n                secondLastHullPoint = secondLastHullPointRecord[0];\n\n                var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n                if (crossProduct < 0) {\n                    // found a right turn\n                    hullPointRecords.push(secondLastHullPointRecord);\n                    hullPointRecords.push(lastHullPointRecord);\n                    hullPointRecords.push(currentPointRecord);\n                    correctTurnFound = true;\n\n                } else if (crossProduct === 0) {\n                    // the three points are collinear\n                    // three options:\n                    // there may be a 180 or 0 degree angle at lastHullPoint\n                    // or two of the three points are coincident\n                    var THRESHOLD = 1e-10; // we have to take rounding errors into account\n                    var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n                    if (abs(angleBetween - 180) < THRESHOLD) { // rounding around 180 to 180\n                        // if the cross product is 0 because the angle is 180 degrees\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n\n                    } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n                        // if the cross product is 0 because two points are the same\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n\n                    } else if (abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) { // rounding around 0 and 360 to 0\n                        // if the cross product is 0 because the angle is 0 degrees\n                        // remove last hull point from hull BUT do not discard it\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // put last hull point back into the sorted point records list\n                        sortedPointRecords.push(lastHullPointRecord);\n                        // we are switching the order of the 0deg and 180deg points\n                        // correct turn not found\n                    }\n\n                } else {\n                    // found a left turn\n                    // discard last hull point (add to insidePoints)\n                    //insidePoints.unshift(lastHullPoint);\n                    insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                    // reenter second-to-last hull point (will be last at next iter of loop)\n                    hullPointRecords.push(secondLastHullPointRecord);\n                    // do not do anything with current point\n                    // correct turn not found\n                }\n            }\n        }\n    }\n    // at this point, hullPointRecords contains the output points in clockwise order\n    // the points start with lowest-y,highest-x startPoint, and end at the same point\n\n    // step 3b: remove duplicated startPointRecord from the end of the array\n    if (hullPointRecords.length > 2) {\n        hullPointRecords.pop();\n    }\n\n    // step 4: find the lowest originalIndex record and put it at the beginning of hull\n    var lowestHullIndex; // the lowest originalIndex on the hull\n    var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n    n = hullPointRecords.length;\n    for (i = 0; i < n; i++) {\n\n        var currentHullIndex = hullPointRecords[i][1];\n\n        if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n            lowestHullIndex = currentHullIndex;\n            indexOfLowestHullIndexRecord = i;\n        }\n    }\n\n    var hullPointRecordsReordered = [];\n    if (indexOfLowestHullIndexRecord > 0) {\n        var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n        var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n        hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n\n    } else {\n        hullPointRecordsReordered = hullPointRecords;\n    }\n\n    var hullPoints = [];\n    n = hullPointRecordsReordered.length;\n    for (i = 0; i < n; i++) {\n        hullPoints.push(hullPointRecordsReordered[i][0]);\n    }\n\n    return hullPoints;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}