{"ast":null,"code":"import { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { Line } from './line.mjs';\nimport { types } from './types.mjs';\nimport { clonePoints, parsePoints, convexHull } from './points.mjs';\nexport const Polyline = function (points) {\n  if (!(this instanceof Polyline)) {\n    return new Polyline(points);\n  }\n  if (typeof points === 'string') {\n    return new Polyline.parse(points);\n  }\n  this.points = Array.isArray(points) ? points.map(Point) : [];\n};\nPolyline.parse = function (svgString) {\n  return new Polyline(parsePoints(svgString));\n};\nPolyline.fromRect = function (rect) {\n  return new Polyline([rect.topLeft(), rect.topRight(), rect.bottomRight(), rect.bottomLeft(), rect.topLeft()]);\n};\nPolyline.prototype = {\n  type: types.Polyline,\n  bbox: function () {\n    var x1 = Infinity;\n    var x2 = -Infinity;\n    var y1 = Infinity;\n    var y2 = -Infinity;\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    for (var i = 0; i < numPoints; i++) {\n      var point = points[i];\n      var x = point.x;\n      var y = point.y;\n      if (x < x1) x1 = x;\n      if (x > x2) x2 = x;\n      if (y < y1) y1 = y;\n      if (y > y2) y2 = y;\n    }\n    return new Rect(x1, y1, x2 - x1, y2 - y1);\n  },\n  clone: function () {\n    return new Polyline(clonePoints(this.points));\n  },\n  closestPoint: function (p) {\n    var cpLength = this.closestPointLength(p);\n    return this.pointAtLength(cpLength);\n  },\n  closestPointLength: function (p) {\n    var points = this.lengthPoints();\n    var numPoints = points.length;\n    if (numPoints === 0) return 0; // if points array is empty\n    if (numPoints === 1) return 0; // if there is only one point\n\n    var cpLength;\n    var minSqrDistance = Infinity;\n    var length = 0;\n    var n = numPoints - 1;\n    for (var i = 0; i < n; i++) {\n      var line = new Line(points[i], points[i + 1]);\n      var lineLength = line.length();\n      var cpNormalizedLength = line.closestPointNormalizedLength(p);\n      var cp = line.pointAt(cpNormalizedLength);\n      var sqrDistance = cp.squaredDistance(p);\n      if (sqrDistance < minSqrDistance) {\n        minSqrDistance = sqrDistance;\n        cpLength = length + cpNormalizedLength * lineLength;\n      }\n      length += lineLength;\n    }\n    return cpLength;\n  },\n  closestPointNormalizedLength: function (p) {\n    var cpLength = this.closestPointLength(p);\n    if (cpLength === 0) return 0; // shortcut\n\n    var length = this.length();\n    if (length === 0) return 0; // prevents division by zero\n\n    return cpLength / length;\n  },\n  closestPointTangent: function (p) {\n    var cpLength = this.closestPointLength(p);\n    return this.tangentAtLength(cpLength);\n  },\n  // Returns `true` if the area surrounded by the polyline contains the point `p`.\n  // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n  // (Uses horizontal rays to the right of `p` to look for intersections.)\n  // Closes open polylines (always imagines a final closing segment).\n  containsPoint: function (p) {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return false; // shortcut (this polyline has no points)\n\n    var x = p.x;\n    var y = p.y;\n\n    // initialize a final closing segment by creating one from last-first points on polyline\n    var startIndex = numPoints - 1; // start of current polyline segment\n    var endIndex = 0; // end of current polyline segment\n    var numIntersections = 0;\n    var segment = new Line();\n    var ray = new Line();\n    var rayEnd = new Point();\n    for (; endIndex < numPoints; endIndex++) {\n      var start = points[startIndex];\n      var end = points[endIndex];\n      if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)\n      // current polyline segment\n      segment.start = start;\n      segment.end = end;\n      if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)\n\n      // do we have an intersection?\n      if (y <= start.y && y > end.y || y > start.y && y <= end.y) {\n        // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n        // (when `y === start.y === end.y`)\n        // this conditional branch IS entered when `segment` touches `ray` at only one point\n        // (e.g. when `y === start.y !== end.y`)\n        // since this branch is entered again for the following segment, the two touches cancel out\n\n        var xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n        if (xDifference >= 0) {\n          // segment lies at least partially to the right of `p`\n          rayEnd.x = x + xDifference;\n          rayEnd.y = y; // right\n          ray.start = p;\n          ray.end = rayEnd;\n          if (segment.intersect(ray)) {\n            // an intersection was detected to the right of `p`\n            numIntersections++;\n          }\n        } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n      }\n\n      // move to check the next polyline segment\n      startIndex = endIndex;\n    }\n\n    // returns `true` for odd numbers of intersections (even-odd algorithm)\n    return numIntersections % 2 === 1;\n  },\n  close: function () {\n    const {\n      start,\n      end,\n      points\n    } = this;\n    if (start && end && !start.equals(end)) {\n      points.push(start.clone());\n    }\n    return this;\n  },\n  lengthPoints: function () {\n    return this.points;\n  },\n  convexHull: function () {\n    return new Polyline(convexHull(this.points));\n  },\n  // Checks whether two polylines are exactly the same.\n  // If `p` is undefined or null, returns false.\n  equals: function (p) {\n    if (!p) return false;\n    var points = this.points;\n    var otherPoints = p.points;\n    var numPoints = points.length;\n    if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal\n\n    for (var i = 0; i < numPoints; i++) {\n      var point = points[i];\n      var otherPoint = p.points[i];\n\n      // as soon as an inequality is found in points, return false\n      if (!point.equals(otherPoint)) return false;\n    }\n\n    // if no inequality found in points, return true\n    return true;\n  },\n  intersectionWithLine: function (l) {\n    var line = new Line(l);\n    var intersections = [];\n    var points = this.lengthPoints();\n    var l2 = new Line();\n    for (var i = 0, n = points.length - 1; i < n; i++) {\n      l2.start = points[i];\n      l2.end = points[i + 1];\n      var int = line.intersectionWithLine(l2);\n      if (int) intersections.push(int[0]);\n    }\n    return intersections.length > 0 ? intersections : null;\n  },\n  isDifferentiable: function () {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return false;\n    var line = new Line();\n    var n = numPoints - 1;\n    for (var i = 0; i < n; i++) {\n      line.start = points[i];\n      line.end = points[i + 1];\n      // as soon as a differentiable line is found between two points, return true\n      if (line.isDifferentiable()) return true;\n    }\n\n    // if no differentiable line is found between pairs of points, return false\n    return false;\n  },\n  length: function () {\n    var points = this.lengthPoints();\n    var numPoints = points.length;\n    if (numPoints === 0) return 0; // if points array is empty\n\n    var length = 0;\n    var n = numPoints - 1;\n    for (var i = 0; i < n; i++) {\n      length += points[i].distance(points[i + 1]);\n    }\n    return length;\n  },\n  pointAt: function (ratio) {\n    var points = this.lengthPoints();\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n    if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n    if (ratio <= 0) return points[0].clone();\n    if (ratio >= 1) return points[numPoints - 1].clone();\n    var polylineLength = this.length();\n    var length = polylineLength * ratio;\n    return this.pointAtLength(length);\n  },\n  pointAtLength: function (length) {\n    var points = this.lengthPoints();\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n    if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n    var fromStart = true;\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n      length = -length; // absolute value\n    }\n    var l = 0;\n    var n = numPoints - 1;\n    for (var i = 0; i < n; i++) {\n      var index = fromStart ? i : n - 1 - i;\n      var a = points[index];\n      var b = points[index + 1];\n      var line = new Line(a, b);\n      var d = a.distance(b);\n      if (length <= l + d) {\n        return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n      }\n      l += d;\n    }\n\n    // if length requested is higher than the length of the polyline, return last endpoint\n    var lastPoint = fromStart ? points[numPoints - 1] : points[0];\n    return lastPoint.clone();\n  },\n  round: function (precision) {\n    var points = this.points;\n    var numPoints = points.length;\n    for (var i = 0; i < numPoints; i++) {\n      points[i].round(precision);\n    }\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    var points = this.points;\n    var numPoints = points.length;\n    for (var i = 0; i < numPoints; i++) {\n      points[i].scale(sx, sy, origin);\n    }\n    return this;\n  },\n  simplify: function (opt = {}) {\n    const points = this.points;\n    if (points.length < 3) return this; // we need at least 3 points\n\n    // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n\n    // Due to the nature of the algorithm, we do not use 0 as the default value for `threshold`\n    // because of the rounding errors that can occur when comparing distances.\n    const threshold = opt.threshold || 1e-10; // = max distance of middle point from chord to be simplified\n\n    // start at the beginning of the polyline and go forward\n    let currentIndex = 0;\n    // we need at least one intermediate point (3 points) in every iteration\n    // as soon as that stops being true, we know we reached the end of the polyline\n    while (points[currentIndex + 2]) {\n      const firstIndex = currentIndex;\n      const middleIndex = currentIndex + 1;\n      const lastIndex = currentIndex + 2;\n      const firstPoint = points[firstIndex];\n      const middlePoint = points[middleIndex];\n      const lastPoint = points[lastIndex];\n      const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n      const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n      const closestPointDistance = closestPoint.distance(middlePoint);\n      if (closestPointDistance <= threshold) {\n        // middle point is close enough to the chord = simplify\n        // 1) remove middle point:\n        points.splice(middleIndex, 1);\n        // 2) in next iteration, investigate the newly-created triplet of points\n        //    - do not change `currentIndex`\n        //    = (first point stays, point after removed point becomes middle point)\n      } else {\n        // middle point is far from the chord\n        // 1) preserve middle point\n        // 2) in next iteration, move `currentIndex` by one step:\n        currentIndex += 1;\n        //    = (point after first point becomes first point)\n      }\n    }\n\n    // `points` array was modified in-place\n    return this;\n  },\n  tangentAt: function (ratio) {\n    var points = this.lengthPoints();\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n    if (numPoints === 1) return null; // if there is only one point\n\n    if (ratio < 0) ratio = 0;\n    if (ratio > 1) ratio = 1;\n    var polylineLength = this.length();\n    var length = polylineLength * ratio;\n    return this.tangentAtLength(length);\n  },\n  tangentAtLength: function (length) {\n    var points = this.lengthPoints();\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n    if (numPoints === 1) return null; // if there is only one point\n\n    var fromStart = true;\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n      length = -length; // absolute value\n    }\n    var lastValidLine; // differentiable (with a tangent)\n    var l = 0; // length so far\n    var n = numPoints - 1;\n    for (var i = 0; i < n; i++) {\n      var index = fromStart ? i : n - 1 - i;\n      var a = points[index];\n      var b = points[index + 1];\n      var line = new Line(a, b);\n      var d = a.distance(b);\n      if (line.isDifferentiable()) {\n        // has a tangent line (line length is not 0)\n        if (length <= l + d) {\n          return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n        }\n        lastValidLine = line;\n      }\n      l += d;\n    }\n\n    // if length requested is higher than the length of the polyline, return last valid endpoint\n    if (lastValidLine) {\n      var ratio = fromStart ? 1 : 0;\n      return lastValidLine.tangentAt(ratio);\n    }\n\n    // if no valid line, return null\n    return null;\n  },\n  toString: function () {\n    return this.points + '';\n  },\n  translate: function (tx, ty) {\n    var points = this.points;\n    var numPoints = points.length;\n    for (var i = 0; i < numPoints; i++) {\n      points[i].translate(tx, ty);\n    }\n    return this;\n  },\n  // Return svgString that can be used to recreate this line.\n  serialize: function () {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return ''; // if points array is empty\n\n    var output = '';\n    for (var i = 0; i < numPoints; i++) {\n      var point = points[i];\n      output += point.x + ',' + point.y + ' ';\n    }\n    return output.trim();\n  }\n};\nObject.defineProperty(Polyline.prototype, 'start', {\n  // Getter for the first point of the polyline.\n\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    return this.points[0];\n  }\n});\nObject.defineProperty(Polyline.prototype, 'end', {\n  // Getter for the last point of the polyline.\n\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    return this.points[numPoints - 1];\n  }\n});","map":{"version":3,"names":["Rect","Point","Line","types","clonePoints","parsePoints","convexHull","Polyline","points","parse","Array","isArray","map","svgString","fromRect","rect","topLeft","topRight","bottomRight","bottomLeft","prototype","type","bbox","x1","Infinity","x2","y1","y2","numPoints","length","i","point","x","y","clone","closestPoint","p","cpLength","closestPointLength","pointAtLength","lengthPoints","minSqrDistance","n","line","lineLength","cpNormalizedLength","closestPointNormalizedLength","cp","pointAt","sqrDistance","squaredDistance","closestPointTangent","tangentAtLength","containsPoint","startIndex","endIndex","numIntersections","segment","ray","rayEnd","start","end","equals","xDifference","intersect","close","push","otherPoints","otherPoint","intersectionWithLine","l","intersections","l2","int","isDifferentiable","distance","ratio","polylineLength","fromStart","index","a","b","d","lastPoint","round","precision","scale","sx","sy","origin","simplify","opt","threshold","currentIndex","firstIndex","middleIndex","lastIndex","firstPoint","middlePoint","chord","closestPointDistance","splice","tangentAt","lastValidLine","toString","translate","tx","ty","serialize","output","trim","Object","defineProperty","configurable","enumerable","get"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/g/polyline.mjs"],"sourcesContent":["import { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { Line } from './line.mjs';\nimport { types } from './types.mjs';\nimport { clonePoints, parsePoints, convexHull } from './points.mjs';\n\n\nexport const Polyline = function(points) {\n\n    if (!(this instanceof Polyline)) {\n        return new Polyline(points);\n    }\n\n    if (typeof points === 'string') {\n        return new Polyline.parse(points);\n    }\n\n    this.points = (Array.isArray(points) ? points.map(Point) : []);\n};\n\nPolyline.parse = function(svgString) {\n    return new Polyline(parsePoints(svgString));\n};\n\nPolyline.fromRect = function(rect) {\n    return new Polyline([\n        rect.topLeft(),\n        rect.topRight(),\n        rect.bottomRight(),\n        rect.bottomLeft(),\n        rect.topLeft(),\n    ]);\n};\n\nPolyline.prototype = {\n\n    type: types.Polyline,\n\n    bbox: function() {\n\n        var x1 = Infinity;\n        var x2 = -Infinity;\n        var y1 = Infinity;\n        var y2 = -Infinity;\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            var x = point.x;\n            var y = point.y;\n\n            if (x < x1) x1 = x;\n            if (x > x2) x2 = x;\n            if (y < y1) y1 = y;\n            if (y > y2) y2 = y;\n        }\n\n        return new Rect(x1, y1, x2 - x1, y2 - y1);\n    },\n\n    clone: function() {\n        return new Polyline(clonePoints(this.points));\n    },\n\n    closestPoint: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n\n        return this.pointAtLength(cpLength);\n    },\n\n    closestPointLength: function(p) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n        if (numPoints === 1) return 0; // if there is only one point\n\n        var cpLength;\n        var minSqrDistance = Infinity;\n        var length = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n\n            var line = new Line(points[i], points[i + 1]);\n            var lineLength = line.length();\n\n            var cpNormalizedLength = line.closestPointNormalizedLength(p);\n            var cp = line.pointAt(cpNormalizedLength);\n\n            var sqrDistance = cp.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                minSqrDistance = sqrDistance;\n                cpLength = length + (cpNormalizedLength * lineLength);\n            }\n\n            length += lineLength;\n        }\n\n        return cpLength;\n    },\n\n    closestPointNormalizedLength: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n        if (cpLength === 0) return 0; // shortcut\n\n        var length = this.length();\n        if (length === 0) return 0; // prevents division by zero\n\n        return cpLength / length;\n    },\n\n    closestPointTangent: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n\n        return this.tangentAtLength(cpLength);\n    },\n\n    // Returns `true` if the area surrounded by the polyline contains the point `p`.\n    // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n    // (Uses horizontal rays to the right of `p` to look for intersections.)\n    // Closes open polylines (always imagines a final closing segment).\n    containsPoint: function(p) {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false; // shortcut (this polyline has no points)\n\n        var x = p.x;\n        var y = p.y;\n\n        // initialize a final closing segment by creating one from last-first points on polyline\n        var startIndex = numPoints - 1; // start of current polyline segment\n        var endIndex = 0; // end of current polyline segment\n        var numIntersections = 0;\n        var segment = new Line();\n        var ray = new Line();\n        var rayEnd = new Point();\n        for (; endIndex < numPoints; endIndex++) {\n            var start = points[startIndex];\n            var end = points[endIndex];\n            if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)\n            // current polyline segment\n            segment.start = start;\n            segment.end = end;\n            if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)\n\n            // do we have an intersection?\n            if (((y <= start.y) && (y > end.y)) || ((y > start.y) && (y <= end.y))) {\n                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n                // (when `y === start.y === end.y`)\n                // this conditional branch IS entered when `segment` touches `ray` at only one point\n                // (e.g. when `y === start.y !== end.y`)\n                // since this branch is entered again for the following segment, the two touches cancel out\n\n                var xDifference = (((start.x - x) > (end.x - x)) ? (start.x - x) : (end.x - x));\n                if (xDifference >= 0) {\n                    // segment lies at least partially to the right of `p`\n                    rayEnd.x = x + xDifference;\n                    rayEnd.y = y; // right\n                    ray.start = p;\n                    ray.end = rayEnd;\n                    if (segment.intersect(ray)) {\n                        // an intersection was detected to the right of `p`\n                        numIntersections++;\n                    }\n                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n            }\n\n            // move to check the next polyline segment\n            startIndex = endIndex;\n        }\n\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return ((numIntersections % 2) === 1);\n    },\n\n    close: function() {\n        const { start, end, points } = this;\n        if (start && end && !start.equals(end)) {\n            points.push(start.clone());\n        }\n        return this;\n    },\n\n    lengthPoints: function() {\n        return this.points;\n    },\n\n    convexHull: function() {\n        return new Polyline(convexHull(this.points));\n    },\n\n    // Checks whether two polylines are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n\n        if (!p) return false;\n\n        var points = this.points;\n        var otherPoints = p.points;\n\n        var numPoints = points.length;\n        if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal\n\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            var otherPoint = p.points[i];\n\n            // as soon as an inequality is found in points, return false\n            if (!point.equals(otherPoint)) return false;\n        }\n\n        // if no inequality found in points, return true\n        return true;\n    },\n\n    intersectionWithLine: function(l) {\n        var line = new Line(l);\n        var intersections = [];\n        var points = this.lengthPoints();\n        var l2 = new Line();\n        for (var i = 0, n = points.length - 1; i < n; i++) {\n            l2.start = points[i];\n            l2.end = points[i + 1];\n            var int = line.intersectionWithLine(l2);\n            if (int) intersections.push(int[0]);\n        }\n        return (intersections.length > 0) ? intersections : null;\n    },\n\n    isDifferentiable: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false;\n\n        var line = new Line();\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            line.start = points[i];\n            line.end = points[i + 1];\n            // as soon as a differentiable line is found between two points, return true\n            if (line.isDifferentiable()) return true;\n        }\n\n        // if no differentiable line is found between pairs of points, return false\n        return false;\n    },\n\n    length: function() {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n\n        var length = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            length += points[i].distance(points[i + 1]);\n        }\n\n        return length;\n    },\n\n    pointAt: function(ratio) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n        if (ratio <= 0) return points[0].clone();\n        if (ratio >= 1) return points[numPoints - 1].clone();\n\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n\n        return this.pointAtLength(length);\n    },\n\n    pointAtLength: function(length) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var l = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new Line(a, b);\n            var d = a.distance(b);\n\n            if (length <= (l + d)) {\n                return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the polyline, return last endpoint\n        var lastPoint = (fromStart ? points[numPoints - 1] : points[0]);\n        return lastPoint.clone();\n    },\n\n    round: function(precision) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].round(precision);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].scale(sx, sy, origin);\n        }\n\n        return this;\n    },\n\n    simplify: function(opt = {}) {\n\n        const points = this.points;\n        if (points.length < 3) return this; // we need at least 3 points\n\n        // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n\n        // Due to the nature of the algorithm, we do not use 0 as the default value for `threshold`\n        // because of the rounding errors that can occur when comparing distances.\n        const threshold = opt.threshold || 1e-10; // = max distance of middle point from chord to be simplified\n\n        // start at the beginning of the polyline and go forward\n        let currentIndex = 0;\n        // we need at least one intermediate point (3 points) in every iteration\n        // as soon as that stops being true, we know we reached the end of the polyline\n        while (points[currentIndex + 2]) {\n            const firstIndex = currentIndex;\n            const middleIndex = (currentIndex + 1);\n            const lastIndex = (currentIndex + 2);\n\n            const firstPoint = points[firstIndex];\n            const middlePoint = points[middleIndex];\n            const lastPoint = points[lastIndex];\n\n            const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n            const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n            const closestPointDistance = closestPoint.distance(middlePoint);\n            if (closestPointDistance <= threshold) {\n                // middle point is close enough to the chord = simplify\n                // 1) remove middle point:\n                points.splice(middleIndex, 1);\n                // 2) in next iteration, investigate the newly-created triplet of points\n                //    - do not change `currentIndex`\n                //    = (first point stays, point after removed point becomes middle point)\n            } else {\n                // middle point is far from the chord\n                // 1) preserve middle point\n                // 2) in next iteration, move `currentIndex` by one step:\n                currentIndex += 1;\n                //    = (point after first point becomes first point)\n            }\n        }\n\n        // `points` array was modified in-place\n        return this;\n    },\n\n    tangentAt: function(ratio) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n\n        return this.tangentAtLength(length);\n    },\n\n    tangentAtLength: function(length) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var lastValidLine; // differentiable (with a tangent)\n        var l = 0; // length so far\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new Line(a, b);\n            var d = a.distance(b);\n\n            if (line.isDifferentiable()) { // has a tangent line (line length is not 0)\n                if (length <= (l + d)) {\n                    return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n                }\n\n                lastValidLine = line;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the polyline, return last valid endpoint\n        if (lastValidLine) {\n            var ratio = (fromStart ? 1 : 0);\n            return lastValidLine.tangentAt(ratio);\n        }\n\n        // if no valid line, return null\n        return null;\n    },\n\n    toString: function() {\n\n        return this.points + '';\n    },\n\n    translate: function(tx, ty) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].translate(tx, ty);\n        }\n\n        return this;\n    },\n\n    // Return svgString that can be used to recreate this line.\n    serialize: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return ''; // if points array is empty\n\n        var output = '';\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            output += point.x + ',' + point.y + ' ';\n        }\n\n        return output.trim();\n    }\n};\n\nObject.defineProperty(Polyline.prototype, 'start', {\n    // Getter for the first point of the polyline.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        return this.points[0];\n    },\n});\n\nObject.defineProperty(Polyline.prototype, 'end', {\n    // Getter for the last point of the polyline.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        return this.points[numPoints - 1];\n    },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}