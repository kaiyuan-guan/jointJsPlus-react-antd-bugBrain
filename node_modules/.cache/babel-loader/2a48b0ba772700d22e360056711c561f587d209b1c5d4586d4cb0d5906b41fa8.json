{"ast":null,"code":"import { Point } from '../../g/index.mjs';\nfunction atConnectionWrapper(method, opt) {\n  var zeroVector = new Point(1, 0);\n  return function (value) {\n    var p, angle;\n    var tangent = this[method](value);\n    if (tangent) {\n      angle = opt.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n      p = tangent.start;\n    } else {\n      p = this.path.start;\n      angle = 0;\n    }\n    if (angle === 0) return {\n      transform: 'translate(' + p.x + ',' + p.y + ')'\n    };\n    return {\n      transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')'\n    };\n  };\n}\nfunction isLinkView() {\n  return this.model.isLink();\n}\nconst connectionAttributesNS = {\n  'connection': {\n    qualify: isLinkView,\n    set: function ({\n      stubs = 0\n    }) {\n      let d;\n      if (isFinite(stubs) && stubs !== 0) {\n        let offset;\n        if (stubs < 0) {\n          offset = (this.getConnectionLength() + stubs) / 2;\n        } else {\n          offset = stubs;\n        }\n        const path = this.getConnection();\n        const segmentSubdivisions = this.getConnectionSubdivisions();\n        const sourceParts = path.divideAtLength(offset, {\n          segmentSubdivisions\n        });\n        const targetParts = path.divideAtLength(-offset, {\n          segmentSubdivisions\n        });\n        if (sourceParts && targetParts) {\n          d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n        }\n      }\n      return {\n        d: d || this.getSerializedConnection()\n      };\n    }\n  },\n  'at-connection-length-keep-gradient': {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtLength', {\n      rotate: true\n    })\n  },\n  'at-connection-length-ignore-gradient': {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtLength', {\n      rotate: false\n    })\n  },\n  'at-connection-ratio-keep-gradient': {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtRatio', {\n      rotate: true\n    })\n  },\n  'at-connection-ratio-ignore-gradient': {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtRatio', {\n      rotate: false\n    })\n  }\n};\nconnectionAttributesNS['at-connection-length'] = connectionAttributesNS['at-connection-length-keep-gradient'];\nconnectionAttributesNS['at-connection-ratio'] = connectionAttributesNS['at-connection-ratio-keep-gradient'];\nexport default connectionAttributesNS;","map":{"version":3,"names":["Point","atConnectionWrapper","method","opt","zeroVector","value","p","angle","tangent","rotate","vector","vectorAngle","start","path","transform","x","y","isLinkView","model","isLink","connectionAttributesNS","qualify","set","stubs","d","isFinite","offset","getConnectionLength","getConnection","segmentSubdivisions","getConnectionSubdivisions","sourceParts","divideAtLength","targetParts","serialize","getSerializedConnection"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/dia/attributes/connection.mjs"],"sourcesContent":["import { Point } from '../../g/index.mjs';\n\nfunction atConnectionWrapper(method, opt) {\n    var zeroVector = new Point(1, 0);\n    return function(value) {\n        var p, angle;\n        var tangent = this[method](value);\n        if (tangent) {\n            angle = (opt.rotate) ? tangent.vector().vectorAngle(zeroVector) : 0;\n            p = tangent.start;\n        } else {\n            p = this.path.start;\n            angle = 0;\n        }\n        if (angle === 0) return { transform: 'translate(' + p.x + ',' + p.y + ')' };\n        return { transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')' };\n    };\n}\n\nfunction isLinkView() {\n    return this.model.isLink();\n}\n\nconst connectionAttributesNS = {\n\n    'connection': {\n        qualify: isLinkView,\n        set: function({ stubs = 0 }) {\n            let d;\n            if (isFinite(stubs) && stubs !== 0) {\n                let offset;\n                if (stubs < 0) {\n                    offset = (this.getConnectionLength() + stubs) / 2;\n                } else {\n                    offset = stubs;\n                }\n                const path = this.getConnection();\n                const segmentSubdivisions = this.getConnectionSubdivisions();\n                const sourceParts = path.divideAtLength(offset, { segmentSubdivisions });\n                const targetParts = path.divideAtLength(-offset, { segmentSubdivisions });\n                if (sourceParts && targetParts) {\n                    d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n                }\n            }\n\n            return { d: d || this.getSerializedConnection() };\n        }\n    },\n\n    'at-connection-length-keep-gradient': {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtLength', { rotate: true })\n    },\n\n    'at-connection-length-ignore-gradient': {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtLength', { rotate: false })\n    },\n\n    'at-connection-ratio-keep-gradient': {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtRatio', { rotate: true })\n    },\n\n    'at-connection-ratio-ignore-gradient': {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtRatio', { rotate: false })\n    }\n\n};\n\nconnectionAttributesNS['at-connection-length'] = connectionAttributesNS['at-connection-length-keep-gradient'];\nconnectionAttributesNS['at-connection-ratio'] = connectionAttributesNS['at-connection-ratio-keep-gradient'];\n\nexport default connectionAttributesNS;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}