{"ast":null,"code":"import * as g from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport * as util from '../util/index.mjs';\nimport * as mvc from '../mvc/index.mjs';\nimport { ToolView } from '../dia/ToolView.mjs';\nimport { getAnchor } from './helpers.mjs';\nvar SegmentHandle = mvc.View.extend({\n  tagName: 'g',\n  svgElement: true,\n  className: 'marker-segment',\n  events: {\n    mousedown: 'onPointerDown',\n    touchstart: 'onPointerDown'\n  },\n  documentEvents: {\n    mousemove: 'onPointerMove',\n    touchmove: 'onPointerMove',\n    mouseup: 'onPointerUp',\n    touchend: 'onPointerUp',\n    touchcancel: 'onPointerUp'\n  },\n  children: [{\n    tagName: 'line',\n    selector: 'line',\n    attributes: {\n      'stroke': '#33334F',\n      'stroke-width': 2,\n      'fill': 'none',\n      'pointer-events': 'none'\n    }\n  }, {\n    tagName: 'rect',\n    selector: 'handle',\n    attributes: {\n      'width': 20,\n      'height': 8,\n      'x': -10,\n      'y': -4,\n      'rx': 4,\n      'ry': 4,\n      'fill': '#33334F',\n      'stroke': '#FFFFFF',\n      'stroke-width': 2\n    }\n  }],\n  onRender: function () {\n    this.renderChildren();\n  },\n  position: function (x, y, angle, view) {\n    const {\n      scale\n    } = this.options;\n    let matrix = V.createSVGMatrix().translate(x, y).rotate(angle);\n    if (scale) matrix = matrix.scale(scale);\n    var handle = this.childNodes.handle;\n    handle.setAttribute('transform', V.matrixToTransformString(matrix));\n    handle.setAttribute('cursor', angle % 180 === 0 ? 'row-resize' : 'col-resize');\n    var viewPoint = view.getClosestPoint(new g.Point(x, y));\n    var line = this.childNodes.line;\n    line.setAttribute('x1', x);\n    line.setAttribute('y1', y);\n    line.setAttribute('x2', viewPoint.x);\n    line.setAttribute('y2', viewPoint.y);\n  },\n  onPointerDown: function (evt) {\n    if (this.options.guard(evt)) return;\n    this.trigger('change:start', this, evt);\n    evt.stopPropagation();\n    evt.preventDefault();\n    this.options.paper.undelegateEvents();\n    this.delegateDocumentEvents(null, evt.data);\n  },\n  onPointerMove: function (evt) {\n    this.trigger('changing', this, evt);\n  },\n  onPointerUp: function (evt) {\n    this.undelegateDocumentEvents();\n    this.options.paper.delegateEvents();\n    this.trigger('change:end', this, evt);\n  },\n  show: function () {\n    this.el.style.display = '';\n  },\n  hide: function () {\n    this.el.style.display = 'none';\n  }\n});\nexport const Segments = ToolView.extend({\n  name: 'segments',\n  precision: .5,\n  options: {\n    handleClass: SegmentHandle,\n    segmentLengthThreshold: 40,\n    redundancyRemoval: true,\n    anchor: getAnchor,\n    snapRadius: 10,\n    snapHandle: true,\n    stopPropagation: true\n  },\n  handles: null,\n  onRender: function () {\n    this.resetHandles();\n    var relatedView = this.relatedView;\n    var vertices = relatedView.model.vertices();\n    vertices.unshift(relatedView.sourcePoint);\n    vertices.push(relatedView.targetPoint);\n    for (var i = 0, n = vertices.length; i < n - 1; i++) {\n      var vertex = vertices[i];\n      var nextVertex = vertices[i + 1];\n      var handle = this.renderHandle(vertex, nextVertex);\n      this.simulateRelatedView(handle.el);\n      this.handles.push(handle);\n      handle.options.index = i;\n    }\n    return this;\n  },\n  renderHandle: function (vertex, nextVertex) {\n    var handle = new this.options.handleClass({\n      paper: this.paper,\n      scale: this.options.scale,\n      guard: evt => this.guard(evt)\n    });\n    handle.render();\n    this.updateHandle(handle, vertex, nextVertex);\n    handle.vel.appendTo(this.el);\n    this.startHandleListening(handle);\n    return handle;\n  },\n  update: function () {\n    this.render();\n    return this;\n  },\n  startHandleListening: function (handle) {\n    this.listenTo(handle, 'change:start', this.onHandleChangeStart);\n    this.listenTo(handle, 'changing', this.onHandleChanging);\n    this.listenTo(handle, 'change:end', this.onHandleChangeEnd);\n  },\n  resetHandles: function () {\n    var handles = this.handles;\n    this.handles = [];\n    this.stopListening();\n    if (!Array.isArray(handles)) return;\n    for (var i = 0, n = handles.length; i < n; i++) {\n      handles[i].remove();\n    }\n  },\n  shiftHandleIndexes: function (value) {\n    var handles = this.handles;\n    for (var i = 0, n = handles.length; i < n; i++) handles[i].options.index += value;\n  },\n  resetAnchor: function (type, anchor) {\n    var relatedModel = this.relatedView.model;\n    if (anchor) {\n      relatedModel.prop([type, 'anchor'], anchor, {\n        rewrite: true,\n        ui: true,\n        tool: this.cid\n      });\n    } else {\n      relatedModel.removeProp([type, 'anchor'], {\n        ui: true,\n        tool: this.cid\n      });\n    }\n  },\n  snapHandle: function (handle, position, data) {\n    var index = handle.options.index;\n    var linkView = this.relatedView;\n    var link = linkView.model;\n    var vertices = link.vertices();\n    var axis = handle.options.axis;\n    var prev = vertices[index - 2] || data.sourceAnchor;\n    var next = vertices[index + 1] || data.targetAnchor;\n    var snapRadius = this.options.snapRadius;\n    if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n      position[axis] = prev[axis];\n    } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n      position[axis] = next[axis];\n    }\n    return position;\n  },\n  onHandleChanging: function (handle, evt) {\n    const {\n      options\n    } = this;\n    var data = this.eventData(evt);\n    var relatedView = this.relatedView;\n    var paper = relatedView.paper;\n    var index = handle.options.index - 1;\n    var normalizedEvent = util.normalizeEvent(evt);\n    var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n    var position = this.snapHandle(handle, coords.clone(), data);\n    var axis = handle.options.axis;\n    var offset = this.options.snapHandle ? 0 : coords[axis] - position[axis];\n    var link = relatedView.model;\n    var vertices = util.cloneDeep(link.vertices());\n    var anchorFn = this.options.anchor;\n    if (typeof anchorFn !== 'function') anchorFn = null;\n    const handleIndex = handle.options.index;\n    const vertexPoints = [relatedView.sourcePoint.clone(), ...vertices, relatedView.targetPoint.clone()];\n    let indexOffset = 0;\n\n    // check if vertex before handle vertex exists\n    if (handleIndex - 1 >= 0) {\n      const v1 = vertexPoints[handleIndex - 1];\n      const v2 = vertexPoints[handleIndex];\n      const theta = new g.Line(v1, v2).vector().theta();\n\n      // check only non-orthogonal segments\n      if (theta % 90 !== 0) {\n        vertices.splice(handleIndex - 1, 0, data.originalVertices[handleIndex - 1]);\n        indexOffset++;\n        this.shiftHandleIndexes(1);\n      }\n    }\n    var vertex = vertices[index + indexOffset];\n    var nextVertex = vertices[index + 1 + indexOffset];\n\n    // check if vertex after handle vertex exists\n    if (handleIndex + 2 < vertexPoints.length) {\n      const v1 = vertexPoints[handleIndex + 1];\n      const v2 = vertexPoints[handleIndex + 2];\n      const theta = new g.Line(v1, v2).vector().theta();\n\n      // check only non-orthogonal segments\n      if (theta % 90 !== 0) {\n        const isSingleVertex = data.originalVertices.length === 1;\n        const origVIndex = isSingleVertex ? 0 : handleIndex;\n        const additionalOffset = data.firstHandleShifted && !isSingleVertex ? 1 : 0;\n        let nextVIndex = 1 + indexOffset;\n        vertices.splice(handleIndex + nextVIndex, 0, data.originalVertices[origVIndex - additionalOffset]);\n      }\n    }\n\n    // First Segment\n    var sourceView = relatedView.sourceView;\n    var sourceBBox = relatedView.sourceBBox;\n    var changeSourceAnchor = false;\n    var deleteSourceAnchor = false;\n    if (!vertex) {\n      vertex = relatedView.sourceAnchor.toJSON();\n      vertex[axis] = position[axis];\n      if (sourceBBox.containsPoint(vertex)) {\n        vertex[axis] = position[axis];\n        changeSourceAnchor = true;\n      } else {\n        // we left the area of the source magnet for the first time\n        vertices.unshift(vertex);\n        this.shiftHandleIndexes(1);\n        data.firstHandleShifted = true;\n        deleteSourceAnchor = true;\n      }\n    } else if (index === 0) {\n      if (sourceBBox.containsPoint(vertex)) {\n        vertices.shift();\n        this.shiftHandleIndexes(-1);\n        changeSourceAnchor = true;\n      } else {\n        vertex[axis] = position[axis];\n        deleteSourceAnchor = true;\n      }\n    } else {\n      vertex[axis] = position[axis];\n    }\n    if (anchorFn && sourceView) {\n      if (changeSourceAnchor) {\n        var sourceAnchorPosition = data.sourceAnchor.clone();\n        sourceAnchorPosition[axis] = position[axis];\n        var sourceAnchor = anchorFn.call(relatedView, sourceAnchorPosition, sourceView, relatedView.sourceMagnet || sourceView.el, 'source', relatedView);\n        this.resetAnchor('source', sourceAnchor);\n      }\n      if (deleteSourceAnchor) {\n        this.resetAnchor('source', data.sourceAnchorDef);\n      }\n    }\n\n    // Last segment\n    var targetView = relatedView.targetView;\n    var targetBBox = relatedView.targetBBox;\n    var changeTargetAnchor = false;\n    var deleteTargetAnchor = false;\n    if (!nextVertex) {\n      nextVertex = relatedView.targetAnchor.toJSON();\n      nextVertex[axis] = position[axis];\n      if (targetBBox.containsPoint(nextVertex)) {\n        changeTargetAnchor = true;\n      } else {\n        // we left the area of the target magnet for the first time\n        vertices.push(nextVertex);\n        deleteTargetAnchor = true;\n      }\n    } else if (index === vertices.length - 2) {\n      if (targetBBox.containsPoint(nextVertex)) {\n        vertices.pop();\n        changeTargetAnchor = true;\n      } else {\n        nextVertex[axis] = position[axis];\n        deleteTargetAnchor = true;\n      }\n    } else {\n      nextVertex[axis] = position[axis];\n    }\n    if (anchorFn && targetView) {\n      if (changeTargetAnchor) {\n        var targetAnchorPosition = data.targetAnchor.clone();\n        targetAnchorPosition[axis] = position[axis];\n        var targetAnchor = anchorFn.call(relatedView, targetAnchorPosition, targetView, relatedView.targetMagnet || targetView.el, 'target', relatedView);\n        this.resetAnchor('target', targetAnchor);\n      }\n      if (deleteTargetAnchor) {\n        this.resetAnchor('target', data.targetAnchorDef);\n      }\n    }\n    if (vertices.some(v => !v)) {\n      // This can happen when the link is using a smart routing and the number of\n      // vertices is not the same as the number of route points.\n      throw new Error('Segments: incompatible router in use');\n    }\n    link.vertices(vertices, {\n      ui: true,\n      tool: this.cid\n    });\n    this.updateHandle(handle, vertex, nextVertex, offset);\n    if (!options.stopPropagation) relatedView.notifyPointermove(normalizedEvent, coords.x, coords.y);\n  },\n  onHandleChangeStart: function (handle, evt) {\n    const {\n      options,\n      handles,\n      relatedView: linkView\n    } = this;\n    const {\n      model,\n      paper\n    } = linkView;\n    var index = handle.options.index;\n    if (!Array.isArray(handles)) return;\n    for (var i = 0, n = handles.length; i < n; i++) {\n      if (i !== index) handles[i].hide();\n    }\n    this.focus();\n    this.eventData(evt, {\n      sourceAnchor: linkView.sourceAnchor.clone(),\n      targetAnchor: linkView.targetAnchor.clone(),\n      sourceAnchorDef: util.clone(model.prop(['source', 'anchor'])),\n      targetAnchorDef: util.clone(model.prop(['target', 'anchor'])),\n      originalVertices: util.cloneDeep(model.vertices()),\n      firstHandleShifted: false\n    });\n    model.startBatch('segment-move', {\n      ui: true,\n      tool: this.cid\n    });\n    if (!options.stopPropagation) linkView.notifyPointerdown(...paper.getPointerArgs(evt));\n  },\n  onHandleChangeEnd: function (_handle, evt) {\n    const {\n      options,\n      relatedView: linkView\n    } = this;\n    const {\n      paper,\n      model\n    } = linkView;\n    if (options.redundancyRemoval) {\n      linkView.removeRedundantLinearVertices({\n        ui: true,\n        tool: this.cid\n      });\n    }\n    const normalizedEvent = util.normalizeEvent(evt);\n    const coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n    this.render();\n    this.blur();\n    model.stopBatch('segment-move', {\n      ui: true,\n      tool: this.cid\n    });\n    if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvent, coords.x, coords.y);\n    linkView.checkMouseleave(normalizedEvent);\n  },\n  updateHandle: function (handle, vertex, nextVertex, offset) {\n    var vertical = Math.abs(vertex.x - nextVertex.x) < this.precision;\n    var horizontal = Math.abs(vertex.y - nextVertex.y) < this.precision;\n    if (vertical || horizontal) {\n      var segmentLine = new g.Line(vertex, nextVertex);\n      var length = segmentLine.length();\n      if (length < this.options.segmentLengthThreshold) {\n        handle.hide();\n      } else {\n        var position = segmentLine.midpoint();\n        var axis = vertical ? 'x' : 'y';\n        position[axis] += offset || 0;\n        var angle = segmentLine.vector().vectorAngle(new g.Point(1, 0));\n        handle.position(position.x, position.y, angle, this.relatedView);\n        handle.show();\n        handle.options.axis = axis;\n      }\n    } else {\n      handle.hide();\n    }\n  },\n  onRemove: function () {\n    this.resetHandles();\n  }\n}, {\n  SegmentHandle: SegmentHandle // keep as class property\n});","map":{"version":3,"names":["g","V","util","mvc","ToolView","getAnchor","SegmentHandle","View","extend","tagName","svgElement","className","events","mousedown","touchstart","documentEvents","mousemove","touchmove","mouseup","touchend","touchcancel","children","selector","attributes","onRender","renderChildren","position","x","y","angle","view","scale","options","matrix","createSVGMatrix","translate","rotate","handle","childNodes","setAttribute","matrixToTransformString","viewPoint","getClosestPoint","Point","line","onPointerDown","evt","guard","trigger","stopPropagation","preventDefault","paper","undelegateEvents","delegateDocumentEvents","data","onPointerMove","onPointerUp","undelegateDocumentEvents","delegateEvents","show","el","style","display","hide","Segments","name","precision","handleClass","segmentLengthThreshold","redundancyRemoval","anchor","snapRadius","snapHandle","handles","resetHandles","relatedView","vertices","model","unshift","sourcePoint","push","targetPoint","i","n","length","vertex","nextVertex","renderHandle","simulateRelatedView","index","render","updateHandle","vel","appendTo","startHandleListening","update","listenTo","onHandleChangeStart","onHandleChanging","onHandleChangeEnd","stopListening","Array","isArray","remove","shiftHandleIndexes","value","resetAnchor","type","relatedModel","prop","rewrite","ui","tool","cid","removeProp","linkView","link","axis","prev","sourceAnchor","next","targetAnchor","Math","abs","eventData","normalizedEvent","normalizeEvent","coords","snapToGrid","clientX","clientY","clone","offset","cloneDeep","anchorFn","handleIndex","vertexPoints","indexOffset","v1","v2","theta","Line","vector","splice","originalVertices","isSingleVertex","origVIndex","additionalOffset","firstHandleShifted","nextVIndex","sourceView","sourceBBox","changeSourceAnchor","deleteSourceAnchor","toJSON","containsPoint","shift","sourceAnchorPosition","call","sourceMagnet","sourceAnchorDef","targetView","targetBBox","changeTargetAnchor","deleteTargetAnchor","pop","targetAnchorPosition","targetMagnet","targetAnchorDef","some","v","Error","notifyPointermove","focus","startBatch","notifyPointerdown","getPointerArgs","_handle","removeRedundantLinearVertices","blur","stopBatch","notifyPointerup","checkMouseleave","vertical","horizontal","segmentLine","midpoint","vectorAngle","onRemove"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/linkTools/Segments.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport * as util from '../util/index.mjs';\nimport * as mvc from '../mvc/index.mjs';\nimport { ToolView } from '../dia/ToolView.mjs';\nimport { getAnchor } from './helpers.mjs';\n\nvar SegmentHandle = mvc.View.extend({\n    tagName: 'g',\n    svgElement: true,\n    className: 'marker-segment',\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    children: [{\n        tagName: 'line',\n        selector: 'line',\n        attributes: {\n            'stroke': '#33334F',\n            'stroke-width': 2,\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }, {\n        tagName: 'rect',\n        selector: 'handle',\n        attributes: {\n            'width': 20,\n            'height': 8,\n            'x': -10,\n            'y': -4,\n            'rx': 4,\n            'ry': 4,\n            'fill': '#33334F',\n            'stroke': '#FFFFFF',\n            'stroke-width': 2\n        }\n    }],\n    onRender: function() {\n        this.renderChildren();\n    },\n    position: function(x, y, angle, view) {\n        const { scale } = this.options;\n        let matrix = V.createSVGMatrix().translate(x, y).rotate(angle);\n        if (scale) matrix = matrix.scale(scale);\n\n        var handle = this.childNodes.handle;\n        handle.setAttribute('transform', V.matrixToTransformString(matrix));\n        handle.setAttribute('cursor', (angle % 180 === 0) ? 'row-resize' : 'col-resize');\n\n        var viewPoint = view.getClosestPoint(new g.Point(x, y));\n        var line = this.childNodes.line;\n        line.setAttribute('x1', x);\n        line.setAttribute('y1', y);\n        line.setAttribute('x2', viewPoint.x);\n        line.setAttribute('y2', viewPoint.y);\n    },\n    onPointerDown: function(evt) {\n        if (this.options.guard(evt)) return;\n        this.trigger('change:start', this, evt);\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.options.paper.undelegateEvents();\n        this.delegateDocumentEvents(null, evt.data);\n    },\n    onPointerMove: function(evt) {\n        this.trigger('changing', this, evt);\n    },\n    onPointerUp: function(evt) {\n        this.undelegateDocumentEvents();\n        this.options.paper.delegateEvents();\n        this.trigger('change:end', this, evt);\n    },\n    show: function() {\n        this.el.style.display = '';\n    },\n    hide: function() {\n        this.el.style.display = 'none';\n    }\n});\n\nexport const Segments = ToolView.extend({\n    name: 'segments',\n    precision: .5,\n    options: {\n        handleClass: SegmentHandle,\n        segmentLengthThreshold: 40,\n        redundancyRemoval: true,\n        anchor: getAnchor,\n        snapRadius: 10,\n        snapHandle: true,\n        stopPropagation: true\n    },\n    handles: null,\n    onRender: function() {\n        this.resetHandles();\n        var relatedView = this.relatedView;\n        var vertices = relatedView.model.vertices();\n        vertices.unshift(relatedView.sourcePoint);\n        vertices.push(relatedView.targetPoint);\n        for (var i = 0, n = vertices.length; i < n - 1; i++) {\n            var vertex = vertices[i];\n            var nextVertex = vertices[i + 1];\n            var handle = this.renderHandle(vertex, nextVertex);\n            this.simulateRelatedView(handle.el);\n            this.handles.push(handle);\n            handle.options.index = i;\n        }\n        return this;\n    },\n    renderHandle: function(vertex, nextVertex) {\n        var handle = new (this.options.handleClass)({\n            paper: this.paper,\n            scale: this.options.scale,\n            guard: evt => this.guard(evt)\n        });\n        handle.render();\n        this.updateHandle(handle, vertex, nextVertex);\n        handle.vel.appendTo(this.el);\n        this.startHandleListening(handle);\n        return handle;\n    },\n    update: function() {\n        this.render();\n        return this;\n    },\n    startHandleListening: function(handle) {\n        this.listenTo(handle, 'change:start', this.onHandleChangeStart);\n        this.listenTo(handle, 'changing', this.onHandleChanging);\n        this.listenTo(handle, 'change:end', this.onHandleChangeEnd);\n    },\n    resetHandles: function() {\n        var handles = this.handles;\n        this.handles = [];\n        this.stopListening();\n        if (!Array.isArray(handles)) return;\n        for (var i = 0, n = handles.length; i < n; i++) {\n            handles[i].remove();\n        }\n    },\n    shiftHandleIndexes: function(value) {\n        var handles = this.handles;\n        for (var i = 0, n = handles.length; i < n; i++) handles[i].options.index += value;\n    },\n    resetAnchor: function(type, anchor) {\n        var relatedModel = this.relatedView.model;\n        if (anchor) {\n            relatedModel.prop([type, 'anchor'], anchor, {\n                rewrite: true,\n                ui: true,\n                tool: this.cid\n            });\n        } else {\n            relatedModel.removeProp([type, 'anchor'], {\n                ui: true,\n                tool: this.cid\n            });\n        }\n    },\n    snapHandle: function(handle, position, data) {\n\n        var index = handle.options.index;\n        var linkView = this.relatedView;\n        var link = linkView.model;\n        var vertices = link.vertices();\n        var axis = handle.options.axis;\n        var prev = vertices[index - 2] || data.sourceAnchor;\n        var next = vertices[index + 1] || data.targetAnchor;\n        var snapRadius = this.options.snapRadius;\n        if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n            position[axis] = prev[axis];\n        } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n            position[axis] = next[axis];\n        }\n        return position;\n    },\n\n    onHandleChanging: function(handle, evt) {\n\n        const { options } = this;\n        var data = this.eventData(evt);\n        var relatedView = this.relatedView;\n        var paper = relatedView.paper;\n        var index = handle.options.index - 1;\n        var normalizedEvent = util.normalizeEvent(evt);\n        var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        var position = this.snapHandle(handle, coords.clone(), data);\n        var axis = handle.options.axis;\n        var offset = (this.options.snapHandle) ? 0 : (coords[axis] - position[axis]);\n        var link = relatedView.model;\n        var vertices = util.cloneDeep(link.vertices());\n        var anchorFn = this.options.anchor;\n        if (typeof anchorFn !== 'function') anchorFn = null;\n\n        const handleIndex = handle.options.index;\n\n        const vertexPoints = [relatedView.sourcePoint.clone(), ...vertices, relatedView.targetPoint.clone()];\n        let indexOffset = 0;\n\n        // check if vertex before handle vertex exists\n        if (handleIndex - 1 >= 0) {\n            const v1 = vertexPoints[handleIndex - 1];\n            const v2 = vertexPoints[handleIndex];\n\n            const theta = new g.Line(v1, v2).vector().theta();\n\n            // check only non-orthogonal segments\n            if (theta % 90 !== 0) {\n                vertices.splice(handleIndex - 1, 0, data.originalVertices[handleIndex - 1]);\n                indexOffset++;\n                this.shiftHandleIndexes(1);\n            }\n        }\n\n        var vertex = vertices[index + indexOffset];\n        var nextVertex = vertices[index + 1 + indexOffset];\n\n        // check if vertex after handle vertex exists\n        if (handleIndex + 2 < vertexPoints.length) {\n            const v1 = vertexPoints[handleIndex + 1];\n            const v2 = vertexPoints[handleIndex + 2];\n\n            const theta = new g.Line(v1, v2).vector().theta();\n\n            // check only non-orthogonal segments\n            if (theta % 90 !== 0) {\n                const isSingleVertex = data.originalVertices.length === 1;\n                const origVIndex = isSingleVertex ? 0 : handleIndex;\n                const additionalOffset = data.firstHandleShifted && !isSingleVertex ? 1 : 0;\n                let nextVIndex = 1 + indexOffset;\n                vertices.splice(handleIndex + nextVIndex, 0, data.originalVertices[origVIndex - additionalOffset]);\n            }\n        }\n\n        // First Segment\n        var sourceView = relatedView.sourceView;\n        var sourceBBox = relatedView.sourceBBox;\n        var changeSourceAnchor = false;\n        var deleteSourceAnchor = false;\n        if (!vertex) {\n            vertex = relatedView.sourceAnchor.toJSON();\n            vertex[axis] = position[axis];\n            if (sourceBBox.containsPoint(vertex)) {\n                vertex[axis] = position[axis];\n                changeSourceAnchor = true;\n            } else {\n                // we left the area of the source magnet for the first time\n                vertices.unshift(vertex);\n                this.shiftHandleIndexes(1);\n                data.firstHandleShifted = true;\n                deleteSourceAnchor = true;\n            }\n        } else if (index === 0) {\n            if (sourceBBox.containsPoint(vertex)) {\n                vertices.shift();\n                this.shiftHandleIndexes(-1);\n                changeSourceAnchor = true;\n            } else {\n                vertex[axis] = position[axis];\n                deleteSourceAnchor = true;\n            }\n        } else {\n            vertex[axis] = position[axis];\n        }\n\n        if (anchorFn && sourceView) {\n            if (changeSourceAnchor) {\n                var sourceAnchorPosition = data.sourceAnchor.clone();\n                sourceAnchorPosition[axis] = position[axis];\n                var sourceAnchor = anchorFn.call(relatedView, sourceAnchorPosition, sourceView, relatedView.sourceMagnet || sourceView.el, 'source', relatedView);\n                this.resetAnchor('source', sourceAnchor);\n            }\n            if (deleteSourceAnchor) {\n                this.resetAnchor('source', data.sourceAnchorDef);\n            }\n        }\n\n        // Last segment\n        var targetView = relatedView.targetView;\n        var targetBBox = relatedView.targetBBox;\n        var changeTargetAnchor = false;\n        var deleteTargetAnchor = false;\n        if (!nextVertex) {\n            nextVertex = relatedView.targetAnchor.toJSON();\n            nextVertex[axis] = position[axis];\n            if (targetBBox.containsPoint(nextVertex)) {\n                changeTargetAnchor = true;\n            } else {\n                // we left the area of the target magnet for the first time\n                vertices.push(nextVertex);\n                deleteTargetAnchor = true;\n            }\n        } else if (index === vertices.length - 2) {\n            if (targetBBox.containsPoint(nextVertex)) {\n                vertices.pop();\n                changeTargetAnchor = true;\n            } else {\n                nextVertex[axis] = position[axis];\n                deleteTargetAnchor = true;\n            }\n        } else {\n            nextVertex[axis] = position[axis];\n        }\n\n        if (anchorFn && targetView) {\n            if (changeTargetAnchor) {\n                var targetAnchorPosition = data.targetAnchor.clone();\n                targetAnchorPosition[axis] = position[axis];\n                var targetAnchor = anchorFn.call(relatedView, targetAnchorPosition, targetView, relatedView.targetMagnet || targetView.el, 'target', relatedView);\n                this.resetAnchor('target', targetAnchor);\n            }\n            if (deleteTargetAnchor) {\n                this.resetAnchor('target', data.targetAnchorDef);\n            }\n        }\n        if (vertices.some(v => !v)) {\n            // This can happen when the link is using a smart routing and the number of\n            // vertices is not the same as the number of route points.\n            throw new Error('Segments: incompatible router in use');\n        }\n        link.vertices(vertices, { ui: true, tool: this.cid });\n        this.updateHandle(handle, vertex, nextVertex, offset);\n        if (!options.stopPropagation) relatedView.notifyPointermove(normalizedEvent, coords.x, coords.y);\n    },\n    onHandleChangeStart: function(handle, evt) {\n        const { options, handles, relatedView: linkView } = this;\n        const { model, paper } = linkView;\n        var index = handle.options.index;\n        if (!Array.isArray(handles)) return;\n        for (var i = 0, n = handles.length; i < n; i++) {\n            if (i !== index) handles[i].hide();\n        }\n        this.focus();\n        this.eventData(evt, {\n            sourceAnchor: linkView.sourceAnchor.clone(),\n            targetAnchor: linkView.targetAnchor.clone(),\n            sourceAnchorDef: util.clone(model.prop(['source', 'anchor'])),\n            targetAnchorDef: util.clone(model.prop(['target', 'anchor'])),\n            originalVertices: util.cloneDeep(model.vertices()),\n            firstHandleShifted: false\n        });\n        model.startBatch('segment-move', { ui: true, tool: this.cid });\n        if (!options.stopPropagation) linkView.notifyPointerdown(...paper.getPointerArgs(evt));\n    },\n    onHandleChangeEnd: function(_handle, evt) {\n        const { options, relatedView: linkView }= this;\n        const { paper, model } = linkView;\n        if (options.redundancyRemoval) {\n            linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid });\n        }\n        const normalizedEvent = util.normalizeEvent(evt);\n        const coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        this.render();\n        this.blur();\n        model.stopBatch('segment-move', { ui: true, tool: this.cid });\n        if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvent, coords.x, coords.y);\n        linkView.checkMouseleave(normalizedEvent);\n    },\n    updateHandle: function(handle, vertex, nextVertex, offset) {\n        var vertical = Math.abs(vertex.x - nextVertex.x) < this.precision;\n        var horizontal = Math.abs(vertex.y - nextVertex.y) < this.precision;\n        if (vertical || horizontal) {\n            var segmentLine = new g.Line(vertex, nextVertex);\n            var length = segmentLine.length();\n            if (length < this.options.segmentLengthThreshold) {\n                handle.hide();\n            } else {\n                var position = segmentLine.midpoint();\n                var axis = (vertical) ? 'x' : 'y';\n                position[axis] += offset || 0;\n                var angle = segmentLine.vector().vectorAngle(new g.Point(1, 0));\n                handle.position(position.x, position.y, angle, this.relatedView);\n                handle.show();\n                handle.options.axis = axis;\n            }\n        } else {\n            handle.hide();\n        }\n    },\n    onRemove: function() {\n        this.resetHandles();\n    }\n}, {\n    SegmentHandle: SegmentHandle // keep as class property\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}