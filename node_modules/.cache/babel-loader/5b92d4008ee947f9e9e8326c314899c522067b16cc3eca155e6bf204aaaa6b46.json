{"ast":null,"code":"import * as util from '../util/index.mjs';\n\n// Routes the link always to/from a certain side\n//\n// Arguments:\n//   padding ... gap between the element and the first vertex. :: Default 40.\n//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\n//\nexport const oneSide = function (vertices, opt, linkView) {\n  var side = opt.side || 'bottom';\n  var padding = util.normalizeSides(opt.padding || 40);\n\n  // LinkView contains cached source an target bboxes.\n  // Note that those are Geometry rectangle objects.\n  var sourceBBox = linkView.sourceBBox;\n  var targetBBox = linkView.targetBBox;\n  var sourcePoint = sourceBBox.center();\n  var targetPoint = targetBBox.center();\n  var coordinate, dimension, direction;\n  switch (side) {\n    case 'bottom':\n      direction = 1;\n      coordinate = 'y';\n      dimension = 'height';\n      break;\n    case 'top':\n      direction = -1;\n      coordinate = 'y';\n      dimension = 'height';\n      break;\n    case 'left':\n      direction = -1;\n      coordinate = 'x';\n      dimension = 'width';\n      break;\n    case 'right':\n      direction = 1;\n      coordinate = 'x';\n      dimension = 'width';\n      break;\n    default:\n      throw new Error('Router: invalid side');\n  }\n\n  // move the points from the center of the element to outside of it.\n  sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);\n  targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);\n\n  // make link orthogonal (at least the first and last vertex).\n  if (direction * (sourcePoint[coordinate] - targetPoint[coordinate]) > 0) {\n    targetPoint[coordinate] = sourcePoint[coordinate];\n  } else {\n    sourcePoint[coordinate] = targetPoint[coordinate];\n  }\n  return [sourcePoint].concat(vertices, targetPoint);\n};","map":{"version":3,"names":["util","oneSide","vertices","opt","linkView","side","padding","normalizeSides","sourceBBox","targetBBox","sourcePoint","center","targetPoint","coordinate","dimension","direction","Error","concat"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/routers/oneSide.mjs"],"sourcesContent":["import * as util from '../util/index.mjs';\n\n// Routes the link always to/from a certain side\n//\n// Arguments:\n//   padding ... gap between the element and the first vertex. :: Default 40.\n//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\n//\nexport const oneSide = function(vertices, opt, linkView) {\n\n    var side = opt.side || 'bottom';\n    var padding = util.normalizeSides(opt.padding || 40);\n\n    // LinkView contains cached source an target bboxes.\n    // Note that those are Geometry rectangle objects.\n    var sourceBBox = linkView.sourceBBox;\n    var targetBBox = linkView.targetBBox;\n    var sourcePoint = sourceBBox.center();\n    var targetPoint = targetBBox.center();\n\n    var coordinate, dimension, direction;\n\n    switch (side) {\n        case 'bottom':\n            direction = 1;\n            coordinate = 'y';\n            dimension = 'height';\n            break;\n        case 'top':\n            direction = -1;\n            coordinate = 'y';\n            dimension = 'height';\n            break;\n        case 'left':\n            direction = -1;\n            coordinate = 'x';\n            dimension = 'width';\n            break;\n        case 'right':\n            direction = 1;\n            coordinate = 'x';\n            dimension = 'width';\n            break;\n        default:\n            throw new Error('Router: invalid side');\n    }\n\n    // move the points from the center of the element to outside of it.\n    sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);\n    targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);\n\n    // make link orthogonal (at least the first and last vertex).\n    if ((direction * (sourcePoint[coordinate] - targetPoint[coordinate])) > 0) {\n        targetPoint[coordinate] = sourcePoint[coordinate];\n    } else {\n        sourcePoint[coordinate] = targetPoint[coordinate];\n    }\n\n    return [sourcePoint].concat(vertices, targetPoint);\n};\n"],"mappings":"AAAA,OAAO,KAAKA,IAAI,MAAM,mBAAmB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,OAAO,GAAG,SAAAA,CAASC,QAAQ,EAAEC,GAAG,EAAEC,QAAQ,EAAE;EAErD,IAAIC,IAAI,GAAGF,GAAG,CAACE,IAAI,IAAI,QAAQ;EAC/B,IAAIC,OAAO,GAAGN,IAAI,CAACO,cAAc,CAACJ,GAAG,CAACG,OAAO,IAAI,EAAE,CAAC;;EAEpD;EACA;EACA,IAAIE,UAAU,GAAGJ,QAAQ,CAACI,UAAU;EACpC,IAAIC,UAAU,GAAGL,QAAQ,CAACK,UAAU;EACpC,IAAIC,WAAW,GAAGF,UAAU,CAACG,MAAM,CAAC,CAAC;EACrC,IAAIC,WAAW,GAAGH,UAAU,CAACE,MAAM,CAAC,CAAC;EAErC,IAAIE,UAAU,EAAEC,SAAS,EAAEC,SAAS;EAEpC,QAAQV,IAAI;IACR,KAAK,QAAQ;MACTU,SAAS,GAAG,CAAC;MACbF,UAAU,GAAG,GAAG;MAChBC,SAAS,GAAG,QAAQ;MACpB;IACJ,KAAK,KAAK;MACNC,SAAS,GAAG,CAAC,CAAC;MACdF,UAAU,GAAG,GAAG;MAChBC,SAAS,GAAG,QAAQ;MACpB;IACJ,KAAK,MAAM;MACPC,SAAS,GAAG,CAAC,CAAC;MACdF,UAAU,GAAG,GAAG;MAChBC,SAAS,GAAG,OAAO;MACnB;IACJ,KAAK,OAAO;MACRC,SAAS,GAAG,CAAC;MACbF,UAAU,GAAG,GAAG;MAChBC,SAAS,GAAG,OAAO;MACnB;IACJ;MACI,MAAM,IAAIE,KAAK,CAAC,sBAAsB,CAAC;EAC/C;;EAEA;EACAN,WAAW,CAACG,UAAU,CAAC,IAAIE,SAAS,IAAIP,UAAU,CAACM,SAAS,CAAC,GAAG,CAAC,GAAGR,OAAO,CAACD,IAAI,CAAC,CAAC;EAClFO,WAAW,CAACC,UAAU,CAAC,IAAIE,SAAS,IAAIN,UAAU,CAACK,SAAS,CAAC,GAAG,CAAC,GAAGR,OAAO,CAACD,IAAI,CAAC,CAAC;;EAElF;EACA,IAAKU,SAAS,IAAIL,WAAW,CAACG,UAAU,CAAC,GAAGD,WAAW,CAACC,UAAU,CAAC,CAAC,GAAI,CAAC,EAAE;IACvED,WAAW,CAACC,UAAU,CAAC,GAAGH,WAAW,CAACG,UAAU,CAAC;EACrD,CAAC,MAAM;IACHH,WAAW,CAACG,UAAU,CAAC,GAAGD,WAAW,CAACC,UAAU,CAAC;EACrD;EAEA,OAAO,CAACH,WAAW,CAAC,CAACO,MAAM,CAACf,QAAQ,EAAEU,WAAW,CAAC;AACtD,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}