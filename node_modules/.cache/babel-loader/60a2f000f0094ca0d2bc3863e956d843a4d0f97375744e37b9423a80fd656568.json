{"ast":null,"code":"const props = {\n  x: 'x',\n  y: 'y',\n  width: 'w',\n  height: 'h',\n  minimum: 's',\n  maximum: 'l',\n  diagonal: 'd'\n};\nconst propsList = Object.keys(props).map(key => props[key]).join('');\nconst numberPattern = '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?';\nconst findSpacesRegex = /\\s/g;\nconst parseExpressionRegExp = new RegExp(`^(${numberPattern}\\\\*)?([${propsList}])(/${numberPattern})?([-+]{1,2}${numberPattern})?$`, 'g');\nfunction throwInvalid(expression) {\n  throw new Error(`Invalid calc() expression: ${expression}`);\n}\nexport function evalCalcExpression(expression, bbox) {\n  const match = parseExpressionRegExp.exec(expression.replace(findSpacesRegex, ''));\n  if (!match) throwInvalid(expression);\n  parseExpressionRegExp.lastIndex = 0; // reset regex results for the next run\n  const [, multiply, property, divide, add] = match;\n  const {\n    x,\n    y,\n    width,\n    height\n  } = bbox;\n  let value = 0;\n  switch (property) {\n    case props.width:\n      {\n        value = width;\n        break;\n      }\n    case props.height:\n      {\n        value = height;\n        break;\n      }\n    case props.x:\n      {\n        value = x;\n        break;\n      }\n    case props.y:\n      {\n        value = y;\n        break;\n      }\n    case props.minimum:\n      {\n        value = Math.min(height, width);\n        break;\n      }\n    case props.maximum:\n      {\n        value = Math.max(height, width);\n        break;\n      }\n    case props.diagonal:\n      {\n        value = Math.sqrt(height * height + width * width);\n        break;\n      }\n  }\n  if (multiply) {\n    // e.g \"2*\"\n    value *= parseFloat(multiply);\n  }\n  if (divide) {\n    // e.g \"/2\"\n    value /= parseFloat(divide.slice(1));\n  }\n  if (add) {\n    value += evalAddExpression(add);\n  }\n  return value;\n}\nfunction evalAddExpression(addExpression) {\n  if (!addExpression) return 0;\n  const [sign] = addExpression;\n  switch (sign) {\n    case '+':\n      {\n        return parseFloat(addExpression.substr(1));\n      }\n    case '-':\n      {\n        return -parseFloat(addExpression.substr(1));\n      }\n  }\n  return parseFloat(addExpression);\n}\nexport function isCalcAttribute(value) {\n  return typeof value === 'string' && value.includes('calc');\n}\nconst calcStart = 'calc(';\nconst calcStartOffset = calcStart.length;\nexport function evalCalcAttribute(attributeValue, refBBox) {\n  let value = attributeValue;\n  let startSearchIndex = 0;\n  do {\n    let calcIndex = value.indexOf(calcStart, startSearchIndex);\n    if (calcIndex === -1) return value;\n    let calcEndIndex = calcIndex + calcStartOffset;\n    let brackets = 1;\n    findClosingBracket: do {\n      switch (value[calcEndIndex]) {\n        case '(':\n          {\n            brackets++;\n            break;\n          }\n        case ')':\n          {\n            brackets--;\n            if (brackets === 0) break findClosingBracket;\n            break;\n          }\n        case undefined:\n          {\n            // Could not find the closing bracket.\n            throwInvalid(value);\n          }\n      }\n      calcEndIndex++;\n    } while (true);\n    // Get the calc() expression without nested calcs (recursion)\n    let expression = value.slice(calcIndex + calcStartOffset, calcEndIndex);\n    if (isCalcAttribute(expression)) {\n      expression = evalCalcAttribute(expression, refBBox);\n    }\n    // Eval the calc() expression without nested calcs.\n    const calcValue = String(evalCalcExpression(expression, refBBox));\n    // Replace the calc() expression and continue search\n    value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);\n    startSearchIndex = calcIndex + calcValue.length;\n  } while (true);\n}","map":{"version":3,"names":["props","x","y","width","height","minimum","maximum","diagonal","propsList","Object","keys","map","key","join","numberPattern","findSpacesRegex","parseExpressionRegExp","RegExp","throwInvalid","expression","Error","evalCalcExpression","bbox","match","exec","replace","lastIndex","multiply","property","divide","add","value","Math","min","max","sqrt","parseFloat","slice","evalAddExpression","addExpression","sign","substr","isCalcAttribute","includes","calcStart","calcStartOffset","length","evalCalcAttribute","attributeValue","refBBox","startSearchIndex","calcIndex","indexOf","calcEndIndex","brackets","findClosingBracket","undefined","calcValue","String"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/dia/attributes/calc.mjs"],"sourcesContent":["const props = {\n    x: 'x',\n    y: 'y',\n    width: 'w',\n    height: 'h',\n    minimum: 's',\n    maximum: 'l',\n    diagonal: 'd'\n};\nconst propsList = Object.keys(props).map(key => props[key]).join('');\nconst numberPattern = '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?';\nconst findSpacesRegex = /\\s/g;\nconst parseExpressionRegExp = new RegExp(`^(${numberPattern}\\\\*)?([${propsList}])(/${numberPattern})?([-+]{1,2}${numberPattern})?$`, 'g');\n\nfunction throwInvalid(expression) {\n    throw new Error(`Invalid calc() expression: ${expression}`);\n}\n\nexport function evalCalcExpression(expression, bbox) {\n    const match = parseExpressionRegExp.exec(expression.replace(findSpacesRegex, ''));\n    if (!match) throwInvalid(expression);\n    parseExpressionRegExp.lastIndex = 0; // reset regex results for the next run\n    const [,multiply, property, divide, add] = match;\n    const { x, y, width, height } = bbox;\n    let value = 0;\n    switch (property) {\n        case props.width: {\n            value = width;\n            break;\n        }\n        case props.height: {\n            value = height;\n            break;\n        }\n        case props.x: {\n            value = x;\n            break;\n        }\n        case props.y: {\n            value = y;\n            break;\n        }\n        case props.minimum: {\n            value = Math.min(height, width);\n            break;\n        }\n        case props.maximum: {\n            value = Math.max(height, width);\n            break;\n        }\n        case props.diagonal: {\n            value = Math.sqrt((height * height) + (width * width));\n            break;\n        }\n    }\n    if (multiply) {\n        // e.g \"2*\"\n        value *= parseFloat(multiply);\n    }\n    if (divide) {\n        // e.g \"/2\"\n        value /= parseFloat(divide.slice(1));\n    }\n    if (add) {\n        value += evalAddExpression(add);\n    }\n    return value;\n}\n\nfunction evalAddExpression(addExpression) {\n    if (!addExpression) return 0;\n    const [sign] = addExpression;\n    switch (sign) {\n        case '+': {\n            return parseFloat(addExpression.substr(1));\n        }\n        case '-': {\n            return -parseFloat(addExpression.substr(1));\n        }\n    }\n    return parseFloat(addExpression);\n}\n\nexport function isCalcAttribute(value) {\n    return typeof value === 'string' && value.includes('calc');\n}\n\nconst calcStart = 'calc(';\nconst calcStartOffset = calcStart.length;\n\nexport function evalCalcAttribute(attributeValue, refBBox) {\n    let value = attributeValue;\n    let startSearchIndex = 0;\n    do {\n        let calcIndex = value.indexOf(calcStart, startSearchIndex);\n        if (calcIndex === -1) return value;\n        let calcEndIndex = calcIndex + calcStartOffset;\n        let brackets = 1;\n        findClosingBracket: do {\n            switch (value[calcEndIndex]) {\n                case '(': {\n                    brackets++;\n                    break;\n                }\n                case ')': {\n                    brackets--;\n                    if (brackets === 0) break findClosingBracket;\n                    break;\n                }\n                case undefined: {\n                    // Could not find the closing bracket.\n                    throwInvalid(value);\n                }\n            }\n            calcEndIndex++;\n        } while (true);\n        // Get the calc() expression without nested calcs (recursion)\n        let expression = value.slice(calcIndex + calcStartOffset, calcEndIndex);\n        if (isCalcAttribute(expression)) {\n            expression = evalCalcAttribute(expression, refBBox);\n        }\n        // Eval the calc() expression without nested calcs.\n        const calcValue = String(evalCalcExpression(expression, refBBox));\n        // Replace the calc() expression and continue search\n        value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);\n        startSearchIndex = calcIndex + calcValue.length;\n    } while (true);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}