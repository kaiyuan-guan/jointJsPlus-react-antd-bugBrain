{"ast":null,"code":"import { config } from '../config/index.mjs';\nimport { View } from '../mvc/index.mjs';\nimport { assign, guid, omit, parseDOMJSON, isFunction, isObject, isPlainObject, isBoolean, isEmpty, isString, result, sortedIndex, merge, uniq } from '../util/index.mjs';\nimport { Point, Rect } from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport $ from '../mvc/Dom/index.mjs';\nimport { HighlighterView } from './HighlighterView.mjs';\nimport { evalAttributes, evalAttribute } from './attributes/eval.mjs';\nconst HighlightingTypes = {\n  DEFAULT: 'default',\n  EMBEDDING: 'embedding',\n  CONNECTING: 'connecting',\n  MAGNET_AVAILABILITY: 'magnetAvailability',\n  ELEMENT_AVAILABILITY: 'elementAvailability'\n};\nconst Flags = {\n  TOOLS: 'TOOLS'\n};\n\n// CellView base view and controller.\n// --------------------------------------------\n\n// This is the base view and controller for `ElementView` and `LinkView`.\nexport const CellView = View.extend({\n  tagName: 'g',\n  svgElement: true,\n  selector: 'root',\n  metrics: null,\n  className: function () {\n    var classNames = ['cell'];\n    var type = this.model.get('type');\n    if (type) {\n      type.toLowerCase().split('.').forEach(function (value, index, list) {\n        classNames.push('type-' + list.slice(0, index + 1).join('-'));\n      });\n    }\n    return classNames.join(' ');\n  },\n  _presentationAttributes: null,\n  _flags: null,\n  setFlags: function () {\n    var flags = {};\n    var attributes = {};\n    var shift = 0;\n    var i, n, label;\n    var presentationAttributes = result(this, 'presentationAttributes');\n    for (var attribute in presentationAttributes) {\n      if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n      var labels = presentationAttributes[attribute];\n      if (!Array.isArray(labels)) labels = [labels];\n      for (i = 0, n = labels.length; i < n; i++) {\n        label = labels[i];\n        var flag = flags[label];\n        if (!flag) {\n          flag = flags[label] = 1 << shift++;\n        }\n        attributes[attribute] |= flag;\n      }\n    }\n    var initFlag = result(this, 'initFlag');\n    if (!Array.isArray(initFlag)) initFlag = [initFlag];\n    for (i = 0, n = initFlag.length; i < n; i++) {\n      label = initFlag[i];\n      if (!flags[label]) flags[label] = 1 << shift++;\n    }\n\n    // 26 - 30 are reserved for paper flags\n    // 31+ overflows maximal number\n    if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');\n    this._flags = flags;\n    this._presentationAttributes = attributes;\n  },\n  hasFlag: function (flag, label) {\n    return flag & this.getFlag(label);\n  },\n  removeFlag: function (flag, label) {\n    return flag ^ flag & this.getFlag(label);\n  },\n  getFlag: function (label) {\n    var flags = this._flags;\n    if (!flags) return 0;\n    var flag = 0;\n    if (Array.isArray(label)) {\n      for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];\n    } else {\n      flag |= flags[label];\n    }\n    return flag;\n  },\n  attributes: function () {\n    var cell = this.model;\n    return {\n      'model-id': cell.id,\n      'data-type': cell.attributes.type\n    };\n  },\n  constructor: function (options) {\n    // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n    // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n    // still be associated to the same object among all those clients. This is necessary for real-time\n    // collaboration mechanism.\n    options.id = options.id || guid(this);\n    View.call(this, options);\n  },\n  initialize: function () {\n    this.setFlags();\n    View.prototype.initialize.apply(this, arguments);\n    this.cleanNodesCache();\n    this.startListening();\n  },\n  startListening: function () {\n    this.listenTo(this.model, 'change', this.onAttributesChange);\n  },\n  onAttributesChange: function (model, opt) {\n    var flag = model.getChangeFlag(this._presentationAttributes);\n    if (opt.updateHandled || !flag) return;\n    if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER');\n    // TODO: tool changes does not need to be sync\n    // Fix Segments tools\n    if (opt.tool) opt.async = false;\n    this.requestUpdate(flag, opt);\n  },\n  requestUpdate: function (flags, opt) {\n    const {\n      paper\n    } = this;\n    if (paper && flags > 0) {\n      paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n    }\n  },\n  parseDOMJSON: function (markup, root) {\n    var doc = parseDOMJSON(markup);\n    var selectors = doc.selectors;\n    var groups = doc.groupSelectors;\n    for (var group in groups) {\n      if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');\n      selectors[group] = groups[group];\n    }\n    if (root) {\n      var rootSelector = this.selector;\n      if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');\n      selectors[rootSelector] = root;\n    }\n    return {\n      fragment: doc.fragment,\n      selectors: selectors\n    };\n  },\n  // Return `true` if cell link is allowed to perform a certain UI `feature`.\n  // Example: `can('labelMove')`.\n  can: function (feature) {\n    var interactive = isFunction(this.options.interactive) ? this.options.interactive(this) : this.options.interactive;\n    return isObject(interactive) && interactive[feature] !== false || isBoolean(interactive) && interactive !== false;\n  },\n  findBySelector: function (selector, root, selectors) {\n    // These are either descendants of `this.$el` of `this.$el` itself.\n    // `.` is a special selector used to select the wrapping `<g>` element.\n    if (!selector || selector === '.') return [root];\n    if (selectors) {\n      var nodes = selectors[selector];\n      if (nodes) {\n        if (Array.isArray(nodes)) return nodes;\n        return [nodes];\n      }\n    }\n\n    // Maintaining backwards compatibility\n    // e.g. `circle:first` would fail with querySelector() call\n    if (this.useCSSSelectors) return $(root).find(selector).toArray();\n    return [];\n  },\n  findNodes: function (selector) {\n    return this.findBySelector(selector, this.el, this.selectors);\n  },\n  findNode: function (selector) {\n    const [node = null] = this.findNodes(selector);\n    return node;\n  },\n  notify: function (eventName) {\n    if (this.paper) {\n      var args = Array.prototype.slice.call(arguments, 1);\n\n      // Trigger the event on both the element itself and also on the paper.\n      this.trigger.apply(this, [eventName].concat(args));\n\n      // Paper event handlers receive the view object as the first argument.\n      this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n    }\n  },\n  getBBox: function (opt) {\n    var bbox;\n    if (opt && opt.useModelGeometry) {\n      var model = this.model;\n      bbox = model.getBBox().bbox(model.angle());\n    } else {\n      bbox = this.getNodeBBox(this.el);\n    }\n    return this.paper.localToPaperRect(bbox);\n  },\n  getNodeBBox: function (magnet) {\n    const rect = this.getNodeBoundingRect(magnet);\n    const transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));\n    const magnetMatrix = this.getNodeMatrix(magnet);\n    return V.transformRect(rect, transformMatrix.multiply(magnetMatrix));\n  },\n  getNodeRotateMatrix(node) {\n    if (!this.rotatableNode || this.rotatableNode.contains(node)) {\n      // Rotate transformation is applied to all nodes when no rotatableGroup\n      // is present or to nodes inside the rotatableGroup only.\n      return this.getRootRotateMatrix();\n    }\n    // Nodes outside the rotatable group\n    return V.createSVGMatrix();\n  },\n  getNodeUnrotatedBBox: function (magnet) {\n    var rect = this.getNodeBoundingRect(magnet);\n    var magnetMatrix = this.getNodeMatrix(magnet);\n    var translateMatrix = this.getRootTranslateMatrix();\n    return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));\n  },\n  getRootTranslateMatrix: function () {\n    var model = this.model;\n    var position = model.position();\n    var mt = V.createSVGMatrix().translate(position.x, position.y);\n    return mt;\n  },\n  getRootRotateMatrix: function () {\n    var mr = V.createSVGMatrix();\n    var model = this.model;\n    var angle = model.angle();\n    if (angle) {\n      var bbox = model.getBBox();\n      var cx = bbox.width / 2;\n      var cy = bbox.height / 2;\n      mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n    }\n    return mr;\n  },\n  _notifyHighlight: function (eventName, el, opt = {}) {\n    const {\n      el: rootNode\n    } = this;\n    let node;\n    if (typeof el === 'string') {\n      node = this.findNode(el) || rootNode;\n    } else {\n      [node = rootNode] = this.$(el);\n    }\n    // set partial flag if the highlighted element is not the entire view.\n    opt.partial = node !== rootNode;\n    // translate type flag into a type string\n    if (opt.type === undefined) {\n      let type;\n      switch (true) {\n        case opt.embedding:\n          type = HighlightingTypes.EMBEDDING;\n          break;\n        case opt.connecting:\n          type = HighlightingTypes.CONNECTING;\n          break;\n        case opt.magnetAvailability:\n          type = HighlightingTypes.MAGNET_AVAILABILITY;\n          break;\n        case opt.elementAvailability:\n          type = HighlightingTypes.ELEMENT_AVAILABILITY;\n          break;\n        default:\n          type = HighlightingTypes.DEFAULT;\n          break;\n      }\n      opt.type = type;\n    }\n    this.notify(eventName, node, opt);\n    return this;\n  },\n  highlight: function (el, opt) {\n    return this._notifyHighlight('cell:highlight', el, opt);\n  },\n  unhighlight: function (el, opt = {}) {\n    return this._notifyHighlight('cell:unhighlight', el, opt);\n  },\n  // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n  // an element found, return the root element of the cell view.\n  findMagnet: function (el) {\n    const root = this.el;\n    let magnet = this.$(el)[0];\n    if (!magnet) {\n      magnet = root;\n    }\n    do {\n      const magnetAttribute = magnet.getAttribute('magnet');\n      const isMagnetRoot = magnet === root;\n      if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n        return magnet;\n      }\n      if (isMagnetRoot) {\n        // If the overall cell has set `magnet === false`, then return `undefined` to\n        // announce there is no magnet found for this cell.\n        // This is especially useful to set on cells that have 'ports'. In this case,\n        // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n        return undefined;\n      }\n      magnet = magnet.parentNode;\n    } while (magnet);\n    return undefined;\n  },\n  findProxyNode: function (el, type) {\n    el || (el = this.el);\n    const nodeSelector = el.getAttribute(`${type}-selector`);\n    if (nodeSelector) {\n      const proxyNode = this.findNode(nodeSelector);\n      if (proxyNode) return proxyNode;\n    }\n    return el;\n  },\n  // Construct a unique selector for the `el` element within this view.\n  // `prevSelector` is being collected through the recursive call.\n  // No value for `prevSelector` is expected when using this method.\n  getSelector: function (el, prevSelector) {\n    var selector;\n    if (el === this.el) {\n      if (typeof prevSelector === 'string') selector = ':scope > ' + prevSelector;\n      return selector;\n    }\n    if (el) {\n      var nthChild = V(el).index() + 1;\n      selector = el.tagName + ':nth-child(' + nthChild + ')';\n      if (prevSelector) {\n        selector += ' > ' + prevSelector;\n      }\n      selector = this.getSelector(el.parentNode, selector);\n    }\n    return selector;\n  },\n  addLinkFromMagnet: function (magnet, x, y) {\n    var paper = this.paper;\n    var graph = paper.model;\n    var link = paper.getDefaultLink(this, magnet);\n    link.set({\n      source: this.getLinkEnd(magnet, x, y, link, 'source'),\n      target: {\n        x: x,\n        y: y\n      }\n    }).addTo(graph, {\n      async: false,\n      ui: true\n    });\n    return link.findView(paper);\n  },\n  getLinkEnd: function (magnet, ...args) {\n    var model = this.model;\n    var id = model.id;\n    var port = this.findAttribute('port', magnet);\n    // Find a unique `selector` of the element under pointer that is a magnet.\n    var selector = magnet.getAttribute('joint-selector');\n    var end = {\n      id: id\n    };\n    if (selector != null) end.magnet = selector;\n    if (port != null) {\n      end.port = port;\n      if (!model.hasPort(port) && !selector) {\n        // port created via the `port` attribute (not API)\n        end.selector = this.getSelector(magnet);\n      }\n    } else if (selector == null && this.el !== magnet) {\n      end.selector = this.getSelector(magnet);\n    }\n    return this.customizeLinkEnd(end, magnet, ...args);\n  },\n  customizeLinkEnd: function (end, magnet, x, y, link, endType) {\n    const {\n      paper\n    } = this;\n    const {\n      connectionStrategy\n    } = paper.options;\n    if (typeof connectionStrategy === 'function') {\n      var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);\n      if (strategy) return strategy;\n    }\n    return end;\n  },\n  getMagnetFromLinkEnd: function (end) {\n    var port = end.port;\n    var selector = end.magnet;\n    var model = this.model;\n    var magnet;\n    if (port != null && model.isElement() && model.hasPort(port)) {\n      magnet = this.findPortNode(port, selector) || this.el;\n    } else {\n      if (!selector) selector = end.selector;\n      if (!selector && port != null) {\n        // link end has only `id` and `port` property referencing\n        // a port created via the `port` attribute (not API).\n        selector = '[port=\"' + port + '\"]';\n      }\n      magnet = this.findNode(selector);\n    }\n    return this.findProxyNode(magnet, 'magnet');\n  },\n  dragLinkStart: function (evt, magnet, x, y) {\n    this.model.startBatch('add-link');\n    const linkView = this.addLinkFromMagnet(magnet, x, y);\n    // backwards compatibility events\n    linkView.notifyPointerdown(evt, x, y);\n    linkView.eventData(evt, linkView.startArrowheadMove('target', {\n      whenNotAllowed: 'remove'\n    }));\n    this.eventData(evt, {\n      linkView\n    });\n  },\n  dragLink: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var linkView = data.linkView;\n    if (linkView) {\n      linkView.pointermove(evt, x, y);\n    } else {\n      var paper = this.paper;\n      var magnetThreshold = paper.options.magnetThreshold;\n      var currentTarget = this.getEventTarget(evt);\n      var targetMagnet = data.targetMagnet;\n      if (magnetThreshold === 'onleave') {\n        // magnetThreshold when the pointer leaves the magnet\n        if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) return;\n      } else {\n        // magnetThreshold defined as a number of movements\n        if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n      }\n      this.dragLinkStart(evt, targetMagnet, x, y);\n    }\n  },\n  dragLinkEnd: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var linkView = data.linkView;\n    if (!linkView) return;\n    linkView.pointerup(evt, x, y);\n    this.model.stopBatch('add-link');\n  },\n  getAttributeDefinition: function (attrName) {\n    return this.model.constructor.getAttributeDefinition(attrName);\n  },\n  setNodeAttributes: function (node, attrs) {\n    if (!isEmpty(attrs)) {\n      if (node instanceof SVGElement) {\n        V(node).attr(attrs);\n      } else {\n        $(node).attr(attrs);\n      }\n    }\n  },\n  processNodeAttributes: function (node, attrs) {\n    var attrName, attrVal, def, i, n;\n    var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n    var relatives = [];\n    const rawAttrs = {};\n    for (attrName in attrs) {\n      if (!attrs.hasOwnProperty(attrName)) continue;\n      rawAttrs[V.attributeNames[attrName]] = attrs[attrName];\n    }\n    // divide the attributes between normal and special\n    for (attrName in rawAttrs) {\n      if (!rawAttrs.hasOwnProperty(attrName)) continue;\n      attrVal = rawAttrs[attrName];\n      def = this.getAttributeDefinition(attrName);\n      if (def && (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, rawAttrs, this))) {\n        if (isString(def.set)) {\n          normalAttrs || (normalAttrs = {});\n          normalAttrs[def.set] = attrVal;\n        }\n        if (attrVal !== null) {\n          relatives.push(attrName, def);\n        }\n      } else {\n        normalAttrs || (normalAttrs = {});\n        normalAttrs[attrName] = attrVal;\n      }\n    }\n\n    // handle the rest of attributes via related method\n    // from the special attributes namespace.\n    for (i = 0, n = relatives.length; i < n; i += 2) {\n      attrName = relatives[i];\n      def = relatives[i + 1];\n      attrVal = attrs[attrName];\n      if (isFunction(def.set)) {\n        setAttrs || (setAttrs = {});\n        setAttrs[attrName] = attrVal;\n      }\n      if (isFunction(def.position)) {\n        positionAttrs || (positionAttrs = {});\n        positionAttrs[attrName] = attrVal;\n      }\n      if (isFunction(def.offset)) {\n        offsetAttrs || (offsetAttrs = {});\n        offsetAttrs[attrName] = attrVal;\n      }\n    }\n    return {\n      raw: rawAttrs,\n      normal: normalAttrs,\n      set: setAttrs,\n      position: positionAttrs,\n      offset: offsetAttrs\n    };\n  },\n  updateRelativeAttributes: function (node, attrs, refBBox, opt) {\n    opt || (opt = {});\n    var attrName, attrVal, def;\n    var evalAttrs = evalAttributes(attrs.raw || {}, refBBox);\n    var nodeAttrs = attrs.normal || {};\n    for (const nodeAttrName in nodeAttrs) {\n      nodeAttrs[nodeAttrName] = evalAttrs[nodeAttrName];\n    }\n    var setAttrs = attrs.set;\n    var positionAttrs = attrs.position;\n    var offsetAttrs = attrs.offset;\n    for (attrName in setAttrs) {\n      attrVal = evalAttrs[attrName];\n      def = this.getAttributeDefinition(attrName);\n      // SET - set function should return attributes to be set on the node,\n      // which will affect the node dimensions based on the reference bounding\n      // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n      var setResult = def.set.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);\n      if (isObject(setResult)) {\n        assign(nodeAttrs, setResult);\n      } else if (setResult !== undefined) {\n        nodeAttrs[attrName] = setResult;\n      }\n    }\n    if (node instanceof HTMLElement) {\n      // TODO: setting the `transform` attribute on HTMLElements\n      // via `node.style.transform = 'matrix(...)';` would introduce\n      // a breaking change (e.g. basic.TextBlock).\n      this.setNodeAttributes(node, nodeAttrs);\n      return;\n    }\n\n    // The final translation of the subelement.\n    var nodeTransform = nodeAttrs.transform;\n    var nodeMatrix = V.transformStringToMatrix(nodeTransform);\n    var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);\n    if (nodeTransform) {\n      nodeAttrs = omit(nodeAttrs, 'transform');\n      nodeMatrix.e = nodeMatrix.f = 0;\n    }\n\n    // Calculate node scale determined by the scalable group\n    // only if later needed.\n    var sx, sy, translation;\n    if (positionAttrs || offsetAttrs) {\n      var nodeScale = this.getNodeScale(node, opt.scalableNode);\n      sx = nodeScale.sx;\n      sy = nodeScale.sy;\n    }\n    var positioned = false;\n    for (attrName in positionAttrs) {\n      attrVal = evalAttrs[attrName];\n      def = this.getAttributeDefinition(attrName);\n      // POSITION - position function should return a point from the\n      // reference bounding box. The default position of the node is x:0, y:0 of\n      // the reference bounding box or could be further specify by some\n      // SVG attributes e.g. `x`, `y`\n      translation = def.position.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);\n      if (translation) {\n        nodePosition.offset(Point(translation).scale(sx, sy));\n        positioned || (positioned = true);\n      }\n    }\n\n    // The node bounding box could depend on the `size` set from the previous loop.\n    // Here we know, that all the size attributes have been already set.\n    this.setNodeAttributes(node, nodeAttrs);\n    var offseted = false;\n    if (offsetAttrs) {\n      // Check if the node is visible\n      var nodeBoundingRect = this.getNodeBoundingRect(node);\n      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n        var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n        for (attrName in offsetAttrs) {\n          attrVal = evalAttrs[attrName];\n          def = this.getAttributeDefinition(attrName);\n          // OFFSET - offset function should return a point from the element\n          // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n          // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n          translation = def.offset.call(this, attrVal, nodeBBox, node, evalAttrs, this);\n          if (translation) {\n            nodePosition.offset(Point(translation).scale(sx, sy));\n            offseted || (offseted = true);\n          }\n        }\n      }\n    }\n\n    // Do not touch node's transform attribute if there is no transformation applied.\n    if (nodeTransform !== undefined || positioned || offseted) {\n      // Round the coordinates to 1 decimal point.\n      nodePosition.round(1);\n      nodeMatrix.e = nodePosition.x;\n      nodeMatrix.f = nodePosition.y;\n      node.setAttribute('transform', V.matrixToTransformString(nodeMatrix));\n      // TODO: store nodeMatrix metrics?\n    }\n  },\n  getNodeScale: function (node, scalableNode) {\n    // Check if the node is a descendant of the scalable group.\n    var sx, sy;\n    if (scalableNode && scalableNode.contains(node)) {\n      var scale = scalableNode.scale();\n      sx = 1 / scale.sx;\n      sy = 1 / scale.sy;\n    } else {\n      sx = 1;\n      sy = 1;\n    }\n    return {\n      sx: sx,\n      sy: sy\n    };\n  },\n  cleanNodesCache: function () {\n    this.metrics = {};\n  },\n  nodeCache: function (magnet) {\n    var metrics = this.metrics;\n    // Don't use cache? It most likely a custom view with overridden update.\n    if (!metrics) return {};\n    var id = V.ensureId(magnet);\n    var value = metrics[id];\n    if (!value) value = metrics[id] = {};\n    return value;\n  },\n  getNodeData: function (magnet) {\n    var metrics = this.nodeCache(magnet);\n    if (!metrics.data) metrics.data = {};\n    return metrics.data;\n  },\n  getNodeBoundingRect: function (magnet) {\n    var metrics = this.nodeCache(magnet);\n    if (metrics.boundingRect === undefined) metrics.boundingRect = V(magnet).getBBox();\n    return new Rect(metrics.boundingRect);\n  },\n  getNodeMatrix: function (magnet) {\n    const metrics = this.nodeCache(magnet);\n    if (metrics.magnetMatrix === undefined) {\n      const {\n        rotatableNode,\n        el\n      } = this;\n      let target;\n      if (rotatableNode && rotatableNode.contains(magnet)) {\n        target = rotatableNode;\n      } else {\n        target = el;\n      }\n      metrics.magnetMatrix = V(magnet).getTransformToElement(target);\n    }\n    return V.createSVGMatrix(metrics.magnetMatrix);\n  },\n  getNodeShape: function (magnet) {\n    var metrics = this.nodeCache(magnet);\n    if (metrics.geometryShape === undefined) metrics.geometryShape = V(magnet).toGeometryShape();\n    return metrics.geometryShape.clone();\n  },\n  isNodeConnection: function (node) {\n    return this.model.isLink() && (!node || node === this.el);\n  },\n  findNodesAttributes: function (attrs, root, selectorCache, selectors) {\n    var i, n, nodeAttrs, nodeId;\n    var nodesAttrs = {};\n    var mergeIds = [];\n    for (var selector in attrs) {\n      if (!attrs.hasOwnProperty(selector)) continue;\n      nodeAttrs = attrs[selector];\n      if (!isPlainObject(nodeAttrs)) continue; // Not a valid selector-attributes pair\n      var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n      for (i = 0, n = selected.length; i < n; i++) {\n        var node = selected[i];\n        nodeId = V.ensureId(node);\n        // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n        // groupSelector referencing a single node is not \"unique\"\n        var unique = selectors && selectors[selector] === node;\n        var prevNodeAttrs = nodesAttrs[nodeId];\n        if (prevNodeAttrs) {\n          // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n          // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n          if (!prevNodeAttrs.array) {\n            mergeIds.push(nodeId);\n            prevNodeAttrs.array = true;\n            prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n            prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n          }\n          var attributes = prevNodeAttrs.attributes;\n          var selectedLength = prevNodeAttrs.selectedLength;\n          if (unique) {\n            // node referenced by `selector`\n            attributes.unshift(nodeAttrs);\n            selectedLength.unshift(-1);\n          } else {\n            // node referenced by `groupSelector`\n            var sortIndex = sortedIndex(selectedLength, n);\n            attributes.splice(sortIndex, 0, nodeAttrs);\n            selectedLength.splice(sortIndex, 0, n);\n          }\n        } else {\n          nodesAttrs[nodeId] = {\n            attributes: nodeAttrs,\n            selectedLength: unique ? -1 : n,\n            node: node,\n            array: false\n          };\n        }\n      }\n    }\n    for (i = 0, n = mergeIds.length; i < n; i++) {\n      nodeId = mergeIds[i];\n      nodeAttrs = nodesAttrs[nodeId];\n      nodeAttrs.attributes = merge({}, ...nodeAttrs.attributes.reverse());\n    }\n    return nodesAttrs;\n  },\n  getEventTarget: function (evt, opt = {}) {\n    const {\n      target,\n      type,\n      clientX = 0,\n      clientY = 0\n    } = evt;\n    if (\n    // Explicitly defined `fromPoint` option\n    opt.fromPoint ||\n    // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n    // It holds the element when a touchstart triggered.\n    type === 'touchmove' || type === 'touchend' ||\n    // Pointermove/Pointerup event with the pointer captured\n    'pointerId' in evt && target.hasPointerCapture(evt.pointerId)) {\n      return document.elementFromPoint(clientX, clientY);\n    }\n    return target;\n  },\n  // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n  // unless `attrs` parameter was passed.\n  updateDOMSubtreeAttributes: function (rootNode, attrs, opt) {\n    opt || (opt = {});\n    opt.rootBBox || (opt.rootBBox = Rect());\n    opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n\n    // Cache table for query results and bounding box calculation.\n    // Note that `selectorCache` needs to be invalidated for all\n    // `updateAttributes` calls, as the selectors might pointing\n    // to nodes designated by an attribute or elements dynamically\n    // created.\n    var selectorCache = {};\n    var bboxCache = {};\n    var relativeItems = [];\n    var relativeRefItems = [];\n    var item, node, nodeAttrs, nodeData, processedAttrs;\n    var roAttrs = opt.roAttributes;\n    var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n    // `nodesAttrs` are different from all attributes, when\n    // rendering only  attributes sent to this method.\n    var nodesAllAttrs = roAttrs ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors) : nodesAttrs;\n    for (var nodeId in nodesAttrs) {\n      nodeData = nodesAttrs[nodeId];\n      nodeAttrs = nodeData.attributes;\n      node = nodeData.node;\n      processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n      if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset && !processedAttrs.raw.ref) {\n        // Set all the normal attributes right on the SVG/HTML element.\n        this.setNodeAttributes(node, evalAttributes(processedAttrs.normal, opt.rootBBox));\n      } else {\n        var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n        var refSelector = nodeAllAttrs && nodeAttrs.ref === undefined ? nodeAllAttrs.ref : nodeAttrs.ref;\n        var refNode;\n        if (refSelector) {\n          refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n          if (!refNode) {\n            throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n          }\n        } else {\n          refNode = null;\n        }\n        item = {\n          node: node,\n          refNode: refNode,\n          processedAttributes: processedAttrs,\n          allAttributes: nodeAllAttrs\n        };\n        if (refNode) {\n          // If an element in the list is positioned relative to this one, then\n          // we want to insert this one before it in the list.\n          var itemIndex = relativeRefItems.findIndex(function (item) {\n            return item.refNode === node;\n          });\n          if (itemIndex > -1) {\n            relativeRefItems.splice(itemIndex, 0, item);\n          } else {\n            relativeRefItems.push(item);\n          }\n        } else {\n          // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n          // The order of no-ref-items is not specified/important.\n          relativeItems.push(item);\n        }\n      }\n    }\n    relativeItems.push(...relativeRefItems);\n    for (let i = 0, n = relativeItems.length; i < n; i++) {\n      item = relativeItems[i];\n      node = item.node;\n      refNode = item.refNode;\n\n      // Find the reference element bounding box. If no reference was provided, we\n      // use the optional bounding box.\n      const refNodeId = refNode ? V.ensureId(refNode) : '';\n      let refBBox = bboxCache[refNodeId];\n      if (!refBBox) {\n        // Get the bounding box of the reference element using to the common ancestor\n        // transformation space.\n        //\n        // @example 1\n        // <g transform=\"translate(11, 13)\">\n        //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n        //     <rect @selector=\"a\"/>\n        // </g>\n        //\n        // In this case, the reference bounding box can not be affected\n        // by the `transform` attribute of the `<g>` element,\n        // because the exact transformation will be applied to the `a` element\n        // as well as to the `b` element.\n        //\n        // @example 2\n        // <g transform=\"translate(11, 13)\">\n        //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n        // </g>\n        // <rect @selector=\"a\"/>\n        //\n        // In this case, the reference bounding box have to be affected by the\n        // `transform` attribute of the `<g>` element, because the `a` element\n        // is not descendant of the `<g>` element and will not be affected\n        // by the transformation.\n        refBBox = bboxCache[refNodeId] = refNode ? V(refNode).getBBox({\n          target: getCommonAncestorNode(node, refNode)\n        }) : opt.rootBBox;\n      }\n      if (roAttrs) {\n        // if there was a special attribute affecting the position amongst passed-in attributes\n        // we have to merge it with the rest of the element's attributes as they are necessary\n        // to update the position relatively (i.e `ref-x` && 'ref-dx')\n        processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n        this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n      } else {\n        processedAttrs = item.processedAttributes;\n      }\n      this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n    }\n  },\n  mergeProcessedAttributes: function (processedAttrs, roProcessedAttrs) {\n    processedAttrs.set || (processedAttrs.set = {});\n    processedAttrs.position || (processedAttrs.position = {});\n    processedAttrs.offset || (processedAttrs.offset = {});\n    assign(processedAttrs.set, roProcessedAttrs.set);\n    assign(processedAttrs.position, roProcessedAttrs.position);\n    assign(processedAttrs.offset, roProcessedAttrs.offset);\n\n    // Handle also the special transform property.\n    var transform = processedAttrs.normal && processedAttrs.normal.transform;\n    if (transform !== undefined && roProcessedAttrs.normal) {\n      roProcessedAttrs.normal.transform = transform;\n    }\n    processedAttrs.normal = roProcessedAttrs.normal;\n  },\n  // Lifecycle methods\n\n  // Called when the view is attached to the DOM,\n  // as result of `cell.addTo(graph)` being called (isInitialMount === true)\n  // or `paper.options.viewport` returning `true` (isInitialMount === false).\n  onMount(isInitialMount) {\n    if (isInitialMount) return;\n    this.mountTools();\n    HighlighterView.mount(this);\n  },\n  // Called when the view is detached from the DOM,\n  // as result of `paper.options.viewport` returning `false`.\n  onDetach() {\n    this.unmountTools();\n    HighlighterView.unmount(this);\n  },\n  // Called when the view is removed from the DOM\n  // as result of `cell.remove()`.\n  onRemove: function () {\n    this.removeTools();\n    this.removeHighlighters();\n  },\n  _toolsView: null,\n  hasTools: function (name) {\n    var toolsView = this._toolsView;\n    if (!toolsView) return false;\n    if (!name) return true;\n    return toolsView.getName() === name;\n  },\n  addTools: function (toolsView) {\n    this.removeTools();\n    if (toolsView) {\n      this._toolsView = toolsView;\n      toolsView.configure({\n        relatedView: this\n      });\n      toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n    }\n    return this;\n  },\n  unmountTools() {\n    const toolsView = this._toolsView;\n    if (toolsView) toolsView.unmount();\n    return this;\n  },\n  mountTools() {\n    const toolsView = this._toolsView;\n    // Prevent unnecessary re-appending of the tools.\n    if (toolsView && !toolsView.isMounted()) toolsView.mount();\n    return this;\n  },\n  updateTools: function (opt) {\n    var toolsView = this._toolsView;\n    if (toolsView) toolsView.update(opt);\n    return this;\n  },\n  removeTools: function () {\n    var toolsView = this._toolsView;\n    if (toolsView) {\n      toolsView.remove();\n      this._toolsView = null;\n    }\n    return this;\n  },\n  hideTools: function () {\n    var toolsView = this._toolsView;\n    if (toolsView) toolsView.hide();\n    return this;\n  },\n  showTools: function () {\n    var toolsView = this._toolsView;\n    if (toolsView) toolsView.show();\n    return this;\n  },\n  onToolEvent: function (event) {\n    switch (event) {\n      case 'remove':\n        this.removeTools();\n        break;\n      case 'hide':\n        this.hideTools();\n        break;\n      case 'show':\n        this.showTools();\n        break;\n    }\n  },\n  removeHighlighters: function () {\n    HighlighterView.remove(this);\n  },\n  updateHighlighters: function (dirty = false) {\n    HighlighterView.update(this, null, dirty);\n  },\n  transformHighlighters: function () {\n    HighlighterView.transform(this);\n  },\n  // Interaction. The controller part.\n  // ---------------------------------\n\n  preventDefaultInteraction(evt) {\n    this.eventData(evt, {\n      defaultInteractionPrevented: true\n    });\n  },\n  isDefaultInteractionPrevented(evt) {\n    const {\n      defaultInteractionPrevented = false\n    } = this.eventData(evt);\n    return defaultInteractionPrevented;\n  },\n  // Interaction is handled by the paper and delegated to the view in interest.\n  // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n  // If necessary, real coordinates can be obtained from the `evt` event object.\n\n  // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,\n  // i.e. `joint.dia.Element` and `joint.dia.Link`.\n\n  pointerdblclick: function (evt, x, y) {\n    this.notify('cell:pointerdblclick', evt, x, y);\n  },\n  pointerclick: function (evt, x, y) {\n    this.notify('cell:pointerclick', evt, x, y);\n  },\n  contextmenu: function (evt, x, y) {\n    this.notify('cell:contextmenu', evt, x, y);\n  },\n  pointerdown: function (evt, x, y) {\n    const {\n      model\n    } = this;\n    const {\n      graph\n    } = model;\n    if (graph) {\n      model.startBatch('pointer');\n      this.eventData(evt, {\n        graph\n      });\n    }\n    this.notify('cell:pointerdown', evt, x, y);\n  },\n  pointermove: function (evt, x, y) {\n    this.notify('cell:pointermove', evt, x, y);\n  },\n  pointerup: function (evt, x, y) {\n    const {\n      graph\n    } = this.eventData(evt);\n    this.notify('cell:pointerup', evt, x, y);\n    if (graph) {\n      // we don't want to trigger event on model as model doesn't\n      // need to be member of collection anymore (remove)\n      graph.stopBatch('pointer', {\n        cell: this.model\n      });\n    }\n  },\n  mouseover: function (evt) {\n    this.notify('cell:mouseover', evt);\n  },\n  mouseout: function (evt) {\n    this.notify('cell:mouseout', evt);\n  },\n  mouseenter: function (evt) {\n    this.notify('cell:mouseenter', evt);\n  },\n  mouseleave: function (evt) {\n    this.notify('cell:mouseleave', evt);\n  },\n  mousewheel: function (evt, x, y, delta) {\n    this.notify('cell:mousewheel', evt, x, y, delta);\n  },\n  onevent: function (evt, eventName, x, y) {\n    this.notify(eventName, evt, x, y);\n  },\n  onmagnet: function () {\n\n    // noop\n  },\n  magnetpointerdblclick: function () {\n\n    // noop\n  },\n  magnetcontextmenu: function () {\n\n    // noop\n  },\n  checkMouseleave(evt) {\n    const {\n      paper,\n      model\n    } = this;\n    if (paper.isAsync()) {\n      // Make sure the source/target views are updated before this view.\n      // It's not 100% bulletproof (see below) but it's a good enough solution for now.\n      // The connected cells could be links as well. In that case, we would\n      // need to recursively go through all the connected links and update\n      // their source/target views as well.\n      if (model.isLink()) {\n        // The `this.sourceView` and `this.targetView` might not be updated yet.\n        // We need to find the view by the model.\n        const sourceElement = model.getSourceElement();\n        if (sourceElement) {\n          const sourceView = paper.findViewByModel(sourceElement);\n          if (sourceView) {\n            paper.dumpView(sourceView);\n            paper.checkViewVisibility(sourceView);\n          }\n        }\n        const targetElement = model.getTargetElement();\n        if (targetElement) {\n          const targetView = paper.findViewByModel(targetElement);\n          if (targetView) {\n            paper.dumpView(targetView);\n            paper.checkViewVisibility(targetView);\n          }\n        }\n      }\n      // Do the updates of the current view synchronously now\n      paper.dumpView(this);\n      paper.checkViewVisibility(this);\n    }\n    const target = this.getEventTarget(evt, {\n      fromPoint: true\n    });\n    const view = paper.findView(target);\n    if (view === this) return;\n    // Leaving the current view\n    this.mouseleave(evt);\n    if (!view) return;\n    // Entering another view\n    view.mouseenter(evt);\n  },\n  setInteractivity: function (value) {\n    this.options.interactive = value;\n  }\n}, {\n  Flags,\n  Highlighting: HighlightingTypes,\n  addPresentationAttributes: function (presentationAttributes) {\n    return merge({}, result(this.prototype, 'presentationAttributes'), presentationAttributes, function (a, b) {\n      if (!a || !b) return;\n      if (typeof a === 'string') a = [a];\n      if (typeof b === 'string') b = [b];\n      if (Array.isArray(a) && Array.isArray(b)) return uniq(a.concat(b));\n    });\n  },\n  evalAttribute\n});\nObject.defineProperty(CellView.prototype, 'useCSSSelectors', {\n  get() {\n    const localUse = this.model.useCSSSelectors;\n    if (localUse !== undefined) return localUse;\n    return config.useCSSSelectors;\n  }\n});\n\n// TODO: Move to Vectorizer library.\nfunction getCommonAncestorNode(node1, node2) {\n  let parent = node1;\n  do {\n    if (parent.contains(node2)) return parent;\n    parent = parent.parentNode;\n  } while (parent);\n  return null;\n}","map":{"version":3,"names":["config","View","assign","guid","omit","parseDOMJSON","isFunction","isObject","isPlainObject","isBoolean","isEmpty","isString","result","sortedIndex","merge","uniq","Point","Rect","V","$","HighlighterView","evalAttributes","evalAttribute","HighlightingTypes","DEFAULT","EMBEDDING","CONNECTING","MAGNET_AVAILABILITY","ELEMENT_AVAILABILITY","Flags","TOOLS","CellView","extend","tagName","svgElement","selector","metrics","className","classNames","type","model","get","toLowerCase","split","forEach","value","index","list","push","slice","join","_presentationAttributes","_flags","setFlags","flags","attributes","shift","i","n","label","presentationAttributes","attribute","hasOwnProperty","labels","Array","isArray","length","flag","initFlag","Error","hasFlag","getFlag","removeFlag","cell","id","constructor","options","call","initialize","prototype","apply","arguments","cleanNodesCache","startListening","listenTo","onAttributesChange","opt","getChangeFlag","updateHandled","dirty","tool","async","requestUpdate","paper","requestViewUpdate","UPDATE_PRIORITY","markup","root","doc","selectors","groups","groupSelectors","group","rootSelector","fragment","can","feature","interactive","findBySelector","nodes","useCSSSelectors","find","toArray","findNodes","el","findNode","node","notify","eventName","args","trigger","concat","getBBox","bbox","useModelGeometry","angle","getNodeBBox","localToPaperRect","magnet","rect","getNodeBoundingRect","transformMatrix","getRootTranslateMatrix","multiply","getNodeRotateMatrix","magnetMatrix","getNodeMatrix","transformRect","rotatableNode","contains","getRootRotateMatrix","createSVGMatrix","getNodeUnrotatedBBox","translateMatrix","position","mt","translate","x","y","mr","cx","width","cy","height","rotate","_notifyHighlight","rootNode","partial","undefined","embedding","connecting","magnetAvailability","elementAvailability","highlight","unhighlight","findMagnet","magnetAttribute","getAttribute","isMagnetRoot","parentNode","findProxyNode","nodeSelector","proxyNode","getSelector","prevSelector","nthChild","addLinkFromMagnet","graph","link","getDefaultLink","set","source","getLinkEnd","target","addTo","ui","findView","port","findAttribute","end","hasPort","customizeLinkEnd","endType","connectionStrategy","strategy","getMagnetFromLinkEnd","isElement","findPortNode","dragLinkStart","evt","startBatch","linkView","notifyPointerdown","eventData","startArrowheadMove","whenNotAllowed","dragLink","data","pointermove","magnetThreshold","currentTarget","getEventTarget","targetMagnet","mousemoved","dragLinkEnd","pointerup","stopBatch","getAttributeDefinition","attrName","setNodeAttributes","attrs","SVGElement","attr","processNodeAttributes","attrVal","def","normalAttrs","setAttrs","positionAttrs","offsetAttrs","relatives","rawAttrs","attributeNames","qualify","offset","raw","normal","updateRelativeAttributes","refBBox","evalAttrs","nodeAttrs","nodeAttrName","setResult","clone","HTMLElement","nodeTransform","transform","nodeMatrix","transformStringToMatrix","nodePosition","e","f","sx","sy","translation","nodeScale","getNodeScale","scalableNode","positioned","scale","offseted","nodeBoundingRect","nodeBBox","round","setAttribute","matrixToTransformString","nodeCache","ensureId","getNodeData","boundingRect","getTransformToElement","getNodeShape","geometryShape","toGeometryShape","isNodeConnection","isLink","findNodesAttributes","selectorCache","nodeId","nodesAttrs","mergeIds","selected","unique","prevNodeAttrs","array","selectedLength","unshift","sortIndex","splice","reverse","clientX","clientY","fromPoint","hasPointerCapture","pointerId","document","elementFromPoint","updateDOMSubtreeAttributes","rootBBox","bboxCache","relativeItems","relativeRefItems","item","nodeData","processedAttrs","roAttrs","roAttributes","nodesAllAttrs","ref","nodeAllAttrs","refSelector","refNode","processedAttributes","allAttributes","itemIndex","findIndex","refNodeId","getCommonAncestorNode","mergeProcessedAttributes","roProcessedAttrs","onMount","isInitialMount","mountTools","mount","onDetach","unmountTools","unmount","onRemove","removeTools","removeHighlighters","_toolsView","hasTools","name","toolsView","getName","addTools","configure","relatedView","onToolEvent","bind","isMounted","updateTools","update","remove","hideTools","hide","showTools","show","event","updateHighlighters","transformHighlighters","preventDefaultInteraction","defaultInteractionPrevented","isDefaultInteractionPrevented","pointerdblclick","pointerclick","contextmenu","pointerdown","mouseover","mouseout","mouseenter","mouseleave","mousewheel","delta","onevent","onmagnet","magnetpointerdblclick","magnetcontextmenu","checkMouseleave","isAsync","sourceElement","getSourceElement","sourceView","findViewByModel","dumpView","checkViewVisibility","targetElement","getTargetElement","targetView","view","setInteractivity","Highlighting","addPresentationAttributes","a","b","Object","defineProperty","localUse","node1","node2","parent"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/dia/CellView.mjs"],"sourcesContent":["import { config } from '../config/index.mjs';\nimport { View } from '../mvc/index.mjs';\nimport {\n    assign,\n    guid,\n    omit,\n    parseDOMJSON,\n    isFunction,\n    isObject,\n    isPlainObject,\n    isBoolean,\n    isEmpty,\n    isString,\n    result,\n    sortedIndex,\n    merge,\n    uniq\n} from '../util/index.mjs';\nimport { Point, Rect } from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport $ from '../mvc/Dom/index.mjs';\nimport { HighlighterView } from './HighlighterView.mjs';\nimport { evalAttributes, evalAttribute } from './attributes/eval.mjs';\n\nconst HighlightingTypes = {\n    DEFAULT: 'default',\n    EMBEDDING: 'embedding',\n    CONNECTING: 'connecting',\n    MAGNET_AVAILABILITY: 'magnetAvailability',\n    ELEMENT_AVAILABILITY: 'elementAvailability'\n};\n\nconst Flags = {\n    TOOLS: 'TOOLS',\n};\n\n// CellView base view and controller.\n// --------------------------------------------\n\n// This is the base view and controller for `ElementView` and `LinkView`.\nexport const CellView = View.extend({\n\n    tagName: 'g',\n\n    svgElement: true,\n\n    selector: 'root',\n\n    metrics: null,\n\n    className: function() {\n\n        var classNames = ['cell'];\n        var type = this.model.get('type');\n\n        if (type) {\n\n            type.toLowerCase().split('.').forEach(function(value, index, list) {\n                classNames.push('type-' + list.slice(0, index + 1).join('-'));\n            });\n        }\n\n        return classNames.join(' ');\n    },\n\n    _presentationAttributes: null,\n    _flags: null,\n\n    setFlags: function() {\n        var flags = {};\n        var attributes = {};\n        var shift = 0;\n        var i, n, label;\n        var presentationAttributes = result(this, 'presentationAttributes');\n        for (var attribute in presentationAttributes) {\n            if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n            var labels = presentationAttributes[attribute];\n            if (!Array.isArray(labels)) labels = [labels];\n            for (i = 0, n = labels.length; i < n; i++) {\n                label = labels[i];\n                var flag = flags[label];\n                if (!flag) {\n                    flag = flags[label] = 1<<(shift++);\n                }\n                attributes[attribute] |= flag;\n            }\n        }\n        var initFlag = result(this, 'initFlag');\n        if (!Array.isArray(initFlag)) initFlag = [initFlag];\n        for (i = 0, n = initFlag.length; i < n; i++) {\n            label = initFlag[i];\n            if (!flags[label]) flags[label] = 1<<(shift++);\n        }\n\n        // 26 - 30 are reserved for paper flags\n        // 31+ overflows maximal number\n        if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');\n\n        this._flags = flags;\n        this._presentationAttributes = attributes;\n    },\n\n    hasFlag: function(flag, label) {\n        return flag & this.getFlag(label);\n    },\n\n    removeFlag: function(flag, label) {\n        return flag ^ (flag & this.getFlag(label));\n    },\n\n    getFlag: function(label) {\n        var flags = this._flags;\n        if (!flags) return 0;\n        var flag = 0;\n        if (Array.isArray(label)) {\n            for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];\n        } else {\n            flag |= flags[label];\n        }\n        return flag;\n    },\n\n    attributes: function() {\n        var cell = this.model;\n        return {\n            'model-id': cell.id,\n            'data-type': cell.attributes.type\n        };\n    },\n\n    constructor: function(options) {\n\n        // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n        // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n        // still be associated to the same object among all those clients. This is necessary for real-time\n        // collaboration mechanism.\n        options.id = options.id || guid(this);\n\n        View.call(this, options);\n    },\n\n    initialize: function() {\n\n        this.setFlags();\n\n        View.prototype.initialize.apply(this, arguments);\n\n        this.cleanNodesCache();\n\n        this.startListening();\n    },\n\n    startListening: function() {\n        this.listenTo(this.model, 'change', this.onAttributesChange);\n    },\n\n    onAttributesChange: function(model, opt) {\n        var flag = model.getChangeFlag(this._presentationAttributes);\n        if (opt.updateHandled || !flag) return;\n        if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER');\n        // TODO: tool changes does not need to be sync\n        // Fix Segments tools\n        if (opt.tool) opt.async = false;\n        this.requestUpdate(flag, opt);\n    },\n\n    requestUpdate: function(flags, opt) {\n        const { paper } = this;\n        if (paper && flags > 0) {\n            paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n        }\n    },\n\n    parseDOMJSON: function(markup, root) {\n\n        var doc = parseDOMJSON(markup);\n        var selectors = doc.selectors;\n        var groups = doc.groupSelectors;\n        for (var group in groups) {\n            if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');\n            selectors[group] = groups[group];\n        }\n        if (root) {\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');\n            selectors[rootSelector] = root;\n        }\n        return { fragment: doc.fragment, selectors: selectors };\n    },\n\n    // Return `true` if cell link is allowed to perform a certain UI `feature`.\n    // Example: `can('labelMove')`.\n    can: function(feature) {\n\n        var interactive = isFunction(this.options.interactive)\n            ? this.options.interactive(this)\n            : this.options.interactive;\n\n        return (isObject(interactive) && interactive[feature] !== false) ||\n            (isBoolean(interactive) && interactive !== false);\n    },\n\n    findBySelector: function(selector, root, selectors) {\n\n        // These are either descendants of `this.$el` of `this.$el` itself.\n        // `.` is a special selector used to select the wrapping `<g>` element.\n        if (!selector || selector === '.') return [root];\n        if (selectors) {\n            var nodes = selectors[selector];\n            if (nodes) {\n                if (Array.isArray(nodes)) return nodes;\n                return [nodes];\n            }\n        }\n\n        // Maintaining backwards compatibility\n        // e.g. `circle:first` would fail with querySelector() call\n        if (this.useCSSSelectors) return $(root).find(selector).toArray();\n\n        return [];\n    },\n\n    findNodes: function(selector) {\n        return this.findBySelector(selector, this.el, this.selectors);\n    },\n\n    findNode: function(selector) {\n        const [node = null] = this.findNodes(selector);\n        return node;\n    },\n\n    notify: function(eventName) {\n\n        if (this.paper) {\n\n            var args = Array.prototype.slice.call(arguments, 1);\n\n            // Trigger the event on both the element itself and also on the paper.\n            this.trigger.apply(this, [eventName].concat(args));\n\n            // Paper event handlers receive the view object as the first argument.\n            this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n        }\n    },\n\n    getBBox: function(opt) {\n\n        var bbox;\n        if (opt && opt.useModelGeometry) {\n            var model = this.model;\n            bbox = model.getBBox().bbox(model.angle());\n        } else {\n            bbox = this.getNodeBBox(this.el);\n        }\n\n        return this.paper.localToPaperRect(bbox);\n    },\n\n    getNodeBBox: function(magnet) {\n\n        const rect = this.getNodeBoundingRect(magnet);\n        const transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));\n        const magnetMatrix = this.getNodeMatrix(magnet);\n        return V.transformRect(rect, transformMatrix.multiply(magnetMatrix));\n    },\n\n    getNodeRotateMatrix(node) {\n        if (!this.rotatableNode || this.rotatableNode.contains(node)) {\n            // Rotate transformation is applied to all nodes when no rotatableGroup\n            // is present or to nodes inside the rotatableGroup only.\n            return this.getRootRotateMatrix();\n        }\n        // Nodes outside the rotatable group\n        return V.createSVGMatrix();\n    },\n\n    getNodeUnrotatedBBox: function(magnet) {\n\n        var rect = this.getNodeBoundingRect(magnet);\n        var magnetMatrix = this.getNodeMatrix(magnet);\n        var translateMatrix = this.getRootTranslateMatrix();\n        return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));\n    },\n\n    getRootTranslateMatrix: function() {\n\n        var model = this.model;\n        var position = model.position();\n        var mt = V.createSVGMatrix().translate(position.x, position.y);\n        return mt;\n    },\n\n    getRootRotateMatrix: function() {\n\n        var mr = V.createSVGMatrix();\n        var model = this.model;\n        var angle = model.angle();\n        if (angle) {\n            var bbox = model.getBBox();\n            var cx = bbox.width / 2;\n            var cy = bbox.height / 2;\n            mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n        }\n        return mr;\n    },\n\n    _notifyHighlight: function(eventName, el, opt = {}) {\n        const { el: rootNode } = this;\n        let node;\n        if (typeof el === 'string') {\n            node = this.findNode(el) || rootNode;\n        } else {\n            [node = rootNode] = this.$(el);\n        }\n        // set partial flag if the highlighted element is not the entire view.\n        opt.partial = (node !== rootNode);\n        // translate type flag into a type string\n        if (opt.type === undefined) {\n            let type;\n            switch (true) {\n                case opt.embedding:\n                    type = HighlightingTypes.EMBEDDING;\n                    break;\n                case opt.connecting:\n                    type = HighlightingTypes.CONNECTING;\n                    break;\n                case opt.magnetAvailability:\n                    type = HighlightingTypes.MAGNET_AVAILABILITY;\n                    break;\n                case opt.elementAvailability:\n                    type = HighlightingTypes.ELEMENT_AVAILABILITY;\n                    break;\n                default:\n                    type = HighlightingTypes.DEFAULT;\n                    break;\n            }\n            opt.type = type;\n        }\n        this.notify(eventName, node, opt);\n        return this;\n    },\n\n    highlight: function(el, opt) {\n        return this._notifyHighlight('cell:highlight', el, opt);\n    },\n\n    unhighlight: function(el, opt = {}) {\n        return this._notifyHighlight('cell:unhighlight', el, opt);\n    },\n\n    // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n    // an element found, return the root element of the cell view.\n    findMagnet: function(el) {\n\n        const root = this.el;\n        let magnet = this.$(el)[0];\n        if (!magnet) {\n            magnet = root;\n        }\n\n        do {\n            const magnetAttribute = magnet.getAttribute('magnet');\n            const isMagnetRoot = (magnet === root);\n            if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n                return magnet;\n            }\n            if (isMagnetRoot) {\n                // If the overall cell has set `magnet === false`, then return `undefined` to\n                // announce there is no magnet found for this cell.\n                // This is especially useful to set on cells that have 'ports'. In this case,\n                // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n                return undefined;\n            }\n            magnet = magnet.parentNode;\n        } while (magnet);\n\n        return undefined;\n    },\n\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const proxyNode = this.findNode(nodeSelector);\n            if (proxyNode) return proxyNode;\n        }\n        return el;\n    },\n\n    // Construct a unique selector for the `el` element within this view.\n    // `prevSelector` is being collected through the recursive call.\n    // No value for `prevSelector` is expected when using this method.\n    getSelector: function(el, prevSelector) {\n\n        var selector;\n\n        if (el === this.el) {\n            if (typeof prevSelector === 'string') selector = ':scope > ' + prevSelector;\n            return selector;\n        }\n\n        if (el) {\n\n            var nthChild = V(el).index() + 1;\n            selector = el.tagName + ':nth-child(' + nthChild + ')';\n\n            if (prevSelector) {\n                selector += ' > ' + prevSelector;\n            }\n\n            selector = this.getSelector(el.parentNode, selector);\n        }\n\n        return selector;\n    },\n\n    addLinkFromMagnet: function(magnet, x, y) {\n\n        var paper = this.paper;\n        var graph = paper.model;\n\n        var link = paper.getDefaultLink(this, magnet);\n        link.set({\n            source: this.getLinkEnd(magnet, x, y, link, 'source'),\n            target: { x: x, y: y }\n        }).addTo(graph, {\n            async: false,\n            ui: true\n        });\n\n        return link.findView(paper);\n    },\n\n    getLinkEnd: function(magnet, ...args) {\n\n        var model = this.model;\n        var id = model.id;\n        var port = this.findAttribute('port', magnet);\n        // Find a unique `selector` of the element under pointer that is a magnet.\n        var selector = magnet.getAttribute('joint-selector');\n\n        var end = { id: id };\n        if (selector != null) end.magnet = selector;\n        if (port != null) {\n            end.port = port;\n            if (!model.hasPort(port) && !selector) {\n                // port created via the `port` attribute (not API)\n                end.selector = this.getSelector(magnet);\n            }\n        } else if (selector == null && this.el !== magnet) {\n            end.selector = this.getSelector(magnet);\n        }\n\n        return this.customizeLinkEnd(end, magnet, ...args);\n    },\n\n    customizeLinkEnd: function(end, magnet, x, y, link, endType) {\n        const { paper } = this;\n        const { connectionStrategy } = paper.options;\n        if (typeof connectionStrategy === 'function') {\n            var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);\n            if (strategy) return strategy;\n        }\n        return end;\n    },\n\n    getMagnetFromLinkEnd: function(end) {\n\n        var port = end.port;\n        var selector = end.magnet;\n        var model = this.model;\n        var magnet;\n        if (port != null && model.isElement() && model.hasPort(port)) {\n            magnet = this.findPortNode(port, selector) || this.el;\n        } else {\n            if (!selector) selector = end.selector;\n            if (!selector && port != null) {\n                // link end has only `id` and `port` property referencing\n                // a port created via the `port` attribute (not API).\n                selector = '[port=\"' + port + '\"]';\n            }\n            magnet = this.findNode(selector);\n        }\n\n        return this.findProxyNode(magnet, 'magnet');\n    },\n\n    dragLinkStart: function(evt, magnet, x, y) {\n        this.model.startBatch('add-link');\n        const linkView = this.addLinkFromMagnet(magnet, x, y);\n        // backwards compatibility events\n        linkView.notifyPointerdown(evt, x, y);\n        linkView.eventData(evt, linkView.startArrowheadMove('target', { whenNotAllowed: 'remove' }));\n        this.eventData(evt, { linkView });\n    },\n\n    dragLink: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (linkView) {\n            linkView.pointermove(evt, x, y);\n        } else {\n            var paper = this.paper;\n            var magnetThreshold = paper.options.magnetThreshold;\n            var currentTarget = this.getEventTarget(evt);\n            var targetMagnet = data.targetMagnet;\n            if (magnetThreshold === 'onleave') {\n                // magnetThreshold when the pointer leaves the magnet\n                if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) return;\n            } else {\n                // magnetThreshold defined as a number of movements\n                if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n            }\n            this.dragLinkStart(evt, targetMagnet, x, y);\n        }\n    },\n\n    dragLinkEnd: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (!linkView) return;\n        linkView.pointerup(evt, x, y);\n        this.model.stopBatch('add-link');\n    },\n\n    getAttributeDefinition: function(attrName) {\n\n        return this.model.constructor.getAttributeDefinition(attrName);\n    },\n\n    setNodeAttributes: function(node, attrs) {\n\n        if (!isEmpty(attrs)) {\n            if (node instanceof SVGElement) {\n                V(node).attr(attrs);\n            } else {\n                $(node).attr(attrs);\n            }\n        }\n    },\n\n    processNodeAttributes: function(node, attrs) {\n\n        var attrName, attrVal, def, i, n;\n        var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n        var relatives = [];\n        const rawAttrs = {};\n        for (attrName in attrs) {\n            if (!attrs.hasOwnProperty(attrName)) continue;\n            rawAttrs[V.attributeNames[attrName]] = attrs[attrName];\n        }\n        // divide the attributes between normal and special\n        for (attrName in rawAttrs) {\n            if (!rawAttrs.hasOwnProperty(attrName)) continue;\n            attrVal = rawAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            if (def && (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, rawAttrs, this))) {\n                if (isString(def.set)) {\n                    normalAttrs || (normalAttrs = {});\n                    normalAttrs[def.set] = attrVal;\n                }\n                if (attrVal !== null) {\n                    relatives.push(attrName, def);\n                }\n            } else {\n                normalAttrs || (normalAttrs = {});\n                normalAttrs[attrName] = attrVal;\n            }\n        }\n\n        // handle the rest of attributes via related method\n        // from the special attributes namespace.\n        for (i = 0, n = relatives.length; i < n; i+=2) {\n            attrName = relatives[i];\n            def = relatives[i+1];\n            attrVal = attrs[attrName];\n            if (isFunction(def.set)) {\n                setAttrs || (setAttrs = {});\n                setAttrs[attrName] = attrVal;\n            }\n            if (isFunction(def.position)) {\n                positionAttrs || (positionAttrs = {});\n                positionAttrs[attrName] = attrVal;\n            }\n            if (isFunction(def.offset)) {\n                offsetAttrs || (offsetAttrs = {});\n                offsetAttrs[attrName] = attrVal;\n            }\n        }\n\n        return {\n            raw: rawAttrs,\n            normal: normalAttrs,\n            set: setAttrs,\n            position: positionAttrs,\n            offset: offsetAttrs\n        };\n    },\n\n    updateRelativeAttributes: function(node, attrs, refBBox, opt) {\n\n        opt || (opt = {});\n\n        var attrName, attrVal, def;\n        var evalAttrs = evalAttributes(attrs.raw || {}, refBBox);\n        var nodeAttrs = attrs.normal || {};\n        for (const nodeAttrName in nodeAttrs) {\n            nodeAttrs[nodeAttrName] = evalAttrs[nodeAttrName];\n        }\n        var setAttrs = attrs.set;\n        var positionAttrs = attrs.position;\n        var offsetAttrs = attrs.offset;\n\n        for (attrName in setAttrs) {\n            attrVal = evalAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // SET - set function should return attributes to be set on the node,\n            // which will affect the node dimensions based on the reference bounding\n            // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n            var setResult = def.set.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);\n            if (isObject(setResult)) {\n                assign(nodeAttrs, setResult);\n            } else if (setResult !== undefined) {\n                nodeAttrs[attrName] = setResult;\n            }\n        }\n\n        if (node instanceof HTMLElement) {\n            // TODO: setting the `transform` attribute on HTMLElements\n            // via `node.style.transform = 'matrix(...)';` would introduce\n            // a breaking change (e.g. basic.TextBlock).\n            this.setNodeAttributes(node, nodeAttrs);\n            return;\n        }\n\n        // The final translation of the subelement.\n        var nodeTransform = nodeAttrs.transform;\n        var nodeMatrix = V.transformStringToMatrix(nodeTransform);\n        var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);\n        if (nodeTransform) {\n            nodeAttrs = omit(nodeAttrs, 'transform');\n            nodeMatrix.e = nodeMatrix.f = 0;\n        }\n\n        // Calculate node scale determined by the scalable group\n        // only if later needed.\n        var sx, sy, translation;\n        if (positionAttrs || offsetAttrs) {\n            var nodeScale = this.getNodeScale(node, opt.scalableNode);\n            sx = nodeScale.sx;\n            sy = nodeScale.sy;\n        }\n\n        var positioned = false;\n        for (attrName in positionAttrs) {\n            attrVal = evalAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // POSITION - position function should return a point from the\n            // reference bounding box. The default position of the node is x:0, y:0 of\n            // the reference bounding box or could be further specify by some\n            // SVG attributes e.g. `x`, `y`\n            translation = def.position.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);\n            if (translation) {\n                nodePosition.offset(Point(translation).scale(sx, sy));\n                positioned || (positioned = true);\n            }\n        }\n\n        // The node bounding box could depend on the `size` set from the previous loop.\n        // Here we know, that all the size attributes have been already set.\n        this.setNodeAttributes(node, nodeAttrs);\n\n        var offseted = false;\n        if (offsetAttrs) {\n            // Check if the node is visible\n            var nodeBoundingRect = this.getNodeBoundingRect(node);\n            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n                var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n                for (attrName in offsetAttrs) {\n                    attrVal = evalAttrs[attrName];\n                    def = this.getAttributeDefinition(attrName);\n                    // OFFSET - offset function should return a point from the element\n                    // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n                    // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n                    translation = def.offset.call(this, attrVal, nodeBBox, node, evalAttrs, this);\n                    if (translation) {\n                        nodePosition.offset(Point(translation).scale(sx, sy));\n                        offseted || (offseted = true);\n                    }\n                }\n            }\n        }\n\n        // Do not touch node's transform attribute if there is no transformation applied.\n        if (nodeTransform !== undefined || positioned || offseted) {\n            // Round the coordinates to 1 decimal point.\n            nodePosition.round(1);\n            nodeMatrix.e = nodePosition.x;\n            nodeMatrix.f = nodePosition.y;\n            node.setAttribute('transform', V.matrixToTransformString(nodeMatrix));\n            // TODO: store nodeMatrix metrics?\n        }\n    },\n\n    getNodeScale: function(node, scalableNode) {\n\n        // Check if the node is a descendant of the scalable group.\n        var sx, sy;\n        if (scalableNode && scalableNode.contains(node)) {\n            var scale = scalableNode.scale();\n            sx = 1 / scale.sx;\n            sy = 1 / scale.sy;\n        } else {\n            sx = 1;\n            sy = 1;\n        }\n\n        return { sx: sx, sy: sy };\n    },\n\n    cleanNodesCache: function() {\n        this.metrics = {};\n    },\n\n    nodeCache: function(magnet) {\n\n        var metrics = this.metrics;\n        // Don't use cache? It most likely a custom view with overridden update.\n        if (!metrics) return {};\n        var id = V.ensureId(magnet);\n        var value = metrics[id];\n        if (!value) value = metrics[id] = {};\n        return value;\n    },\n\n    getNodeData: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (!metrics.data) metrics.data = {};\n        return metrics.data;\n    },\n\n    getNodeBoundingRect: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.boundingRect === undefined) metrics.boundingRect = V(magnet).getBBox();\n        return new Rect(metrics.boundingRect);\n    },\n\n    getNodeMatrix: function(magnet) {\n\n        const metrics = this.nodeCache(magnet);\n        if (metrics.magnetMatrix === undefined) {\n            const { rotatableNode, el } = this;\n            let target;\n            if (rotatableNode && rotatableNode.contains(magnet)) {\n                target = rotatableNode;\n            } else {\n                target = el;\n            }\n            metrics.magnetMatrix = V(magnet).getTransformToElement(target);\n        }\n        return V.createSVGMatrix(metrics.magnetMatrix);\n    },\n\n    getNodeShape: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.geometryShape === undefined) metrics.geometryShape = V(magnet).toGeometryShape();\n        return metrics.geometryShape.clone();\n    },\n\n    isNodeConnection: function(node) {\n        return this.model.isLink() && (!node || node === this.el);\n    },\n\n    findNodesAttributes: function(attrs, root, selectorCache, selectors) {\n\n        var i, n, nodeAttrs, nodeId;\n        var nodesAttrs = {};\n        var mergeIds = [];\n        for (var selector in attrs) {\n            if (!attrs.hasOwnProperty(selector)) continue;\n            nodeAttrs = attrs[selector];\n            if (!isPlainObject(nodeAttrs)) continue; // Not a valid selector-attributes pair\n            var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n            for (i = 0, n = selected.length; i < n; i++) {\n                var node = selected[i];\n                nodeId = V.ensureId(node);\n                // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n                // groupSelector referencing a single node is not \"unique\"\n                var unique = (selectors && selectors[selector] === node);\n                var prevNodeAttrs = nodesAttrs[nodeId];\n                if (prevNodeAttrs) {\n                    // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n                    // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n                    if (!prevNodeAttrs.array) {\n                        mergeIds.push(nodeId);\n                        prevNodeAttrs.array = true;\n                        prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n                        prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n                    }\n                    var attributes = prevNodeAttrs.attributes;\n                    var selectedLength = prevNodeAttrs.selectedLength;\n                    if (unique) {\n                        // node referenced by `selector`\n                        attributes.unshift(nodeAttrs);\n                        selectedLength.unshift(-1);\n                    } else {\n                        // node referenced by `groupSelector`\n                        var sortIndex = sortedIndex(selectedLength, n);\n                        attributes.splice(sortIndex, 0, nodeAttrs);\n                        selectedLength.splice(sortIndex, 0, n);\n                    }\n                } else {\n                    nodesAttrs[nodeId] = {\n                        attributes: nodeAttrs,\n                        selectedLength: unique ? -1 : n,\n                        node: node,\n                        array: false\n                    };\n                }\n            }\n        }\n\n        for (i = 0, n = mergeIds.length; i < n; i++) {\n            nodeId = mergeIds[i];\n            nodeAttrs = nodesAttrs[nodeId];\n            nodeAttrs.attributes = merge({}, ...nodeAttrs.attributes.reverse());\n        }\n\n        return nodesAttrs;\n    },\n\n    getEventTarget: function(evt, opt = {}) {\n        const { target, type, clientX = 0, clientY = 0 } = evt;\n        if (\n            // Explicitly defined `fromPoint` option\n            opt.fromPoint ||\n            // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n            // It holds the element when a touchstart triggered.\n            type === 'touchmove' || type === 'touchend' ||\n            // Pointermove/Pointerup event with the pointer captured\n            ('pointerId' in evt && target.hasPointerCapture(evt.pointerId))\n        ) {\n            return document.elementFromPoint(clientX, clientY);\n        }\n\n        return target;\n    },\n\n    // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n    // unless `attrs` parameter was passed.\n    updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {\n\n        opt || (opt = {});\n        opt.rootBBox || (opt.rootBBox = Rect());\n        opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n\n        // Cache table for query results and bounding box calculation.\n        // Note that `selectorCache` needs to be invalidated for all\n        // `updateAttributes` calls, as the selectors might pointing\n        // to nodes designated by an attribute or elements dynamically\n        // created.\n        var selectorCache = {};\n        var bboxCache = {};\n        var relativeItems = [];\n        var relativeRefItems = [];\n        var item, node, nodeAttrs, nodeData, processedAttrs;\n\n        var roAttrs = opt.roAttributes;\n        var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n        // `nodesAttrs` are different from all attributes, when\n        // rendering only  attributes sent to this method.\n        var nodesAllAttrs = (roAttrs)\n            ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors)\n            : nodesAttrs;\n\n        for (var nodeId in nodesAttrs) {\n            nodeData = nodesAttrs[nodeId];\n            nodeAttrs = nodeData.attributes;\n            node = nodeData.node;\n            processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n\n            if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset && !processedAttrs.raw.ref) {\n                // Set all the normal attributes right on the SVG/HTML element.\n                this.setNodeAttributes(node, evalAttributes(processedAttrs.normal, opt.rootBBox));\n\n            } else {\n\n                var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n                var refSelector = (nodeAllAttrs && (nodeAttrs.ref === undefined))\n                    ? nodeAllAttrs.ref\n                    : nodeAttrs.ref;\n\n                var refNode;\n                if (refSelector) {\n                    refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n                    if (!refNode) {\n                        throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n                    }\n                } else {\n                    refNode = null;\n                }\n\n                item = {\n                    node: node,\n                    refNode: refNode,\n                    processedAttributes: processedAttrs,\n                    allAttributes: nodeAllAttrs\n                };\n\n                if (refNode) {\n                    // If an element in the list is positioned relative to this one, then\n                    // we want to insert this one before it in the list.\n                    var itemIndex = relativeRefItems.findIndex(function(item) {\n                        return item.refNode === node;\n                    });\n\n                    if (itemIndex > -1) {\n                        relativeRefItems.splice(itemIndex, 0, item);\n                    } else {\n                        relativeRefItems.push(item);\n                    }\n                } else {\n                    // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n                    // The order of no-ref-items is not specified/important.\n                    relativeItems.push(item);\n                }\n            }\n        }\n\n        relativeItems.push(...relativeRefItems);\n\n        for (let i = 0, n = relativeItems.length; i < n; i++) {\n            item = relativeItems[i];\n            node = item.node;\n            refNode = item.refNode;\n\n            // Find the reference element bounding box. If no reference was provided, we\n            // use the optional bounding box.\n            const refNodeId = refNode ? V.ensureId(refNode) : '';\n            let refBBox = bboxCache[refNodeId];\n            if (!refBBox) {\n                // Get the bounding box of the reference element using to the common ancestor\n                // transformation space.\n                //\n                // @example 1\n                // <g transform=\"translate(11, 13)\">\n                //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n                //     <rect @selector=\"a\"/>\n                // </g>\n                //\n                // In this case, the reference bounding box can not be affected\n                // by the `transform` attribute of the `<g>` element,\n                // because the exact transformation will be applied to the `a` element\n                // as well as to the `b` element.\n                //\n                // @example 2\n                // <g transform=\"translate(11, 13)\">\n                //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n                // </g>\n                // <rect @selector=\"a\"/>\n                //\n                // In this case, the reference bounding box have to be affected by the\n                // `transform` attribute of the `<g>` element, because the `a` element\n                // is not descendant of the `<g>` element and will not be affected\n                // by the transformation.\n                refBBox = bboxCache[refNodeId] = (refNode)\n                    ? V(refNode).getBBox({ target: getCommonAncestorNode(node, refNode) })\n                    : opt.rootBBox;\n            }\n\n            if (roAttrs) {\n                // if there was a special attribute affecting the position amongst passed-in attributes\n                // we have to merge it with the rest of the element's attributes as they are necessary\n                // to update the position relatively (i.e `ref-x` && 'ref-dx')\n                processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n                this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n\n            } else {\n                processedAttrs = item.processedAttributes;\n            }\n\n            this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n        }\n    },\n\n    mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {\n\n        processedAttrs.set || (processedAttrs.set = {});\n        processedAttrs.position || (processedAttrs.position = {});\n        processedAttrs.offset || (processedAttrs.offset = {});\n\n        assign(processedAttrs.set, roProcessedAttrs.set);\n        assign(processedAttrs.position, roProcessedAttrs.position);\n        assign(processedAttrs.offset, roProcessedAttrs.offset);\n\n        // Handle also the special transform property.\n        var transform = processedAttrs.normal && processedAttrs.normal.transform;\n        if (transform !== undefined && roProcessedAttrs.normal) {\n            roProcessedAttrs.normal.transform = transform;\n        }\n        processedAttrs.normal = roProcessedAttrs.normal;\n    },\n\n    // Lifecycle methods\n\n    // Called when the view is attached to the DOM,\n    // as result of `cell.addTo(graph)` being called (isInitialMount === true)\n    // or `paper.options.viewport` returning `true` (isInitialMount === false).\n    onMount(isInitialMount) {\n        if (isInitialMount) return;\n        this.mountTools();\n        HighlighterView.mount(this);\n    },\n\n    // Called when the view is detached from the DOM,\n    // as result of `paper.options.viewport` returning `false`.\n    onDetach() {\n        this.unmountTools();\n        HighlighterView.unmount(this);\n    },\n\n    // Called when the view is removed from the DOM\n    // as result of `cell.remove()`.\n    onRemove: function() {\n        this.removeTools();\n        this.removeHighlighters();\n    },\n\n    _toolsView: null,\n\n    hasTools: function(name) {\n        var toolsView = this._toolsView;\n        if (!toolsView) return false;\n        if (!name) return true;\n        return (toolsView.getName() === name);\n    },\n\n    addTools: function(toolsView) {\n\n        this.removeTools();\n\n        if (toolsView) {\n            this._toolsView = toolsView;\n            toolsView.configure({ relatedView: this });\n            toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n        }\n        return this;\n    },\n\n    unmountTools() {\n        const toolsView = this._toolsView;\n        if (toolsView) toolsView.unmount();\n        return this;\n    },\n\n    mountTools() {\n        const toolsView = this._toolsView;\n        // Prevent unnecessary re-appending of the tools.\n        if (toolsView && !toolsView.isMounted()) toolsView.mount();\n        return this;\n    },\n\n    updateTools: function(opt) {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.update(opt);\n        return this;\n    },\n\n    removeTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) {\n            toolsView.remove();\n            this._toolsView = null;\n        }\n        return this;\n    },\n\n    hideTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.hide();\n        return this;\n    },\n\n    showTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.show();\n        return this;\n    },\n\n    onToolEvent: function(event) {\n        switch (event) {\n            case 'remove':\n                this.removeTools();\n                break;\n            case 'hide':\n                this.hideTools();\n                break;\n            case 'show':\n                this.showTools();\n                break;\n        }\n    },\n\n    removeHighlighters: function() {\n        HighlighterView.remove(this);\n    },\n\n    updateHighlighters: function(dirty = false) {\n        HighlighterView.update(this, null, dirty);\n    },\n\n    transformHighlighters: function() {\n        HighlighterView.transform(this);\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    preventDefaultInteraction(evt) {\n        this.eventData(evt, { defaultInteractionPrevented: true  });\n    },\n\n    isDefaultInteractionPrevented(evt) {\n        const { defaultInteractionPrevented = false } = this.eventData(evt);\n        return defaultInteractionPrevented;\n    },\n\n    // Interaction is handled by the paper and delegated to the view in interest.\n    // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n    // If necessary, real coordinates can be obtained from the `evt` event object.\n\n    // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,\n    // i.e. `joint.dia.Element` and `joint.dia.Link`.\n\n    pointerdblclick: function(evt, x, y) {\n\n        this.notify('cell:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        this.notify('cell:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        this.notify('cell:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        const { model } = this;\n        const { graph } = model;\n        if (graph) {\n            model.startBatch('pointer');\n            this.eventData(evt, { graph });\n        }\n\n        this.notify('cell:pointerdown', evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        this.notify('cell:pointermove', evt, x, y);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        const { graph } = this.eventData(evt);\n\n        this.notify('cell:pointerup', evt, x, y);\n\n        if (graph) {\n            // we don't want to trigger event on model as model doesn't\n            // need to be member of collection anymore (remove)\n            graph.stopBatch('pointer', { cell: this.model });\n        }\n    },\n\n    mouseover: function(evt) {\n\n        this.notify('cell:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        this.notify('cell:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        this.notify('cell:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        this.notify('cell:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        this.notify('cell:mousewheel', evt, x, y, delta);\n    },\n\n    onevent: function(evt, eventName, x, y) {\n\n        this.notify(eventName, evt, x, y);\n    },\n\n    onmagnet: function() {\n\n        // noop\n    },\n\n    magnetpointerdblclick: function() {\n\n        // noop\n    },\n\n    magnetcontextmenu: function() {\n\n        // noop\n    },\n\n    checkMouseleave(evt) {\n        const { paper, model } = this;\n        if (paper.isAsync()) {\n            // Make sure the source/target views are updated before this view.\n            // It's not 100% bulletproof (see below) but it's a good enough solution for now.\n            // The connected cells could be links as well. In that case, we would\n            // need to recursively go through all the connected links and update\n            // their source/target views as well.\n            if (model.isLink()) {\n                // The `this.sourceView` and `this.targetView` might not be updated yet.\n                // We need to find the view by the model.\n                const sourceElement = model.getSourceElement();\n                if (sourceElement) {\n                    const sourceView = paper.findViewByModel(sourceElement);\n                    if (sourceView) {\n                        paper.dumpView(sourceView);\n                        paper.checkViewVisibility(sourceView);\n                    }\n                }\n                const targetElement = model.getTargetElement();\n                if (targetElement) {\n                    const targetView = paper.findViewByModel(targetElement);\n                    if (targetView) {\n                        paper.dumpView(targetView);\n                        paper.checkViewVisibility(targetView);\n                    }\n                }\n            }\n            // Do the updates of the current view synchronously now\n            paper.dumpView(this);\n            paper.checkViewVisibility(this);\n        }\n        const target = this.getEventTarget(evt, { fromPoint: true });\n        const view = paper.findView(target);\n        if (view === this) return;\n        // Leaving the current view\n        this.mouseleave(evt);\n        if (!view) return;\n        // Entering another view\n        view.mouseenter(evt);\n    },\n\n    setInteractivity: function(value) {\n\n        this.options.interactive = value;\n    }\n}, {\n\n    Flags,\n\n    Highlighting: HighlightingTypes,\n\n    addPresentationAttributes: function(presentationAttributes) {\n        return merge({}, result(this.prototype, 'presentationAttributes'), presentationAttributes, function(a, b) {\n            if (!a || !b) return;\n            if (typeof a === 'string') a = [a];\n            if (typeof b === 'string') b = [b];\n            if (Array.isArray(a) && Array.isArray(b)) return uniq(a.concat(b));\n        });\n    },\n\n    evalAttribute,\n\n});\n\n\nObject.defineProperty(CellView.prototype, 'useCSSSelectors', {\n    get() {\n        const localUse = this.model.useCSSSelectors;\n        if (localUse !== undefined) return localUse;\n        return config.useCSSSelectors;\n    }\n});\n\n// TODO: Move to Vectorizer library.\nfunction getCommonAncestorNode(node1, node2) {\n    let parent = node1;\n    do {\n        if (parent.contains(node2)) return parent;\n        parent = parent.parentNode;\n    } while (parent);\n    return null;\n}\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}