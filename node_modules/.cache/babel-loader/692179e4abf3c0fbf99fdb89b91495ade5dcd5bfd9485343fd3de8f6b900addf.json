{"ast":null,"code":"import { isEmpty, uniqueId } from '../util/util.mjs';\n\n// Events\n// ---------------\n\n// A module that can be mixed in to *any object* in order to provide it with\n// a custom event channel. You may bind a callback to an event with `on` or\n// remove with `off`; `trigger`-ing an event fires all callbacks in\n// succession.\n//\n//     const object = {};\n//     assign(object, Events);\n//     object.on('expand', function(){ alert('expanded'); });\n//     object.trigger('expand');\n//\nexport var Events = {};\n\n// Regular expression used to split event strings.\nvar eventSplitter = /\\s+/;\n\n// A private global variable to share between listeners and listenees.\nvar _listening;\n\n// Iterates over the standard `event, callback` (as well as the fancy multiple\n// space-separated events `\"change blur\", callback` and jQuery-style event\n// maps `{event: callback}`).\nvar eventsApi = function (iteratee, events, name, callback, opts) {\n  var i = 0,\n    names;\n  if (name && typeof name === 'object') {\n    // Handle event maps.\n    if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;\n    for (names = Object.keys(name); i < names.length; i++) {\n      events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n    }\n  } else if (name && eventSplitter.test(name)) {\n    // Handle space-separated event names by delegating them individually.\n    for (names = name.split(eventSplitter); i < names.length; i++) {\n      events = iteratee(events, names[i], callback, opts);\n    }\n  } else {\n    // Finally, standard events.\n    events = iteratee(events, name, callback, opts);\n  }\n  return events;\n};\n\n// Bind an event to a `callback` function. Passing `\"all\"` will bind\n// the callback to all events fired.\nEvents.on = function (name, callback, context) {\n  this._events = eventsApi(onApi, this._events || {}, name, callback, {\n    context: context,\n    ctx: this,\n    listening: _listening\n  });\n  if (_listening) {\n    var listeners = this._listeners || (this._listeners = {});\n    listeners[_listening.id] = _listening;\n    // Allow the listening to use a counter, instead of tracking\n    // callbacks for library interop\n    _listening.interop = false;\n  }\n  return this;\n};\n\n// Inversion-of-control versions of `on`. Tell *this* object to listen to\n// an event in another object... keeping track of what it's listening to\n// for easier unbinding later.\nEvents.listenTo = function (obj, name, callback) {\n  if (!obj) return this;\n  var id = obj._listenId || (obj._listenId = uniqueId('l'));\n  var listeningTo = this._listeningTo || (this._listeningTo = {});\n  var listening = _listening = listeningTo[id];\n\n  // This object is not listening to any other events on `obj` yet.\n  // Setup the necessary references to track the listening callbacks.\n  if (!listening) {\n    this._listenId || (this._listenId = uniqueId('l'));\n    listening = _listening = listeningTo[id] = new Listening(this, obj);\n  }\n\n  // Bind callbacks on obj.\n  var error = tryCatchOn(obj, name, callback, this);\n  _listening = void 0;\n  if (error) throw error;\n  // If the target obj is not Events, track events manually.\n  if (listening.interop) listening.on(name, callback);\n  return this;\n};\n\n// The reducing API that adds a callback to the `events` object.\nvar onApi = function (events, name, callback, options) {\n  if (callback) {\n    var handlers = events[name] || (events[name] = []);\n    var context = options.context,\n      ctx = options.ctx,\n      listening = options.listening;\n    if (listening) listening.count++;\n    handlers.push({\n      callback: callback,\n      context: context,\n      ctx: context || ctx,\n      listening: listening\n    });\n  }\n  return events;\n};\n\n// An try-catch guarded #on function, to prevent poisoning the global\n// `_listening` variable.\nvar tryCatchOn = function (obj, name, callback, context) {\n  try {\n    obj.on(name, callback, context);\n  } catch (e) {\n    return e;\n  }\n};\n\n// Remove one or many callbacks. If `context` is null, removes all\n// callbacks with that function. If `callback` is null, removes all\n// callbacks for the event. If `name` is null, removes all bound\n// callbacks for all events.\nEvents.off = function (name, callback, context) {\n  if (!this._events) return this;\n  this._events = eventsApi(offApi, this._events, name, callback, {\n    context: context,\n    listeners: this._listeners\n  });\n  return this;\n};\n\n// Tell this object to stop listening to either specific events ... or\n// to every object it's currently listening to.\nEvents.stopListening = function (obj, name, callback) {\n  var listeningTo = this._listeningTo;\n  if (!listeningTo) return this;\n  var ids = obj ? [obj._listenId] : Object.keys(listeningTo);\n  for (var i = 0; i < ids.length; i++) {\n    var listening = listeningTo[ids[i]];\n\n    // If listening doesn't exist, this object is not currently\n    // listening to obj. Break out early.\n    if (!listening) break;\n    listening.obj.off(name, callback, this);\n    if (listening.interop) listening.off(name, callback);\n  }\n  if (isEmpty(listeningTo)) this._listeningTo = void 0;\n  return this;\n};\n\n// The reducing API that removes a callback from the `events` object.\nvar offApi = function (events, name, callback, options) {\n  if (!events) return;\n  var context = options.context,\n    listeners = options.listeners;\n  var i = 0,\n    names;\n\n  // Delete all event listeners and \"drop\" events.\n  if (!name && !context && !callback) {\n    if (listeners != null) {\n      for (names = Object.keys(listeners); i < names.length; i++) {\n        listeners[names[i]].cleanup();\n      }\n    }\n    return;\n  }\n  names = name ? [name] : Object.keys(events);\n  for (; i < names.length; i++) {\n    name = names[i];\n    var handlers = events[name];\n\n    // Bail out if there are no events stored.\n    if (!handlers) break;\n\n    // Find any remaining events.\n    var remaining = [];\n    for (var j = 0; j < handlers.length; j++) {\n      var handler = handlers[j];\n      if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {\n        remaining.push(handler);\n      } else {\n        var listening = handler.listening;\n        if (listening) listening.off(name, callback);\n      }\n    }\n\n    // Replace events if there are any remaining.  Otherwise, clean up.\n    if (remaining.length) {\n      events[name] = remaining;\n    } else {\n      delete events[name];\n    }\n  }\n  return events;\n};\n\n// Bind an event to only be triggered a single time. After the first time\n// the callback is invoked, its listener will be removed. If multiple events\n// are passed in using the space-separated syntax, the handler will fire\n// once for each event, not once for a combination of all events.\nEvents.once = function (name, callback, context) {\n  // Map the event into a `{event: once}` object.\n  var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));\n  if (typeof name === 'string' && context == null) callback = void 0;\n  return this.on(events, callback, context);\n};\n\n// Inversion-of-control versions of `once`.\nEvents.listenToOnce = function (obj, name, callback) {\n  // Map the event into a `{event: once}` object.\n  var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));\n  return this.listenTo(obj, events);\n};\n\n// Reduces the event callbacks into a map of `{event: onceWrapper}`.\n// `offer` unbinds the `onceWrapper` after it has been called.\nvar onceMap = function (map, name, callback, offer) {\n  if (callback) {\n    var once = map[name] = onceInvoke(function () {\n      offer(name, once);\n      callback.apply(this, arguments);\n    });\n    once._callback = callback;\n  }\n  return map;\n};\n\n// Creates a function that is restricted to invoking 'func' once.\n// Repeat calls to the function return the value of the first invocation.\nvar onceInvoke = function (func) {\n  var result;\n  if (typeof func != 'function') {\n    throw new TypeError('Expected a function');\n  }\n  var n = 2;\n  return function () {\n    if (--n > 0) {\n      result = func.apply(this, arguments);\n    }\n    if (n <= 1) {\n      func = undefined;\n    }\n    return result;\n  };\n};\n\n// Trigger one or many events, firing all bound callbacks. Callbacks are\n// passed the same arguments as `trigger` is, apart from the event name\n// (unless you're listening on `\"all\"`, which will cause your callback to\n// receive the true name of the event as the first argument).\nEvents.trigger = function (name) {\n  if (!this._events) return this;\n  var length = Math.max(0, arguments.length - 1);\n  var args = Array(length);\n  for (var i = 0; i < length; i++) args[i] = arguments[i + 1];\n  eventsApi(triggerApi, this._events, name, void 0, args);\n  return this;\n};\n\n// Handles triggering the appropriate event callbacks.\nvar triggerApi = function (objEvents, name, callback, args) {\n  if (objEvents) {\n    var events = objEvents[name];\n    var allEvents = objEvents.all;\n    if (events && allEvents) allEvents = allEvents.slice();\n    if (events) triggerEvents(events, args);\n    if (allEvents) triggerEvents(allEvents, [name].concat(args));\n  }\n  return objEvents;\n};\n\n// A difficult-to-believe, but optimized internal dispatch function for\n// triggering events. Tries to keep the usual cases speedy (most internal\n// events have 3 arguments).\nvar triggerEvents = function (events, args) {\n  var ev,\n    i = -1,\n    l = events.length,\n    a1 = args[0],\n    a2 = args[1],\n    a3 = args[2];\n  switch (args.length) {\n    case 0:\n      while (++i < l) (ev = events[i]).callback.call(ev.ctx);\n      return;\n    case 1:\n      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);\n      return;\n    case 2:\n      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);\n      return;\n    case 3:\n      while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n      return;\n    default:\n      while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);\n      return;\n  }\n};\n\n// A listening class that tracks and cleans up memory bindings\n// when all callbacks have been offed.\nvar Listening = function (listener, obj) {\n  this.id = listener._listenId;\n  this.listener = listener;\n  this.obj = obj;\n  this.interop = true;\n  this.count = 0;\n  this._events = void 0;\n};\nListening.prototype.on = Events.on;\n\n// Offs a callback (or several).\n// Uses an optimized counter if the listenee uses Events.\n// Otherwise, falls back to manual tracking to support events\n// library interop.\nListening.prototype.off = function (name, callback) {\n  var cleanup;\n  if (this.interop) {\n    this._events = eventsApi(offApi, this._events, name, callback, {\n      context: void 0,\n      listeners: void 0\n    });\n    cleanup = !this._events;\n  } else {\n    this.count--;\n    cleanup = this.count === 0;\n  }\n  if (cleanup) this.cleanup();\n};\n\n// Cleans up memory bindings between the listener and the listenee.\nListening.prototype.cleanup = function () {\n  delete this.listener._listeningTo[this.obj._listenId];\n  if (!this.interop) delete this.obj._listeners[this.id];\n};\n\n// Aliases for backwards compatibility.\nEvents.bind = Events.on;\nEvents.unbind = Events.off;","map":{"version":3,"names":["isEmpty","uniqueId","Events","eventSplitter","_listening","eventsApi","iteratee","events","name","callback","opts","i","names","context","Object","keys","length","test","split","on","_events","onApi","ctx","listening","listeners","_listeners","id","interop","listenTo","obj","_listenId","listeningTo","_listeningTo","Listening","error","tryCatchOn","options","handlers","count","push","e","off","offApi","stopListening","ids","cleanup","remaining","j","handler","_callback","once","onceMap","bind","listenToOnce","map","offer","onceInvoke","apply","arguments","func","result","TypeError","n","undefined","trigger","Math","max","args","Array","triggerApi","objEvents","allEvents","all","slice","triggerEvents","concat","ev","l","a1","a2","a3","call","listener","prototype","unbind"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/mvc/Events.mjs"],"sourcesContent":["import {\n    isEmpty,\n    uniqueId \n} from '../util/util.mjs';\n\n// Events\n// ---------------\n\n// A module that can be mixed in to *any object* in order to provide it with\n// a custom event channel. You may bind a callback to an event with `on` or\n// remove with `off`; `trigger`-ing an event fires all callbacks in\n// succession.\n//\n//     const object = {};\n//     assign(object, Events);\n//     object.on('expand', function(){ alert('expanded'); });\n//     object.trigger('expand');\n//\nexport var Events = {};\n\n// Regular expression used to split event strings.\nvar eventSplitter = /\\s+/;\n\n// A private global variable to share between listeners and listenees.\nvar _listening;\n\n// Iterates over the standard `event, callback` (as well as the fancy multiple\n// space-separated events `\"change blur\", callback` and jQuery-style event\n// maps `{event: callback}`).\nvar eventsApi = function(iteratee, events, name, callback, opts) {\n    var i = 0, names;\n    if (name && typeof name === 'object') {\n    // Handle event maps.\n        if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;\n        for (names = Object.keys(name); i < names.length ; i++) {\n            events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n        }\n    } else if (name && eventSplitter.test(name)) {\n    // Handle space-separated event names by delegating them individually.\n        for (names = name.split(eventSplitter); i < names.length; i++) {\n            events = iteratee(events, names[i], callback, opts);\n        }\n    } else {\n    // Finally, standard events.\n        events = iteratee(events, name, callback, opts);\n    }\n    return events;\n};\n\n// Bind an event to a `callback` function. Passing `\"all\"` will bind\n// the callback to all events fired.\nEvents.on = function(name, callback, context) {\n    this._events = eventsApi(onApi, this._events || {}, name, callback, {\n        context: context,\n        ctx: this,\n        listening: _listening\n    });\n\n    if (_listening) {\n        var listeners = this._listeners || (this._listeners = {});\n        listeners[_listening.id] = _listening;\n        // Allow the listening to use a counter, instead of tracking\n        // callbacks for library interop\n        _listening.interop = false;\n    }\n\n    return this;\n};\n\n// Inversion-of-control versions of `on`. Tell *this* object to listen to\n// an event in another object... keeping track of what it's listening to\n// for easier unbinding later.\nEvents.listenTo = function(obj, name, callback) {\n    if (!obj) return this;\n    var id = obj._listenId || (obj._listenId = uniqueId('l'));\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var listening = _listening = listeningTo[id];\n\n    // This object is not listening to any other events on `obj` yet.\n    // Setup the necessary references to track the listening callbacks.\n    if (!listening) {\n        this._listenId || (this._listenId = uniqueId('l'));\n        listening = _listening = listeningTo[id] = new Listening(this, obj);\n    }\n\n    // Bind callbacks on obj.\n    var error = tryCatchOn(obj, name, callback, this);\n    _listening = void 0;\n\n    if (error) throw error;\n    // If the target obj is not Events, track events manually.\n    if (listening.interop) listening.on(name, callback);\n\n    return this;\n};\n\n// The reducing API that adds a callback to the `events` object.\nvar onApi = function(events, name, callback, options) {\n    if (callback) {\n        var handlers = events[name] || (events[name] = []);\n        var context = options.context, ctx = options.ctx, listening = options.listening;\n        if (listening) listening.count++;\n\n        handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });\n    }\n    return events;\n};\n\n// An try-catch guarded #on function, to prevent poisoning the global\n// `_listening` variable.\nvar tryCatchOn = function(obj, name, callback, context) {\n    try {\n        obj.on(name, callback, context);\n    } catch (e) {\n        return e;\n    }\n};\n\n// Remove one or many callbacks. If `context` is null, removes all\n// callbacks with that function. If `callback` is null, removes all\n// callbacks for the event. If `name` is null, removes all bound\n// callbacks for all events.\nEvents.off = function(name, callback, context) {\n    if (!this._events) return this;\n    this._events = eventsApi(offApi, this._events, name, callback, {\n        context: context,\n        listeners: this._listeners\n    });\n\n    return this;\n};\n\n// Tell this object to stop listening to either specific events ... or\n// to every object it's currently listening to.\nEvents.stopListening = function(obj, name, callback) {\n    var listeningTo = this._listeningTo;\n    if (!listeningTo) return this;\n\n    var ids = obj ? [obj._listenId] : Object.keys(listeningTo);\n    for (var i = 0; i < ids.length; i++) {\n        var listening = listeningTo[ids[i]];\n\n        // If listening doesn't exist, this object is not currently\n        // listening to obj. Break out early.\n        if (!listening) break;\n\n        listening.obj.off(name, callback, this);\n        if (listening.interop) listening.off(name, callback);\n    }\n    if (isEmpty(listeningTo)) this._listeningTo = void 0;\n\n    return this;\n};\n\n// The reducing API that removes a callback from the `events` object.\nvar offApi = function(events, name, callback, options) {\n    if (!events) return;\n\n    var context = options.context, listeners = options.listeners;\n    var i = 0, names;\n\n    // Delete all event listeners and \"drop\" events.\n    if (!name && !context && !callback) {\n        if(listeners != null) {\n            for (names = Object.keys(listeners); i < names.length; i++) {\n                listeners[names[i]].cleanup();\n            }\n        }\n        return;\n    }\n    names = name ? [name] : Object.keys(events);\n    for (; i < names.length; i++) {\n        name = names[i];\n        var handlers = events[name];\n\n        // Bail out if there are no events stored.\n        if (!handlers) break;\n\n        // Find any remaining events.\n        var remaining = [];\n        for (var j = 0; j < handlers.length; j++) {\n            var handler = handlers[j];\n            if (\n                callback && callback !== handler.callback &&\n        callback !== handler.callback._callback ||\n          context && context !== handler.context\n            ) {\n                remaining.push(handler);\n            } else {\n                var listening = handler.listening;\n                if (listening) listening.off(name, callback);\n            }\n        }\n\n        // Replace events if there are any remaining.  Otherwise, clean up.\n        if (remaining.length) {\n            events[name] = remaining;\n        } else {\n            delete events[name];\n        }\n    }\n\n    return events;\n};\n\n// Bind an event to only be triggered a single time. After the first time\n// the callback is invoked, its listener will be removed. If multiple events\n// are passed in using the space-separated syntax, the handler will fire\n// once for each event, not once for a combination of all events.\nEvents.once = function(name, callback, context) {\n// Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));\n    if (typeof name === 'string' && context == null) callback = void 0;\n    return this.on(events, callback, context);\n};\n\n// Inversion-of-control versions of `once`.\nEvents.listenToOnce = function(obj, name, callback) {\n// Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));\n    return this.listenTo(obj, events);\n};\n\n// Reduces the event callbacks into a map of `{event: onceWrapper}`.\n// `offer` unbinds the `onceWrapper` after it has been called.\nvar onceMap = function(map, name, callback, offer) {\n    if (callback) {\n        var once = map[name] = onceInvoke(function() {\n            offer(name, once);\n            callback.apply(this, arguments);\n        });\n        once._callback = callback;\n    }\n    return map;\n};\n\n// Creates a function that is restricted to invoking 'func' once.\n// Repeat calls to the function return the value of the first invocation.\nvar onceInvoke = function(func) {\n    var result;\n    if (typeof func != 'function') {\n        throw new TypeError('Expected a function');\n    }\n    var n = 2;\n    return function() {\n        if (--n > 0) {\n            result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n            func = undefined;\n        }\n        return result;\n    };\n};\n\n// Trigger one or many events, firing all bound callbacks. Callbacks are\n// passed the same arguments as `trigger` is, apart from the event name\n// (unless you're listening on `\"all\"`, which will cause your callback to\n// receive the true name of the event as the first argument).\nEvents.trigger = function(name) {\n    if (!this._events) return this;\n\n    var length = Math.max(0, arguments.length - 1);\n    var args = Array(length);\n    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];\n\n    eventsApi(triggerApi, this._events, name, void 0, args);\n    return this;\n};\n\n// Handles triggering the appropriate event callbacks.\nvar triggerApi = function(objEvents, name, callback, args) {\n    if (objEvents) {\n        var events = objEvents[name];\n        var allEvents = objEvents.all;\n        if (events && allEvents) allEvents = allEvents.slice();\n        if (events) triggerEvents(events, args);\n        if (allEvents) triggerEvents(allEvents, [name].concat(args));\n    }\n    return objEvents;\n};\n\n// A difficult-to-believe, but optimized internal dispatch function for\n// triggering events. Tries to keep the usual cases speedy (most internal\n// events have 3 arguments).\nvar triggerEvents = function(events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n        case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n        case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n        case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n        case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n        default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;\n    }\n};\n\n// A listening class that tracks and cleans up memory bindings\n// when all callbacks have been offed.\nvar Listening = function(listener, obj) {\n    this.id = listener._listenId;\n    this.listener = listener;\n    this.obj = obj;\n    this.interop = true;\n    this.count = 0;\n    this._events = void 0;\n};\n\nListening.prototype.on = Events.on;\n\n// Offs a callback (or several).\n// Uses an optimized counter if the listenee uses Events.\n// Otherwise, falls back to manual tracking to support events\n// library interop.\nListening.prototype.off = function(name, callback) {\n    var cleanup;\n    if (this.interop) {\n        this._events = eventsApi(offApi, this._events, name, callback, {\n            context: void 0,\n            listeners: void 0\n        });\n        cleanup = !this._events;\n    } else {\n        this.count--;\n        cleanup = this.count === 0;\n    }\n    if (cleanup) this.cleanup();\n};\n\n// Cleans up memory bindings between the listener and the listenee.\nListening.prototype.cleanup = function() {\n    delete this.listener._listeningTo[this.obj._listenId];\n    if (!this.interop) delete this.obj._listeners[this.id];\n};\n\n// Aliases for backwards compatibility.\nEvents.bind   = Events.on;\nEvents.unbind = Events.off;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}