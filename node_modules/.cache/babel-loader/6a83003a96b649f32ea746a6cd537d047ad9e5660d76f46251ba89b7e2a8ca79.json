{"ast":null,"code":"import { assign, isFunction, toArray } from '../util/index.mjs';\nimport { CellView } from './CellView.mjs';\nimport { Cell } from './Cell.mjs';\nimport V from '../V/index.mjs';\nimport { elementViewPortPrototype } from './ports.mjs';\nimport { Rect, snapToGrid } from '../g/index.mjs';\nconst Flags = {\n  TOOLS: CellView.Flags.TOOLS,\n  UPDATE: 'UPDATE',\n  TRANSLATE: 'TRANSLATE',\n  RESIZE: 'RESIZE',\n  PORTS: 'PORTS',\n  ROTATE: 'ROTATE',\n  RENDER: 'RENDER'\n};\nconst DragActions = {\n  MOVE: 'move',\n  MAGNET: 'magnet'\n};\n// Element base view and controller.\n// -------------------------------------------\n\nexport const ElementView = CellView.extend({\n  /**\n   * @abstract\n   */\n  _removePorts: function () {\n    // implemented in ports.js\n  },\n  /**\n   *\n   * @abstract\n   */\n  _renderPorts: function () {\n    // implemented in ports.js\n  },\n  className: function () {\n    var classNames = CellView.prototype.className.apply(this).split(' ');\n    classNames.push('element');\n    return classNames.join(' ');\n  },\n  initialize: function () {\n    CellView.prototype.initialize.apply(this, arguments);\n    this._initializePorts();\n  },\n  presentationAttributes: {\n    'attrs': [Flags.UPDATE],\n    'position': [Flags.TRANSLATE, Flags.TOOLS],\n    'size': [Flags.RESIZE, Flags.PORTS, Flags.TOOLS],\n    'angle': [Flags.ROTATE, Flags.TOOLS],\n    'markup': [Flags.RENDER],\n    'ports': [Flags.PORTS]\n  },\n  initFlag: [Flags.RENDER],\n  UPDATE_PRIORITY: 0,\n  confirmUpdate: function (flag, opt) {\n    const {\n      useCSSSelectors\n    } = this;\n    if (this.hasFlag(flag, Flags.PORTS)) {\n      this._removePorts();\n      this._cleanPortsCache();\n    }\n    let transformHighlighters = false;\n    if (this.hasFlag(flag, Flags.RENDER)) {\n      this.render();\n      this.updateTools(opt);\n      this.updateHighlighters(true);\n      transformHighlighters = true;\n      flag = this.removeFlag(flag, [Flags.RENDER, Flags.UPDATE, Flags.RESIZE, Flags.TRANSLATE, Flags.ROTATE, Flags.PORTS, Flags.TOOLS]);\n    } else {\n      let updateHighlighters = false;\n\n      // Skip this branch if render is required\n      if (this.hasFlag(flag, Flags.RESIZE)) {\n        this.resize(opt);\n        updateHighlighters = true;\n        // Resize method is calling `update()` internally\n        flag = this.removeFlag(flag, [Flags.RESIZE, Flags.UPDATE]);\n        if (useCSSSelectors) {\n          // `resize()` rendered the ports when useCSSSelectors are enabled\n          flag = this.removeFlag(flag, Flags.PORTS);\n        }\n      }\n      if (this.hasFlag(flag, Flags.UPDATE)) {\n        this.update(this.model, null, opt);\n        flag = this.removeFlag(flag, Flags.UPDATE);\n        updateHighlighters = true;\n        if (useCSSSelectors) {\n          // `update()` will render ports when useCSSSelectors are enabled\n          flag = this.removeFlag(flag, Flags.PORTS);\n        }\n      }\n      if (this.hasFlag(flag, Flags.TRANSLATE)) {\n        this.translate();\n        flag = this.removeFlag(flag, Flags.TRANSLATE);\n        transformHighlighters = true;\n      }\n      if (this.hasFlag(flag, Flags.ROTATE)) {\n        this.rotate();\n        flag = this.removeFlag(flag, Flags.ROTATE);\n        transformHighlighters = true;\n      }\n      if (this.hasFlag(flag, Flags.PORTS)) {\n        this._renderPorts();\n        updateHighlighters = true;\n        flag = this.removeFlag(flag, Flags.PORTS);\n      }\n      if (updateHighlighters) {\n        this.updateHighlighters(false);\n      }\n    }\n    if (transformHighlighters) {\n      this.transformHighlighters();\n    }\n    if (this.hasFlag(flag, Flags.TOOLS)) {\n      this.updateTools(opt);\n      flag = this.removeFlag(flag, Flags.TOOLS);\n    }\n    return flag;\n  },\n  /**\n   * @abstract\n   */\n  _initializePorts: function () {},\n  update: function (_, renderingOnlyAttrs) {\n    this.cleanNodesCache();\n\n    // When CSS selector strings are used, make sure no rule matches port nodes.\n    const {\n      useCSSSelectors\n    } = this;\n    if (useCSSSelectors) this._removePorts();\n    var model = this.model;\n    var modelAttrs = model.attr();\n    this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n      rootBBox: new Rect(model.size()),\n      selectors: this.selectors,\n      scalableNode: this.scalableNode,\n      rotatableNode: this.rotatableNode,\n      // Use rendering only attributes if they differs from the model attributes\n      roAttributes: renderingOnlyAttrs === modelAttrs ? null : renderingOnlyAttrs\n    });\n    if (useCSSSelectors) {\n      this._renderPorts();\n    }\n  },\n  rotatableSelector: 'rotatable',\n  scalableSelector: 'scalable',\n  scalableNode: null,\n  rotatableNode: null,\n  // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n  // default markup is not desirable.\n  renderMarkup: function () {\n    var element = this.model;\n    var markup = element.get('markup') || element.markup;\n    if (!markup) throw new Error('dia.ElementView: markup required');\n    if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n    if (typeof markup === 'string') return this.renderStringMarkup(markup);\n    throw new Error('dia.ElementView: invalid markup');\n  },\n  renderJSONMarkup: function (markup) {\n    var doc = this.parseDOMJSON(markup, this.el);\n    var selectors = this.selectors = doc.selectors;\n    this.rotatableNode = V(selectors[this.rotatableSelector]) || null;\n    this.scalableNode = V(selectors[this.scalableSelector]) || null;\n    // Fragment\n    this.vel.append(doc.fragment);\n  },\n  renderStringMarkup: function (markup) {\n    var vel = this.vel;\n    vel.append(V(markup));\n    // Cache transformation groups\n    this.rotatableNode = vel.findOne('.rotatable');\n    this.scalableNode = vel.findOne('.scalable');\n    var selectors = this.selectors = {};\n    selectors[this.selector] = this.el;\n  },\n  render: function () {\n    this.vel.empty();\n    this.renderMarkup();\n    if (this.scalableNode) {\n      // Double update is necessary for elements with the scalable group only\n      // Note the resize() triggers the other `update`.\n      this.update();\n    }\n    this.resize();\n    if (this.rotatableNode) {\n      // Translate transformation is applied on `this.el` while the rotation transformation\n      // on `this.rotatableNode`\n      this.rotate();\n      this.translate();\n    } else {\n      this.updateTransformation();\n    }\n    if (!this.useCSSSelectors) this._renderPorts();\n    return this;\n  },\n  resize: function (opt) {\n    if (this.scalableNode) return this.sgResize(opt);\n    if (this.model.attributes.angle) this.rotate();\n    this.update();\n  },\n  translate: function () {\n    if (this.rotatableNode) return this.rgTranslate();\n    this.updateTransformation();\n  },\n  rotate: function () {\n    if (this.rotatableNode) {\n      this.rgRotate();\n      // It's necessary to call the update for the nodes outside\n      // the rotatable group referencing nodes inside the group\n      this.update();\n      return;\n    }\n    this.updateTransformation();\n  },\n  updateTransformation: function () {\n    var transformation = this.getTranslateString();\n    var rotateString = this.getRotateString();\n    if (rotateString) transformation += ' ' + rotateString;\n    this.vel.attr('transform', transformation);\n  },\n  getTranslateString: function () {\n    var position = this.model.attributes.position;\n    return 'translate(' + position.x + ',' + position.y + ')';\n  },\n  getRotateString: function () {\n    var attributes = this.model.attributes;\n    var angle = attributes.angle;\n    if (!angle) return null;\n    var size = attributes.size;\n    return 'rotate(' + angle + ',' + size.width / 2 + ',' + size.height / 2 + ')';\n  },\n  // Rotatable & Scalable Group\n  // always slower, kept mainly for backwards compatibility\n\n  rgRotate: function () {\n    this.rotatableNode.attr('transform', this.getRotateString());\n  },\n  rgTranslate: function () {\n    this.vel.attr('transform', this.getTranslateString());\n  },\n  sgResize: function (opt) {\n    var model = this.model;\n    var angle = model.angle();\n    var size = model.size();\n    var scalable = this.scalableNode;\n\n    // Getting scalable group's bbox.\n    // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n    // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n    var recursive = false;\n    if (scalable.node.getElementsByTagName('path').length > 0) {\n      // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n      // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n      recursive = true;\n    }\n    var scalableBBox = scalable.getBBox({\n      recursive: recursive\n    });\n\n    // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n    // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n    var sx = size.width / (scalableBBox.width || 1);\n    var sy = size.height / (scalableBBox.height || 1);\n    scalable.attr('transform', 'scale(' + sx + ',' + sy + ')');\n\n    // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n    // Order of transformations is significant but we want to reconstruct the object always in the order:\n    // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n    // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n    // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n    // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n    // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n\n    // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n    var rotatable = this.rotatableNode;\n    var rotation = rotatable && rotatable.attr('transform');\n    if (rotation) {\n      rotatable.attr('transform', rotation + ' rotate(' + -angle + ',' + size.width / 2 + ',' + size.height / 2 + ')');\n      var rotatableBBox = scalable.getBBox({\n        target: this.paper.cells\n      });\n\n      // Store new x, y and perform rotate() again against the new rotation origin.\n      model.set('position', {\n        x: rotatableBBox.x,\n        y: rotatableBBox.y\n      }, assign({\n        updateHandled: true\n      }, opt));\n      this.translate();\n      this.rotate();\n    }\n\n    // Update must always be called on non-rotated element. Otherwise, relative positioning\n    // would work with wrong (rotated) bounding boxes.\n    this.update();\n  },\n  // Embedding mode methods.\n  // -----------------------\n\n  prepareEmbedding: function (data = {}) {\n    const element = data.model || this.model;\n    const paper = data.paper || this.paper;\n    const graph = paper.model;\n    const initialZIndices = data.initialZIndices = {};\n    const embeddedCells = element.getEmbeddedCells({\n      deep: true\n    });\n    const connectedLinks = graph.getConnectedLinks(element, {\n      deep: true,\n      includeEnclosed: true\n    });\n\n    // Note: an embedded cell can be a connect link, but it's fine\n    // to iterate over the cell twice.\n    [element, ...embeddedCells, ...connectedLinks].forEach(cell => initialZIndices[cell.id] = cell.attributes.z);\n    element.startBatch('to-front');\n\n    // Bring the model to the front with all his embeds.\n    element.toFront({\n      deep: true,\n      ui: true\n    });\n\n    // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n    // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n    const maxZ = graph.getElements().reduce((max, cell) => Math.max(max, cell.attributes.z || 0), 0);\n\n    // Move to front also all the inbound and outbound links that are connected\n    // to any of the element descendant. If we bring to front only embedded elements,\n    // links connected to them would stay in the background.\n    connectedLinks.forEach(link => {\n      if (link.attributes.z <= maxZ) {\n        link.set('z', maxZ + 1, {\n          ui: true\n        });\n      }\n    });\n    element.stopBatch('to-front');\n\n    // Before we start looking for suitable parent we remove the current one.\n    const parentId = element.parent();\n    if (parentId) {\n      const parent = graph.getCell(parentId);\n      parent.unembed(element, {\n        ui: true\n      });\n      data.initialParentId = parentId;\n    } else {\n      data.initialParentId = null;\n    }\n  },\n  processEmbedding: function (data = {}, evt, x, y) {\n    const model = data.model || this.model;\n    const paper = data.paper || this.paper;\n    const graph = paper.model;\n    const {\n      findParentBy,\n      frontParentOnly,\n      validateEmbedding\n    } = paper.options;\n    let candidates;\n    if (isFunction(findParentBy)) {\n      candidates = toArray(findParentBy.call(graph, this, evt, x, y));\n    } else if (findParentBy === 'pointer') {\n      candidates = toArray(graph.findModelsFromPoint({\n        x,\n        y\n      }));\n    } else {\n      candidates = graph.findModelsUnderElement(model, {\n        searchBy: findParentBy\n      });\n    }\n    candidates = candidates.filter(el => {\n      return el instanceof Cell && model.id !== el.id && !el.isEmbeddedIn(model);\n    });\n    if (frontParentOnly) {\n      // pick the element with the highest `z` index\n      candidates = candidates.slice(-1);\n    }\n    let newCandidateView = null;\n    const prevCandidateView = data.candidateEmbedView;\n\n    // iterate over all candidates starting from the last one (has the highest z-index).\n    for (let i = candidates.length - 1; i >= 0; i--) {\n      const candidate = candidates[i];\n      if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n        // candidate remains the same\n        newCandidateView = prevCandidateView;\n        break;\n      } else {\n        const view = candidate.findView(paper);\n        if (!isFunction(validateEmbedding) || validateEmbedding.call(paper, this, view)) {\n          // flip to the new candidate\n          newCandidateView = view;\n          break;\n        }\n      }\n    }\n    if (newCandidateView && newCandidateView != prevCandidateView) {\n      // A new candidate view found. Highlight the new one.\n      this.clearEmbedding(data);\n      data.candidateEmbedView = newCandidateView.highlight(newCandidateView.findProxyNode(null, 'container'), {\n        embedding: true\n      });\n    }\n    if (!newCandidateView && prevCandidateView) {\n      // No candidate view found. Unhighlight the previous candidate.\n      this.clearEmbedding(data);\n    }\n  },\n  clearEmbedding: function (data) {\n    data || (data = {});\n    var candidateView = data.candidateEmbedView;\n    if (candidateView) {\n      // No candidate view found. Unhighlight the previous candidate.\n      candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), {\n        embedding: true\n      });\n      data.candidateEmbedView = null;\n    }\n  },\n  finalizeEmbedding: function (data = {}) {\n    const candidateView = data.candidateEmbedView;\n    const element = data.model || this.model;\n    const paper = data.paper || this.paper;\n    if (candidateView) {\n      // We finished embedding. Candidate view is chosen to become the parent of the model.\n      candidateView.model.embed(element, {\n        ui: true\n      });\n      candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), {\n        embedding: true\n      });\n      data.candidateEmbedView = null;\n    } else {\n      const {\n        validateUnembedding\n      } = paper.options;\n      const {\n        initialParentId\n      } = data;\n      // The element was originally embedded into another element.\n      // The interaction would unembed the element. Let's validate\n      // if the element can be unembedded.\n      if (initialParentId && typeof validateUnembedding === 'function' && !validateUnembedding.call(paper, this)) {\n        this._disallowUnembed(data);\n        return;\n      }\n    }\n    paper.model.getConnectedLinks(element, {\n      deep: true\n    }).forEach(link => {\n      link.reparent({\n        ui: true\n      });\n    });\n  },\n  _disallowUnembed: function (data) {\n    const {\n      model,\n      whenNotAllowed = 'revert'\n    } = data;\n    const element = model || this.model;\n    const paper = data.paper || this.paper;\n    const graph = paper.model;\n    switch (whenNotAllowed) {\n      case 'remove':\n        {\n          element.remove({\n            ui: true\n          });\n          break;\n        }\n      case 'revert':\n        {\n          const {\n            initialParentId,\n            initialPosition,\n            initialZIndices\n          } = data;\n          // Revert the element's position (and the position of its embedded cells if any)\n          if (initialPosition) {\n            const {\n              x,\n              y\n            } = initialPosition;\n            element.position(x, y, {\n              deep: true,\n              ui: true\n            });\n          }\n          // Revert all the z-indices changed during the embedding\n          if (initialZIndices) {\n            Object.keys(initialZIndices).forEach(id => {\n              const cell = graph.getCell(id);\n              if (cell) {\n                cell.set('z', initialZIndices[id], {\n                  ui: true\n                });\n              }\n            });\n          }\n          // Revert the original parent\n          const parent = graph.getCell(initialParentId);\n          if (parent) {\n            parent.embed(element, {\n              ui: true\n            });\n          }\n          break;\n        }\n    }\n  },\n  getDelegatedView: function () {\n    var view = this;\n    var model = view.model;\n    var paper = view.paper;\n    while (view) {\n      if (model.isLink()) break;\n      if (!model.isEmbedded() || view.can('stopDelegation')) return view;\n      model = model.getParentCell();\n      view = paper.findViewByModel(model);\n    }\n    return null;\n  },\n  findProxyNode: function (el, type) {\n    el || (el = this.el);\n    const nodeSelector = el.getAttribute(`${type}-selector`);\n    if (nodeSelector) {\n      const port = this.findAttribute('port', el);\n      if (port) {\n        const proxyPortNode = this.findPortNode(port, nodeSelector);\n        if (proxyPortNode) return proxyPortNode;\n      } else {\n        const proxyNode = this.findNode(nodeSelector);\n        if (proxyNode) return proxyNode;\n      }\n    }\n    return el;\n  },\n  // Interaction. The controller part.\n  // ---------------------------------\n\n  notifyPointerdown(evt, x, y) {\n    CellView.prototype.pointerdown.call(this, evt, x, y);\n    this.notify('element:pointerdown', evt, x, y);\n  },\n  notifyPointermove(evt, x, y) {\n    CellView.prototype.pointermove.call(this, evt, x, y);\n    this.notify('element:pointermove', evt, x, y);\n  },\n  notifyPointerup(evt, x, y) {\n    this.notify('element:pointerup', evt, x, y);\n    CellView.prototype.pointerup.call(this, evt, x, y);\n  },\n  pointerdblclick: function (evt, x, y) {\n    CellView.prototype.pointerdblclick.apply(this, arguments);\n    this.notify('element:pointerdblclick', evt, x, y);\n  },\n  pointerclick: function (evt, x, y) {\n    CellView.prototype.pointerclick.apply(this, arguments);\n    this.notify('element:pointerclick', evt, x, y);\n  },\n  contextmenu: function (evt, x, y) {\n    CellView.prototype.contextmenu.apply(this, arguments);\n    this.notify('element:contextmenu', evt, x, y);\n  },\n  pointerdown: function (evt, x, y) {\n    this.notifyPointerdown(evt, x, y);\n    this.dragStart(evt, x, y);\n  },\n  pointermove: function (evt, x, y) {\n    const data = this.eventData(evt);\n    const {\n      targetMagnet,\n      action,\n      delegatedView\n    } = data;\n    if (targetMagnet) {\n      this.magnetpointermove(evt, targetMagnet, x, y);\n    }\n    switch (action) {\n      case DragActions.MAGNET:\n        this.dragMagnet(evt, x, y);\n        break;\n      case DragActions.MOVE:\n        (delegatedView || this).drag(evt, x, y);\n      // eslint: no-fallthrough=false\n      default:\n        if (data.preventPointerEvents) break;\n        this.notifyPointermove(evt, x, y);\n        break;\n    }\n\n    // Make sure the element view data is passed along.\n    // It could have been wiped out in the handlers above.\n    this.eventData(evt, data);\n  },\n  pointerup: function (evt, x, y) {\n    const data = this.eventData(evt);\n    const {\n      targetMagnet,\n      action,\n      delegatedView\n    } = data;\n    if (targetMagnet) {\n      this.magnetpointerup(evt, targetMagnet, x, y);\n    }\n    switch (action) {\n      case DragActions.MAGNET:\n        this.dragMagnetEnd(evt, x, y);\n        break;\n      case DragActions.MOVE:\n        (delegatedView || this).dragEnd(evt, x, y);\n      // eslint: no-fallthrough=false\n      default:\n        if (data.preventPointerEvents) break;\n        this.notifyPointerup(evt, x, y);\n    }\n    if (targetMagnet) {\n      this.magnetpointerclick(evt, targetMagnet, x, y);\n    }\n    this.checkMouseleave(evt);\n  },\n  mouseover: function (evt) {\n    CellView.prototype.mouseover.apply(this, arguments);\n    this.notify('element:mouseover', evt);\n  },\n  mouseout: function (evt) {\n    CellView.prototype.mouseout.apply(this, arguments);\n    this.notify('element:mouseout', evt);\n  },\n  mouseenter: function (evt) {\n    CellView.prototype.mouseenter.apply(this, arguments);\n    this.notify('element:mouseenter', evt);\n  },\n  mouseleave: function (evt) {\n    CellView.prototype.mouseleave.apply(this, arguments);\n    this.notify('element:mouseleave', evt);\n  },\n  mousewheel: function (evt, x, y, delta) {\n    CellView.prototype.mousewheel.apply(this, arguments);\n    this.notify('element:mousewheel', evt, x, y, delta);\n  },\n  onmagnet: function (evt, x, y) {\n    const {\n      currentTarget: targetMagnet\n    } = evt;\n    this.magnetpointerdown(evt, targetMagnet, x, y);\n    this.eventData(evt, {\n      targetMagnet\n    });\n    this.dragMagnetStart(evt, x, y);\n  },\n  magnetpointerdown: function (evt, magnet, x, y) {\n    this.notify('element:magnet:pointerdown', evt, magnet, x, y);\n  },\n  magnetpointermove: function (evt, magnet, x, y) {\n    this.notify('element:magnet:pointermove', evt, magnet, x, y);\n  },\n  magnetpointerup: function (evt, magnet, x, y) {\n    this.notify('element:magnet:pointerup', evt, magnet, x, y);\n  },\n  magnetpointerdblclick: function (evt, magnet, x, y) {\n    this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);\n  },\n  magnetcontextmenu: function (evt, magnet, x, y) {\n    this.notify('element:magnet:contextmenu', evt, magnet, x, y);\n  },\n  // Drag Start Handlers\n\n  dragStart: function (evt, x, y) {\n    if (this.isDefaultInteractionPrevented(evt)) return;\n    var view = this.getDelegatedView();\n    if (!view || !view.can('elementMove')) return;\n    this.eventData(evt, {\n      action: DragActions.MOVE,\n      delegatedView: view\n    });\n    const position = view.model.position();\n    view.eventData(evt, {\n      initialPosition: position,\n      pointerOffset: position.difference(x, y),\n      restrictedArea: this.paper.getRestrictedArea(view, x, y)\n    });\n  },\n  dragMagnetStart: function (evt, x, y) {\n    const {\n      paper\n    } = this;\n    const isPropagationAlreadyStopped = evt.isPropagationStopped();\n    if (isPropagationAlreadyStopped) {\n      // Special case when the propagation was already stopped\n      // on the `element:magnet:pointerdown` event.\n      // Do not trigger any `element:pointer*` events\n      // but still start the magnet dragging.\n      this.eventData(evt, {\n        preventPointerEvents: true\n      });\n    }\n    if (this.isDefaultInteractionPrevented(evt) || !this.can('addLinkFromMagnet')) {\n      // Stop the default action, which is to start dragging a link.\n      return;\n    }\n    const {\n      targetMagnet = evt.currentTarget\n    } = this.eventData(evt);\n    evt.stopPropagation();\n\n    // Invalid (Passive) magnet. Start dragging the element.\n    if (!paper.options.validateMagnet.call(paper, this, targetMagnet, evt)) {\n      if (isPropagationAlreadyStopped) {\n        // Do not trigger `element:pointerdown` and start element dragging\n        // if the propagation was stopped.\n        this.dragStart(evt, x, y);\n        // The `element:pointerdown` event is not triggered because\n        // of `preventPointerEvents` flag.\n      } else {\n        // We need to reset the action\n        // to `MOVE` so that the element is dragged.\n        this.pointerdown(evt, x, y);\n      }\n      return;\n    }\n\n    // Valid magnet. Start dragging a link.\n    if (paper.options.magnetThreshold <= 0) {\n      this.dragLinkStart(evt, targetMagnet, x, y);\n    }\n    this.eventData(evt, {\n      action: DragActions.MAGNET\n    });\n  },\n  // Drag Handlers\n\n  drag: function (evt, x, y) {\n    var paper = this.paper;\n    var grid = paper.options.gridSize;\n    var element = this.model;\n    var data = this.eventData(evt);\n    var {\n      pointerOffset,\n      restrictedArea,\n      embedding\n    } = data;\n\n    // Make sure the new element's position always snaps to the current grid\n    var elX = snapToGrid(x + pointerOffset.x, grid);\n    var elY = snapToGrid(y + pointerOffset.y, grid);\n    element.position(elX, elY, {\n      restrictedArea,\n      deep: true,\n      ui: true\n    });\n    if (paper.options.embeddingMode) {\n      if (!embedding) {\n        // Prepare the element for embedding only if the pointer moves.\n        // We don't want to do unnecessary action with the element\n        // if an user only clicks/dblclicks on it.\n        this.prepareEmbedding(data);\n        embedding = true;\n      }\n      this.processEmbedding(data, evt, x, y);\n    }\n    this.eventData(evt, {\n      embedding\n    });\n  },\n  dragMagnet: function (evt, x, y) {\n    this.dragLink(evt, x, y);\n  },\n  // Drag End Handlers\n\n  dragEnd: function (evt, x, y) {\n    var data = this.eventData(evt);\n    if (data.embedding) this.finalizeEmbedding(data);\n  },\n  dragMagnetEnd: function (evt, x, y) {\n    this.dragLinkEnd(evt, x, y);\n  },\n  magnetpointerclick: function (evt, magnet, x, y) {\n    var paper = this.paper;\n    if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;\n    this.notify('element:magnet:pointerclick', evt, magnet, x, y);\n  }\n}, {\n  Flags: Flags\n});\nassign(ElementView.prototype, elementViewPortPrototype);","map":{"version":3,"names":["assign","isFunction","toArray","CellView","Cell","V","elementViewPortPrototype","Rect","snapToGrid","Flags","TOOLS","UPDATE","TRANSLATE","RESIZE","PORTS","ROTATE","RENDER","DragActions","MOVE","MAGNET","ElementView","extend","_removePorts","_renderPorts","className","classNames","prototype","apply","split","push","join","initialize","arguments","_initializePorts","presentationAttributes","initFlag","UPDATE_PRIORITY","confirmUpdate","flag","opt","useCSSSelectors","hasFlag","_cleanPortsCache","transformHighlighters","render","updateTools","updateHighlighters","removeFlag","resize","update","model","translate","rotate","_","renderingOnlyAttrs","cleanNodesCache","modelAttrs","attr","updateDOMSubtreeAttributes","el","rootBBox","size","selectors","scalableNode","rotatableNode","roAttributes","rotatableSelector","scalableSelector","renderMarkup","element","markup","get","Error","Array","isArray","renderJSONMarkup","renderStringMarkup","doc","parseDOMJSON","vel","append","fragment","findOne","selector","empty","updateTransformation","sgResize","attributes","angle","rgTranslate","rgRotate","transformation","getTranslateString","rotateString","getRotateString","position","x","y","width","height","scalable","recursive","node","getElementsByTagName","length","scalableBBox","getBBox","sx","sy","rotatable","rotation","rotatableBBox","target","paper","cells","set","updateHandled","prepareEmbedding","data","graph","initialZIndices","embeddedCells","getEmbeddedCells","deep","connectedLinks","getConnectedLinks","includeEnclosed","forEach","cell","id","z","startBatch","toFront","ui","maxZ","getElements","reduce","max","Math","link","stopBatch","parentId","parent","getCell","unembed","initialParentId","processEmbedding","evt","findParentBy","frontParentOnly","validateEmbedding","options","candidates","call","findModelsFromPoint","findModelsUnderElement","searchBy","filter","isEmbeddedIn","slice","newCandidateView","prevCandidateView","candidateEmbedView","i","candidate","view","findView","clearEmbedding","highlight","findProxyNode","embedding","candidateView","unhighlight","finalizeEmbedding","embed","validateUnembedding","_disallowUnembed","reparent","whenNotAllowed","remove","initialPosition","Object","keys","getDelegatedView","isLink","isEmbedded","can","getParentCell","findViewByModel","type","nodeSelector","getAttribute","port","findAttribute","proxyPortNode","findPortNode","proxyNode","findNode","notifyPointerdown","pointerdown","notify","notifyPointermove","pointermove","notifyPointerup","pointerup","pointerdblclick","pointerclick","contextmenu","dragStart","eventData","targetMagnet","action","delegatedView","magnetpointermove","dragMagnet","drag","preventPointerEvents","magnetpointerup","dragMagnetEnd","dragEnd","magnetpointerclick","checkMouseleave","mouseover","mouseout","mouseenter","mouseleave","mousewheel","delta","onmagnet","currentTarget","magnetpointerdown","dragMagnetStart","magnet","magnetpointerdblclick","magnetcontextmenu","isDefaultInteractionPrevented","pointerOffset","difference","restrictedArea","getRestrictedArea","isPropagationAlreadyStopped","isPropagationStopped","stopPropagation","validateMagnet","magnetThreshold","dragLinkStart","grid","gridSize","elX","elY","embeddingMode","dragLink","dragLinkEnd","mousemoved","clickThreshold"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/dia/ElementView.mjs"],"sourcesContent":["import { assign, isFunction, toArray } from '../util/index.mjs';\nimport { CellView } from './CellView.mjs';\nimport { Cell } from './Cell.mjs';\nimport V from '../V/index.mjs';\nimport { elementViewPortPrototype } from './ports.mjs';\nimport { Rect, snapToGrid } from '../g/index.mjs';\n\nconst Flags = {\n    TOOLS: CellView.Flags.TOOLS,\n    UPDATE: 'UPDATE',\n    TRANSLATE: 'TRANSLATE',\n    RESIZE: 'RESIZE',\n    PORTS: 'PORTS',\n    ROTATE: 'ROTATE',\n    RENDER: 'RENDER'\n};\n\nconst DragActions = {\n    MOVE: 'move',\n    MAGNET: 'magnet',\n};\n// Element base view and controller.\n// -------------------------------------------\n\nexport const ElementView = CellView.extend({\n\n    /**\n     * @abstract\n     */\n    _removePorts: function() {\n        // implemented in ports.js\n    },\n\n    /**\n     *\n     * @abstract\n     */\n    _renderPorts: function() {\n        // implemented in ports.js\n    },\n\n    className: function() {\n\n        var classNames = CellView.prototype.className.apply(this).split(' ');\n\n        classNames.push('element');\n\n        return classNames.join(' ');\n    },\n\n    initialize: function() {\n\n        CellView.prototype.initialize.apply(this, arguments);\n\n        this._initializePorts();\n    },\n\n    presentationAttributes: {\n        'attrs': [Flags.UPDATE],\n        'position': [Flags.TRANSLATE, Flags.TOOLS],\n        'size': [Flags.RESIZE, Flags.PORTS, Flags.TOOLS],\n        'angle': [Flags.ROTATE, Flags.TOOLS],\n        'markup': [Flags.RENDER],\n        'ports': [Flags.PORTS],\n    },\n\n    initFlag: [Flags.RENDER],\n\n    UPDATE_PRIORITY: 0,\n\n    confirmUpdate: function(flag, opt) {\n\n        const { useCSSSelectors } = this;\n        if (this.hasFlag(flag, Flags.PORTS)) {\n            this._removePorts();\n            this._cleanPortsCache();\n        }\n        let transformHighlighters = false;\n        if (this.hasFlag(flag, Flags.RENDER)) {\n            this.render();\n            this.updateTools(opt);\n            this.updateHighlighters(true);\n            transformHighlighters = true;\n            flag = this.removeFlag(flag, [Flags.RENDER, Flags.UPDATE, Flags.RESIZE, Flags.TRANSLATE, Flags.ROTATE, Flags.PORTS, Flags.TOOLS]);\n        } else {\n            let updateHighlighters = false;\n\n            // Skip this branch if render is required\n            if (this.hasFlag(flag, Flags.RESIZE)) {\n                this.resize(opt);\n                updateHighlighters = true;\n                // Resize method is calling `update()` internally\n                flag = this.removeFlag(flag, [Flags.RESIZE, Flags.UPDATE]);\n                if (useCSSSelectors) {\n                    // `resize()` rendered the ports when useCSSSelectors are enabled\n                    flag = this.removeFlag(flag, Flags.PORTS);\n                }\n            }\n            if (this.hasFlag(flag, Flags.UPDATE)) {\n                this.update(this.model, null, opt);\n                flag = this.removeFlag(flag, Flags.UPDATE);\n                updateHighlighters = true;\n                if (useCSSSelectors) {\n                    // `update()` will render ports when useCSSSelectors are enabled\n                    flag = this.removeFlag(flag, Flags.PORTS);\n                }\n            }\n            if (this.hasFlag(flag, Flags.TRANSLATE)) {\n                this.translate();\n                flag = this.removeFlag(flag, Flags.TRANSLATE);\n                transformHighlighters = true;\n            }\n            if (this.hasFlag(flag, Flags.ROTATE)) {\n                this.rotate();\n                flag = this.removeFlag(flag, Flags.ROTATE);\n                transformHighlighters = true;\n            }\n            if (this.hasFlag(flag, Flags.PORTS)) {\n                this._renderPorts();\n                updateHighlighters = true;\n                flag = this.removeFlag(flag, Flags.PORTS);\n            }\n\n            if (updateHighlighters) {\n                this.updateHighlighters(false);\n            }\n        }\n\n        if (transformHighlighters) {\n            this.transformHighlighters();\n        }\n\n        if (this.hasFlag(flag, Flags.TOOLS)) {\n            this.updateTools(opt);\n            flag = this.removeFlag(flag, Flags.TOOLS);\n        }\n\n        return flag;\n    },\n\n    /**\n     * @abstract\n     */\n    _initializePorts: function() {\n\n    },\n\n    update: function(_, renderingOnlyAttrs) {\n\n        this.cleanNodesCache();\n\n        // When CSS selector strings are used, make sure no rule matches port nodes.\n        const { useCSSSelectors } = this;\n        if (useCSSSelectors) this._removePorts();\n\n        var model = this.model;\n        var modelAttrs = model.attr();\n        this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n            rootBBox: new Rect(model.size()),\n            selectors: this.selectors,\n            scalableNode: this.scalableNode,\n            rotatableNode: this.rotatableNode,\n            // Use rendering only attributes if they differs from the model attributes\n            roAttributes: (renderingOnlyAttrs === modelAttrs) ? null : renderingOnlyAttrs\n        });\n\n        if (useCSSSelectors) {\n            this._renderPorts();\n        }\n    },\n\n    rotatableSelector: 'rotatable',\n    scalableSelector: 'scalable',\n    scalableNode: null,\n    rotatableNode: null,\n\n    // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n    // default markup is not desirable.\n    renderMarkup: function() {\n\n        var element = this.model;\n        var markup = element.get('markup') || element.markup;\n        if (!markup) throw new Error('dia.ElementView: markup required');\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === 'string') return this.renderStringMarkup(markup);\n        throw new Error('dia.ElementView: invalid markup');\n    },\n\n    renderJSONMarkup: function(markup) {\n\n        var doc = this.parseDOMJSON(markup, this.el);\n        var selectors = this.selectors = doc.selectors;\n        this.rotatableNode = V(selectors[this.rotatableSelector]) || null;\n        this.scalableNode = V(selectors[this.scalableSelector]) || null;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n\n    renderStringMarkup: function(markup) {\n\n        var vel = this.vel;\n        vel.append(V(markup));\n        // Cache transformation groups\n        this.rotatableNode = vel.findOne('.rotatable');\n        this.scalableNode = vel.findOne('.scalable');\n\n        var selectors = this.selectors = {};\n        selectors[this.selector] = this.el;\n    },\n\n    render: function() {\n\n        this.vel.empty();\n        this.renderMarkup();\n        if (this.scalableNode) {\n            // Double update is necessary for elements with the scalable group only\n            // Note the resize() triggers the other `update`.\n            this.update();\n        }\n        this.resize();\n        if (this.rotatableNode) {\n            // Translate transformation is applied on `this.el` while the rotation transformation\n            // on `this.rotatableNode`\n            this.rotate();\n            this.translate();\n        } else {\n            this.updateTransformation();\n        }\n        if (!this.useCSSSelectors) this._renderPorts();\n        return this;\n    },\n\n    resize: function(opt) {\n\n        if (this.scalableNode) return this.sgResize(opt);\n        if (this.model.attributes.angle) this.rotate();\n        this.update();\n    },\n\n    translate: function() {\n\n        if (this.rotatableNode) return this.rgTranslate();\n        this.updateTransformation();\n    },\n\n    rotate: function() {\n\n        if (this.rotatableNode) {\n            this.rgRotate();\n            // It's necessary to call the update for the nodes outside\n            // the rotatable group referencing nodes inside the group\n            this.update();\n            return;\n        }\n        this.updateTransformation();\n    },\n\n    updateTransformation: function() {\n\n        var transformation = this.getTranslateString();\n        var rotateString = this.getRotateString();\n        if (rotateString) transformation += ' ' + rotateString;\n        this.vel.attr('transform', transformation);\n    },\n\n    getTranslateString: function() {\n\n        var position = this.model.attributes.position;\n        return 'translate(' + position.x + ',' + position.y + ')';\n    },\n\n    getRotateString: function() {\n        var attributes = this.model.attributes;\n        var angle = attributes.angle;\n        if (!angle) return null;\n        var size = attributes.size;\n        return 'rotate(' + angle + ',' + (size.width / 2) + ',' + (size.height / 2) + ')';\n    },\n\n    // Rotatable & Scalable Group\n    // always slower, kept mainly for backwards compatibility\n\n    rgRotate: function() {\n\n        this.rotatableNode.attr('transform', this.getRotateString());\n    },\n\n    rgTranslate: function() {\n\n        this.vel.attr('transform', this.getTranslateString());\n    },\n\n    sgResize: function(opt) {\n\n        var model = this.model;\n        var angle = model.angle();\n        var size = model.size();\n        var scalable = this.scalableNode;\n\n        // Getting scalable group's bbox.\n        // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n        // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n        var recursive = false;\n        if (scalable.node.getElementsByTagName('path').length > 0) {\n            // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n            // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n            recursive = true;\n        }\n        var scalableBBox = scalable.getBBox({ recursive: recursive });\n\n        // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n        // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n        var sx = (size.width / (scalableBBox.width || 1));\n        var sy = (size.height / (scalableBBox.height || 1));\n        scalable.attr('transform', 'scale(' + sx + ',' + sy + ')');\n\n        // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n        // Order of transformations is significant but we want to reconstruct the object always in the order:\n        // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n        // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n        // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n        // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n        // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n\n        // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n        var rotatable = this.rotatableNode;\n        var rotation = rotatable && rotatable.attr('transform');\n        if (rotation) {\n\n            rotatable.attr('transform', rotation + ' rotate(' + (-angle) + ',' + (size.width / 2) + ',' + (size.height / 2) + ')');\n            var rotatableBBox = scalable.getBBox({ target: this.paper.cells });\n\n            // Store new x, y and perform rotate() again against the new rotation origin.\n            model.set('position', { x: rotatableBBox.x, y: rotatableBBox.y }, assign({ updateHandled: true }, opt));\n            this.translate();\n            this.rotate();\n        }\n\n        // Update must always be called on non-rotated element. Otherwise, relative positioning\n        // would work with wrong (rotated) bounding boxes.\n        this.update();\n    },\n\n    // Embedding mode methods.\n    // -----------------------\n\n    prepareEmbedding: function(data = {}) {\n\n        const element = data.model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n\n        const initialZIndices = data.initialZIndices = {};\n        const embeddedCells = element.getEmbeddedCells({ deep: true });\n        const connectedLinks = graph.getConnectedLinks(element, { deep: true, includeEnclosed: true });\n\n        // Note: an embedded cell can be a connect link, but it's fine\n        // to iterate over the cell twice.\n        [\n            element,\n            ...embeddedCells,\n            ...connectedLinks\n        ].forEach(cell => initialZIndices[cell.id] = cell.attributes.z);\n\n        element.startBatch('to-front');\n\n        // Bring the model to the front with all his embeds.\n        element.toFront({ deep: true, ui: true });\n\n        // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n        // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n        const maxZ = graph.getElements().reduce((max, cell) => Math.max(max, cell.attributes.z || 0), 0);\n\n        // Move to front also all the inbound and outbound links that are connected\n        // to any of the element descendant. If we bring to front only embedded elements,\n        // links connected to them would stay in the background.\n        connectedLinks.forEach((link) => {\n            if (link.attributes.z <= maxZ) {\n                link.set('z', maxZ + 1, { ui: true });\n            }\n        });\n\n        element.stopBatch('to-front');\n\n        // Before we start looking for suitable parent we remove the current one.\n        const parentId = element.parent();\n        if (parentId) {\n            const parent = graph.getCell(parentId);\n            parent.unembed(element, { ui: true });\n            data.initialParentId = parentId;\n        } else {\n            data.initialParentId = null;\n        }\n    },\n\n    processEmbedding: function(data = {}, evt, x, y) {\n\n        const model = data.model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n        const { findParentBy, frontParentOnly, validateEmbedding } = paper.options;\n\n        let candidates;\n        if (isFunction(findParentBy)) {\n            candidates = toArray(findParentBy.call(graph, this, evt, x, y));\n        } else if (findParentBy === 'pointer') {\n            candidates = toArray(graph.findModelsFromPoint({ x, y }));\n        } else {\n            candidates = graph.findModelsUnderElement(model, { searchBy: findParentBy });\n        }\n\n        candidates = candidates.filter((el) => {\n            return (el instanceof Cell) && (model.id !== el.id) && !el.isEmbeddedIn(model);\n        });\n\n        if (frontParentOnly) {\n            // pick the element with the highest `z` index\n            candidates = candidates.slice(-1);\n        }\n\n        let newCandidateView = null;\n        const prevCandidateView = data.candidateEmbedView;\n\n        // iterate over all candidates starting from the last one (has the highest z-index).\n        for (let i = candidates.length - 1; i >= 0; i--) {\n            const candidate = candidates[i];\n            if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n                // candidate remains the same\n                newCandidateView = prevCandidateView;\n                break;\n            } else {\n                const view = candidate.findView(paper);\n                if (!isFunction(validateEmbedding) || validateEmbedding.call(paper, this, view)) {\n                    // flip to the new candidate\n                    newCandidateView = view;\n                    break;\n                }\n            }\n        }\n\n        if (newCandidateView && newCandidateView != prevCandidateView) {\n            // A new candidate view found. Highlight the new one.\n            this.clearEmbedding(data);\n            data.candidateEmbedView = newCandidateView.highlight(\n                newCandidateView.findProxyNode(null, 'container'),\n                { embedding: true }\n            );\n        }\n\n        if (!newCandidateView && prevCandidateView) {\n            // No candidate view found. Unhighlight the previous candidate.\n            this.clearEmbedding(data);\n        }\n    },\n\n    clearEmbedding: function(data) {\n\n        data || (data = {});\n\n        var candidateView = data.candidateEmbedView;\n        if (candidateView) {\n            // No candidate view found. Unhighlight the previous candidate.\n            candidateView.unhighlight(\n                candidateView.findProxyNode(null, 'container'),\n                { embedding: true }\n            );\n            data.candidateEmbedView = null;\n        }\n    },\n\n    finalizeEmbedding: function(data = {}) {\n\n        const candidateView = data.candidateEmbedView;\n        const element = data.model || this.model;\n        const paper = data.paper || this.paper;\n\n        if (candidateView) {\n\n            // We finished embedding. Candidate view is chosen to become the parent of the model.\n            candidateView.model.embed(element, { ui: true });\n            candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), { embedding: true });\n\n            data.candidateEmbedView = null;\n\n        } else {\n\n            const { validateUnembedding } = paper.options;\n            const { initialParentId } = data;\n            // The element was originally embedded into another element.\n            // The interaction would unembed the element. Let's validate\n            // if the element can be unembedded.\n            if (\n                initialParentId &&\n                typeof validateUnembedding === 'function' &&\n                !validateUnembedding.call(paper, this)\n            ) {\n                this._disallowUnembed(data);\n                return;\n            }\n        }\n\n        paper.model.getConnectedLinks(element, { deep: true }).forEach(link => {\n            link.reparent({ ui: true });\n        });\n    },\n\n    _disallowUnembed: function(data) {\n        const { model, whenNotAllowed = 'revert' } = data;\n        const element = model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n        switch (whenNotAllowed) {\n            case 'remove': {\n                element.remove({ ui: true });\n                break;\n            }\n            case 'revert': {\n                const { initialParentId, initialPosition, initialZIndices } = data;\n                // Revert the element's position (and the position of its embedded cells if any)\n                if (initialPosition) {\n                    const { x, y } = initialPosition;\n                    element.position(x, y, { deep: true, ui: true });\n                }\n                // Revert all the z-indices changed during the embedding\n                if (initialZIndices) {\n                    Object.keys(initialZIndices).forEach(id => {\n                        const cell = graph.getCell(id);\n                        if (cell) {\n                            cell.set('z', initialZIndices[id], { ui: true });\n                        }\n                    });\n                }\n                // Revert the original parent\n                const parent = graph.getCell(initialParentId);\n                if (parent) {\n                    parent.embed(element, { ui: true });\n                }\n                break;\n            }\n        }\n    },\n\n    getDelegatedView: function() {\n\n        var view = this;\n        var model = view.model;\n        var paper = view.paper;\n\n        while (view) {\n            if (model.isLink()) break;\n            if (!model.isEmbedded() || view.can('stopDelegation')) return view;\n            model = model.getParentCell();\n            view = paper.findViewByModel(model);\n        }\n\n        return null;\n    },\n\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const port = this.findAttribute('port', el);\n            if (port) {\n                const proxyPortNode = this.findPortNode(port, nodeSelector);\n                if (proxyPortNode) return proxyPortNode;\n            } else {\n                const proxyNode = this.findNode(nodeSelector);\n                if (proxyNode) return proxyNode;\n            }\n        }\n        return el;\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    notifyPointerdown(evt, x, y) {\n        CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify('element:pointerdown', evt, x, y);\n    },\n\n    notifyPointermove(evt, x, y) {\n        CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify('element:pointermove', evt, x, y);\n    },\n\n    notifyPointerup(evt, x, y) {\n        this.notify('element:pointerup', evt, x, y);\n        CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n\n    pointerdblclick: function(evt, x, y) {\n\n        CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify('element:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify('element:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify('element:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n        this.dragStart(evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        const data = this.eventData(evt);\n        const { targetMagnet, action, delegatedView } = data;\n\n        if (targetMagnet) {\n            this.magnetpointermove(evt, targetMagnet, x, y);\n        }\n\n        switch (action) {\n            case DragActions.MAGNET:\n                this.dragMagnet(evt, x, y);\n                break;\n            case DragActions.MOVE:\n                (delegatedView || this).drag(evt, x, y);\n            // eslint: no-fallthrough=false\n            default:\n                if (data.preventPointerEvents) break;\n                this.notifyPointermove(evt, x, y);\n                break;\n        }\n\n        // Make sure the element view data is passed along.\n        // It could have been wiped out in the handlers above.\n        this.eventData(evt, data);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        const data = this.eventData(evt);\n        const { targetMagnet, action, delegatedView } = data;\n\n        if (targetMagnet) {\n            this.magnetpointerup(evt, targetMagnet, x, y);\n        }\n\n        switch (action) {\n            case DragActions.MAGNET:\n                this.dragMagnetEnd(evt, x, y);\n                break;\n            case DragActions.MOVE:\n                (delegatedView || this).dragEnd(evt, x, y);\n            // eslint: no-fallthrough=false\n            default:\n                if (data.preventPointerEvents) break;\n                this.notifyPointerup(evt, x, y);\n        }\n\n        if (targetMagnet) {\n            this.magnetpointerclick(evt, targetMagnet, x, y);\n        }\n\n        this.checkMouseleave(evt);\n    },\n\n    mouseover: function(evt) {\n\n        CellView.prototype.mouseover.apply(this, arguments);\n        this.notify('element:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        CellView.prototype.mouseout.apply(this, arguments);\n        this.notify('element:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify('element:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify('element:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify('element:mousewheel', evt, x, y, delta);\n    },\n\n    onmagnet: function(evt, x, y) {\n\n        const { currentTarget: targetMagnet } = evt;\n        this.magnetpointerdown(evt, targetMagnet, x, y);\n        this.eventData(evt, { targetMagnet });\n        this.dragMagnetStart(evt, x, y);\n    },\n\n    magnetpointerdown: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointerdown', evt, magnet, x, y);\n    },\n\n    magnetpointermove: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointermove', evt, magnet, x, y);\n    },\n\n    magnetpointerup: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointerup', evt, magnet, x, y);\n    },\n\n    magnetpointerdblclick: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);\n    },\n\n    magnetcontextmenu: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:contextmenu', evt, magnet, x, y);\n    },\n\n    // Drag Start Handlers\n\n    dragStart: function(evt, x, y) {\n\n        if (this.isDefaultInteractionPrevented(evt)) return;\n\n        var view = this.getDelegatedView();\n        if (!view || !view.can('elementMove')) return;\n\n        this.eventData(evt, {\n            action: DragActions.MOVE,\n            delegatedView: view\n        });\n\n        const position = view.model.position();\n        view.eventData(evt, {\n            initialPosition: position,\n            pointerOffset: position.difference(x, y),\n            restrictedArea: this.paper.getRestrictedArea(view, x, y)\n        });\n    },\n\n    dragMagnetStart: function(evt, x, y) {\n\n        const { paper } = this;\n        const isPropagationAlreadyStopped = evt.isPropagationStopped();\n        if (isPropagationAlreadyStopped) {\n            // Special case when the propagation was already stopped\n            // on the `element:magnet:pointerdown` event.\n            // Do not trigger any `element:pointer*` events\n            // but still start the magnet dragging.\n            this.eventData(evt, { preventPointerEvents: true });\n        }\n\n        if (this.isDefaultInteractionPrevented(evt) || !this.can('addLinkFromMagnet')) {\n            // Stop the default action, which is to start dragging a link.\n            return;\n        }\n\n        const { targetMagnet = evt.currentTarget } = this.eventData(evt);\n        evt.stopPropagation();\n\n        // Invalid (Passive) magnet. Start dragging the element.\n        if (!paper.options.validateMagnet.call(paper, this, targetMagnet, evt)) {\n            if (isPropagationAlreadyStopped) {\n                // Do not trigger `element:pointerdown` and start element dragging\n                // if the propagation was stopped.\n                this.dragStart(evt, x, y);\n                // The `element:pointerdown` event is not triggered because\n                // of `preventPointerEvents` flag.\n            } else {\n                // We need to reset the action\n                // to `MOVE` so that the element is dragged.\n                this.pointerdown(evt, x, y);\n            }\n            return;\n        }\n\n        // Valid magnet. Start dragging a link.\n        if (paper.options.magnetThreshold <= 0) {\n            this.dragLinkStart(evt, targetMagnet, x, y);\n        }\n        this.eventData(evt, { action: DragActions.MAGNET });\n    },\n\n    // Drag Handlers\n\n    drag: function(evt, x, y) {\n\n        var paper = this.paper;\n        var grid = paper.options.gridSize;\n        var element = this.model;\n        var data = this.eventData(evt);\n        var { pointerOffset, restrictedArea, embedding } = data;\n\n        // Make sure the new element's position always snaps to the current grid\n        var elX = snapToGrid(x + pointerOffset.x, grid);\n        var elY = snapToGrid(y + pointerOffset.y, grid);\n\n        element.position(elX, elY, { restrictedArea, deep: true, ui: true });\n\n        if (paper.options.embeddingMode) {\n            if (!embedding) {\n                // Prepare the element for embedding only if the pointer moves.\n                // We don't want to do unnecessary action with the element\n                // if an user only clicks/dblclicks on it.\n                this.prepareEmbedding(data);\n                embedding = true;\n            }\n            this.processEmbedding(data, evt, x, y);\n        }\n\n        this.eventData(evt, {\n            embedding\n        });\n    },\n\n    dragMagnet: function(evt, x, y) {\n        this.dragLink(evt, x, y);\n    },\n\n    // Drag End Handlers\n\n    dragEnd: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        if (data.embedding) this.finalizeEmbedding(data);\n    },\n\n    dragMagnetEnd: function(evt, x, y) {\n        this.dragLinkEnd(evt, x, y);\n    },\n\n    magnetpointerclick: function(evt, magnet, x, y) {\n        var paper = this.paper;\n        if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;\n        this.notify('element:magnet:pointerclick', evt, magnet, x, y);\n    }\n\n}, {\n\n    Flags: Flags,\n});\n\nassign(ElementView.prototype, elementViewPortPrototype);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}