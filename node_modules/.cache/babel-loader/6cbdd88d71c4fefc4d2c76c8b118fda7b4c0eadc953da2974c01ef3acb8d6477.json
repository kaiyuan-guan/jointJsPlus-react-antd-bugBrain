{"ast":null,"code":"import { PaperLayer } from '../PaperLayer.mjs';\nimport { isFunction, isString, defaults, omit, assign, merge } from '../../util/index.mjs';\nimport V from '../../V/index.mjs';\nexport const GridLayer = PaperLayer.extend({\n  style: {\n    'pointer-events': 'none'\n  },\n  _gridCache: null,\n  _gridSettings: null,\n  init() {\n    PaperLayer.prototype.init.apply(this, arguments);\n    const {\n      options: {\n        paper\n      }\n    } = this;\n    this._gridCache = null;\n    this._gridSettings = [];\n    this.listenTo(paper, 'transform resize', this.updateGrid);\n  },\n  setGrid(drawGrid) {\n    this._gridSettings = this.getGridSettings(drawGrid);\n    this.renderGrid();\n  },\n  getGridSettings(drawGrid) {\n    const gridSettings = [];\n    if (drawGrid) {\n      const optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];\n      optionsList.forEach(item => {\n        gridSettings.push(...this._resolveDrawGridOption(item));\n      });\n    }\n    return gridSettings;\n  },\n  removeGrid() {\n    const {\n      _gridCache: grid\n    } = this;\n    if (!grid) return;\n    grid.root.remove();\n    this._gridCache = null;\n  },\n  renderGrid() {\n    const {\n      options: {\n        paper\n      }\n    } = this;\n    const {\n      _gridSettings: gridSettings\n    } = this;\n    this.removeGrid();\n    if (gridSettings.length === 0) return;\n    const gridSize = paper.options.drawGridSize || paper.options.gridSize;\n    if (gridSize <= 1) {\n      return;\n    }\n    const refs = this._getGridRefs();\n    gridSettings.forEach((gridLayerSetting, index) => {\n      const id = 'pattern_' + index;\n      const options = merge({}, gridLayerSetting);\n      const {\n        scaleFactor = 1\n      } = options;\n      options.width = gridSize * scaleFactor || 1;\n      options.height = gridSize * scaleFactor || 1;\n      let vPattern;\n      if (!refs.exist(id)) {\n        vPattern = V('pattern', {\n          id: id,\n          patternUnits: 'userSpaceOnUse'\n        }, V(options.markup));\n        refs.add(id, vPattern);\n      } else {\n        vPattern = refs.get(id);\n      }\n      if (isFunction(options.render)) {\n        options.render(vPattern.node.firstChild, options, paper);\n      }\n      vPattern.attr({\n        width: options.width,\n        height: options.height\n      });\n    });\n    refs.root.appendTo(this.el);\n    this.updateGrid();\n  },\n  updateGrid() {\n    const {\n      _gridCache: grid,\n      _gridSettings: gridSettings,\n      options: {\n        paper\n      }\n    } = this;\n    if (!grid) return;\n    const {\n      root: vSvg,\n      patterns\n    } = grid;\n    const {\n      x,\n      y,\n      width,\n      height\n    } = paper.getArea();\n    vSvg.attr({\n      x,\n      y,\n      width,\n      height\n    });\n    for (const patternId in patterns) {\n      const vPattern = patterns[patternId];\n      vPattern.attr({\n        x: -x,\n        y: -y\n      });\n    }\n    gridSettings.forEach((options, index) => {\n      if (isFunction(options.update)) {\n        const vPattern = patterns['pattern_' + index];\n        options.update(vPattern.node.firstChild, options, paper);\n      }\n    });\n  },\n  _getGridRefs() {\n    let {\n      _gridCache: grid\n    } = this;\n    if (grid) return grid;\n    const defsVEl = V('defs');\n    const svgVEl = V('svg', {\n      width: '100%',\n      height: '100%'\n    }, [defsVEl]);\n    grid = this._gridCache = {\n      root: svgVEl,\n      patterns: {},\n      add: function (id, patternVEl) {\n        const rectVEl = V('rect', {\n          width: '100%',\n          height: '100%',\n          fill: `url(#${id})`\n        });\n        defsVEl.append(patternVEl);\n        svgVEl.append(rectVEl);\n        this.patterns[id] = patternVEl;\n      },\n      get: function (id) {\n        return this.patterns[id];\n      },\n      exist: function (id) {\n        return this.patterns[id] !== undefined;\n      }\n    };\n    return grid;\n  },\n  _resolveDrawGridOption(opt) {\n    var namespace = this.options.patterns;\n    if (isString(opt) && Array.isArray(namespace[opt])) {\n      return namespace[opt].map(function (item) {\n        return assign({}, item);\n      });\n    }\n    var options = opt || {\n      args: [{}]\n    };\n    var isArray = Array.isArray(options);\n    var name = options.name;\n    if (!isArray && !name && !options.markup) {\n      name = 'dot';\n    }\n    if (name && Array.isArray(namespace[name])) {\n      var pattern = namespace[name].map(function (item) {\n        return assign({}, item);\n      });\n      var args = Array.isArray(options.args) ? options.args : [options.args || {}];\n      defaults(args[0], omit(opt, 'args'));\n      for (var i = 0; i < args.length; i++) {\n        if (pattern[i]) {\n          assign(pattern[i], args[i]);\n        }\n      }\n      return pattern;\n    }\n    return isArray ? options : [options];\n  }\n});","map":{"version":3,"names":["PaperLayer","isFunction","isString","defaults","omit","assign","merge","V","GridLayer","extend","style","_gridCache","_gridSettings","init","prototype","apply","arguments","options","paper","listenTo","updateGrid","setGrid","drawGrid","getGridSettings","renderGrid","gridSettings","optionsList","Array","isArray","forEach","item","push","_resolveDrawGridOption","removeGrid","grid","root","remove","length","gridSize","drawGridSize","refs","_getGridRefs","gridLayerSetting","index","id","scaleFactor","width","height","vPattern","exist","patternUnits","markup","add","get","render","node","firstChild","attr","appendTo","el","vSvg","patterns","x","y","getArea","patternId","update","defsVEl","svgVEl","patternVEl","rectVEl","fill","append","undefined","opt","namespace","map","args","name","pattern","i"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/dia/layers/GridLayer.mjs"],"sourcesContent":["import { PaperLayer } from '../PaperLayer.mjs';\nimport {\n    isFunction,\n    isString,\n    defaults,\n    omit,\n    assign,\n    merge,\n} from '../../util/index.mjs';\nimport V from '../../V/index.mjs';\n\nexport const GridLayer = PaperLayer.extend({\n\n    style: {\n        'pointer-events': 'none'\n    },\n\n    _gridCache: null,\n    _gridSettings: null,\n\n    init() {\n        PaperLayer.prototype.init.apply(this, arguments);\n        const { options: { paper }} = this;\n        this._gridCache = null;\n        this._gridSettings = [];\n        this.listenTo(paper, 'transform resize', this.updateGrid);\n    },\n\n    setGrid(drawGrid) {\n        this._gridSettings = this.getGridSettings(drawGrid);\n        this.renderGrid();\n    },\n\n    getGridSettings(drawGrid) {\n        const gridSettings = [];\n        if (drawGrid) {\n            const optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];\n            optionsList.forEach((item) => {\n                gridSettings.push(...this._resolveDrawGridOption(item));\n            });\n        }\n        return gridSettings;\n    },\n\n    removeGrid() {\n        const { _gridCache: grid } = this;\n        if (!grid) return;\n        grid.root.remove();\n        this._gridCache = null;\n    },\n\n    renderGrid() {\n\n        const { options: { paper }} = this;\n        const { _gridSettings: gridSettings } = this;\n\n        this.removeGrid();\n\n        if (gridSettings.length === 0) return;\n\n        const gridSize = paper.options.drawGridSize || paper.options.gridSize;\n        if (gridSize <= 1) {\n            return;\n        }\n\n        const refs = this._getGridRefs();\n\n        gridSettings.forEach((gridLayerSetting, index) => {\n\n            const id = 'pattern_' + index;\n            const options = merge({}, gridLayerSetting);\n            const { scaleFactor = 1 } = options;\n            options.width = gridSize * scaleFactor || 1;\n            options.height = gridSize * scaleFactor || 1;\n\n            let vPattern;\n            if (!refs.exist(id)) {\n                vPattern = V('pattern', { id: id, patternUnits: 'userSpaceOnUse' }, V(options.markup));\n                refs.add(id, vPattern);\n            } else {\n                vPattern = refs.get(id);\n            }\n\n            if (isFunction(options.render)) {\n                options.render(vPattern.node.firstChild, options, paper);\n            }\n            vPattern.attr({\n                width: options.width,\n                height: options.height\n            });\n        });\n\n        refs.root.appendTo(this.el);\n        this.updateGrid();\n    },\n\n    updateGrid() {\n\n        const { _gridCache: grid, _gridSettings: gridSettings, options: { paper }} = this;\n        if (!grid) return;\n        const { root: vSvg, patterns } = grid;\n        const { x, y, width, height } = paper.getArea();\n        vSvg.attr({ x, y, width, height });\n        for (const patternId in patterns) {\n            const vPattern = patterns[patternId];\n            vPattern.attr({ x: -x, y: -y });\n        }\n        gridSettings.forEach((options, index) => {\n            if (isFunction(options.update)) {\n                const vPattern = patterns['pattern_' + index];\n                options.update(vPattern.node.firstChild, options, paper);\n            }\n        });\n    },\n\n    _getGridRefs() {\n        let { _gridCache: grid } = this;\n        if (grid) return grid;\n        const defsVEl = V('defs');\n        const svgVEl = V('svg', { width: '100%', height: '100%' }, [defsVEl]);\n        grid = this._gridCache = {\n            root: svgVEl,\n            patterns: {},\n            add: function(id, patternVEl) {\n                const rectVEl = V('rect', { width: '100%', height: '100%', fill: `url(#${id})` });\n                defsVEl.append(patternVEl);\n                svgVEl.append(rectVEl);\n                this.patterns[id] = patternVEl;\n            },\n            get: function(id) {\n                return this.patterns[id];\n            },\n            exist: function(id) {\n                return this.patterns[id] !== undefined;\n            }\n        };\n        return grid;\n    },\n\n    _resolveDrawGridOption(opt) {\n\n        var namespace = this.options.patterns;\n        if (isString(opt) && Array.isArray(namespace[opt])) {\n            return namespace[opt].map(function(item) {\n                return assign({}, item);\n            });\n        }\n\n        var options = opt || { args: [{}] };\n        var isArray = Array.isArray(options);\n        var name = options.name;\n\n        if (!isArray && !name && !options.markup) {\n            name = 'dot';\n        }\n\n        if (name && Array.isArray(namespace[name])) {\n            var pattern = namespace[name].map(function(item) {\n                return assign({}, item);\n            });\n\n            var args = Array.isArray(options.args) ? options.args : [options.args || {}];\n\n            defaults(args[0], omit(opt, 'args'));\n            for (var i = 0; i < args.length; i++) {\n                if (pattern[i]) {\n                    assign(pattern[i], args[i]);\n                }\n            }\n            return pattern;\n        }\n\n        return isArray ? options : [options];\n    },\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}