{"ast":null,"code":"// Vectorizer.\n// -----------\n\n// A tiny library for making your life easier when dealing with SVG.\n// The only Vectorizer dependency is the Geometry library.\n\nimport * as g from '../g/index.mjs';\nconst V = function () {\n  var hasSvg = typeof window === 'object' && !!window.SVGAngle;\n\n  // SVG support is required.\n  if (!hasSvg) {\n    // Return a function that throws an error when it is used.\n    return function () {\n      throw new Error('SVG is required to use Vectorizer.');\n    };\n  }\n\n  // XML namespaces.\n  var ns = {\n    svg: 'http://www.w3.org/2000/svg',\n    xmlns: 'http://www.w3.org/2000/xmlns/',\n    xml: 'http://www.w3.org/XML/1998/namespace',\n    xlink: 'http://www.w3.org/1999/xlink',\n    xhtml: 'http://www.w3.org/1999/xhtml'\n  };\n  var SVGVersion = '1.1';\n\n  // Declare shorthands to the most used math functions.\n  var math = Math;\n  var PI = math.PI;\n  var atan2 = math.atan2;\n  var sqrt = math.sqrt;\n  var min = math.min;\n  var max = math.max;\n  var cos = math.cos;\n  var sin = math.sin;\n  var V = function (el, attrs, children) {\n    // This allows using V() without the new keyword.\n    if (!(this instanceof V)) {\n      return V.apply(Object.create(V.prototype), arguments);\n    }\n    if (!el) return;\n    if (V.isV(el)) {\n      el = el.node;\n    }\n    attrs = attrs || {};\n    if (V.isString(el)) {\n      el = el.trim();\n      if (el.toLowerCase() === 'svg') {\n        // Create a new SVG canvas.\n        el = V.createSvgDocument();\n      } else if (el[0] === '<') {\n        // Create element from an SVG string.\n        // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\n\n        var svgDoc = V.createSvgDocument(el);\n\n        // Note that `V()` might also return an array should the SVG string passed as\n        // the first argument contain more than one root element.\n        if (svgDoc.childNodes.length > 1) {\n          // Map child nodes to `V`s.\n          var arrayOfVels = [];\n          var i, len;\n          for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {\n            var childNode = svgDoc.childNodes[i];\n            arrayOfVels.push(new V(document.importNode(childNode, true)));\n          }\n          return arrayOfVels;\n        }\n        el = document.importNode(svgDoc.firstChild, true);\n      } else {\n        el = document.createElementNS(ns.svg, el);\n      }\n      V.ensureId(el);\n    }\n    this.node = el;\n    this.setAttributes(attrs);\n    if (children) {\n      this.append(children);\n    }\n    return this;\n  };\n  var VPrototype = V.prototype;\n  Object.defineProperty(VPrototype, 'id', {\n    enumerable: true,\n    get: function () {\n      return this.node.id;\n    },\n    set: function (id) {\n      this.node.id = id;\n    }\n  });\n\n  /**\n   * @param {SVGGElement} toElem\n   * @returns {SVGMatrix}\n   */\n  VPrototype.getTransformToElement = function (target) {\n    var node = this.node;\n    if (V.isSVGGraphicsElement(target) && V.isSVGGraphicsElement(node)) {\n      var targetCTM = V.toNode(target).getScreenCTM();\n      var nodeCTM = node.getScreenCTM();\n      if (targetCTM && nodeCTM) {\n        return targetCTM.inverse().multiply(nodeCTM);\n      }\n    }\n    // Could not get actual transformation matrix\n    return V.createSVGMatrix();\n  };\n\n  /**\n   * @param {SVGMatrix} matrix\n   * @param {Object=} opt\n   * @returns {Vectorizer|SVGMatrix} Setter / Getter\n   */\n  VPrototype.transform = function (matrix, opt) {\n    var node = this.node;\n    if (V.isUndefined(matrix)) {\n      return V.transformStringToMatrix(this.attr('transform'));\n    }\n    if (opt && opt.absolute) {\n      return this.attr('transform', V.matrixToTransformString(matrix));\n    }\n    var svgTransform = V.createSVGTransform(matrix);\n    node.transform.baseVal.appendItem(svgTransform);\n    return this;\n  };\n  VPrototype.translate = function (tx, ty, opt) {\n    opt = opt || {};\n    ty = ty || 0;\n    var transformAttr = this.attr('transform') || '';\n    var transform = V.parseTransformString(transformAttr);\n    transformAttr = transform.value;\n    // Is it a getter?\n    if (V.isUndefined(tx)) {\n      return transform.translate;\n    }\n    transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n    var newTx = opt.absolute ? tx : transform.translate.tx + tx;\n    var newTy = opt.absolute ? ty : transform.translate.ty + ty;\n    var newTranslate = 'translate(' + newTx + ',' + newTy + ')';\n\n    // Note that `translate()` is always the first transformation. This is\n    // usually the desired case.\n    this.attr('transform', (newTranslate + ' ' + transformAttr).trim());\n    return this;\n  };\n  VPrototype.rotate = function (angle, cx, cy, opt) {\n    opt = opt || {};\n    var transformAttr = this.attr('transform') || '';\n    var transform = V.parseTransformString(transformAttr);\n    transformAttr = transform.value;\n\n    // Is it a getter?\n    if (V.isUndefined(angle)) {\n      return transform.rotate;\n    }\n    transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n    angle %= 360;\n    var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\n    var newOrigin = cx !== undefined && cy !== undefined ? ',' + cx + ',' + cy : '';\n    var newRotate = 'rotate(' + newAngle + newOrigin + ')';\n    this.attr('transform', (transformAttr + ' ' + newRotate).trim());\n    return this;\n  };\n\n  // Note that `scale` as the only transformation does not combine with previous values.\n  VPrototype.scale = function (sx, sy) {\n    sy = V.isUndefined(sy) ? sx : sy;\n    var transformAttr = this.attr('transform') || '';\n    var transform = V.parseTransformString(transformAttr);\n    transformAttr = transform.value;\n\n    // Is it a getter?\n    if (V.isUndefined(sx)) {\n      return transform.scale;\n    }\n    transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n    var newScale = 'scale(' + sx + ',' + sy + ')';\n    this.attr('transform', (transformAttr + ' ' + newScale).trim());\n    return this;\n  };\n\n  // Get SVGRect that contains coordinates and dimension of the real bounding box,\n  // i.e. after transformations are applied.\n  // If `target` is specified, bounding box will be computed relatively to `target` element.\n  VPrototype.bbox = function (withoutTransformations, target) {\n    var box;\n    var node = this.node;\n    var ownerSVGElement = node.ownerSVGElement;\n\n    // If the element is not in the live DOM, it does not have a bounding box defined and\n    // so fall back to 'zero' dimension element.\n    if (!ownerSVGElement) {\n      return new g.Rect(0, 0, 0, 0);\n    }\n    try {\n      box = node.getBBox();\n    } catch (e) {\n      // Fallback for IE.\n      box = {\n        x: node.clientLeft,\n        y: node.clientTop,\n        width: node.clientWidth,\n        height: node.clientHeight\n      };\n    }\n    if (withoutTransformations) {\n      return new g.Rect(box);\n    }\n    var matrix = this.getTransformToElement(target || ownerSVGElement);\n    return V.transformRect(box, matrix);\n  };\n\n  // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,\n  // i.e. after transformations are applied.\n  // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.\n  // Takes an (Object) `opt` argument (optional) with the following attributes:\n  // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this\n  // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();\n  VPrototype.getBBox = function (opt) {\n    var options = {};\n    var outputBBox;\n    var node = this.node;\n    var ownerSVGElement = node.ownerSVGElement;\n\n    // If the element is not in the live DOM, it does not have a bounding box defined and\n    // so fall back to 'zero' dimension element.\n    // If the element is not an SVGGraphicsElement, we could not measure the bounding box either\n    if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {\n      return new g.Rect(0, 0, 0, 0);\n    }\n    if (opt) {\n      if (opt.target) {\n        // check if target exists\n        options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects\n      }\n      if (opt.recursive) {\n        options.recursive = opt.recursive;\n      }\n    }\n    if (!options.recursive) {\n      try {\n        outputBBox = node.getBBox();\n      } catch (e) {\n        // Fallback for IE.\n        outputBBox = {\n          x: node.clientLeft,\n          y: node.clientTop,\n          width: node.clientWidth,\n          height: node.clientHeight\n        };\n      }\n      if (!options.target) {\n        // transform like this (that is, not at all)\n        return new g.Rect(outputBBox);\n      } else {\n        // transform like target\n        var matrix = this.getTransformToElement(options.target);\n        return V.transformRect(outputBBox, matrix);\n      }\n    } else {\n      // if we want to calculate the bbox recursively\n      // browsers report correct bbox around svg elements (one that envelops the path lines tightly)\n      // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())\n      // this happens even if we wrap a single svg element into a group!\n      // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes\n\n      var children = this.children();\n      var n = children.length;\n      if (n === 0) {\n        return this.getBBox({\n          target: options.target,\n          recursive: false\n        });\n      }\n\n      // recursion's initial pass-through setting:\n      // recursive passes-through just keep the target as whatever was set up here during the initial pass-through\n      if (!options.target) {\n        // transform children/descendants like this (their parent/ancestor)\n        options.target = this;\n      } // else transform children/descendants like target\n\n      for (var i = 0; i < n; i++) {\n        var currentChild = children[i];\n        var childBBox;\n\n        // if currentChild is not a group element, get its bbox with a nonrecursive call\n        if (currentChild.children().length === 0) {\n          childBBox = currentChild.getBBox({\n            target: options.target,\n            recursive: false\n          });\n        } else {\n          // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call\n          childBBox = currentChild.getBBox({\n            target: options.target,\n            recursive: true\n          });\n        }\n        if (!outputBBox) {\n          // if this is the first iteration\n          outputBBox = childBBox;\n        } else {\n          // make a new bounding box rectangle that contains this child's bounding box and previous bounding box\n          outputBBox = outputBBox.union(childBBox);\n        }\n      }\n      return outputBBox;\n    }\n  };\n\n  // Text() helpers\n\n  function createTextPathNode(attrs, vel) {\n    attrs || (attrs = {});\n    var textPathElement = V('textPath');\n    var d = attrs.d;\n    if (d && attrs['xlink:href'] === undefined) {\n      // If `opt.attrs` is a plain string, consider it to be directly the\n      // SVG path data for the text to go along (this is a shortcut).\n      // Otherwise if it is an object and contains the `d` property, then this is our path.\n      // Wrap the text in the SVG <textPath> element that points\n      // to a path defined by `opt.attrs` inside the `<defs>` element.\n      var linkedPath = V('path').attr('d', d).appendTo(vel.defs());\n      textPathElement.attr('xlink:href', '#' + linkedPath.id);\n    }\n    if (V.isObject(attrs)) {\n      // Set attributes on the `<textPath>`. The most important one\n      // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\n      // Note that we also allow the following construct:\n      // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\n      // In other words, one can completely skip the auto-creation of the path\n      // and use any other arbitrary path that is in the document.\n      textPathElement.attr(attrs);\n    }\n    return textPathElement.node;\n  }\n  function annotateTextLine(lineNode, lineAnnotations, opt) {\n    opt || (opt = {});\n    var includeAnnotationIndices = opt.includeAnnotationIndices;\n    var eol = opt.eol;\n    var lineHeight = opt.lineHeight;\n    var baseSize = opt.baseSize;\n    var maxFontSize = 0;\n    var fontMetrics = {};\n    var lastJ = lineAnnotations.length - 1;\n    for (var j = 0; j <= lastJ; j++) {\n      var annotation = lineAnnotations[j];\n      var fontSize = null;\n      if (V.isObject(annotation)) {\n        var annotationAttrs = annotation.attrs;\n        var vTSpan = V('tspan', annotationAttrs);\n        var tspanNode = vTSpan.node;\n        var t = annotation.t;\n        if (eol && j === lastJ) t += eol;\n        tspanNode.textContent = t;\n        // Per annotation className\n        var annotationClass = annotationAttrs['class'];\n        if (annotationClass) vTSpan.addClass(annotationClass);\n        // If `opt.includeAnnotationIndices` is `true`,\n        // set the list of indices of all the applied annotations\n        // in the `annotations` attribute. This list is a comma\n        // separated list of indices.\n        if (includeAnnotationIndices) vTSpan.attr('annotations', annotation.annotations);\n        // Check for max font size\n        fontSize = parseFloat(annotationAttrs['font-size']);\n        if (!isFinite(fontSize)) fontSize = baseSize;\n        if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n      } else {\n        if (eol && j === lastJ) annotation += eol;\n        tspanNode = document.createTextNode(annotation || ' ');\n        if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;\n      }\n      lineNode.appendChild(tspanNode);\n    }\n    if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;\n    if (lineHeight) {\n      fontMetrics.lineHeight = lineHeight;\n    } else if (maxFontSize) {\n      fontMetrics.lineHeight = maxFontSize * 1.2;\n    }\n    return fontMetrics;\n  }\n  var emRegex = /em$/;\n  function convertEmToPx(em, fontSize) {\n    var numerical = parseFloat(em);\n    if (emRegex.test(em)) return numerical * fontSize;\n    return numerical;\n  }\n  function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n    if (!Array.isArray(linesMetrics)) return 0;\n    var n = linesMetrics.length;\n    if (!n) return 0;\n    var lineMetrics = linesMetrics[0];\n    var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n    var rLineHeights = 0;\n    var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);\n    for (var i = 1; i < n; i++) {\n      lineMetrics = linesMetrics[i];\n      var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n      rLineHeights += iLineHeight;\n    }\n    var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n    var dy;\n    switch (alignment) {\n      case 'middle':\n        dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;\n        break;\n      case 'bottom':\n        dy = -(0.25 * llMaxFont) - rLineHeights;\n        break;\n      default:\n      case 'top':\n        dy = 0.8 * flMaxFont;\n        break;\n    }\n    return dy;\n  }\n  VPrototype.text = function (content, opt) {\n    if (content && typeof content !== 'string') throw new Error('Vectorizer: text() expects the first argument to be a string.');\n\n    // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n    // IE would otherwise collapse all spaces into one.\n    content = V.sanitizeText(content);\n    opt || (opt = {});\n    // Should we allow the text to be selected?\n    var displayEmpty = opt.displayEmpty;\n    // End of Line character\n    var eol = opt.eol;\n    // Text along path\n    var textPath = opt.textPath;\n    // Vertical shift\n    var verticalAnchor = opt.textVerticalAnchor;\n    var namedVerticalAnchor = verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top';\n    // Horizontal shift applied to all the lines but the first.\n    var x = opt.x;\n    if (x === undefined) x = this.attr('x') || 0;\n    // Annotations\n    var iai = opt.includeAnnotationIndices;\n    var annotations = opt.annotations;\n    if (annotations && !V.isArray(annotations)) annotations = [annotations];\n    // Shift all the <tspan> but first by one line (`1em`)\n    var defaultLineHeight = opt.lineHeight;\n    var autoLineHeight = defaultLineHeight === 'auto';\n    var lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';\n    // Clearing the element\n    this.empty();\n    this.attr({\n      // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\n      'xml:space': 'preserve',\n      // An empty text gets rendered into the DOM in webkit-based browsers.\n      // In order to unify this behaviour across all browsers\n      // we rather hide the text element when it's empty.\n      'display': content || displayEmpty ? null : 'none'\n    });\n\n    // Set default font-size if none\n    var fontSize = parseFloat(this.attr('font-size'));\n    if (!fontSize) {\n      fontSize = 16;\n      if (namedVerticalAnchor || annotations) this.attr('font-size', fontSize);\n    }\n    var doc = document;\n    var containerNode;\n    if (textPath) {\n      // Now all the `<tspan>`s will be inside the `<textPath>`.\n      if (typeof textPath === 'string') textPath = {\n        d: textPath\n      };\n      containerNode = createTextPathNode(textPath, this);\n    } else {\n      containerNode = doc.createDocumentFragment();\n    }\n    var offset = 0;\n    var lines = content.split('\\n');\n    var linesMetrics = [];\n    var annotatedY;\n    for (var i = 0, lastI = lines.length - 1; i <= lastI; i++) {\n      var dy = lineHeight;\n      var lineClassName = 'v-line';\n      var lineNode = doc.createElementNS(ns.svg, 'tspan');\n      var line = lines[i];\n      var lineMetrics;\n      if (line) {\n        if (annotations) {\n          // Find the *compacted* annotations for this line.\n          var lineAnnotations = V.annotateString(line, annotations, {\n            offset: -offset,\n            includeAnnotationIndices: iai\n          });\n          lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n            includeAnnotationIndices: iai,\n            eol: i !== lastI && eol,\n            lineHeight: autoLineHeight ? null : lineHeight,\n            baseSize: fontSize\n          });\n          // Get the line height based on the biggest font size in the annotations for this line.\n          var iLineHeight = lineMetrics.lineHeight;\n          if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;\n          if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;\n        } else {\n          if (eol && i !== lastI) line += eol;\n          lineNode.textContent = line;\n        }\n      } else {\n        // Make sure the textContent is never empty. If it is, add a dummy\n        // character and make it invisible, making the following lines correctly\n        // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n        lineNode.textContent = '-';\n        lineClassName += ' v-empty-line';\n        // 'opacity' needs to be specified with fill, stroke. Opacity without specification\n        // is not applied in Firefox\n        var lineNodeStyle = lineNode.style;\n        lineNodeStyle.fillOpacity = 0;\n        lineNodeStyle.strokeOpacity = 0;\n        if (annotations) {\n          // Empty line with annotations.\n          lineMetrics = {};\n          lineAnnotations = V.findAnnotationsAtIndex(annotations, offset);\n          let lineFontSize = fontSize;\n          // Check if any of the annotations overrides the font size.\n          for (let j = lineAnnotations.length; j > 0; j--) {\n            const attrs = lineAnnotations[j - 1].attrs;\n            if (!attrs || !('font-size' in attrs)) continue;\n            const fs = parseFloat(attrs['font-size']);\n            if (isFinite(fs)) {\n              lineFontSize = fs;\n              break;\n            }\n          }\n          if (autoLineHeight) {\n            if (i > 0) {\n              dy = lineFontSize * 1.2;\n            } else {\n              annotatedY = lineFontSize * 0.8;\n            }\n          }\n          // The font size is important for the native selection box height.\n          lineNode.setAttribute('font-size', lineFontSize);\n          lineMetrics.maxFontSize = lineFontSize;\n        }\n      }\n      if (lineMetrics) linesMetrics.push(lineMetrics);\n      if (i > 0) lineNode.setAttribute('dy', dy);\n      // Firefox requires 'x' to be set on the first line when inside a text path\n      if (i > 0 || textPath) lineNode.setAttribute('x', x);\n      lineNode.className.baseVal = lineClassName;\n      containerNode.appendChild(lineNode);\n      offset += line.length + 1; // + 1 = newline character.\n    }\n    // Y Alignment calculation\n    if (namedVerticalAnchor) {\n      if (annotations) {\n        dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n      } else if (verticalAnchor === 'top') {\n        // A shortcut for top alignment. It does not depend on font-size nor line-height\n        dy = '0.8em';\n      } else {\n        var rh; // remaining height\n        if (lastI > 0) {\n          rh = parseFloat(lineHeight) || 1;\n          rh *= lastI;\n          if (!emRegex.test(lineHeight)) rh /= fontSize;\n        } else {\n          // Single-line text\n          rh = 0;\n        }\n        switch (verticalAnchor) {\n          case 'middle':\n            dy = 0.3 - rh / 2 + 'em';\n            break;\n          case 'bottom':\n            dy = -rh - 0.3 + 'em';\n            break;\n        }\n      }\n    } else {\n      if (verticalAnchor === 0) {\n        dy = '0em';\n      } else if (verticalAnchor) {\n        dy = verticalAnchor;\n      } else {\n        // No vertical anchor is defined\n        dy = 0;\n        // Backwards compatibility - we change the `y` attribute instead of `dy`.\n        if (this.attr('y') === null) this.attr('y', annotatedY || '0.8em');\n      }\n    }\n    containerNode.firstChild.setAttribute('dy', dy);\n    // Appending lines to the element.\n    this.append(containerNode);\n    return this;\n  };\n\n  /**\n   * @public\n   * @param {string} name\n   * @returns {Vectorizer}\n   */\n  VPrototype.removeAttr = function (name) {\n    const trueName = attributeNames[name];\n    const {\n      ns,\n      local\n    } = V.qualifyAttr(trueName);\n    const el = this.node;\n    if (ns) {\n      if (el.hasAttributeNS(ns, local)) {\n        el.removeAttributeNS(ns, local);\n      }\n    } else if (el.hasAttribute(trueName)) {\n      el.removeAttribute(trueName);\n    }\n    return this;\n  };\n  VPrototype.attr = function (name, value) {\n    if (V.isUndefined(name)) {\n      // Return all attributes.\n      var attributes = this.node.attributes;\n      var attrs = {};\n      for (var i = 0; i < attributes.length; i++) {\n        attrs[attributes[i].name] = attributes[i].value;\n      }\n      return attrs;\n    }\n    if (V.isString(name) && V.isUndefined(value)) {\n      return this.node.getAttribute(attributeNames[name]);\n    }\n    if (typeof name === 'object') {\n      for (var attrName in name) {\n        if (name.hasOwnProperty(attrName)) {\n          this.setAttribute(attrName, name[attrName]);\n        }\n      }\n    } else {\n      this.setAttribute(name, value);\n    }\n    return this;\n  };\n  VPrototype.normalizePath = function () {\n    var tagName = this.tagName();\n    if (tagName === 'PATH') {\n      this.attr('d', V.normalizePathData(this.attr('d')));\n    }\n    return this;\n  };\n  VPrototype.remove = function () {\n    if (this.node.parentNode) {\n      this.node.parentNode.removeChild(this.node);\n    }\n    return this;\n  };\n  VPrototype.empty = function () {\n    while (this.node.firstChild) {\n      this.node.removeChild(this.node.firstChild);\n    }\n    return this;\n  };\n\n  /**\n   * @private\n   * @param {object} attrs\n   * @returns {Vectorizer}\n   */\n  VPrototype.setAttributes = function (attrs) {\n    for (var key in attrs) {\n      if (attrs.hasOwnProperty(key)) {\n        this.setAttribute(key, attrs[key]);\n      }\n    }\n    return this;\n  };\n  VPrototype.append = function (els) {\n    if (!V.isArray(els)) {\n      els = [els];\n    }\n    for (var i = 0, len = els.length; i < len; i++) {\n      this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]\n    }\n    return this;\n  };\n  VPrototype.prepend = function (els) {\n    var child = this.node.firstChild;\n    return child ? V(child).before(els) : this.append(els);\n  };\n  VPrototype.before = function (els) {\n    var node = this.node;\n    var parent = node.parentNode;\n    if (parent) {\n      if (!V.isArray(els)) {\n        els = [els];\n      }\n      for (var i = 0, len = els.length; i < len; i++) {\n        parent.insertBefore(V.toNode(els[i]), node);\n      }\n    }\n    return this;\n  };\n  VPrototype.appendTo = function (node) {\n    V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]\n    return this;\n  };\n  VPrototype.svg = function () {\n    return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\n  };\n  VPrototype.tagName = function () {\n    return this.node.tagName.toUpperCase();\n  };\n  VPrototype.defs = function () {\n    var context = this.svg() || this;\n    var defsNode = context.node.getElementsByTagName('defs')[0];\n    if (defsNode) return V(defsNode);\n    return V('defs').appendTo(context);\n  };\n  VPrototype.clone = function () {\n    var clone = V(this.node.cloneNode(true /* deep */));\n    // Note that clone inherits also ID. Therefore, we need to change it here.\n    clone.node.id = V.uniqueId();\n    return clone;\n  };\n  VPrototype.findOne = function (selector) {\n    var found = this.node.querySelector(selector);\n    return found ? V(found) : undefined;\n  };\n  VPrototype.find = function (selector) {\n    var vels = [];\n    var nodes = this.node.querySelectorAll(selector);\n    if (nodes) {\n      // Map DOM elements to `V`s.\n      for (var i = 0; i < nodes.length; i++) {\n        vels.push(V(nodes[i]));\n      }\n    }\n    return vels;\n  };\n\n  // Returns an array of V elements made from children of this.node.\n  VPrototype.children = function () {\n    var children = this.node.childNodes;\n    var outputArray = [];\n    for (var i = 0; i < children.length; i++) {\n      var currentChild = children[i];\n      if (currentChild.nodeType === 1) {\n        outputArray.push(V(children[i]));\n      }\n    }\n    return outputArray;\n  };\n\n  // Returns the V element from parentNode of this.node.\n  VPrototype.parent = function () {\n    return V(this.node.parentNode) || null;\n  },\n  // Find an index of an element inside its container.\n  VPrototype.index = function () {\n    var index = 0;\n    var node = this.node.previousSibling;\n    while (node) {\n      // nodeType 1 for ELEMENT_NODE\n      if (node.nodeType === 1) index++;\n      node = node.previousSibling;\n    }\n    return index;\n  };\n  VPrototype.findParentByClass = function (className, terminator) {\n    var ownerSVGElement = this.node.ownerSVGElement;\n    var node = this.node.parentNode;\n    while (node && node !== terminator && node !== ownerSVGElement) {\n      var vel = V(node);\n      if (vel.hasClass(className)) {\n        return vel;\n      }\n      node = node.parentNode;\n    }\n    return null;\n  };\n\n  // https://jsperf.com/get-common-parent\n  VPrototype.contains = function (el) {\n    var a = this.node;\n    var b = V.toNode(el);\n    var bup = b && b.parentNode;\n    return a === bup || !!(bup && bup.nodeType === 1 && a.compareDocumentPosition(bup) & 16);\n  };\n\n  // Convert global point into the coordinate space of this element.\n  VPrototype.toLocalPoint = function (x, y) {\n    var svg = this.svg().node;\n    var p = svg.createSVGPoint();\n    p.x = x;\n    p.y = y;\n    try {\n      var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\n      var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\n    } catch (e) {\n      // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\n      // We have to make do with the original coordianates.\n      return p;\n    }\n    return globalPoint.matrixTransform(globalToLocalMatrix);\n  };\n  VPrototype.translateCenterToPoint = function (p) {\n    var bbox = this.getBBox({\n      target: this.svg()\n    });\n    var center = bbox.center();\n    this.translate(p.x - center.x, p.y - center.y);\n    return this;\n  };\n\n  // Efficiently auto-orient an element. This basically implements the orient=auto attribute\n  // of markers. The easiest way of understanding on what this does is to imagine the element is an\n  // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\n  // being auto-oriented (properly rotated) towards the `reference` point.\n  // `target` is the element relative to which the transformations are applied. Usually a viewport.\n  VPrototype.translateAndAutoOrient = function (position, reference, target) {\n    position = new g.Point(position);\n    reference = new g.Point(reference);\n    target || (target = this.svg());\n\n    // Clean-up previously set transformations except the scale. If we didn't clean up the\n    // previous transformations then they'd add up with the old ones. Scale is an exception as\n    // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\n    // element is scaled by the factor 2, not 8.\n    var scale = this.scale();\n    this.attr('transform', '');\n    var bbox = this.getBBox({\n      target: target\n    }).scale(scale.sx, scale.sy);\n\n    // 1. Translate to origin.\n    var translateToOrigin = V.createSVGTransform();\n    translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n\n    // 2. Rotate around origin.\n    var rotateAroundOrigin = V.createSVGTransform();\n    var angle = position.angleBetween(reference, position.clone().offset(1, 0));\n    if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);\n\n    // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\n    var translateFromOrigin = V.createSVGTransform();\n    var finalPosition = position.clone().move(reference, bbox.width / 2);\n    translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);\n\n    // 4. Get the current transformation matrix of this node\n    var ctm = this.getTransformToElement(target);\n\n    // 5. Apply transformations and the scale\n    var transform = V.createSVGTransform();\n    transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(scale.sx, scale.sy)))));\n    this.attr('transform', V.matrixToTransformString(transform.matrix));\n    return this;\n  };\n  VPrototype.animateAlongPath = function (attrs, path) {\n    path = V.toNode(path);\n    var id = V.ensureId(path);\n    var animateMotion = V('animateMotion', attrs);\n    var mpath = V('mpath', {\n      'xlink:href': '#' + id\n    });\n    animateMotion.append(mpath);\n    this.append(animateMotion);\n    try {\n      animateMotion.node.beginElement();\n    } catch (e) {\n      // Fallback for IE 9.\n      // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present\n      if (document.documentElement.getAttribute('smiling') === 'fake') {\n        /* global getTargets:true, Animator:true, animators:true id2anim:true */\n        // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n        var animation = animateMotion.node;\n        animation.animators = [];\n        var animationID = animation.getAttribute('id');\n        if (animationID) id2anim[animationID] = animation;\n        var targets = getTargets(animation);\n        for (var i = 0, len = targets.length; i < len; i++) {\n          var target = targets[i];\n          var animator = new Animator(animation, target, i);\n          animators.push(animator);\n          animation.animators[i] = animator;\n          animator.register();\n        }\n      }\n    }\n    return this;\n  };\n\n  // Split a string into an array of tokens.\n  // https://infra.spec.whatwg.org/#ascii-whitespace\n  const noHTMLWhitespaceRegex = /[^\\x20\\t\\r\\n\\f]+/g;\n  function getTokenList(str) {\n    if (!V.isString(str)) return [];\n    return str.trim().match(noHTMLWhitespaceRegex) || [];\n  }\n  VPrototype.hasClass = function (className) {\n    if (!V.isString(className)) return false;\n    return this.node.classList.contains(className.trim());\n  };\n  VPrototype.addClass = function (className) {\n    this.node.classList.add(...getTokenList(className));\n    return this;\n  };\n  VPrototype.removeClass = function (className) {\n    this.node.classList.remove(...getTokenList(className));\n    return this;\n  };\n  VPrototype.toggleClass = function (className, toAdd) {\n    const tokens = getTokenList(className);\n    for (let i = 0; i < tokens.length; i++) {\n      this.node.classList.toggle(tokens[i], toAdd);\n    }\n    return this;\n  };\n\n  // Interpolate path by discrete points. The precision of the sampling\n  // is controlled by `interval`. In other words, `sample()` will generate\n  // a point on the path starting at the beginning of the path going to the end\n  // every `interval` pixels.\n  // The sampler can be very useful for e.g. finding intersection between two\n  // paths (finding the two closest points from two samples).\n  VPrototype.sample = function (interval) {\n    interval = interval || 1;\n    var node = this.node;\n    var length = node.getTotalLength();\n    var samples = [];\n    var distance = 0;\n    var sample;\n    while (distance < length) {\n      sample = node.getPointAtLength(distance);\n      samples.push({\n        x: sample.x,\n        y: sample.y,\n        distance: distance\n      });\n      distance += interval;\n    }\n    return samples;\n  };\n  VPrototype.convertToPath = function () {\n    var path = V('path');\n    path.attr(this.attr());\n    var d = this.convertToPathData();\n    if (d) {\n      path.attr('d', d);\n    }\n    return path;\n  };\n  VPrototype.convertToPathData = function () {\n    var tagName = this.tagName();\n    switch (tagName) {\n      case 'PATH':\n        return this.attr('d');\n      case 'LINE':\n        return V.convertLineToPathData(this.node);\n      case 'POLYGON':\n        return V.convertPolygonToPathData(this.node);\n      case 'POLYLINE':\n        return V.convertPolylineToPathData(this.node);\n      case 'ELLIPSE':\n        return V.convertEllipseToPathData(this.node);\n      case 'CIRCLE':\n        return V.convertCircleToPathData(this.node);\n      case 'RECT':\n        return V.convertRectToPathData(this.node);\n    }\n    throw new Error(tagName + ' cannot be converted to PATH.');\n  };\n  V.prototype.toGeometryShape = function () {\n    var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;\n    switch (this.tagName()) {\n      case 'RECT':\n        x = parseFloat(this.attr('x')) || 0;\n        y = parseFloat(this.attr('y')) || 0;\n        width = parseFloat(this.attr('width')) || 0;\n        height = parseFloat(this.attr('height')) || 0;\n        return new g.Rect(x, y, width, height);\n      case 'CIRCLE':\n        cx = parseFloat(this.attr('cx')) || 0;\n        cy = parseFloat(this.attr('cy')) || 0;\n        r = parseFloat(this.attr('r')) || 0;\n        return new g.Ellipse({\n          x: cx,\n          y: cy\n        }, r, r);\n      case 'ELLIPSE':\n        cx = parseFloat(this.attr('cx')) || 0;\n        cy = parseFloat(this.attr('cy')) || 0;\n        rx = parseFloat(this.attr('rx')) || 0;\n        ry = parseFloat(this.attr('ry')) || 0;\n        return new g.Ellipse({\n          x: cx,\n          y: cy\n        }, rx, ry);\n      case 'POLYLINE':\n        points = V.getPointsFromSvgNode(this);\n        return new g.Polyline(points);\n      case 'POLYGON':\n        points = V.getPointsFromSvgNode(this);\n        if (points.length > 1) points.push(points[0]);\n        return new g.Polyline(points);\n      case 'PATH':\n        d = this.attr('d');\n        if (!g.Path.isDataSupported(d)) d = V.normalizePathData(d);\n        return new g.Path(d);\n      case 'LINE':\n        x1 = parseFloat(this.attr('x1')) || 0;\n        y1 = parseFloat(this.attr('y1')) || 0;\n        x2 = parseFloat(this.attr('x2')) || 0;\n        y2 = parseFloat(this.attr('y2')) || 0;\n        return new g.Line({\n          x: x1,\n          y: y1\n        }, {\n          x: x2,\n          y: y2\n        });\n    }\n\n    // Anything else is a rectangle\n    return this.getBBox();\n  };\n\n  // Find the intersection of a line starting in the center\n  // of the SVG `node` ending in the point `ref`.\n  // `target` is an SVG element to which `node`s transformations are relative to.\n  // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\n  // Returns a point in the `target` coordinate system (the same system as `ref` is in) if\n  // an intersection is found. Returns `undefined` otherwise.\n  VPrototype.findIntersection = function (ref, target) {\n    var svg = this.svg().node;\n    target = target || svg;\n    var bbox = this.getBBox({\n      target: target\n    });\n    var center = bbox.center();\n    if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;\n    var spot;\n    var tagName = this.tagName();\n\n    // Little speed up optimization for `<rect>` element. We do not do conversion\n    // to path element and sampling but directly calculate the intersection through\n    // a transformed geometrical rectangle.\n    if (tagName === 'RECT') {\n      var gRect = new g.Rect(parseFloat(this.attr('x') || 0), parseFloat(this.attr('y') || 0), parseFloat(this.attr('width')), parseFloat(this.attr('height')));\n      // Get the rect transformation matrix with regards to the SVG document.\n      var rectMatrix = this.getTransformToElement(target);\n      // Decompose the matrix to find the rotation angle.\n      var rectMatrixComponents = V.decomposeMatrix(rectMatrix);\n      // Now we want to rotate the rectangle back so that we\n      // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\n      var resetRotation = svg.createSVGTransform();\n      resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n      var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\n      spot = new g.Rect(rect).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n    } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {\n      var pathNode = tagName === 'PATH' ? this : this.convertToPath();\n      var samples = pathNode.sample();\n      var minDistance = Infinity;\n      var closestSamples = [];\n      var i, sample, gp, centerDistance, refDistance, distance;\n      for (i = 0; i < samples.length; i++) {\n        sample = samples[i];\n        // Convert the sample point in the local coordinate system to the global coordinate system.\n        gp = V.createSVGPoint(sample.x, sample.y);\n        gp = gp.matrixTransform(this.getTransformToElement(target));\n        sample = new g.Point(gp);\n        centerDistance = sample.distance(center);\n        // Penalize a higher distance to the reference point by 10%.\n        // This gives better results. This is due to\n        // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n        refDistance = sample.distance(ref) * 1.1;\n        distance = centerDistance + refDistance;\n        if (distance < minDistance) {\n          minDistance = distance;\n          closestSamples = [{\n            sample: sample,\n            refDistance: refDistance\n          }];\n        } else if (distance < minDistance + 1) {\n          closestSamples.push({\n            sample: sample,\n            refDistance: refDistance\n          });\n        }\n      }\n      closestSamples.sort(function (a, b) {\n        return a.refDistance - b.refDistance;\n      });\n      if (closestSamples[0]) {\n        spot = closestSamples[0].sample;\n      }\n    }\n    return spot;\n  };\n\n  /**\n   * @private\n   * @param {string} name\n   * @param {string} value\n   * @returns {Vectorizer}\n   */\n  VPrototype.setAttribute = function (name, value) {\n    const el = this.node;\n    if (value === null) {\n      this.removeAttr(name);\n      return this;\n    }\n    const trueName = attributeNames[name];\n    const {\n      ns\n    } = V.qualifyAttr(trueName);\n    if (ns) {\n      // Attribute names can be namespaced. E.g. `image` elements\n      // have a `xlink:href` attribute to set the source of the image.\n      el.setAttributeNS(ns, trueName, value);\n    } else if (trueName === 'id') {\n      el.id = value;\n    } else {\n      el.setAttribute(trueName, value);\n    }\n    return this;\n  };\n\n  // Create an SVG document element.\n  // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\n  V.createSvgDocument = function (content) {\n    if (content) {\n      const XMLString = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${SVGVersion}\">${content}</svg>`;\n      const {\n        documentElement\n      } = V.parseXML(XMLString, {\n        async: false\n      });\n      return documentElement;\n    }\n    const svg = document.createElementNS(ns.svg, 'svg');\n    svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);\n    svg.setAttribute('version', SVGVersion);\n    return svg;\n  };\n  V.createSVGStyle = function (stylesheet) {\n    const {\n      node\n    } = V('style', {\n      type: 'text/css'\n    }, [V.createCDATASection(stylesheet)]);\n    return node;\n  }, V.createCDATASection = function (data = '') {\n    const xml = document.implementation.createDocument(null, 'xml', null);\n    return xml.createCDATASection(data);\n  };\n  V.idCounter = 0;\n\n  // A function returning a unique identifier for this client session with every call.\n  V.uniqueId = function () {\n    return 'v-' + ++V.idCounter;\n  };\n  V.toNode = function (el) {\n    return V.isV(el) ? el.node : el.nodeName && el || el[0];\n  };\n  V.ensureId = function (node) {\n    node = V.toNode(node);\n    return node.id || (node.id = V.uniqueId());\n  };\n\n  // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n  // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\n  // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\n  // when you want to compare the actual DOM text content without having to add the unicode character in\n  // the place of all spaces.\n  V.sanitizeText = function (text) {\n    return (text || '').replace(/ /g, '\\u00A0');\n  };\n  V.isUndefined = function (value) {\n    return typeof value === 'undefined';\n  };\n  V.isString = function (value) {\n    return typeof value === 'string';\n  };\n  V.isObject = function (value) {\n    return value && typeof value === 'object';\n  };\n  V.isArray = Array.isArray;\n  V.parseXML = function (data, opt) {\n    opt = opt || {};\n    var xml;\n    try {\n      var parser = new DOMParser();\n      if (!V.isUndefined(opt.async)) {\n        parser.async = opt.async;\n      }\n      xml = parser.parseFromString(data, 'text/xml');\n    } catch (error) {\n      xml = undefined;\n    }\n    if (!xml || xml.getElementsByTagName('parsererror').length) {\n      throw new Error('Invalid XML: ' + data);\n    }\n    return xml;\n  };\n\n  // Create an empty object which does not inherit any properties from `Object.prototype`.\n  // This is useful when we want to use an object as a dictionary without having to\n  // worry about inherited properties such as `toString`, `valueOf` etc.\n  const _attributeNames = Object.create(null);\n\n  // List of attributes for which not to split camel case words.\n  // It contains known SVG attribute names and may be extended with user-defined attribute names.\n  ['baseFrequency', 'baseProfile', 'clipPathUnits', 'contentScriptType', 'contentStyleType', 'diffuseConstant', 'edgeMode', 'externalResourcesRequired', 'filterRes',\n  // deprecated\n  'filterUnits', 'gradientTransform', 'gradientUnits', 'kernelMatrix', 'kernelUnitLength', 'keyPoints', 'lengthAdjust', 'limitingConeAngle', 'markerHeight', 'markerUnits', 'markerWidth', 'maskContentUnits', 'maskUnits', 'numOctaves', 'pathLength', 'patternContentUnits', 'patternTransform', 'patternUnits', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'preserveAlpha', 'preserveAspectRatio', 'primitiveUnits', 'refX', 'refY', 'requiredExtensions', 'requiredFeatures', 'specularConstant', 'specularExponent', 'spreadMethod', 'startOffset', 'stdDeviation', 'stitchTiles', 'surfaceScale', 'systemLanguage', 'tableValues', 'targetX', 'targetY', 'textLength', 'viewBox', 'viewTarget',\n  // deprecated\n  'xChannelSelector', 'yChannelSelector', 'zoomAndPan' // deprecated\n  ].forEach(name => _attributeNames[name] = name);\n  _attributeNames['xlinkShow'] = 'xlink:show';\n  _attributeNames['xlinkRole'] = 'xlink:role';\n  _attributeNames['xlinkActuate'] = 'xlink:actuate';\n  _attributeNames['xlinkHref'] = 'xlink:href';\n  _attributeNames['xlinkType'] = 'xlink:type';\n  _attributeNames['xlinkTitle'] = 'xlink:title';\n  _attributeNames['xmlBase'] = 'xml:base';\n  _attributeNames['xmlLang'] = 'xml:lang';\n  _attributeNames['xmlSpace'] = 'xml:space';\n  const attributeNames = new Proxy(_attributeNames, {\n    get(cache, name) {\n      // The cache is a dictionary of attribute names. See `_attributeNames` above.\n      // If the attribute name is not in the cache, it means that it is not\n      // a camel-case attribute name. In that case, we need to convert\n      // the attribute name to dash-separated words.\n      if (!V.supportCamelCaseAttributes) return name;\n      if (name in cache) {\n        return cache[name];\n      }\n      // Convert camel case to dash-separated words.\n      return cache[name] = name.replace(/[A-Z]/g, '-$&').toLowerCase();\n    }\n  });\n\n  // Dictionary of attribute names\n  Object.defineProperty(V, 'attributeNames', {\n    enumerable: true,\n    value: attributeNames,\n    writable: false\n  });\n\n  // Should camel case attributes be supported?\n  Object.defineProperty(V, 'supportCamelCaseAttributes', {\n    enumerable: true,\n    value: true,\n    writable: true\n  });\n\n  /**\n   * @param {string} name\n   * @returns {{ns: string|null, local: string}} namespace and attribute name\n   */\n  V.qualifyAttr = function (name) {\n    if (name.indexOf(':') !== -1) {\n      var combinedKey = name.split(':');\n      return {\n        ns: ns[combinedKey[0]],\n        local: combinedKey[1]\n      };\n    }\n    return {\n      ns: null,\n      local: name\n    };\n  };\n\n  // Note: This regex allows multiple commas as separator which is incorrect in SVG\n  // This regex is used by `split()`, so it doesn't need to use /g\n  V.transformSeparatorRegex = /[ ,]+/;\n  // Note: All following regexes are more restrictive than SVG specification\n  // ReDoS mitigation: Use an anchor at the beginning of the match\n  // ReDoS mitigation: Avoid backtracking (uses `[^()]+` instead of `.*?`)\n  // ReDoS mitigation: Don't match initial `(` inside repeated part\n  // The following regex needs to use /g (= cannot use capturing groups)\n  V.transformRegex = /\\b\\w+\\([^()]+\\)/g;\n  // The following regexes need to use capturing groups (= cannot use /g)\n  V.transformFunctionRegex = /\\b(\\w+)\\(([^()]+)\\)/;\n  V.transformTranslateRegex = /\\btranslate\\(([^()]+)\\)/;\n  V.transformRotateRegex = /\\brotate\\(([^()]+)\\)/;\n  V.transformScaleRegex = /\\bscale\\(([^()]+)\\)/;\n  V.transformStringToMatrix = function (transform) {\n    // Initialize result matrix as identity matrix\n    let transformationMatrix = V.createSVGMatrix();\n\n    // Note: Multiple transform functions are allowed in `transform` string\n    // `match()` returns `null` if none found\n    const transformMatches = transform && transform.match(V.transformRegex);\n    if (!transformMatches) {\n      // Return identity matrix\n      return transformationMatrix;\n    }\n    const numMatches = transformMatches.length;\n    for (let i = 0; i < numMatches; i++) {\n      const transformMatch = transformMatches[i];\n      // Use same regex as above, but with capturing groups\n      // `match()` returns values of capturing groups as `[1]`, `[2]`\n      const transformFunctionMatch = transformMatch.match(V.transformFunctionRegex);\n      if (transformFunctionMatch) {\n        let sx, sy, tx, ty, angle;\n        let ctm = V.createSVGMatrix();\n        const transformFunction = transformFunctionMatch[1].toLowerCase();\n        const args = transformFunctionMatch[2].split(V.transformSeparatorRegex);\n        switch (transformFunction) {\n          case 'scale':\n            sx = parseFloat(args[0]);\n            sy = args[1] === undefined ? sx : parseFloat(args[1]);\n            ctm = ctm.scaleNonUniform(sx, sy);\n            break;\n          case 'translate':\n            tx = parseFloat(args[0]);\n            ty = parseFloat(args[1]);\n            ctm = ctm.translate(tx, ty);\n            break;\n          case 'rotate':\n            angle = parseFloat(args[0]);\n            tx = parseFloat(args[1]) || 0;\n            ty = parseFloat(args[2]) || 0;\n            if (tx !== 0 || ty !== 0) {\n              ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n            } else {\n              ctm = ctm.rotate(angle);\n            }\n            break;\n          case 'skewx':\n            angle = parseFloat(args[0]);\n            ctm = ctm.skewX(angle);\n            break;\n          case 'skewy':\n            angle = parseFloat(args[0]);\n            ctm = ctm.skewY(angle);\n            break;\n          case 'matrix':\n            ctm.a = parseFloat(args[0]);\n            ctm.b = parseFloat(args[1]);\n            ctm.c = parseFloat(args[2]);\n            ctm.d = parseFloat(args[3]);\n            ctm.e = parseFloat(args[4]);\n            ctm.f = parseFloat(args[5]);\n            break;\n          default:\n            continue;\n        }\n\n        // Multiply current transformation into result matrix\n        transformationMatrix = transformationMatrix.multiply(ctm);\n      }\n    }\n    return transformationMatrix;\n  };\n  V.matrixToTransformString = function (matrix) {\n    matrix || (matrix = true);\n    return 'matrix(' + (matrix.a !== undefined ? matrix.a : 1) + ',' + (matrix.b !== undefined ? matrix.b : 0) + ',' + (matrix.c !== undefined ? matrix.c : 0) + ',' + (matrix.d !== undefined ? matrix.d : 1) + ',' + (matrix.e !== undefined ? matrix.e : 0) + ',' + (matrix.f !== undefined ? matrix.f : 0) + ')';\n  };\n  V.parseTransformString = function (transform) {\n    var translate, rotate, scale;\n    if (transform) {\n      var separator = V.transformSeparatorRegex;\n\n      // Special handling for `transform` with one or more matrix functions\n      if (transform.trim().indexOf('matrix') >= 0) {\n        // Convert EVERYTHING in `transform` string to a matrix\n        // Will combine ALL matrixes * ALL translates * ALL scales * ALL rotates\n        // Note: In non-matrix case, we only take first one of each (if any)\n        var matrix = V.transformStringToMatrix(transform);\n        var decomposedMatrix = V.decomposeMatrix(matrix);\n\n        // Extract `translate`, `scale`, `rotate` from matrix\n        translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n        scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n        rotate = [decomposedMatrix.rotation];\n\n        // Rewrite `transform` string in `translate scale rotate` format\n        var transformations = [];\n        if (translate[0] !== 0 || translate[1] !== 0) {\n          transformations.push('translate(' + translate + ')');\n        }\n        if (scale[0] !== 1 || scale[1] !== 1) {\n          transformations.push('scale(' + scale + ')');\n        }\n        if (rotate[0] !== 0) {\n          transformations.push('rotate(' + rotate + ')');\n        }\n        transform = transformations.join(' ');\n      } else {\n        // Extract `translate`, `rotate`, `scale` functions from `transform` string\n        // Note: We only detect the first match of each (if any)\n        // `match()` returns value of capturing group as `[1]`\n        const translateMatch = transform.match(V.transformTranslateRegex);\n        if (translateMatch) {\n          translate = translateMatch[1].split(separator);\n        }\n        const rotateMatch = transform.match(V.transformRotateRegex);\n        if (rotateMatch) {\n          rotate = rotateMatch[1].split(separator);\n        }\n        const scaleMatch = transform.match(V.transformScaleRegex);\n        if (scaleMatch) {\n          scale = scaleMatch[1].split(separator);\n        }\n      }\n    }\n    var sx = scale && scale[0] ? parseFloat(scale[0]) : 1;\n    return {\n      value: transform,\n      translate: {\n        tx: translate && translate[0] ? parseInt(translate[0], 10) : 0,\n        ty: translate && translate[1] ? parseInt(translate[1], 10) : 0\n      },\n      rotate: {\n        angle: rotate && rotate[0] ? parseInt(rotate[0], 10) : 0,\n        cx: rotate && rotate[1] ? parseInt(rotate[1], 10) : undefined,\n        cy: rotate && rotate[2] ? parseInt(rotate[2], 10) : undefined\n      },\n      scale: {\n        sx: sx,\n        sy: scale && scale[1] ? parseFloat(scale[1]) : sx\n      }\n    };\n  };\n  V.deltaTransformPoint = function (matrix, point) {\n    var dx = point.x * matrix.a + point.y * matrix.c + 0;\n    var dy = point.x * matrix.b + point.y * matrix.d + 0;\n    return {\n      x: dx,\n      y: dy\n    };\n  };\n  V.decomposeMatrix = function (matrix) {\n    // @see https://gist.github.com/2052247\n\n    // calculate delta transform point\n    var px = V.deltaTransformPoint(matrix, {\n      x: 0,\n      y: 1\n    });\n    var py = V.deltaTransformPoint(matrix, {\n      x: 1,\n      y: 0\n    });\n\n    // calculate skew\n    var skewX = 180 / PI * atan2(px.y, px.x) - 90;\n    var skewY = 180 / PI * atan2(py.y, py.x);\n    return {\n      translateX: matrix.e,\n      translateY: matrix.f,\n      scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n      scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n      skewX: skewX,\n      skewY: skewY,\n      rotation: skewX // rotation is the same as skew x\n    };\n  };\n\n  // Return the `scale` transformation from the following equation:\n  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n  V.matrixToScale = function (matrix) {\n    var a, b, c, d;\n    if (matrix) {\n      a = V.isUndefined(matrix.a) ? 1 : matrix.a;\n      d = V.isUndefined(matrix.d) ? 1 : matrix.d;\n      b = matrix.b;\n      c = matrix.c;\n    } else {\n      a = d = 1;\n    }\n    return {\n      sx: b ? sqrt(a * a + b * b) : a,\n      sy: c ? sqrt(c * c + d * d) : d\n    };\n  };\n\n  // Return the `rotate` transformation from the following equation:\n  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n  V.matrixToRotate = function (matrix) {\n    var p = {\n      x: 0,\n      y: 1\n    };\n    if (matrix) {\n      p = V.deltaTransformPoint(matrix, p);\n    }\n    return {\n      angle: g.normalizeAngle(g.toDeg(atan2(p.y, p.x)) - 90)\n    };\n  };\n\n  // Return the `translate` transformation from the following equation:\n  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n  V.matrixToTranslate = function (matrix) {\n    return {\n      tx: matrix && matrix.e || 0,\n      ty: matrix && matrix.f || 0\n    };\n  };\n  V.isV = function (object) {\n    return object instanceof V;\n  };\n\n  // For backwards compatibility:\n  V.isVElement = V.isV;\n\n  // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`\n  // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n  V.isSVGGraphicsElement = function (node) {\n    if (!node) return false;\n    node = V.toNode(node);\n    // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below\n    return node instanceof SVGElement && typeof node.getScreenCTM === 'function';\n  };\n  var svgDocument = V('svg').node;\n  V.createSVGMatrix = function (matrix) {\n    var svgMatrix = svgDocument.createSVGMatrix();\n    for (var component in matrix) {\n      svgMatrix[component] = matrix[component];\n    }\n    return svgMatrix;\n  };\n  V.createSVGTransform = function (matrix) {\n    if (!V.isUndefined(matrix)) {\n      if (!(matrix instanceof SVGMatrix)) {\n        matrix = V.createSVGMatrix(matrix);\n      }\n      return svgDocument.createSVGTransformFromMatrix(matrix);\n    }\n    return svgDocument.createSVGTransform();\n  };\n  V.createSVGPoint = function (x, y) {\n    var p = svgDocument.createSVGPoint();\n    p.x = x;\n    p.y = y;\n    return p;\n  };\n  V.transformRect = function (r, matrix) {\n    var p = svgDocument.createSVGPoint();\n    p.x = r.x;\n    p.y = r.y;\n    var corner1 = p.matrixTransform(matrix);\n    p.x = r.x + r.width;\n    p.y = r.y;\n    var corner2 = p.matrixTransform(matrix);\n    p.x = r.x + r.width;\n    p.y = r.y + r.height;\n    var corner3 = p.matrixTransform(matrix);\n    p.x = r.x;\n    p.y = r.y + r.height;\n    var corner4 = p.matrixTransform(matrix);\n    var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);\n    var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);\n    var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);\n    var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);\n    return new g.Rect(minX, minY, maxX - minX, maxY - minY);\n  };\n  V.transformPoint = function (p, matrix) {\n    return new g.Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\n  };\n  V.transformLine = function (l, matrix) {\n    return new g.Line(V.transformPoint(l.start, matrix), V.transformPoint(l.end, matrix));\n  };\n  V.transformPolyline = function (p, matrix) {\n    var inPoints = p instanceof g.Polyline ? p.points : p;\n    if (!V.isArray(inPoints)) inPoints = [];\n    var outPoints = [];\n    for (var i = 0, n = inPoints.length; i < n; i++) outPoints[i] = V.transformPoint(inPoints[i], matrix);\n    return new g.Polyline(outPoints);\n  };\n\n  // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\n  // an object (`{ fill: 'blue', stroke: 'red' }`).\n  V.styleToObject = function (styleString) {\n    var ret = {};\n    var styles = styleString.split(';');\n    for (var i = 0; i < styles.length; i++) {\n      var style = styles[i];\n      var pair = style.split('=');\n      ret[pair[0].trim()] = pair[1].trim();\n    }\n    return ret;\n  };\n\n  // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n  V.createSlicePathData = function (innerRadius, outerRadius, startAngle, endAngle) {\n    var svgArcMax = 2 * PI - 1e-6;\n    var r0 = innerRadius;\n    var r1 = outerRadius;\n    var a0 = startAngle;\n    var a1 = endAngle;\n    var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\n    var df = da < PI ? '0' : '1';\n    var c0 = cos(a0);\n    var s0 = sin(a0);\n    var c1 = cos(a1);\n    var s1 = sin(a1);\n    return da >= svgArcMax ? r0 ? 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1 + 'M0,' + r0 + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + -r0 + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0 + 'Z' : 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1 + 'Z' : r0 ? 'M' + r1 * c0 + ',' + r1 * s0 + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1 + 'L' + r0 * c1 + ',' + r0 * s1 + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0 + 'Z' : 'M' + r1 * c0 + ',' + r1 * s0 + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1 + 'L0,0' + 'Z';\n  };\n\n  // Merge attributes from object `b` with attributes in object `a`.\n  // Note that this modifies the object `a`.\n  // Also important to note that attributes are merged but CSS classes are concatenated.\n  V.mergeAttrs = function (a, b) {\n    for (var attr in b) {\n      if (attr === 'class') {\n        // Concatenate classes.\n        a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];\n      } else if (attr === 'style') {\n        // `style` attribute can be an object.\n        if (V.isObject(a[attr]) && V.isObject(b[attr])) {\n          // `style` stored in `a` is an object.\n          a[attr] = V.mergeAttrs(a[attr], b[attr]);\n        } else if (V.isObject(a[attr])) {\n          // `style` in `a` is an object but it's a string in `b`.\n          // Convert the style represented as a string to an object in `b`.\n          a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\n        } else if (V.isObject(b[attr])) {\n          // `style` in `a` is a string, in `b` it's an object.\n          a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\n        } else {\n          // Both styles are strings.\n          a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\n        }\n      } else {\n        a[attr] = b[attr];\n      }\n    }\n    return a;\n  };\n  V.annotateString = function (t, annotations, opt) {\n    annotations = annotations || [];\n    opt = opt || {};\n    var offset = opt.offset || 0;\n    var compacted = [];\n    var batch;\n    var ret = [];\n    var item;\n    var prev;\n    for (var i = 0; i < t.length; i++) {\n      item = ret[i] = t[i];\n      for (var j = 0; j < annotations.length; j++) {\n        var annotation = annotations[j];\n        var start = annotation.start + offset;\n        var end = annotation.end + offset;\n        if (i >= start && i < end) {\n          // Annotation applies.\n          if (V.isObject(item)) {\n            // There is more than one annotation to be applied => Merge attributes.\n            item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\n          } else {\n            item = ret[i] = {\n              t: t[i],\n              attrs: annotation.attrs\n            };\n          }\n          if (opt.includeAnnotationIndices) {\n            (item.annotations || (item.annotations = [])).push(j);\n          }\n        }\n      }\n      prev = ret[i - 1];\n      if (!prev) {\n        batch = item;\n      } else if (V.isObject(item) && V.isObject(prev)) {\n        // Both previous item and the current one are annotations. If the attributes\n        // didn't change, merge the text.\n        if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {\n          batch.t += item.t;\n        } else {\n          compacted.push(batch);\n          batch = item;\n        }\n      } else if (V.isObject(item)) {\n        // Previous item was a string, current item is an annotation.\n        compacted.push(batch);\n        batch = item;\n      } else if (V.isObject(prev)) {\n        // Previous item was an annotation, current item is a string.\n        compacted.push(batch);\n        batch = item;\n      } else {\n        // Both previous and current item are strings.\n        batch = (batch || '') + item;\n      }\n    }\n    if (batch) {\n      compacted.push(batch);\n    }\n    return compacted;\n  };\n  V.findAnnotationsAtIndex = function (annotations, index) {\n    var found = [];\n    if (annotations) {\n      annotations.forEach(function (annotation) {\n        if (annotation.start < index && index <= annotation.end) {\n          found.push(annotation);\n        }\n      });\n    }\n    return found;\n  };\n  V.findAnnotationsBetweenIndexes = function (annotations, start, end) {\n    var found = [];\n    if (annotations) {\n      annotations.forEach(function (annotation) {\n        if (start >= annotation.start && start < annotation.end || end > annotation.start && end <= annotation.end || annotation.start >= start && annotation.end < end) {\n          found.push(annotation);\n        }\n      });\n    }\n    return found;\n  };\n\n  // Shift all the text annotations after character `index` by `offset` positions.\n  V.shiftAnnotations = function (annotations, index, offset) {\n    if (annotations) {\n      annotations.forEach(function (annotation) {\n        if (annotation.start < index && annotation.end >= index) {\n          annotation.end += offset;\n        } else if (annotation.start >= index) {\n          annotation.start += offset;\n          annotation.end += offset;\n        }\n      });\n    }\n    return annotations;\n  };\n  V.convertLineToPathData = function (line) {\n    line = V(line);\n    var d = ['M', line.attr('x1'), line.attr('y1'), 'L', line.attr('x2'), line.attr('y2')].join(' ');\n    return d;\n  };\n  V.convertPolygonToPathData = function (polygon) {\n    var points = V.getPointsFromSvgNode(polygon);\n    if (points.length === 0) return null;\n    return V.svgPointsToPath(points) + ' Z';\n  };\n  V.convertPolylineToPathData = function (polyline) {\n    var points = V.getPointsFromSvgNode(polyline);\n    if (points.length === 0) return null;\n    return V.svgPointsToPath(points);\n  };\n  V.svgPointsToPath = function (points) {\n    for (var i = 0, n = points.length; i < n; i++) {\n      points[i] = points[i].x + ' ' + points[i].y;\n    }\n    return 'M ' + points.join(' L');\n  };\n  V.getPointsFromSvgNode = function (node) {\n    node = V.toNode(node);\n    var points = [];\n    var nodePoints = node.points;\n    if (nodePoints) {\n      for (var i = 0, n = nodePoints.numberOfItems; i < n; i++) {\n        points.push(nodePoints.getItem(i));\n      }\n    }\n    return points;\n  };\n  V.KAPPA = 0.551784;\n  V.convertCircleToPathData = function (circle) {\n    circle = V(circle);\n    var cx = parseFloat(circle.attr('cx')) || 0;\n    var cy = parseFloat(circle.attr('cy')) || 0;\n    var r = parseFloat(circle.attr('r'));\n    var cd = r * V.KAPPA; // Control distance.\n\n    var d = ['M', cx, cy - r,\n    // Move to the first point.\n    'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy,\n    // I. Quadrant.\n    'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r,\n    // II. Quadrant.\n    'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy,\n    // III. Quadrant.\n    'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r,\n    // IV. Quadrant.\n    'Z'].join(' ');\n    return d;\n  };\n  V.convertEllipseToPathData = function (ellipse) {\n    ellipse = V(ellipse);\n    var cx = parseFloat(ellipse.attr('cx')) || 0;\n    var cy = parseFloat(ellipse.attr('cy')) || 0;\n    var rx = parseFloat(ellipse.attr('rx'));\n    var ry = parseFloat(ellipse.attr('ry')) || rx;\n    var cdx = rx * V.KAPPA; // Control distance x.\n    var cdy = ry * V.KAPPA; // Control distance y.\n\n    var d = ['M', cx, cy - ry,\n    // Move to the first point.\n    'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy,\n    // I. Quadrant.\n    'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry,\n    // II. Quadrant.\n    'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy,\n    // III. Quadrant.\n    'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry,\n    // IV. Quadrant.\n    'Z'].join(' ');\n    return d;\n  };\n  V.convertRectToPathData = function (rect) {\n    rect = V(rect);\n    return V.rectToPath({\n      x: parseFloat(rect.attr('x')) || 0,\n      y: parseFloat(rect.attr('y')) || 0,\n      width: parseFloat(rect.attr('width')) || 0,\n      height: parseFloat(rect.attr('height')) || 0,\n      rx: parseFloat(rect.attr('rx')) || 0,\n      ry: parseFloat(rect.attr('ry')) || 0\n    });\n  };\n\n  // Convert a rectangle to SVG path commands. `r` is an object of the form:\n  // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\n  // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\n  // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\n  // that has only `rx` and `ry` attributes).\n  V.rectToPath = function (r) {\n    var d;\n    var x = r.x;\n    var y = r.y;\n    var width = r.width;\n    var height = r.height;\n    var topRx = min(r.rx || r['top-rx'] || 0, width / 2);\n    var bottomRx = min(r.rx || r['bottom-rx'] || 0, width / 2);\n    var topRy = min(r.ry || r['top-ry'] || 0, height / 2);\n    var bottomRy = min(r.ry || r['bottom-ry'] || 0, height / 2);\n    if (topRx || bottomRx || topRy || bottomRy) {\n      d = ['M', x, y + topRy, 'v', height - topRy - bottomRy, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy, 'h', width - 2 * bottomRx, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy, 'v', -(height - bottomRy - topRy), 'a', topRx, topRy, 0, 0, 0, -topRx, -topRy, 'h', -(width - 2 * topRx), 'a', topRx, topRy, 0, 0, 0, -topRx, topRy, 'Z'];\n    } else {\n      d = ['M', x, y, 'H', x + width, 'V', y + height, 'H', x, 'V', y, 'Z'];\n    }\n    return d.join(' ');\n  };\n\n  // Take a path data string\n  // Return a normalized path data string\n  // If data cannot be parsed, return 'M 0 0'\n  // Highly inspired by Raphael Library (www.raphael.com)\n  V.normalizePathData = function () {\n    var spaces = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\n    var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', 'ig');\n    var pathValues = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');\n    var math = Math;\n    var PI = math.PI;\n    var sin = math.sin;\n    var cos = math.cos;\n    var tan = math.tan;\n    var asin = math.asin;\n    var sqrt = math.sqrt;\n    var abs = math.abs;\n    function q2c(x1, y1, ax, ay, x2, y2) {\n      var _13 = 1 / 3;\n      var _23 = 2 / 3;\n      return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];\n    }\n    function rotate(x, y, rad) {\n      var X = x * cos(rad) - y * sin(rad);\n      var Y = x * sin(rad) + y * cos(rad);\n      return {\n        x: X,\n        y: Y\n      };\n    }\n    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n      // for more information of where this math came from visit:\n      // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n      var _120 = PI * 120 / 180;\n      var rad = PI / 180 * (+angle || 0);\n      var res = [];\n      var xy;\n      if (!recursive) {\n        xy = rotate(x1, y1, -rad);\n        x1 = xy.x;\n        y1 = xy.y;\n        xy = rotate(x2, y2, -rad);\n        x2 = xy.x;\n        y2 = xy.y;\n        var x = (x1 - x2) / 2;\n        var y = (y1 - y2) / 2;\n        var h = x * x / (rx * rx) + y * y / (ry * ry);\n        if (h > 1) {\n          h = sqrt(h);\n          rx = h * rx;\n          ry = h * ry;\n        }\n        var rx2 = rx * rx;\n        var ry2 = ry * ry;\n        var k = (large_arc_flag == sweep_flag ? -1 : 1) * sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n        var cx = k * rx * y / ry + (x1 + x2) / 2;\n        var cy = k * -ry * x / rx + (y1 + y2) / 2;\n        var f1 = asin(((y1 - cy) / ry).toFixed(9));\n        var f2 = asin(((y2 - cy) / ry).toFixed(9));\n        f1 = x1 < cx ? PI - f1 : f1;\n        f2 = x2 < cx ? PI - f2 : f2;\n        if (f1 < 0) f1 = PI * 2 + f1;\n        if (f2 < 0) f2 = PI * 2 + f2;\n        if (sweep_flag && f1 > f2) f1 = f1 - PI * 2;\n        if (!sweep_flag && f2 > f1) f2 = f2 - PI * 2;\n      } else {\n        f1 = recursive[0];\n        f2 = recursive[1];\n        cx = recursive[2];\n        cy = recursive[3];\n      }\n      var df = f2 - f1;\n      if (abs(df) > _120) {\n        var f2old = f2;\n        var x2old = x2;\n        var y2old = y2;\n        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n        x2 = cx + rx * cos(f2);\n        y2 = cy + ry * sin(f2);\n        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n      }\n      df = f2 - f1;\n      var c1 = cos(f1);\n      var s1 = sin(f1);\n      var c2 = cos(f2);\n      var s2 = sin(f2);\n      var t = tan(df / 4);\n      var hx = 4 / 3 * (rx * t);\n      var hy = 4 / 3 * (ry * t);\n      var m1 = [x1, y1];\n      var m2 = [x1 + hx * s1, y1 - hy * c1];\n      var m3 = [x2 + hx * s2, y2 - hy * c2];\n      var m4 = [x2, y2];\n      m2[0] = 2 * m1[0] - m2[0];\n      m2[1] = 2 * m1[1] - m2[1];\n      if (recursive) {\n        return [m2, m3, m4].concat(res);\n      } else {\n        res = [m2, m3, m4].concat(res).join().split(',');\n        var newres = [];\n        var ii = res.length;\n        for (var i = 0; i < ii; i++) {\n          newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n        }\n        return newres;\n      }\n    }\n    function parsePathString(pathString) {\n      if (!pathString) return null;\n      var paramCounts = {\n        a: 7,\n        c: 6,\n        h: 1,\n        l: 2,\n        m: 2,\n        q: 4,\n        s: 4,\n        t: 2,\n        v: 1,\n        z: 0\n      };\n      var data = [];\n      String(pathString).replace(pathCommand, function (a, b, c) {\n        var params = [];\n        var name = b.toLowerCase();\n        c.replace(pathValues, function (a, b) {\n          if (b) params.push(+b);\n        });\n        if (name === 'm' && params.length > 2) {\n          data.push([b].concat(params.splice(0, 2)));\n          name = 'l';\n          b = b === 'm' ? 'l' : 'L';\n        }\n        while (params.length >= paramCounts[name]) {\n          data.push([b].concat(params.splice(0, paramCounts[name])));\n          if (!paramCounts[name]) break;\n        }\n      });\n      return data;\n    }\n    function pathToAbsolute(pathArray) {\n      if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) {\n        // rough assumption\n        pathArray = parsePathString(pathArray);\n      }\n\n      // if invalid string, return 'M 0 0'\n      if (!pathArray || !pathArray.length) return [['M', 0, 0]];\n      var res = [];\n      var x = 0;\n      var y = 0;\n      var mx = 0;\n      var my = 0;\n      var start = 0;\n      var pa0;\n      var ii = pathArray.length;\n      for (var i = start; i < ii; i++) {\n        var r = [];\n        res.push(r);\n        var pa = pathArray[i];\n        pa0 = pa[0];\n        if (pa0 != pa0.toUpperCase()) {\n          r[0] = pa0.toUpperCase();\n          var jj;\n          var j;\n          switch (r[0]) {\n            case 'A':\n              r[1] = pa[1];\n              r[2] = pa[2];\n              r[3] = pa[3];\n              r[4] = pa[4];\n              r[5] = pa[5];\n              r[6] = +pa[6] + x;\n              r[7] = +pa[7] + y;\n              break;\n            case 'V':\n              r[1] = +pa[1] + y;\n              break;\n            case 'H':\n              r[1] = +pa[1] + x;\n              break;\n            case 'M':\n              mx = +pa[1] + x;\n              my = +pa[2] + y;\n              jj = pa.length;\n              for (j = 1; j < jj; j++) {\n                r[j] = +pa[j] + (j % 2 ? x : y);\n              }\n              break;\n            default:\n              jj = pa.length;\n              for (j = 1; j < jj; j++) {\n                r[j] = +pa[j] + (j % 2 ? x : y);\n              }\n              break;\n          }\n        } else {\n          var kk = pa.length;\n          for (var k = 0; k < kk; k++) {\n            r[k] = pa[k];\n          }\n        }\n        switch (r[0]) {\n          case 'Z':\n            x = +mx;\n            y = +my;\n            break;\n          case 'H':\n            x = r[1];\n            break;\n          case 'V':\n            y = r[1];\n            break;\n          case 'M':\n            mx = r[r.length - 2];\n            my = r[r.length - 1];\n            x = r[r.length - 2];\n            y = r[r.length - 1];\n            break;\n          default:\n            x = r[r.length - 2];\n            y = r[r.length - 1];\n            break;\n        }\n      }\n      return res;\n    }\n    function normalize(path) {\n      var p = pathToAbsolute(path);\n      var attrs = {\n        x: 0,\n        y: 0,\n        bx: 0,\n        by: 0,\n        X: 0,\n        Y: 0,\n        qx: null,\n        qy: null\n      };\n      function processPath(path, d, pcom) {\n        var nx, ny;\n        if (!path) return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n        if (!(path[0] in {\n          T: 1,\n          Q: 1\n        })) {\n          d.qx = null;\n          d.qy = null;\n        }\n        switch (path[0]) {\n          case 'M':\n            d.X = path[1];\n            d.Y = path[2];\n            break;\n          case 'A':\n            if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {\n              // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n              // \"If either rx or ry is 0, then this arc is treated as a\n              // straight line segment (a \"lineto\") joining the endpoints.\"\n              path = ['L', path[6], path[7]];\n            } else {\n              path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n            }\n            break;\n          case 'S':\n            if (pcom === 'C' || pcom === 'S') {\n              // In 'S' case we have to take into account, if the previous command is C/S.\n              nx = d.x * 2 - d.bx; // And reflect the previous\n              ny = d.y * 2 - d.by; // command's control point relative to the current point.\n            } else {\n              // or some else or nothing\n              nx = d.x;\n              ny = d.y;\n            }\n            path = ['C', nx, ny].concat(path.slice(1));\n            break;\n          case 'T':\n            if (pcom === 'Q' || pcom === 'T') {\n              // In 'T' case we have to take into account, if the previous command is Q/T.\n              d.qx = d.x * 2 - d.qx; // And make a reflection similar\n              d.qy = d.y * 2 - d.qy; // to case 'S'.\n            } else {\n              // or something else or nothing\n              d.qx = d.x;\n              d.qy = d.y;\n            }\n            path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n            break;\n          case 'Q':\n            d.qx = path[1];\n            d.qy = path[2];\n            path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n            break;\n          case 'H':\n            path = ['L'].concat(path[1], d.y);\n            break;\n          case 'V':\n            path = ['L'].concat(d.x, path[1]);\n            break;\n          case 'L':\n            break;\n          case 'Z':\n            break;\n        }\n        return path;\n      }\n      function fixArc(pp, i) {\n        if (pp[i].length > 7) {\n          pp[i].shift();\n          var pi = pp[i];\n          while (pi.length) {\n            pcoms[i] = 'A'; // if created multiple 'C's, their original seg is saved\n            pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n          }\n          pp.splice(i, 1);\n          ii = p.length;\n        }\n      }\n      var pcoms = []; // path commands of original path p\n      var pfirst = ''; // temporary holder for original path command\n      var pcom = ''; // holder for previous path command of original path\n\n      var ii = p.length;\n      for (var i = 0; i < ii; i++) {\n        if (p[i]) pfirst = p[i][0]; // save current path command\n\n        if (pfirst !== 'C') {\n          // C is not saved yet, because it may be result of conversion\n          pcoms[i] = pfirst; // Save current path command\n          if (i > 0) pcom = pcoms[i - 1]; // Get previous path command pcom\n        }\n        p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n        if (pcoms[i] !== 'A' && pfirst === 'C') pcoms[i] = 'C'; // 'A' is the only command\n        // which may produce multiple 'C's\n        // so we have to make sure that 'C' is also 'C' in original path\n\n        fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms\n\n        var seg = p[i];\n        var seglen = seg.length;\n        attrs.x = seg[seglen - 2];\n        attrs.y = seg[seglen - 1];\n        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n      }\n\n      // make sure normalized path data string starts with an M segment\n      if (!p[0][0] || p[0][0] !== 'M') {\n        p.unshift(['M', 0, 0]);\n      }\n      return p;\n    }\n    return function (pathData) {\n      return normalize(pathData).join(',').split(',').join(' ');\n    };\n  }();\n  V.namespace = ns;\n  V.g = g;\n  return V;\n}();\nexport default V;","map":{"version":3,"names":["g","V","hasSvg","window","SVGAngle","Error","ns","svg","xmlns","xml","xlink","xhtml","SVGVersion","math","Math","PI","atan2","sqrt","min","max","cos","sin","el","attrs","children","apply","Object","create","prototype","arguments","isV","node","isString","trim","toLowerCase","createSvgDocument","svgDoc","childNodes","length","arrayOfVels","i","len","childNode","push","document","importNode","firstChild","createElementNS","ensureId","setAttributes","append","VPrototype","defineProperty","enumerable","get","id","set","getTransformToElement","target","isSVGGraphicsElement","targetCTM","toNode","getScreenCTM","nodeCTM","inverse","multiply","createSVGMatrix","transform","matrix","opt","isUndefined","transformStringToMatrix","attr","absolute","matrixToTransformString","svgTransform","createSVGTransform","baseVal","appendItem","translate","tx","ty","transformAttr","parseTransformString","value","replace","newTx","newTy","newTranslate","rotate","angle","cx","cy","newAngle","newOrigin","undefined","newRotate","scale","sx","sy","newScale","bbox","withoutTransformations","box","ownerSVGElement","Rect","getBBox","e","x","clientLeft","y","clientTop","width","clientWidth","height","clientHeight","transformRect","options","outputBBox","recursive","n","currentChild","childBBox","union","createTextPathNode","vel","textPathElement","d","linkedPath","appendTo","defs","isObject","annotateTextLine","lineNode","lineAnnotations","includeAnnotationIndices","eol","lineHeight","baseSize","maxFontSize","fontMetrics","lastJ","j","annotation","fontSize","annotationAttrs","vTSpan","tspanNode","t","textContent","annotationClass","addClass","annotations","parseFloat","isFinite","createTextNode","appendChild","emRegex","convertEmToPx","em","numerical","test","calculateDY","alignment","linesMetrics","baseSizePx","Array","isArray","lineMetrics","flMaxFont","rLineHeights","lineHeightPx","iLineHeight","llMaxFont","dy","text","content","sanitizeText","displayEmpty","textPath","verticalAnchor","textVerticalAnchor","namedVerticalAnchor","iai","defaultLineHeight","autoLineHeight","empty","doc","containerNode","createDocumentFragment","offset","lines","split","annotatedY","lastI","lineClassName","line","annotateString","lineNodeStyle","style","fillOpacity","strokeOpacity","findAnnotationsAtIndex","lineFontSize","fs","setAttribute","className","rh","removeAttr","name","trueName","attributeNames","local","qualifyAttr","hasAttributeNS","removeAttributeNS","hasAttribute","removeAttribute","attributes","getAttribute","attrName","hasOwnProperty","normalizePath","tagName","normalizePathData","remove","parentNode","removeChild","key","els","prepend","child","before","parent","insertBefore","SVGSVGElement","toUpperCase","context","defsNode","getElementsByTagName","clone","cloneNode","uniqueId","findOne","selector","found","querySelector","find","vels","nodes","querySelectorAll","outputArray","nodeType","index","previousSibling","findParentByClass","terminator","hasClass","contains","a","b","bup","compareDocumentPosition","toLocalPoint","p","createSVGPoint","globalPoint","matrixTransform","globalToLocalMatrix","translateCenterToPoint","center","translateAndAutoOrient","position","reference","Point","translateToOrigin","setTranslate","rotateAroundOrigin","angleBetween","setRotate","translateFromOrigin","finalPosition","move","ctm","setMatrix","animateAlongPath","path","animateMotion","mpath","beginElement","documentElement","animation","animators","animationID","id2anim","targets","getTargets","animator","Animator","register","noHTMLWhitespaceRegex","getTokenList","str","match","classList","add","removeClass","toggleClass","toAdd","tokens","toggle","sample","interval","getTotalLength","samples","distance","getPointAtLength","convertToPath","convertToPathData","convertLineToPathData","convertPolygonToPathData","convertPolylineToPathData","convertEllipseToPathData","convertCircleToPathData","convertRectToPathData","toGeometryShape","r","rx","ry","points","x1","x2","y1","y2","Ellipse","getPointsFromSvgNode","Polyline","Path","isDataSupported","Line","findIntersection","ref","intersectionWithLineFromCenterToPoint","spot","gRect","rectMatrix","rectMatrixComponents","decomposeMatrix","resetRotation","rotation","rect","pathNode","minDistance","Infinity","closestSamples","gp","centerDistance","refDistance","sort","setAttributeNS","XMLString","parseXML","async","createSVGStyle","stylesheet","type","createCDATASection","data","implementation","createDocument","idCounter","nodeName","parser","DOMParser","parseFromString","error","_attributeNames","forEach","Proxy","cache","supportCamelCaseAttributes","writable","indexOf","combinedKey","transformSeparatorRegex","transformRegex","transformFunctionRegex","transformTranslateRegex","transformRotateRegex","transformScaleRegex","transformationMatrix","transformMatches","numMatches","transformMatch","transformFunctionMatch","transformFunction","args","scaleNonUniform","skewX","skewY","c","f","separator","decomposedMatrix","translateX","translateY","scaleX","scaleY","transformations","join","translateMatch","rotateMatch","scaleMatch","parseInt","deltaTransformPoint","point","dx","px","py","matrixToScale","matrixToRotate","normalizeAngle","toDeg","matrixToTranslate","object","isVElement","SVGElement","svgDocument","svgMatrix","component","SVGMatrix","createSVGTransformFromMatrix","corner1","corner2","corner3","corner4","minX","maxX","minY","maxY","transformPoint","transformLine","l","start","end","transformPolyline","inPoints","outPoints","styleToObject","styleString","ret","styles","pair","createSlicePathData","innerRadius","outerRadius","startAngle","endAngle","svgArcMax","r0","r1","a0","a1","da","df","c0","s0","c1","s1","mergeAttrs","compacted","batch","item","prev","JSON","stringify","findAnnotationsBetweenIndexes","shiftAnnotations","polygon","svgPointsToPath","polyline","nodePoints","numberOfItems","getItem","KAPPA","circle","cd","ellipse","cdx","cdy","rectToPath","topRx","bottomRx","topRy","bottomRy","spaces","pathCommand","RegExp","pathValues","tan","asin","abs","q2c","ax","ay","_13","_23","rad","X","Y","a2c","large_arc_flag","sweep_flag","_120","res","xy","h","rx2","ry2","k","f1","toFixed","f2","f2old","x2old","y2old","c2","s2","hx","hy","m1","m2","m3","m4","concat","newres","ii","parsePathString","pathString","paramCounts","m","q","s","v","z","String","params","splice","pathToAbsolute","pathArray","mx","my","pa0","pa","jj","kk","normalize","bx","by","qx","qy","processPath","pcom","nx","ny","T","Q","slice","fixArc","pp","shift","pi","pcoms","pfirst","seg","seglen","unshift","pathData","namespace"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/V/index.mjs"],"sourcesContent":["// Vectorizer.\n// -----------\n\n// A tiny library for making your life easier when dealing with SVG.\n// The only Vectorizer dependency is the Geometry library.\n\nimport * as g from '../g/index.mjs';\n\nconst V = (function() {\n\n    var hasSvg = typeof window === 'object' && !!window.SVGAngle;\n\n    // SVG support is required.\n    if (!hasSvg) {\n\n        // Return a function that throws an error when it is used.\n        return function() {\n            throw new Error('SVG is required to use Vectorizer.');\n        };\n    }\n\n    // XML namespaces.\n    var ns = {\n        svg: 'http://www.w3.org/2000/svg',\n        xmlns: 'http://www.w3.org/2000/xmlns/',\n        xml: 'http://www.w3.org/XML/1998/namespace',\n        xlink: 'http://www.w3.org/1999/xlink',\n        xhtml: 'http://www.w3.org/1999/xhtml'\n    };\n\n    var SVGVersion = '1.1';\n\n    // Declare shorthands to the most used math functions.\n    var math = Math;\n    var PI = math.PI;\n    var atan2 = math.atan2;\n    var sqrt = math.sqrt;\n    var min = math.min;\n    var max = math.max;\n    var cos = math.cos;\n    var sin = math.sin;\n\n    var V = function(el, attrs, children) {\n\n        // This allows using V() without the new keyword.\n        if (!(this instanceof V)) {\n            return V.apply(Object.create(V.prototype), arguments);\n        }\n\n        if (!el) return;\n\n        if (V.isV(el)) {\n            el = el.node;\n        }\n\n        attrs = attrs || {};\n\n        if (V.isString(el)) {\n\n            el = el.trim();\n\n            if (el.toLowerCase() === 'svg') {\n\n                // Create a new SVG canvas.\n                el = V.createSvgDocument();\n\n            } else if (el[0] === '<') {\n\n                // Create element from an SVG string.\n                // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\n\n                var svgDoc = V.createSvgDocument(el);\n\n                // Note that `V()` might also return an array should the SVG string passed as\n                // the first argument contain more than one root element.\n                if (svgDoc.childNodes.length > 1) {\n\n                    // Map child nodes to `V`s.\n                    var arrayOfVels = [];\n                    var i, len;\n\n                    for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {\n\n                        var childNode = svgDoc.childNodes[i];\n                        arrayOfVels.push(new V(document.importNode(childNode, true)));\n                    }\n\n                    return arrayOfVels;\n                }\n\n                el = document.importNode(svgDoc.firstChild, true);\n\n            } else {\n\n                el = document.createElementNS(ns.svg, el);\n            }\n\n            V.ensureId(el);\n        }\n\n        this.node = el;\n\n        this.setAttributes(attrs);\n\n        if (children) {\n            this.append(children);\n        }\n\n        return this;\n    };\n\n    var VPrototype = V.prototype;\n\n    Object.defineProperty(VPrototype, 'id', {\n        enumerable: true,\n        get: function() {\n            return this.node.id;\n        },\n        set: function(id) {\n            this.node.id = id;\n        }\n    });\n\n    /**\n     * @param {SVGGElement} toElem\n     * @returns {SVGMatrix}\n     */\n    VPrototype.getTransformToElement = function(target) {\n        var node = this.node;\n        if (V.isSVGGraphicsElement(target) && V.isSVGGraphicsElement(node)) {\n            var targetCTM = V.toNode(target).getScreenCTM();\n            var nodeCTM = node.getScreenCTM();\n            if (targetCTM && nodeCTM) {\n                return targetCTM.inverse().multiply(nodeCTM);\n            }\n        }\n        // Could not get actual transformation matrix\n        return V.createSVGMatrix();\n    };\n\n    /**\n     * @param {SVGMatrix} matrix\n     * @param {Object=} opt\n     * @returns {Vectorizer|SVGMatrix} Setter / Getter\n     */\n    VPrototype.transform = function(matrix, opt) {\n\n        var node = this.node;\n        if (V.isUndefined(matrix)) {\n            return V.transformStringToMatrix(this.attr('transform'));\n        }\n\n        if (opt && opt.absolute) {\n            return this.attr('transform', V.matrixToTransformString(matrix));\n        }\n\n        var svgTransform = V.createSVGTransform(matrix);\n        node.transform.baseVal.appendItem(svgTransform);\n        return this;\n    };\n\n    VPrototype.translate = function(tx, ty, opt) {\n\n        opt = opt || {};\n        ty = ty || 0;\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n        // Is it a getter?\n        if (V.isUndefined(tx)) {\n            return transform.translate;\n        }\n\n        transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n\n        var newTx = opt.absolute ? tx : transform.translate.tx + tx;\n        var newTy = opt.absolute ? ty : transform.translate.ty + ty;\n        var newTranslate = 'translate(' + newTx + ',' + newTy + ')';\n\n        // Note that `translate()` is always the first transformation. This is\n        // usually the desired case.\n        this.attr('transform', (newTranslate + ' ' + transformAttr).trim());\n        return this;\n    };\n\n    VPrototype.rotate = function(angle, cx, cy, opt) {\n\n        opt = opt || {};\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n\n        // Is it a getter?\n        if (V.isUndefined(angle)) {\n            return transform.rotate;\n        }\n\n        transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n\n        angle %= 360;\n\n        var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\n        var newOrigin = (cx !== undefined && cy !== undefined) ? ',' + cx + ',' + cy : '';\n        var newRotate = 'rotate(' + newAngle + newOrigin + ')';\n\n        this.attr('transform', (transformAttr + ' ' + newRotate).trim());\n        return this;\n    };\n\n    // Note that `scale` as the only transformation does not combine with previous values.\n    VPrototype.scale = function(sx, sy) {\n\n        sy = V.isUndefined(sy) ? sx : sy;\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n\n        // Is it a getter?\n        if (V.isUndefined(sx)) {\n            return transform.scale;\n        }\n\n        transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n\n        var newScale = 'scale(' + sx + ',' + sy + ')';\n\n        this.attr('transform', (transformAttr + ' ' + newScale).trim());\n        return this;\n    };\n\n    // Get SVGRect that contains coordinates and dimension of the real bounding box,\n    // i.e. after transformations are applied.\n    // If `target` is specified, bounding box will be computed relatively to `target` element.\n    VPrototype.bbox = function(withoutTransformations, target) {\n\n        var box;\n        var node = this.node;\n        var ownerSVGElement = node.ownerSVGElement;\n\n        // If the element is not in the live DOM, it does not have a bounding box defined and\n        // so fall back to 'zero' dimension element.\n        if (!ownerSVGElement) {\n            return new g.Rect(0, 0, 0, 0);\n        }\n\n        try {\n\n            box = node.getBBox();\n\n        } catch (e) {\n\n            // Fallback for IE.\n            box = {\n                x: node.clientLeft,\n                y: node.clientTop,\n                width: node.clientWidth,\n                height: node.clientHeight\n            };\n        }\n\n        if (withoutTransformations) {\n            return new g.Rect(box);\n        }\n\n        var matrix = this.getTransformToElement(target || ownerSVGElement);\n\n        return V.transformRect(box, matrix);\n    };\n\n    // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,\n    // i.e. after transformations are applied.\n    // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.\n    // Takes an (Object) `opt` argument (optional) with the following attributes:\n    // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this\n    // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();\n    VPrototype.getBBox = function(opt) {\n\n        var options = {};\n\n        var outputBBox;\n        var node = this.node;\n        var ownerSVGElement = node.ownerSVGElement;\n\n        // If the element is not in the live DOM, it does not have a bounding box defined and\n        // so fall back to 'zero' dimension element.\n        // If the element is not an SVGGraphicsElement, we could not measure the bounding box either\n        if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {\n            return new g.Rect(0, 0, 0, 0);\n        }\n\n        if (opt) {\n            if (opt.target) { // check if target exists\n                options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects\n            }\n            if (opt.recursive) {\n                options.recursive = opt.recursive;\n            }\n        }\n\n        if (!options.recursive) {\n            try {\n                outputBBox = node.getBBox();\n            } catch (e) {\n                // Fallback for IE.\n                outputBBox = {\n                    x: node.clientLeft,\n                    y: node.clientTop,\n                    width: node.clientWidth,\n                    height: node.clientHeight\n                };\n            }\n\n            if (!options.target) {\n                // transform like this (that is, not at all)\n                return new g.Rect(outputBBox);\n            } else {\n                // transform like target\n                var matrix = this.getTransformToElement(options.target);\n                return V.transformRect(outputBBox, matrix);\n            }\n        } else { // if we want to calculate the bbox recursively\n            // browsers report correct bbox around svg elements (one that envelops the path lines tightly)\n            // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())\n            // this happens even if we wrap a single svg element into a group!\n            // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes\n\n            var children = this.children();\n            var n = children.length;\n\n            if (n === 0) {\n                return this.getBBox({ target: options.target, recursive: false });\n            }\n\n            // recursion's initial pass-through setting:\n            // recursive passes-through just keep the target as whatever was set up here during the initial pass-through\n            if (!options.target) {\n                // transform children/descendants like this (their parent/ancestor)\n                options.target = this;\n            } // else transform children/descendants like target\n\n            for (var i = 0; i < n; i++) {\n                var currentChild = children[i];\n\n                var childBBox;\n\n                // if currentChild is not a group element, get its bbox with a nonrecursive call\n                if (currentChild.children().length === 0) {\n                    childBBox = currentChild.getBBox({ target: options.target, recursive: false });\n                } else {\n                    // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call\n                    childBBox = currentChild.getBBox({ target: options.target, recursive: true });\n                }\n\n                if (!outputBBox) {\n                    // if this is the first iteration\n                    outputBBox = childBBox;\n                } else {\n                    // make a new bounding box rectangle that contains this child's bounding box and previous bounding box\n                    outputBBox = outputBBox.union(childBBox);\n                }\n            }\n\n            return outputBBox;\n        }\n    };\n\n    // Text() helpers\n\n    function createTextPathNode(attrs, vel) {\n        attrs || (attrs = {});\n        var textPathElement = V('textPath');\n        var d = attrs.d;\n        if (d && attrs['xlink:href'] === undefined) {\n            // If `opt.attrs` is a plain string, consider it to be directly the\n            // SVG path data for the text to go along (this is a shortcut).\n            // Otherwise if it is an object and contains the `d` property, then this is our path.\n            // Wrap the text in the SVG <textPath> element that points\n            // to a path defined by `opt.attrs` inside the `<defs>` element.\n            var linkedPath = V('path').attr('d', d).appendTo(vel.defs());\n            textPathElement.attr('xlink:href', '#' + linkedPath.id);\n        }\n        if (V.isObject(attrs)) {\n            // Set attributes on the `<textPath>`. The most important one\n            // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\n            // Note that we also allow the following construct:\n            // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\n            // In other words, one can completely skip the auto-creation of the path\n            // and use any other arbitrary path that is in the document.\n            textPathElement.attr(attrs);\n        }\n        return textPathElement.node;\n    }\n\n    function annotateTextLine(lineNode, lineAnnotations, opt) {\n        opt || (opt = {});\n        var includeAnnotationIndices = opt.includeAnnotationIndices;\n        var eol = opt.eol;\n        var lineHeight = opt.lineHeight;\n        var baseSize = opt.baseSize;\n        var maxFontSize = 0;\n        var fontMetrics = {};\n        var lastJ = lineAnnotations.length - 1;\n        for (var j = 0; j <= lastJ; j++) {\n            var annotation = lineAnnotations[j];\n            var fontSize = null;\n            if (V.isObject(annotation)) {\n                var annotationAttrs = annotation.attrs;\n                var vTSpan = V('tspan', annotationAttrs);\n                var tspanNode = vTSpan.node;\n                var t = annotation.t;\n                if (eol && j === lastJ) t += eol;\n                tspanNode.textContent = t;\n                // Per annotation className\n                var annotationClass = annotationAttrs['class'];\n                if (annotationClass) vTSpan.addClass(annotationClass);\n                // If `opt.includeAnnotationIndices` is `true`,\n                // set the list of indices of all the applied annotations\n                // in the `annotations` attribute. This list is a comma\n                // separated list of indices.\n                if (includeAnnotationIndices) vTSpan.attr('annotations', annotation.annotations);\n                // Check for max font size\n                fontSize = parseFloat(annotationAttrs['font-size']);\n                if (!isFinite(fontSize)) fontSize = baseSize;\n                if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n            } else {\n                if (eol && j === lastJ) annotation += eol;\n                tspanNode = document.createTextNode(annotation || ' ');\n                if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;\n            }\n            lineNode.appendChild(tspanNode);\n        }\n\n        if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;\n        if (lineHeight) {\n            fontMetrics.lineHeight = lineHeight;\n        } else if (maxFontSize) {\n            fontMetrics.lineHeight = (maxFontSize * 1.2);\n        }\n        return fontMetrics;\n    }\n\n    var emRegex = /em$/;\n\n    function convertEmToPx(em, fontSize) {\n        var numerical = parseFloat(em);\n        if (emRegex.test(em)) return numerical * fontSize;\n        return numerical;\n    }\n\n    function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n        if (!Array.isArray(linesMetrics)) return 0;\n        var n = linesMetrics.length;\n        if (!n) return 0;\n        var lineMetrics = linesMetrics[0];\n        var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n        var rLineHeights = 0;\n        var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);\n        for (var i = 1; i < n; i++) {\n            lineMetrics = linesMetrics[i];\n            var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n            rLineHeights += iLineHeight;\n        }\n        var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n        var dy;\n        switch (alignment) {\n            case 'middle':\n                dy = (flMaxFont / 2) - (0.15 * llMaxFont) - (rLineHeights / 2);\n                break;\n            case 'bottom':\n                dy = -(0.25 * llMaxFont) - rLineHeights;\n                break;\n            default:\n            case 'top':\n                dy = (0.8 * flMaxFont);\n                break;\n        }\n        return dy;\n    }\n\n    VPrototype.text = function(content, opt) {\n\n        if (content && typeof content !== 'string') throw new Error('Vectorizer: text() expects the first argument to be a string.');\n\n        // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n        // IE would otherwise collapse all spaces into one.\n        content = V.sanitizeText(content);\n        opt || (opt = {});\n        // Should we allow the text to be selected?\n        var displayEmpty = opt.displayEmpty;\n        // End of Line character\n        var eol = opt.eol;\n        // Text along path\n        var textPath = opt.textPath;\n        // Vertical shift\n        var verticalAnchor = opt.textVerticalAnchor;\n        var namedVerticalAnchor = (verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top');\n        // Horizontal shift applied to all the lines but the first.\n        var x = opt.x;\n        if (x === undefined) x = this.attr('x') || 0;\n        // Annotations\n        var iai = opt.includeAnnotationIndices;\n        var annotations = opt.annotations;\n        if (annotations && !V.isArray(annotations)) annotations = [annotations];\n        // Shift all the <tspan> but first by one line (`1em`)\n        var defaultLineHeight = opt.lineHeight;\n        var autoLineHeight = (defaultLineHeight === 'auto');\n        var lineHeight = (autoLineHeight) ? '1.5em' : (defaultLineHeight || '1em');\n        // Clearing the element\n        this.empty();\n        this.attr({\n            // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\n            'xml:space': 'preserve',\n            // An empty text gets rendered into the DOM in webkit-based browsers.\n            // In order to unify this behaviour across all browsers\n            // we rather hide the text element when it's empty.\n            'display': (content || displayEmpty) ? null : 'none'\n        });\n\n        // Set default font-size if none\n        var fontSize = parseFloat(this.attr('font-size'));\n        if (!fontSize) {\n            fontSize = 16;\n            if (namedVerticalAnchor || annotations) this.attr('font-size', fontSize);\n        }\n\n        var doc = document;\n        var containerNode;\n        if (textPath) {\n            // Now all the `<tspan>`s will be inside the `<textPath>`.\n            if (typeof textPath === 'string') textPath = { d: textPath };\n            containerNode = createTextPathNode(textPath, this);\n        } else {\n            containerNode = doc.createDocumentFragment();\n        }\n        var offset = 0;\n        var lines = content.split('\\n');\n        var linesMetrics = [];\n        var annotatedY;\n        for (var i = 0, lastI = lines.length - 1; i <= lastI; i++) {\n            var dy = lineHeight;\n            var lineClassName = 'v-line';\n            var lineNode = doc.createElementNS(ns.svg, 'tspan');\n            var line = lines[i];\n            var lineMetrics;\n            if (line) {\n                if (annotations) {\n                    // Find the *compacted* annotations for this line.\n                    var lineAnnotations = V.annotateString(line, annotations, {\n                        offset: -offset,\n                        includeAnnotationIndices: iai\n                    });\n                    lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n                        includeAnnotationIndices: iai,\n                        eol: (i !== lastI && eol),\n                        lineHeight: (autoLineHeight) ? null : lineHeight,\n                        baseSize: fontSize\n                    });\n                    // Get the line height based on the biggest font size in the annotations for this line.\n                    var iLineHeight = lineMetrics.lineHeight;\n                    if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;\n                    if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;\n                } else {\n                    if (eol && i !== lastI) line += eol;\n                    lineNode.textContent = line;\n                }\n            } else {\n                // Make sure the textContent is never empty. If it is, add a dummy\n                // character and make it invisible, making the following lines correctly\n                // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n                lineNode.textContent = '-';\n                lineClassName += ' v-empty-line';\n                // 'opacity' needs to be specified with fill, stroke. Opacity without specification\n                // is not applied in Firefox\n                var lineNodeStyle = lineNode.style;\n                lineNodeStyle.fillOpacity = 0;\n                lineNodeStyle.strokeOpacity = 0;\n                if (annotations) {\n                    // Empty line with annotations.\n                    lineMetrics = {};\n                    lineAnnotations = V.findAnnotationsAtIndex(annotations, offset);\n                    let lineFontSize = fontSize;\n                    // Check if any of the annotations overrides the font size.\n                    for (let j = lineAnnotations.length; j > 0; j--) {\n                        const attrs = lineAnnotations[j - 1].attrs;\n                        if (!attrs || !('font-size' in attrs)) continue;\n                        const fs = parseFloat(attrs['font-size']);\n                        if (isFinite(fs)) {\n                            lineFontSize = fs;\n                            break;\n                        }\n                    }\n                    if (autoLineHeight) {\n                        if (i > 0) {\n                            dy = lineFontSize * 1.2;\n                        } else {\n                            annotatedY = lineFontSize * 0.8;\n                        }\n                    }\n                    // The font size is important for the native selection box height.\n                    lineNode.setAttribute('font-size', lineFontSize);\n                    lineMetrics.maxFontSize = lineFontSize;\n                }\n            }\n            if (lineMetrics) linesMetrics.push(lineMetrics);\n            if (i > 0) lineNode.setAttribute('dy', dy);\n            // Firefox requires 'x' to be set on the first line when inside a text path\n            if (i > 0 || textPath) lineNode.setAttribute('x', x);\n            lineNode.className.baseVal = lineClassName;\n            containerNode.appendChild(lineNode);\n            offset += line.length + 1;      // + 1 = newline character.\n        }\n        // Y Alignment calculation\n        if (namedVerticalAnchor) {\n            if (annotations) {\n                dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n            } else if (verticalAnchor === 'top') {\n                // A shortcut for top alignment. It does not depend on font-size nor line-height\n                dy = '0.8em';\n            } else {\n                var rh; // remaining height\n                if (lastI > 0) {\n                    rh = parseFloat(lineHeight) || 1;\n                    rh *= lastI;\n                    if (!emRegex.test(lineHeight)) rh /= fontSize;\n                } else {\n                    // Single-line text\n                    rh = 0;\n                }\n                switch (verticalAnchor) {\n                    case 'middle':\n                        dy = (0.3 - (rh / 2)) + 'em';\n                        break;\n                    case 'bottom':\n                        dy = (-rh - 0.3) + 'em';\n                        break;\n                }\n            }\n        } else {\n            if (verticalAnchor === 0) {\n                dy = '0em';\n            } else if (verticalAnchor) {\n                dy = verticalAnchor;\n            } else {\n                // No vertical anchor is defined\n                dy = 0;\n                // Backwards compatibility - we change the `y` attribute instead of `dy`.\n                if (this.attr('y') === null) this.attr('y', annotatedY || '0.8em');\n            }\n        }\n        containerNode.firstChild.setAttribute('dy', dy);\n        // Appending lines to the element.\n        this.append(containerNode);\n        return this;\n    };\n\n    /**\n     * @public\n     * @param {string} name\n     * @returns {Vectorizer}\n     */\n    VPrototype.removeAttr = function(name) {\n\n        const trueName = attributeNames[name];\n\n        const { ns, local } = V.qualifyAttr(trueName);\n        const el = this.node;\n\n        if (ns) {\n            if (el.hasAttributeNS(ns, local)) {\n                el.removeAttributeNS(ns, local);\n            }\n        } else if (el.hasAttribute(trueName)) {\n            el.removeAttribute(trueName);\n        }\n        return this;\n    };\n\n    VPrototype.attr = function(name, value) {\n\n        if (V.isUndefined(name)) {\n\n            // Return all attributes.\n            var attributes = this.node.attributes;\n            var attrs = {};\n\n            for (var i = 0; i < attributes.length; i++) {\n                attrs[attributes[i].name] = attributes[i].value;\n            }\n\n            return attrs;\n        }\n\n        if (V.isString(name) && V.isUndefined(value)) {\n            return this.node.getAttribute(attributeNames[name]);\n        }\n\n        if (typeof name === 'object') {\n\n            for (var attrName in name) {\n                if (name.hasOwnProperty(attrName)) {\n                    this.setAttribute(attrName, name[attrName]);\n                }\n            }\n\n        } else {\n\n            this.setAttribute(name, value);\n        }\n\n        return this;\n    };\n\n    VPrototype.normalizePath = function() {\n\n        var tagName = this.tagName();\n        if (tagName === 'PATH') {\n            this.attr('d', V.normalizePathData(this.attr('d')));\n        }\n\n        return this;\n    };\n\n    VPrototype.remove = function() {\n\n        if (this.node.parentNode) {\n            this.node.parentNode.removeChild(this.node);\n        }\n\n        return this;\n    };\n\n    VPrototype.empty = function() {\n\n        while (this.node.firstChild) {\n            this.node.removeChild(this.node.firstChild);\n        }\n\n        return this;\n    };\n\n    /**\n     * @private\n     * @param {object} attrs\n     * @returns {Vectorizer}\n     */\n    VPrototype.setAttributes = function(attrs) {\n\n        for (var key in attrs) {\n            if (attrs.hasOwnProperty(key)) {\n                this.setAttribute(key, attrs[key]);\n            }\n        }\n\n        return this;\n    };\n\n    VPrototype.append = function(els) {\n\n        if (!V.isArray(els)) {\n            els = [els];\n        }\n\n        for (var i = 0, len = els.length; i < len; i++) {\n            this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]\n        }\n\n        return this;\n    };\n\n    VPrototype.prepend = function(els) {\n\n        var child = this.node.firstChild;\n        return child ? V(child).before(els) : this.append(els);\n    };\n\n    VPrototype.before = function(els) {\n\n        var node = this.node;\n        var parent = node.parentNode;\n\n        if (parent) {\n\n            if (!V.isArray(els)) {\n                els = [els];\n            }\n\n            for (var i = 0, len = els.length; i < len; i++) {\n                parent.insertBefore(V.toNode(els[i]), node);\n            }\n        }\n\n        return this;\n    };\n\n    VPrototype.appendTo = function(node) {\n        V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]\n        return this;\n    };\n\n    VPrototype.svg = function() {\n\n        return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\n    };\n\n    VPrototype.tagName = function() {\n\n        return this.node.tagName.toUpperCase();\n    };\n\n    VPrototype.defs = function() {\n        var context = this.svg() || this;\n        var defsNode = context.node.getElementsByTagName('defs')[0];\n        if (defsNode) return V(defsNode);\n        return V('defs').appendTo(context);\n    };\n\n    VPrototype.clone = function() {\n\n        var clone = V(this.node.cloneNode(true/* deep */));\n        // Note that clone inherits also ID. Therefore, we need to change it here.\n        clone.node.id = V.uniqueId();\n        return clone;\n    };\n\n    VPrototype.findOne = function(selector) {\n\n        var found = this.node.querySelector(selector);\n        return found ? V(found) : undefined;\n    };\n\n    VPrototype.find = function(selector) {\n\n        var vels = [];\n        var nodes = this.node.querySelectorAll(selector);\n\n        if (nodes) {\n\n            // Map DOM elements to `V`s.\n            for (var i = 0; i < nodes.length; i++) {\n                vels.push(V(nodes[i]));\n            }\n        }\n\n        return vels;\n    };\n\n    // Returns an array of V elements made from children of this.node.\n    VPrototype.children = function() {\n\n        var children = this.node.childNodes;\n\n        var outputArray = [];\n        for (var i = 0; i < children.length; i++) {\n            var currentChild = children[i];\n            if (currentChild.nodeType === 1) {\n                outputArray.push(V(children[i]));\n            }\n        }\n        return outputArray;\n    };\n\n    // Returns the V element from parentNode of this.node.\n    VPrototype.parent = function() {\n        return V(this.node.parentNode) || null;\n    },\n\n    // Find an index of an element inside its container.\n    VPrototype.index = function() {\n\n        var index = 0;\n        var node = this.node.previousSibling;\n\n        while (node) {\n            // nodeType 1 for ELEMENT_NODE\n            if (node.nodeType === 1) index++;\n            node = node.previousSibling;\n        }\n\n        return index;\n    };\n\n    VPrototype.findParentByClass = function(className, terminator) {\n\n        var ownerSVGElement = this.node.ownerSVGElement;\n        var node = this.node.parentNode;\n\n        while (node && node !== terminator && node !== ownerSVGElement) {\n\n            var vel = V(node);\n            if (vel.hasClass(className)) {\n                return vel;\n            }\n\n            node = node.parentNode;\n        }\n\n        return null;\n    };\n\n    // https://jsperf.com/get-common-parent\n    VPrototype.contains = function(el) {\n\n        var a = this.node;\n        var b = V.toNode(el);\n        var bup = b && b.parentNode;\n\n        return (a === bup) || !!(bup && bup.nodeType === 1 && (a.compareDocumentPosition(bup) & 16));\n    };\n\n    // Convert global point into the coordinate space of this element.\n    VPrototype.toLocalPoint = function(x, y) {\n\n        var svg = this.svg().node;\n\n        var p = svg.createSVGPoint();\n        p.x = x;\n        p.y = y;\n\n        try {\n\n            var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\n            var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\n\n        } catch (e) {\n            // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\n            // We have to make do with the original coordianates.\n            return p;\n        }\n\n        return globalPoint.matrixTransform(globalToLocalMatrix);\n    };\n\n    VPrototype.translateCenterToPoint = function(p) {\n\n        var bbox = this.getBBox({ target: this.svg() });\n        var center = bbox.center();\n\n        this.translate(p.x - center.x, p.y - center.y);\n        return this;\n    };\n\n    // Efficiently auto-orient an element. This basically implements the orient=auto attribute\n    // of markers. The easiest way of understanding on what this does is to imagine the element is an\n    // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\n    // being auto-oriented (properly rotated) towards the `reference` point.\n    // `target` is the element relative to which the transformations are applied. Usually a viewport.\n    VPrototype.translateAndAutoOrient = function(position, reference, target) {\n\n        position = new g.Point(position);\n        reference =  new g.Point(reference);\n        target || (target = this.svg());\n\n        // Clean-up previously set transformations except the scale. If we didn't clean up the\n        // previous transformations then they'd add up with the old ones. Scale is an exception as\n        // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\n        // element is scaled by the factor 2, not 8.\n        var scale = this.scale();\n        this.attr('transform', '');\n        var bbox = this.getBBox({ target: target }).scale(scale.sx, scale.sy);\n\n        // 1. Translate to origin.\n        var translateToOrigin = V.createSVGTransform();\n        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n\n        // 2. Rotate around origin.\n        var rotateAroundOrigin = V.createSVGTransform();\n        var angle = position.angleBetween(reference, position.clone().offset(1, 0));\n        if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);\n\n        // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\n        var translateFromOrigin = V.createSVGTransform();\n        var finalPosition = position.clone().move(reference, bbox.width / 2);\n        translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);\n\n        // 4. Get the current transformation matrix of this node\n        var ctm = this.getTransformToElement(target);\n\n        // 5. Apply transformations and the scale\n        var transform = V.createSVGTransform();\n        transform.setMatrix(\n            translateFromOrigin.matrix.multiply(\n                rotateAroundOrigin.matrix.multiply(\n                    translateToOrigin.matrix.multiply(\n                        ctm.scale(scale.sx, scale.sy)))));\n\n        this.attr('transform', V.matrixToTransformString(transform.matrix));\n\n        return this;\n    };\n\n    VPrototype.animateAlongPath = function(attrs, path) {\n\n        path = V.toNode(path);\n\n        var id = V.ensureId(path);\n        var animateMotion = V('animateMotion', attrs);\n        var mpath = V('mpath', { 'xlink:href': '#' + id });\n\n        animateMotion.append(mpath);\n\n        this.append(animateMotion);\n        try {\n            animateMotion.node.beginElement();\n        } catch (e) {\n            // Fallback for IE 9.\n            // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present\n            if (document.documentElement.getAttribute('smiling') === 'fake') {\n                /* global getTargets:true, Animator:true, animators:true id2anim:true */\n                // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n                var animation = animateMotion.node;\n                animation.animators = [];\n\n                var animationID = animation.getAttribute('id');\n                if (animationID) id2anim[animationID] = animation;\n\n                var targets = getTargets(animation);\n                for (var i = 0, len = targets.length; i < len; i++) {\n                    var target = targets[i];\n                    var animator = new Animator(animation, target, i);\n                    animators.push(animator);\n                    animation.animators[i] = animator;\n                    animator.register();\n                }\n            }\n        }\n        return this;\n    };\n\n\n    // Split a string into an array of tokens.\n    // https://infra.spec.whatwg.org/#ascii-whitespace\n    const noHTMLWhitespaceRegex = /[^\\x20\\t\\r\\n\\f]+/g;\n    function getTokenList(str) {\n        if (!V.isString(str)) return [];\n        return str.trim().match(noHTMLWhitespaceRegex) || [];\n    }\n\n    VPrototype.hasClass = function(className) {\n        if (!V.isString(className)) return false;\n        return this.node.classList.contains(className.trim());\n    };\n\n    VPrototype.addClass = function(className) {\n        this.node.classList.add(...getTokenList(className));\n        return this;\n    };\n\n    VPrototype.removeClass = function(className) {\n        this.node.classList.remove(...getTokenList(className));\n        return this;\n    };\n\n    VPrototype.toggleClass = function(className, toAdd) {\n        const tokens = getTokenList(className);\n        for (let i = 0; i < tokens.length; i++) {\n            this.node.classList.toggle(tokens[i], toAdd);\n        }\n        return this;\n    };\n\n    // Interpolate path by discrete points. The precision of the sampling\n    // is controlled by `interval`. In other words, `sample()` will generate\n    // a point on the path starting at the beginning of the path going to the end\n    // every `interval` pixels.\n    // The sampler can be very useful for e.g. finding intersection between two\n    // paths (finding the two closest points from two samples).\n    VPrototype.sample = function(interval) {\n\n        interval = interval || 1;\n        var node = this.node;\n        var length = node.getTotalLength();\n        var samples = [];\n        var distance = 0;\n        var sample;\n        while (distance < length) {\n            sample = node.getPointAtLength(distance);\n            samples.push({ x: sample.x, y: sample.y, distance: distance });\n            distance += interval;\n        }\n        return samples;\n    };\n\n    VPrototype.convertToPath = function() {\n\n        var path = V('path');\n        path.attr(this.attr());\n        var d = this.convertToPathData();\n        if (d) {\n            path.attr('d', d);\n        }\n        return path;\n    };\n\n    VPrototype.convertToPathData = function() {\n\n        var tagName = this.tagName();\n\n        switch (tagName) {\n            case 'PATH':\n                return this.attr('d');\n            case 'LINE':\n                return V.convertLineToPathData(this.node);\n            case 'POLYGON':\n                return V.convertPolygonToPathData(this.node);\n            case 'POLYLINE':\n                return V.convertPolylineToPathData(this.node);\n            case 'ELLIPSE':\n                return V.convertEllipseToPathData(this.node);\n            case 'CIRCLE':\n                return V.convertCircleToPathData(this.node);\n            case 'RECT':\n                return V.convertRectToPathData(this.node);\n        }\n\n        throw new Error(tagName + ' cannot be converted to PATH.');\n    };\n\n    V.prototype.toGeometryShape = function() {\n        var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;\n        switch (this.tagName()) {\n\n            case 'RECT':\n                x = parseFloat(this.attr('x')) || 0;\n                y = parseFloat(this.attr('y')) || 0;\n                width = parseFloat(this.attr('width')) || 0;\n                height = parseFloat(this.attr('height')) || 0;\n                return new g.Rect(x, y, width, height);\n\n            case 'CIRCLE':\n                cx = parseFloat(this.attr('cx')) || 0;\n                cy = parseFloat(this.attr('cy')) || 0;\n                r = parseFloat(this.attr('r')) || 0;\n                return new g.Ellipse({ x: cx, y: cy }, r, r);\n\n            case 'ELLIPSE':\n                cx = parseFloat(this.attr('cx')) || 0;\n                cy = parseFloat(this.attr('cy')) || 0;\n                rx = parseFloat(this.attr('rx')) || 0;\n                ry = parseFloat(this.attr('ry')) || 0;\n                return new g.Ellipse({ x: cx, y: cy }, rx, ry);\n\n            case 'POLYLINE':\n                points = V.getPointsFromSvgNode(this);\n                return new g.Polyline(points);\n\n            case 'POLYGON':\n                points = V.getPointsFromSvgNode(this);\n                if (points.length > 1) points.push(points[0]);\n                return new g.Polyline(points);\n\n            case 'PATH':\n                d = this.attr('d');\n                if (!g.Path.isDataSupported(d)) d = V.normalizePathData(d);\n                return new g.Path(d);\n\n            case 'LINE':\n                x1 = parseFloat(this.attr('x1')) || 0;\n                y1 = parseFloat(this.attr('y1')) || 0;\n                x2 = parseFloat(this.attr('x2')) || 0;\n                y2 = parseFloat(this.attr('y2')) || 0;\n                return new g.Line({ x: x1, y: y1 }, { x: x2, y: y2 });\n        }\n\n        // Anything else is a rectangle\n        return this.getBBox();\n    };\n\n    // Find the intersection of a line starting in the center\n    // of the SVG `node` ending in the point `ref`.\n    // `target` is an SVG element to which `node`s transformations are relative to.\n    // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\n    // Returns a point in the `target` coordinate system (the same system as `ref` is in) if\n    // an intersection is found. Returns `undefined` otherwise.\n    VPrototype.findIntersection = function(ref, target) {\n\n        var svg = this.svg().node;\n        target = target || svg;\n        var bbox = this.getBBox({ target: target });\n        var center = bbox.center();\n\n        if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;\n\n        var spot;\n        var tagName = this.tagName();\n\n        // Little speed up optimization for `<rect>` element. We do not do conversion\n        // to path element and sampling but directly calculate the intersection through\n        // a transformed geometrical rectangle.\n        if (tagName === 'RECT') {\n\n            var gRect = new g.Rect(\n                parseFloat(this.attr('x') || 0),\n                parseFloat(this.attr('y') || 0),\n                parseFloat(this.attr('width')),\n                parseFloat(this.attr('height'))\n            );\n            // Get the rect transformation matrix with regards to the SVG document.\n            var rectMatrix = this.getTransformToElement(target);\n            // Decompose the matrix to find the rotation angle.\n            var rectMatrixComponents = V.decomposeMatrix(rectMatrix);\n            // Now we want to rotate the rectangle back so that we\n            // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\n            var resetRotation = svg.createSVGTransform();\n            resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n            var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\n            spot = (new g.Rect(rect)).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n\n        } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {\n\n            var pathNode = (tagName === 'PATH') ? this : this.convertToPath();\n            var samples = pathNode.sample();\n            var minDistance = Infinity;\n            var closestSamples = [];\n\n            var i, sample, gp, centerDistance, refDistance, distance;\n\n            for (i = 0; i < samples.length; i++) {\n\n                sample = samples[i];\n                // Convert the sample point in the local coordinate system to the global coordinate system.\n                gp = V.createSVGPoint(sample.x, sample.y);\n                gp = gp.matrixTransform(this.getTransformToElement(target));\n                sample = new g.Point(gp);\n                centerDistance = sample.distance(center);\n                // Penalize a higher distance to the reference point by 10%.\n                // This gives better results. This is due to\n                // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n                refDistance = sample.distance(ref) * 1.1;\n                distance = centerDistance + refDistance;\n\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestSamples = [{ sample: sample, refDistance: refDistance }];\n                } else if (distance < minDistance + 1) {\n                    closestSamples.push({ sample: sample, refDistance: refDistance });\n                }\n            }\n\n            closestSamples.sort(function(a, b) {\n                return a.refDistance - b.refDistance;\n            });\n\n            if (closestSamples[0]) {\n                spot = closestSamples[0].sample;\n            }\n        }\n\n        return spot;\n    };\n\n    /**\n     * @private\n     * @param {string} name\n     * @param {string} value\n     * @returns {Vectorizer}\n     */\n    VPrototype.setAttribute = function(name, value) {\n\n        const el = this.node;\n\n        if (value === null) {\n            this.removeAttr(name);\n            return this;\n        }\n\n        const trueName = attributeNames[name];\n\n        const { ns } = V.qualifyAttr(trueName);\n        if (ns) {\n            // Attribute names can be namespaced. E.g. `image` elements\n            // have a `xlink:href` attribute to set the source of the image.\n            el.setAttributeNS(ns, trueName, value);\n        } else if (trueName === 'id') {\n            el.id = value;\n        } else {\n            el.setAttribute(trueName, value);\n        }\n\n        return this;\n    };\n\n    // Create an SVG document element.\n    // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\n    V.createSvgDocument = function(content) {\n\n        if (content) {\n            const XMLString = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${SVGVersion}\">${content}</svg>`;\n            const { documentElement } = V.parseXML(XMLString, { async: false });\n            return documentElement;\n        }\n\n        const svg = document.createElementNS(ns.svg, 'svg');\n        svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);\n        svg.setAttribute('version', SVGVersion);\n        return svg;\n    };\n\n    V.createSVGStyle = function(stylesheet) {\n        const { node } = V('style', { type: 'text/css' }, [\n            V.createCDATASection(stylesheet)\n        ]);\n        return node;\n    },\n\n    V.createCDATASection = function(data = '') {\n        const xml = document.implementation.createDocument(null, 'xml', null);\n        return xml.createCDATASection(data);\n    };\n\n    V.idCounter = 0;\n\n    // A function returning a unique identifier for this client session with every call.\n    V.uniqueId = function() {\n\n        return 'v-' + (++V.idCounter);\n    };\n\n    V.toNode = function(el) {\n\n        return V.isV(el) ? el.node : (el.nodeName && el || el[0]);\n    };\n\n    V.ensureId = function(node) {\n\n        node = V.toNode(node);\n        return node.id || (node.id = V.uniqueId());\n    };\n\n    // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n    // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\n    // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\n    // when you want to compare the actual DOM text content without having to add the unicode character in\n    // the place of all spaces.\n    V.sanitizeText = function(text) {\n\n        return (text || '').replace(/ /g, '\\u00A0');\n    };\n\n    V.isUndefined = function(value) {\n\n        return typeof value === 'undefined';\n    };\n\n    V.isString = function(value) {\n\n        return typeof value === 'string';\n    };\n\n    V.isObject = function(value) {\n\n        return value && (typeof value === 'object');\n    };\n\n    V.isArray = Array.isArray;\n\n    V.parseXML = function(data, opt) {\n\n        opt = opt || {};\n\n        var xml;\n\n        try {\n            var parser = new DOMParser();\n\n            if (!V.isUndefined(opt.async)) {\n                parser.async = opt.async;\n            }\n\n            xml = parser.parseFromString(data, 'text/xml');\n        } catch (error) {\n            xml = undefined;\n        }\n\n        if (!xml || xml.getElementsByTagName('parsererror').length) {\n            throw new Error('Invalid XML: ' + data);\n        }\n\n        return xml;\n    };\n\n    // Create an empty object which does not inherit any properties from `Object.prototype`.\n    // This is useful when we want to use an object as a dictionary without having to\n    // worry about inherited properties such as `toString`, `valueOf` etc.\n    const _attributeNames = Object.create(null);\n\n    // List of attributes for which not to split camel case words.\n    // It contains known SVG attribute names and may be extended with user-defined attribute names.\n    [\n        'baseFrequency',\n        'baseProfile',\n        'clipPathUnits',\n        'contentScriptType',\n        'contentStyleType',\n        'diffuseConstant',\n        'edgeMode',\n        'externalResourcesRequired',\n        'filterRes', // deprecated\n        'filterUnits',\n        'gradientTransform',\n        'gradientUnits',\n        'kernelMatrix',\n        'kernelUnitLength',\n        'keyPoints',\n        'lengthAdjust',\n        'limitingConeAngle',\n        'markerHeight',\n        'markerUnits',\n        'markerWidth',\n        'maskContentUnits',\n        'maskUnits',\n        'numOctaves',\n        'pathLength',\n        'patternContentUnits',\n        'patternTransform',\n        'patternUnits',\n        'pointsAtX',\n        'pointsAtY',\n        'pointsAtZ',\n        'preserveAlpha',\n        'preserveAspectRatio',\n        'primitiveUnits',\n        'refX',\n        'refY',\n        'requiredExtensions',\n        'requiredFeatures',\n        'specularConstant',\n        'specularExponent',\n        'spreadMethod',\n        'startOffset',\n        'stdDeviation',\n        'stitchTiles',\n        'surfaceScale',\n        'systemLanguage',\n        'tableValues',\n        'targetX',\n        'targetY',\n        'textLength',\n        'viewBox',\n        'viewTarget', // deprecated\n        'xChannelSelector',\n        'yChannelSelector',\n        'zoomAndPan' // deprecated\n    ].forEach((name) => _attributeNames[name] = name);\n\n    _attributeNames['xlinkShow'] = 'xlink:show';\n    _attributeNames['xlinkRole'] = 'xlink:role';\n    _attributeNames['xlinkActuate'] = 'xlink:actuate';\n    _attributeNames['xlinkHref'] = 'xlink:href';\n    _attributeNames['xlinkType'] = 'xlink:type';\n    _attributeNames['xlinkTitle'] = 'xlink:title';\n    _attributeNames['xmlBase'] = 'xml:base';\n    _attributeNames['xmlLang'] = 'xml:lang';\n    _attributeNames['xmlSpace'] = 'xml:space';\n\n    const attributeNames = new Proxy(_attributeNames, {\n        get(cache, name) {\n            // The cache is a dictionary of attribute names. See `_attributeNames` above.\n            // If the attribute name is not in the cache, it means that it is not\n            // a camel-case attribute name. In that case, we need to convert\n            // the attribute name to dash-separated words.\n            if (!V.supportCamelCaseAttributes) return name;\n            if (name in cache) {\n                return cache[name];\n            }\n            // Convert camel case to dash-separated words.\n            return (cache[name] = name.replace(/[A-Z]/g, '-$&').toLowerCase());\n        }\n    });\n\n    // Dictionary of attribute names\n    Object.defineProperty(V, 'attributeNames', {\n        enumerable: true,\n        value: attributeNames,\n        writable: false,\n    });\n\n    // Should camel case attributes be supported?\n    Object.defineProperty(V, 'supportCamelCaseAttributes', {\n        enumerable: true,\n        value: true,\n        writable: true,\n    });\n\n    /**\n     * @param {string} name\n     * @returns {{ns: string|null, local: string}} namespace and attribute name\n     */\n    V.qualifyAttr = function(name) {\n\n        if (name.indexOf(':') !== -1) {\n            var combinedKey = name.split(':');\n            return {\n                ns: ns[combinedKey[0]],\n                local: combinedKey[1]\n            };\n        }\n\n        return {\n            ns: null,\n            local: name\n        };\n    };\n\n    // Note: This regex allows multiple commas as separator which is incorrect in SVG\n    // This regex is used by `split()`, so it doesn't need to use /g\n    V.transformSeparatorRegex = /[ ,]+/;\n    // Note: All following regexes are more restrictive than SVG specification\n    // ReDoS mitigation: Use an anchor at the beginning of the match\n    // ReDoS mitigation: Avoid backtracking (uses `[^()]+` instead of `.*?`)\n    // ReDoS mitigation: Don't match initial `(` inside repeated part\n    // The following regex needs to use /g (= cannot use capturing groups)\n    V.transformRegex = /\\b\\w+\\([^()]+\\)/g;\n    // The following regexes need to use capturing groups (= cannot use /g)\n    V.transformFunctionRegex = /\\b(\\w+)\\(([^()]+)\\)/;\n    V.transformTranslateRegex = /\\btranslate\\(([^()]+)\\)/;\n    V.transformRotateRegex = /\\brotate\\(([^()]+)\\)/;\n    V.transformScaleRegex = /\\bscale\\(([^()]+)\\)/;\n\n    V.transformStringToMatrix = function(transform) {\n\n        // Initialize result matrix as identity matrix\n        let transformationMatrix = V.createSVGMatrix();\n\n        // Note: Multiple transform functions are allowed in `transform` string\n        // `match()` returns `null` if none found\n        const transformMatches = transform && transform.match(V.transformRegex);\n        if (!transformMatches) {\n            // Return identity matrix\n            return transformationMatrix;\n        }\n\n        const numMatches = transformMatches.length;\n        for (let i = 0; i < numMatches; i++) {\n\n            const transformMatch = transformMatches[i];\n            // Use same regex as above, but with capturing groups\n            // `match()` returns values of capturing groups as `[1]`, `[2]`\n            const transformFunctionMatch = transformMatch.match(V.transformFunctionRegex);\n            if (transformFunctionMatch) {\n\n                let sx, sy, tx, ty, angle;\n                let ctm = V.createSVGMatrix();\n                const transformFunction = transformFunctionMatch[1].toLowerCase();\n                const args = transformFunctionMatch[2].split(V.transformSeparatorRegex);\n                switch (transformFunction) {\n\n                    case 'scale':\n                        sx = parseFloat(args[0]);\n                        sy = (args[1] === undefined) ? sx : parseFloat(args[1]);\n                        ctm = ctm.scaleNonUniform(sx, sy);\n                        break;\n\n                    case 'translate':\n                        tx = parseFloat(args[0]);\n                        ty = parseFloat(args[1]);\n                        ctm = ctm.translate(tx, ty);\n                        break;\n\n                    case 'rotate':\n                        angle = parseFloat(args[0]);\n                        tx = parseFloat(args[1]) || 0;\n                        ty = parseFloat(args[2]) || 0;\n                        if (tx !== 0 || ty !== 0) {\n                            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n                        } else {\n                            ctm = ctm.rotate(angle);\n                        }\n                        break;\n\n                    case 'skewx':\n                        angle = parseFloat(args[0]);\n                        ctm = ctm.skewX(angle);\n                        break;\n\n                    case 'skewy':\n                        angle = parseFloat(args[0]);\n                        ctm = ctm.skewY(angle);\n                        break;\n\n                    case 'matrix':\n                        ctm.a = parseFloat(args[0]);\n                        ctm.b = parseFloat(args[1]);\n                        ctm.c = parseFloat(args[2]);\n                        ctm.d = parseFloat(args[3]);\n                        ctm.e = parseFloat(args[4]);\n                        ctm.f = parseFloat(args[5]);\n                        break;\n\n                    default:\n                        continue;\n                }\n\n                // Multiply current transformation into result matrix\n                transformationMatrix = transformationMatrix.multiply(ctm);\n            }\n\n        }\n        return transformationMatrix;\n    };\n\n    V.matrixToTransformString = function(matrix) {\n        matrix || (matrix = true);\n\n        return 'matrix(' +\n            (matrix.a !== undefined ? matrix.a : 1) + ',' +\n            (matrix.b !== undefined ? matrix.b : 0) + ',' +\n            (matrix.c !== undefined ? matrix.c : 0) + ',' +\n            (matrix.d !== undefined ? matrix.d : 1) + ',' +\n            (matrix.e !== undefined ? matrix.e : 0) + ',' +\n            (matrix.f !== undefined ? matrix.f : 0) +\n            ')';\n    };\n\n    V.parseTransformString = function(transform) {\n\n        var translate, rotate, scale;\n\n        if (transform) {\n\n            var separator = V.transformSeparatorRegex;\n\n            // Special handling for `transform` with one or more matrix functions\n            if (transform.trim().indexOf('matrix') >= 0) {\n\n                // Convert EVERYTHING in `transform` string to a matrix\n                // Will combine ALL matrixes * ALL translates * ALL scales * ALL rotates\n                // Note: In non-matrix case, we only take first one of each (if any)\n                var matrix = V.transformStringToMatrix(transform);\n                var decomposedMatrix = V.decomposeMatrix(matrix);\n\n                // Extract `translate`, `scale`, `rotate` from matrix\n                translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n                scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n                rotate = [decomposedMatrix.rotation];\n\n                // Rewrite `transform` string in `translate scale rotate` format\n                var transformations = [];\n                if (translate[0] !== 0 || translate[1] !== 0) {\n                    transformations.push('translate(' + translate + ')');\n                }\n                if (scale[0] !== 1 || scale[1] !== 1) {\n                    transformations.push('scale(' + scale + ')');\n                }\n                if (rotate[0] !== 0) {\n                    transformations.push('rotate(' + rotate + ')');\n                }\n                transform = transformations.join(' ');\n\n            } else {\n\n                // Extract `translate`, `rotate`, `scale` functions from `transform` string\n                // Note: We only detect the first match of each (if any)\n                // `match()` returns value of capturing group as `[1]`\n                const translateMatch = transform.match(V.transformTranslateRegex);\n                if (translateMatch) {\n                    translate = translateMatch[1].split(separator);\n                }\n                const rotateMatch = transform.match(V.transformRotateRegex);\n                if (rotateMatch) {\n                    rotate = rotateMatch[1].split(separator);\n                }\n                const scaleMatch = transform.match(V.transformScaleRegex);\n                if (scaleMatch) {\n                    scale = scaleMatch[1].split(separator);\n                }\n            }\n        }\n\n        var sx = (scale && scale[0]) ? parseFloat(scale[0]) : 1;\n\n        return {\n            value: transform,\n            translate: {\n                tx: (translate && translate[0]) ? parseInt(translate[0], 10) : 0,\n                ty: (translate && translate[1]) ? parseInt(translate[1], 10) : 0\n            },\n            rotate: {\n                angle: (rotate && rotate[0]) ? parseInt(rotate[0], 10) : 0,\n                cx: (rotate && rotate[1]) ? parseInt(rotate[1], 10) : undefined,\n                cy: (rotate && rotate[2]) ? parseInt(rotate[2], 10) : undefined\n            },\n            scale: {\n                sx: sx,\n                sy: (scale && scale[1]) ? parseFloat(scale[1]) : sx\n            }\n        };\n    };\n\n    V.deltaTransformPoint = function(matrix, point) {\n\n        var dx = point.x * matrix.a + point.y * matrix.c + 0;\n        var dy = point.x * matrix.b + point.y * matrix.d + 0;\n        return { x: dx, y: dy };\n    };\n\n    V.decomposeMatrix = function(matrix) {\n\n        // @see https://gist.github.com/2052247\n\n        // calculate delta transform point\n        var px = V.deltaTransformPoint(matrix, { x: 0, y: 1 });\n        var py = V.deltaTransformPoint(matrix, { x: 1, y: 0 });\n\n        // calculate skew\n        var skewX = ((180 / PI) * atan2(px.y, px.x) - 90);\n        var skewY = ((180 / PI) * atan2(py.y, py.x));\n\n        return {\n\n            translateX: matrix.e,\n            translateY: matrix.f,\n            scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n            scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n            skewX: skewX,\n            skewY: skewY,\n            rotation: skewX // rotation is the same as skew x\n        };\n    };\n\n    // Return the `scale` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToScale = function(matrix) {\n\n        var a, b, c, d;\n        if (matrix) {\n            a = V.isUndefined(matrix.a) ? 1 : matrix.a;\n            d = V.isUndefined(matrix.d) ? 1 : matrix.d;\n            b = matrix.b;\n            c = matrix.c;\n        } else {\n            a = d = 1;\n        }\n        return {\n            sx: b ? sqrt(a * a + b * b) : a,\n            sy: c ? sqrt(c * c + d * d) : d\n        };\n    };\n\n    // Return the `rotate` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToRotate = function(matrix) {\n\n        var p = { x: 0, y: 1 };\n        if (matrix) {\n            p = V.deltaTransformPoint(matrix, p);\n        }\n\n        return {\n            angle: g.normalizeAngle(g.toDeg(atan2(p.y, p.x)) - 90)\n        };\n    };\n\n    // Return the `translate` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToTranslate = function(matrix) {\n\n        return {\n            tx: (matrix && matrix.e) || 0,\n            ty: (matrix && matrix.f) || 0\n        };\n    };\n\n    V.isV = function(object) {\n\n        return object instanceof V;\n    };\n\n    // For backwards compatibility:\n    V.isVElement = V.isV;\n\n    // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`\n    // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n    V.isSVGGraphicsElement = function(node) {\n        if (!node) return false;\n        node = V.toNode(node);\n        // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below\n        return node instanceof SVGElement && typeof node.getScreenCTM === 'function';\n    };\n\n    var svgDocument = V('svg').node;\n\n    V.createSVGMatrix = function(matrix) {\n\n        var svgMatrix = svgDocument.createSVGMatrix();\n        for (var component in matrix) {\n            svgMatrix[component] = matrix[component];\n        }\n\n        return svgMatrix;\n    };\n\n    V.createSVGTransform = function(matrix) {\n\n        if (!V.isUndefined(matrix)) {\n\n            if (!(matrix instanceof SVGMatrix)) {\n                matrix = V.createSVGMatrix(matrix);\n            }\n\n            return svgDocument.createSVGTransformFromMatrix(matrix);\n        }\n\n        return svgDocument.createSVGTransform();\n    };\n\n    V.createSVGPoint = function(x, y) {\n\n        var p = svgDocument.createSVGPoint();\n        p.x = x;\n        p.y = y;\n        return p;\n    };\n\n    V.transformRect = function(r, matrix) {\n\n        var p = svgDocument.createSVGPoint();\n\n        p.x = r.x;\n        p.y = r.y;\n        var corner1 = p.matrixTransform(matrix);\n\n        p.x = r.x + r.width;\n        p.y = r.y;\n        var corner2 = p.matrixTransform(matrix);\n\n        p.x = r.x + r.width;\n        p.y = r.y + r.height;\n        var corner3 = p.matrixTransform(matrix);\n\n        p.x = r.x;\n        p.y = r.y + r.height;\n        var corner4 = p.matrixTransform(matrix);\n\n        var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);\n        var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);\n        var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);\n        var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);\n\n        return new g.Rect(minX, minY, maxX - minX, maxY - minY);\n    };\n\n    V.transformPoint = function(p, matrix) {\n\n        return new g.Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\n    };\n\n    V.transformLine = function(l, matrix) {\n\n        return new g.Line(\n            V.transformPoint(l.start, matrix),\n            V.transformPoint(l.end, matrix)\n        );\n    };\n\n    V.transformPolyline = function(p, matrix) {\n\n        var inPoints = (p instanceof g.Polyline) ? p.points : p;\n        if (!V.isArray(inPoints)) inPoints = [];\n        var outPoints = [];\n        for (var i = 0, n = inPoints.length; i < n; i++) outPoints[i] = V.transformPoint(inPoints[i], matrix);\n        return new g.Polyline(outPoints);\n    };\n\n    // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\n    // an object (`{ fill: 'blue', stroke: 'red' }`).\n    V.styleToObject = function(styleString) {\n        var ret = {};\n        var styles = styleString.split(';');\n        for (var i = 0; i < styles.length; i++) {\n            var style = styles[i];\n            var pair = style.split('=');\n            ret[pair[0].trim()] = pair[1].trim();\n        }\n        return ret;\n    };\n\n    // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n    V.createSlicePathData = function(innerRadius, outerRadius, startAngle, endAngle) {\n\n        var svgArcMax = 2 * PI - 1e-6;\n        var r0 = innerRadius;\n        var r1 = outerRadius;\n        var a0 = startAngle;\n        var a1 = endAngle;\n        var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\n        var df = da < PI ? '0' : '1';\n        var c0 = cos(a0);\n        var s0 = sin(a0);\n        var c1 = cos(a1);\n        var s1 = sin(a1);\n\n        return (da >= svgArcMax)\n            ? (r0\n                ? 'M0,' + r1\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n                + 'M0,' + r0\n                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + (-r0)\n                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0\n                + 'Z'\n                : 'M0,' + r1\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n                + 'Z')\n            : (r0\n                ? 'M' + r1 * c0 + ',' + r1 * s0\n                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n                + 'L' + r0 * c1 + ',' + r0 * s1\n                + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0\n                + 'Z'\n                : 'M' + r1 * c0 + ',' + r1 * s0\n                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n                + 'L0,0'\n                + 'Z');\n    };\n\n    // Merge attributes from object `b` with attributes in object `a`.\n    // Note that this modifies the object `a`.\n    // Also important to note that attributes are merged but CSS classes are concatenated.\n    V.mergeAttrs = function(a, b) {\n\n        for (var attr in b) {\n\n            if (attr === 'class') {\n                // Concatenate classes.\n                a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];\n            } else if (attr === 'style') {\n                // `style` attribute can be an object.\n                if (V.isObject(a[attr]) && V.isObject(b[attr])) {\n                    // `style` stored in `a` is an object.\n                    a[attr] = V.mergeAttrs(a[attr], b[attr]);\n                } else if (V.isObject(a[attr])) {\n                    // `style` in `a` is an object but it's a string in `b`.\n                    // Convert the style represented as a string to an object in `b`.\n                    a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\n                } else if (V.isObject(b[attr])) {\n                    // `style` in `a` is a string, in `b` it's an object.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\n                } else {\n                    // Both styles are strings.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\n                }\n            } else {\n                a[attr] = b[attr];\n            }\n        }\n\n        return a;\n    };\n\n    V.annotateString = function(t, annotations, opt) {\n\n        annotations = annotations || [];\n        opt = opt || {};\n\n        var offset = opt.offset || 0;\n        var compacted = [];\n        var batch;\n        var ret = [];\n        var item;\n        var prev;\n\n        for (var i = 0; i < t.length; i++) {\n\n            item = ret[i] = t[i];\n\n            for (var j = 0; j < annotations.length; j++) {\n\n                var annotation = annotations[j];\n                var start = annotation.start + offset;\n                var end = annotation.end + offset;\n\n                if (i >= start && i < end) {\n                    // Annotation applies.\n                    if (V.isObject(item)) {\n                        // There is more than one annotation to be applied => Merge attributes.\n                        item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\n                    } else {\n                        item = ret[i] = { t: t[i], attrs: annotation.attrs };\n                    }\n                    if (opt.includeAnnotationIndices) {\n                        (item.annotations || (item.annotations = [])).push(j);\n                    }\n                }\n            }\n\n            prev = ret[i - 1];\n\n            if (!prev) {\n\n                batch = item;\n\n            } else if (V.isObject(item) && V.isObject(prev)) {\n                // Both previous item and the current one are annotations. If the attributes\n                // didn't change, merge the text.\n                if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {\n                    batch.t += item.t;\n                } else {\n                    compacted.push(batch);\n                    batch = item;\n                }\n\n            } else if (V.isObject(item)) {\n                // Previous item was a string, current item is an annotation.\n                compacted.push(batch);\n                batch = item;\n\n            } else if (V.isObject(prev)) {\n                // Previous item was an annotation, current item is a string.\n                compacted.push(batch);\n                batch = item;\n\n            } else {\n                // Both previous and current item are strings.\n                batch = (batch || '') + item;\n            }\n        }\n\n        if (batch) {\n            compacted.push(batch);\n        }\n\n        return compacted;\n    };\n\n    V.findAnnotationsAtIndex = function(annotations, index) {\n\n        var found = [];\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if (annotation.start < index && index <= annotation.end) {\n                    found.push(annotation);\n                }\n            });\n        }\n\n        return found;\n    };\n\n    V.findAnnotationsBetweenIndexes = function(annotations, start, end) {\n\n        var found = [];\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if ((start >= annotation.start && start < annotation.end) || (end > annotation.start && end <= annotation.end) || (annotation.start >= start && annotation.end < end)) {\n                    found.push(annotation);\n                }\n            });\n        }\n\n        return found;\n    };\n\n    // Shift all the text annotations after character `index` by `offset` positions.\n    V.shiftAnnotations = function(annotations, index, offset) {\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if (annotation.start < index && annotation.end >= index) {\n                    annotation.end += offset;\n                } else if (annotation.start >= index) {\n                    annotation.start += offset;\n                    annotation.end += offset;\n                }\n            });\n        }\n\n        return annotations;\n    };\n\n    V.convertLineToPathData = function(line) {\n\n        line = V(line);\n        var d = [\n            'M', line.attr('x1'), line.attr('y1'),\n            'L', line.attr('x2'), line.attr('y2')\n        ].join(' ');\n        return d;\n    };\n\n    V.convertPolygonToPathData = function(polygon) {\n\n        var points = V.getPointsFromSvgNode(polygon);\n        if (points.length === 0) return null;\n\n        return V.svgPointsToPath(points) + ' Z';\n    };\n\n    V.convertPolylineToPathData = function(polyline) {\n\n        var points = V.getPointsFromSvgNode(polyline);\n        if (points.length === 0) return null;\n\n        return V.svgPointsToPath(points);\n    };\n\n    V.svgPointsToPath = function(points) {\n\n        for (var i = 0, n = points.length; i < n; i++) {\n            points[i] = points[i].x + ' ' + points[i].y;\n        }\n\n        return 'M ' + points.join(' L');\n    };\n\n    V.getPointsFromSvgNode = function(node) {\n\n        node = V.toNode(node);\n        var points = [];\n        var nodePoints = node.points;\n        if (nodePoints) {\n            for (var i = 0, n = nodePoints.numberOfItems; i < n; i++) {\n                points.push(nodePoints.getItem(i));\n            }\n        }\n\n        return points;\n    };\n\n    V.KAPPA = 0.551784;\n\n    V.convertCircleToPathData = function(circle) {\n\n        circle = V(circle);\n        var cx = parseFloat(circle.attr('cx')) || 0;\n        var cy = parseFloat(circle.attr('cy')) || 0;\n        var r = parseFloat(circle.attr('r'));\n        var cd = r * V.KAPPA; // Control distance.\n\n        var d = [\n            'M', cx, cy - r,    // Move to the first point.\n            'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy, // I. Quadrant.\n            'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r, // II. Quadrant.\n            'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy, // III. Quadrant.\n            'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r, // IV. Quadrant.\n            'Z'\n        ].join(' ');\n        return d;\n    };\n\n    V.convertEllipseToPathData = function(ellipse) {\n\n        ellipse = V(ellipse);\n        var cx = parseFloat(ellipse.attr('cx')) || 0;\n        var cy = parseFloat(ellipse.attr('cy')) || 0;\n        var rx = parseFloat(ellipse.attr('rx'));\n        var ry = parseFloat(ellipse.attr('ry')) || rx;\n        var cdx = rx * V.KAPPA; // Control distance x.\n        var cdy = ry * V.KAPPA; // Control distance y.\n\n        var d = [\n            'M', cx, cy - ry,    // Move to the first point.\n            'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy, // I. Quadrant.\n            'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry, // II. Quadrant.\n            'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy, // III. Quadrant.\n            'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry, // IV. Quadrant.\n            'Z'\n        ].join(' ');\n        return d;\n    };\n\n    V.convertRectToPathData = function(rect) {\n\n        rect = V(rect);\n\n        return V.rectToPath({\n            x: parseFloat(rect.attr('x')) || 0,\n            y: parseFloat(rect.attr('y')) || 0,\n            width: parseFloat(rect.attr('width')) || 0,\n            height: parseFloat(rect.attr('height')) || 0,\n            rx: parseFloat(rect.attr('rx')) || 0,\n            ry: parseFloat(rect.attr('ry')) || 0\n        });\n    };\n\n    // Convert a rectangle to SVG path commands. `r` is an object of the form:\n    // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\n    // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\n    // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\n    // that has only `rx` and `ry` attributes).\n    V.rectToPath = function(r) {\n\n        var d;\n        var x = r.x;\n        var y = r.y;\n        var width = r.width;\n        var height = r.height;\n        var topRx = min(r.rx || r['top-rx'] || 0, width / 2);\n        var bottomRx = min(r.rx || r['bottom-rx'] || 0, width / 2);\n        var topRy = min(r.ry || r['top-ry'] || 0, height / 2);\n        var bottomRy = min(r.ry || r['bottom-ry'] || 0, height / 2);\n\n        if (topRx || bottomRx || topRy || bottomRy) {\n            d = [\n                'M', x, y + topRy,\n                'v', height - topRy - bottomRy,\n                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy,\n                'h', width - 2 * bottomRx,\n                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy,\n                'v', -(height - bottomRy - topRy),\n                'a', topRx, topRy, 0, 0, 0, -topRx, -topRy,\n                'h', -(width - 2 * topRx),\n                'a', topRx, topRy, 0, 0, 0, -topRx, topRy,\n                'Z'\n            ];\n        } else {\n            d = [\n                'M', x, y,\n                'H', x + width,\n                'V', y + height,\n                'H', x,\n                'V', y,\n                'Z'\n            ];\n        }\n\n        return d.join(' ');\n    };\n\n    // Take a path data string\n    // Return a normalized path data string\n    // If data cannot be parsed, return 'M 0 0'\n    // Highly inspired by Raphael Library (www.raphael.com)\n    V.normalizePathData = (function() {\n\n        var spaces = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\n        var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', 'ig');\n        var pathValues = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');\n\n        var math = Math;\n        var PI = math.PI;\n        var sin = math.sin;\n        var cos = math.cos;\n        var tan = math.tan;\n        var asin = math.asin;\n        var sqrt = math.sqrt;\n        var abs = math.abs;\n\n        function q2c(x1, y1, ax, ay, x2, y2) {\n\n            var _13 = 1 / 3;\n            var _23 = 2 / 3;\n            return [(_13 * x1) + (_23 * ax), (_13 * y1) + (_23 * ay), (_13 * x2) + (_23 * ax), (_13 * y2) + (_23 * ay), x2, y2];\n        }\n\n        function rotate(x, y, rad) {\n\n            var X = (x * cos(rad)) - (y * sin(rad));\n            var Y = (x * sin(rad)) + (y * cos(rad));\n            return { x: X, y: Y };\n        }\n\n        function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n            // for more information of where this math came from visit:\n            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n            var _120 = (PI * 120) / 180;\n            var rad = (PI / 180) * (+angle || 0);\n            var res = [];\n            var xy;\n\n            if (!recursive) {\n                xy = rotate(x1, y1, -rad);\n                x1 = xy.x;\n                y1 = xy.y;\n\n                xy = rotate(x2, y2, -rad);\n                x2 = xy.x;\n                y2 = xy.y;\n\n                var x = (x1 - x2) / 2;\n                var y = (y1 - y2) / 2;\n                var h = ((x * x) / (rx * rx)) + ((y * y) / (ry * ry));\n\n                if (h > 1) {\n                    h = sqrt(h);\n                    rx = h * rx;\n                    ry = h * ry;\n                }\n\n                var rx2 = rx * rx;\n                var ry2 = ry * ry;\n\n                var k = ((large_arc_flag == sweep_flag) ? -1 : 1) * sqrt(abs(((rx2 * ry2) - (rx2 * y * y) - (ry2 * x * x)) / ((rx2 * y * y) + (ry2 * x * x))));\n\n                var cx = ((k * rx * y) / ry) + ((x1 + x2) / 2);\n                var cy = ((k * -ry * x) / rx) + ((y1 + y2) / 2);\n\n                var f1 = asin(((y1 - cy) / ry).toFixed(9));\n                var f2 = asin(((y2 - cy) / ry).toFixed(9));\n\n                f1 = ((x1 < cx) ? (PI - f1) : f1);\n                f2 = ((x2 < cx) ? (PI - f2) : f2);\n\n                if (f1 < 0) f1 = (PI * 2) + f1;\n                if (f2 < 0) f2 = (PI * 2) + f2;\n\n                if (sweep_flag && (f1 > f2)) f1 = f1 - (PI * 2);\n                if (!sweep_flag && (f2 > f1)) f2 = f2 - (PI * 2);\n\n            } else {\n                f1 = recursive[0];\n                f2 = recursive[1];\n                cx = recursive[2];\n                cy = recursive[3];\n            }\n\n            var df = f2 - f1;\n            if (abs(df) > _120) {\n                var f2old = f2;\n                var x2old = x2;\n                var y2old = y2;\n                f2 = f1 + (_120 * ((sweep_flag && (f2 > f1)) ? 1 : -1));\n                x2 = cx + (rx * cos(f2));\n                y2 = cy + (ry * sin(f2));\n                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n            }\n\n            df = f2 - f1;\n\n            var c1 = cos(f1);\n            var s1 = sin(f1);\n            var c2 = cos(f2);\n            var s2 = sin(f2);\n            var t = tan(df / 4);\n            var hx = (4 / 3) * (rx * t);\n            var hy = (4 / 3) * (ry * t);\n            var m1 = [x1, y1];\n            var m2 = [x1 + (hx * s1), y1 - (hy * c1)];\n            var m3 = [x2 + (hx * s2), y2 - (hy * c2)];\n            var m4 = [x2, y2];\n\n            m2[0] = (2 * m1[0]) - m2[0];\n            m2[1] = (2 * m1[1]) - m2[1];\n\n            if (recursive) {\n                return [m2, m3, m4].concat(res);\n            } else {\n                res = [m2, m3, m4].concat(res).join().split(',');\n                var newres = [];\n                var ii = res.length;\n                for (var i = 0; i < ii; i++) {\n                    newres[i] = (i % 2) ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n                }\n                return newres;\n            }\n        }\n\n        function parsePathString(pathString) {\n\n            if (!pathString) return null;\n\n            var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };\n            var data = [];\n\n            String(pathString).replace(pathCommand, function(a, b, c) {\n\n                var params = [];\n                var name = b.toLowerCase();\n                c.replace(pathValues, function(a, b) {\n                    if (b) params.push(+b);\n                });\n\n                if ((name === 'm') && (params.length > 2)) {\n                    data.push([b].concat(params.splice(0, 2)));\n                    name = 'l';\n                    b = ((b === 'm') ? 'l' : 'L');\n                }\n\n                while (params.length >= paramCounts[name]) {\n                    data.push([b].concat(params.splice(0, paramCounts[name])));\n                    if (!paramCounts[name]) break;\n                }\n            });\n\n            return data;\n        }\n\n        function pathToAbsolute(pathArray) {\n\n            if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) { // rough assumption\n                pathArray = parsePathString(pathArray);\n            }\n\n            // if invalid string, return 'M 0 0'\n            if (!pathArray || !pathArray.length) return [['M', 0, 0]];\n\n            var res = [];\n            var x = 0;\n            var y = 0;\n            var mx = 0;\n            var my = 0;\n            var start = 0;\n            var pa0;\n\n            var ii = pathArray.length;\n            for (var i = start; i < ii; i++) {\n\n                var r = [];\n                res.push(r);\n\n                var pa = pathArray[i];\n                pa0 = pa[0];\n\n                if (pa0 != pa0.toUpperCase()) {\n                    r[0] = pa0.toUpperCase();\n\n                    var jj;\n                    var j;\n                    switch (r[0]) {\n                        case 'A':\n                            r[1] = pa[1];\n                            r[2] = pa[2];\n                            r[3] = pa[3];\n                            r[4] = pa[4];\n                            r[5] = pa[5];\n                            r[6] = +pa[6] + x;\n                            r[7] = +pa[7] + y;\n                            break;\n\n                        case 'V':\n                            r[1] = +pa[1] + y;\n                            break;\n\n                        case 'H':\n                            r[1] = +pa[1] + x;\n                            break;\n\n                        case 'M':\n                            mx = +pa[1] + x;\n                            my = +pa[2] + y;\n\n                            jj = pa.length;\n                            for (j = 1; j < jj; j++) {\n                                r[j] = +pa[j] + ((j % 2) ? x : y);\n                            }\n                            break;\n\n                        default:\n                            jj = pa.length;\n                            for (j = 1; j < jj; j++) {\n                                r[j] = +pa[j] + ((j % 2) ? x : y);\n                            }\n                            break;\n                    }\n                } else {\n                    var kk = pa.length;\n                    for (var k = 0; k < kk; k++) {\n                        r[k] = pa[k];\n                    }\n                }\n\n                switch (r[0]) {\n                    case 'Z':\n                        x = +mx;\n                        y = +my;\n                        break;\n\n                    case 'H':\n                        x = r[1];\n                        break;\n\n                    case 'V':\n                        y = r[1];\n                        break;\n\n                    case 'M':\n                        mx = r[r.length - 2];\n                        my = r[r.length - 1];\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                        break;\n\n                    default:\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                        break;\n                }\n            }\n\n            return res;\n        }\n\n        function normalize(path) {\n\n            var p = pathToAbsolute(path);\n            var attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };\n\n            function processPath(path, d, pcom) {\n\n                var nx, ny;\n\n                if (!path) return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n\n                if (!(path[0] in { T: 1, Q: 1 })) {\n                    d.qx = null;\n                    d.qy = null;\n                }\n\n                switch (path[0]) {\n                    case 'M':\n                        d.X = path[1];\n                        d.Y = path[2];\n                        break;\n\n                    case 'A':\n                        if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {\n                            // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n                            // \"If either rx or ry is 0, then this arc is treated as a\n                            // straight line segment (a \"lineto\") joining the endpoints.\"\n                            path = ['L', path[6], path[7]];\n                        } else {\n                            path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n                        }\n                        break;\n\n                    case 'S':\n                        if (pcom === 'C' || pcom === 'S') { // In 'S' case we have to take into account, if the previous command is C/S.\n                            nx = (d.x * 2) - d.bx;          // And reflect the previous\n                            ny = (d.y * 2) - d.by;          // command's control point relative to the current point.\n                        } else {                            // or some else or nothing\n                            nx = d.x;\n                            ny = d.y;\n                        }\n                        path = ['C', nx, ny].concat(path.slice(1));\n                        break;\n\n                    case 'T':\n                        if (pcom === 'Q' || pcom === 'T') { // In 'T' case we have to take into account, if the previous command is Q/T.\n                            d.qx = (d.x * 2) - d.qx;        // And make a reflection similar\n                            d.qy = (d.y * 2) - d.qy;        // to case 'S'.\n                        } else {                            // or something else or nothing\n                            d.qx = d.x;\n                            d.qy = d.y;\n                        }\n                        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                        break;\n\n                    case 'Q':\n                        d.qx = path[1];\n                        d.qy = path[2];\n                        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                        break;\n\n                    case 'H':\n                        path = ['L'].concat(path[1], d.y);\n                        break;\n\n                    case 'V':\n                        path = ['L'].concat(d.x, path[1]);\n                        break;\n\n                    case 'L':\n                        break;\n\n                    case 'Z':\n                        break;\n                }\n\n                return path;\n            }\n\n            function fixArc(pp, i) {\n\n                if (pp[i].length > 7) {\n\n                    pp[i].shift();\n                    var pi = pp[i];\n\n                    while (pi.length) {\n                        pcoms[i] = 'A'; // if created multiple 'C's, their original seg is saved\n                        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n                    }\n\n                    pp.splice(i, 1);\n                    ii = p.length;\n                }\n            }\n\n            var pcoms = []; // path commands of original path p\n            var pfirst = ''; // temporary holder for original path command\n            var pcom = ''; // holder for previous path command of original path\n\n            var ii = p.length;\n            for (var i = 0; i < ii; i++) {\n                if (p[i]) pfirst = p[i][0]; // save current path command\n\n                if (pfirst !== 'C') { // C is not saved yet, because it may be result of conversion\n                    pcoms[i] = pfirst; // Save current path command\n                    if (i > 0) pcom = pcoms[i - 1]; // Get previous path command pcom\n                }\n\n                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n                if (pcoms[i] !== 'A' && pfirst === 'C') pcoms[i] = 'C'; // 'A' is the only command\n                // which may produce multiple 'C's\n                // so we have to make sure that 'C' is also 'C' in original path\n\n                fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms\n\n                var seg = p[i];\n                var seglen = seg.length;\n\n                attrs.x = seg[seglen - 2];\n                attrs.y = seg[seglen - 1];\n\n                attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n                attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n            }\n\n            // make sure normalized path data string starts with an M segment\n            if (!p[0][0] || p[0][0] !== 'M') {\n                p.unshift(['M', 0, 0]);\n            }\n\n            return p;\n        }\n\n        return function(pathData) {\n            return normalize(pathData).join(',').split(',').join(' ');\n        };\n    })();\n\n    V.namespace = ns;\n\n    V.g = g;\n\n    return V;\n\n})();\n\nexport default V;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}