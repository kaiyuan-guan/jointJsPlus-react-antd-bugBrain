{"ast":null,"code":"import { Path, Point, Curve } from '../g/index.mjs';\nconst Directions = {\n  AUTO: 'auto',\n  HORIZONTAL: 'horizontal',\n  VERTICAL: 'vertical',\n  CLOSEST_POINT: 'closest-point',\n  OUTWARDS: 'outwards'\n};\nconst TangentDirections = {\n  UP: 'up',\n  DOWN: 'down',\n  LEFT: 'left',\n  RIGHT: 'right',\n  AUTO: 'auto',\n  CLOSEST_POINT: 'closest-point',\n  OUTWARDS: 'outwards'\n};\nexport const curve = function (sourcePoint, targetPoint, route = [], opt = {}, linkView) {\n  const raw = Boolean(opt.raw);\n  // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.\n  // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.\n  // tension - a Catmull-Rom curve tension parameter.\n  // sourceTangent - a tangent vector along the curve at the sourcePoint.\n  // sourceDirection - a unit direction vector along the curve at the sourcePoint.\n  // targetTangent - a tangent vector along the curve at the targetPoint.\n  // targetDirection - a unit direction vector along the curve at the targetPoint.\n  // precision - a rounding precision for path values.\n  const {\n    direction = Directions.AUTO,\n    precision = 3\n  } = opt;\n  const options = {\n    coeff: opt.distanceCoefficient || 0.6,\n    angleTangentCoefficient: opt.angleTangentCoefficient || 80,\n    tau: opt.tension || 0.5,\n    sourceTangent: opt.sourceTangent ? new Point(opt.sourceTangent) : null,\n    targetTangent: opt.targetTangent ? new Point(opt.targetTangent) : null,\n    rotate: Boolean(opt.rotate)\n  };\n  if (typeof opt.sourceDirection === 'string') options.sourceDirection = opt.sourceDirection;else if (typeof opt.sourceDirection === 'number') options.sourceDirection = new Point(1, 0).rotate(null, opt.sourceDirection);else options.sourceDirection = opt.sourceDirection ? new Point(opt.sourceDirection).normalize() : null;\n  if (typeof opt.targetDirection === 'string') options.targetDirection = opt.targetDirection;else if (typeof opt.targetDirection === 'number') options.targetDirection = new Point(1, 0).rotate(null, opt.targetDirection);else options.targetDirection = opt.targetDirection ? new Point(opt.targetDirection).normalize() : null;\n  const completeRoute = [sourcePoint, ...route, targetPoint].map(p => new Point(p));\n\n  // The calculation of a sourceTangent\n  let sourceTangent;\n  if (options.sourceTangent) {\n    sourceTangent = options.sourceTangent;\n  } else {\n    const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);\n    const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;\n    const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();\n    const angle = angleBetweenVectors(sourceDirection, pointsVector);\n    if (angle > Math.PI / 4) {\n      const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n      sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);\n    } else {\n      sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);\n    }\n  }\n\n  // The calculation of a targetTangent\n  let targetTangent;\n  if (options.targetTangent) {\n    targetTangent = options.targetTangent;\n  } else {\n    const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);\n    const last = completeRoute.length - 1;\n    const tangentLength = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;\n    const pointsVector = completeRoute[last - 1].difference(completeRoute[last]).normalize();\n    const angle = angleBetweenVectors(targetDirection, pointsVector);\n    if (angle > Math.PI / 4) {\n      const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n      targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);\n    } else {\n      targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);\n    }\n  }\n  const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);\n  const bezierCurves = catmullRomCurves.map(curve => catmullRomToBezier(curve, options));\n  const path = new Path(bezierCurves).round(precision);\n  return raw ? path : path.serialize();\n};\ncurve.Directions = Directions;\ncurve.TangentDirections = TangentDirections;\nfunction getHorizontalSourceDirection(linkView, route, options) {\n  const {\n    sourceBBox\n  } = linkView;\n  let sourceSide;\n  let rotation;\n  if (!linkView.sourceView) {\n    if (sourceBBox.x > route[1].x) sourceSide = 'right';else sourceSide = 'left';\n  } else {\n    rotation = linkView.sourceView.model.angle();\n    if (options.rotate && rotation) {\n      const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n      const sourcePoint = route[0].clone();\n      sourcePoint.rotate(sourceBBox.center(), rotation);\n      sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n    } else {\n      sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n    }\n  }\n  let direction;\n  switch (sourceSide) {\n    case 'left':\n      direction = new Point(-1, 0);\n      break;\n    case 'right':\n    default:\n      direction = new Point(1, 0);\n      break;\n  }\n  if (options.rotate && rotation) {\n    direction.rotate(null, -rotation);\n  }\n  return direction;\n}\nfunction getHorizontalTargetDirection(linkView, route, options) {\n  const {\n    targetBBox\n  } = linkView;\n  let targetSide;\n  let rotation;\n  if (!linkView.targetView) {\n    if (targetBBox.x > route[route.length - 2].x) targetSide = 'left';else targetSide = 'right';\n  } else {\n    rotation = linkView.targetView.model.angle();\n    if (options.rotate && rotation) {\n      const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n      const targetPoint = route[route.length - 1].clone();\n      targetPoint.rotate(targetBBox.center(), rotation);\n      targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n    } else {\n      targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n    }\n  }\n  let direction;\n  switch (targetSide) {\n    case 'left':\n      direction = new Point(-1, 0);\n      break;\n    case 'right':\n    default:\n      direction = new Point(1, 0);\n      break;\n  }\n  if (options.rotate && rotation) {\n    direction.rotate(null, -rotation);\n  }\n  return direction;\n}\nfunction getVerticalSourceDirection(linkView, route, options) {\n  const {\n    sourceBBox\n  } = linkView;\n  let sourceSide;\n  let rotation;\n  if (!linkView.sourceView) {\n    if (sourceBBox.y > route[1].y) sourceSide = 'bottom';else sourceSide = 'top';\n  } else {\n    rotation = linkView.sourceView.model.angle();\n    if (options.rotate && rotation) {\n      const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n      const sourcePoint = route[0].clone();\n      sourcePoint.rotate(sourceBBox.center(), rotation);\n      sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n    } else {\n      sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n    }\n  }\n  let direction;\n  switch (sourceSide) {\n    case 'top':\n      direction = new Point(0, -1);\n      break;\n    case 'bottom':\n    default:\n      direction = new Point(0, 1);\n      break;\n  }\n  if (options.rotate && rotation) {\n    direction.rotate(null, -rotation);\n  }\n  return direction;\n}\nfunction getVerticalTargetDirection(linkView, route, options) {\n  const {\n    targetBBox\n  } = linkView;\n  let targetSide;\n  let rotation;\n  if (!linkView.targetView) {\n    if (targetBBox.y > route[route.length - 2].y) targetSide = 'top';else targetSide = 'bottom';\n  } else {\n    rotation = linkView.targetView.model.angle();\n    if (options.rotate && rotation) {\n      const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n      const targetPoint = route[route.length - 1].clone();\n      targetPoint.rotate(targetBBox.center(), rotation);\n      targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n    } else {\n      targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n    }\n  }\n  let direction;\n  switch (targetSide) {\n    case 'top':\n      direction = new Point(0, -1);\n      break;\n    case 'bottom':\n    default:\n      direction = new Point(0, 1);\n      break;\n  }\n  if (options.rotate && rotation) {\n    direction.rotate(null, -rotation);\n  }\n  return direction;\n}\nfunction getAutoSourceDirection(linkView, route, options) {\n  const {\n    sourceBBox\n  } = linkView;\n  let sourceSide;\n  let rotation;\n  if (!linkView.sourceView) {\n    sourceSide = sourceBBox.sideNearestToPoint(route[1]);\n  } else {\n    rotation = linkView.sourceView.model.angle();\n    if (options.rotate && rotation) {\n      const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n      const sourcePoint = route[0].clone();\n      sourcePoint.rotate(sourceBBox.center(), rotation);\n      sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n    } else {\n      sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n    }\n  }\n  let direction;\n  switch (sourceSide) {\n    case 'top':\n      direction = new Point(0, -1);\n      break;\n    case 'bottom':\n      direction = new Point(0, 1);\n      break;\n    case 'right':\n      direction = new Point(1, 0);\n      break;\n    case 'left':\n      direction = new Point(-1, 0);\n      break;\n  }\n  if (options.rotate && rotation) {\n    direction.rotate(null, -rotation);\n  }\n  return direction;\n}\nfunction getAutoTargetDirection(linkView, route, options) {\n  const {\n    targetBBox\n  } = linkView;\n  let targetSide;\n  let rotation;\n  if (!linkView.targetView) {\n    targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);\n  } else {\n    rotation = linkView.targetView.model.angle();\n    if (options.rotate && rotation) {\n      const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n      const targetPoint = route[route.length - 1].clone();\n      targetPoint.rotate(targetBBox.center(), rotation);\n      targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n    } else {\n      targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n    }\n  }\n  let direction;\n  switch (targetSide) {\n    case 'top':\n      direction = new Point(0, -1);\n      break;\n    case 'bottom':\n      direction = new Point(0, 1);\n      break;\n    case 'right':\n      direction = new Point(1, 0);\n      break;\n    case 'left':\n      direction = new Point(-1, 0);\n      break;\n  }\n  if (options.rotate && rotation) {\n    direction.rotate(null, -rotation);\n  }\n  return direction;\n}\nfunction getClosestPointSourceDirection(linkView, route, options) {\n  return route[1].difference(route[0]).normalize();\n}\nfunction getClosestPointTargetDirection(linkView, route, options) {\n  const last = route.length - 1;\n  return route[last - 1].difference(route[last]).normalize();\n}\nfunction getOutwardsSourceDirection(linkView, route, options) {\n  const {\n    sourceBBox\n  } = linkView;\n  const sourceCenter = sourceBBox.center();\n  return route[0].difference(sourceCenter).normalize();\n}\nfunction getOutwardsTargetDirection(linkView, route, options) {\n  const {\n    targetBBox\n  } = linkView;\n  const targetCenter = targetBBox.center();\n  return route[route.length - 1].difference(targetCenter).normalize();\n}\nfunction getSourceTangentDirection(linkView, route, direction, options) {\n  if (options.sourceDirection) {\n    switch (options.sourceDirection) {\n      case TangentDirections.UP:\n        return new Point(0, -1);\n      case TangentDirections.DOWN:\n        return new Point(0, 1);\n      case TangentDirections.LEFT:\n        return new Point(-1, 0);\n      case TangentDirections.RIGHT:\n        return new Point(1, 0);\n      case TangentDirections.AUTO:\n        return getAutoSourceDirection(linkView, route, options);\n      case TangentDirections.CLOSEST_POINT:\n        return getClosestPointSourceDirection(linkView, route, options);\n      case TangentDirections.OUTWARDS:\n        return getOutwardsSourceDirection(linkView, route, options);\n      default:\n        return options.sourceDirection;\n    }\n  }\n  switch (direction) {\n    case Directions.HORIZONTAL:\n      return getHorizontalSourceDirection(linkView, route, options);\n    case Directions.VERTICAL:\n      return getVerticalSourceDirection(linkView, route, options);\n    case Directions.CLOSEST_POINT:\n      return getClosestPointSourceDirection(linkView, route, options);\n    case Directions.OUTWARDS:\n      return getOutwardsSourceDirection(linkView, route, options);\n    case Directions.AUTO:\n    default:\n      return getAutoSourceDirection(linkView, route, options);\n  }\n}\nfunction getTargetTangentDirection(linkView, route, direction, options) {\n  if (options.targetDirection) {\n    switch (options.targetDirection) {\n      case TangentDirections.UP:\n        return new Point(0, -1);\n      case TangentDirections.DOWN:\n        return new Point(0, 1);\n      case TangentDirections.LEFT:\n        return new Point(-1, 0);\n      case TangentDirections.RIGHT:\n        return new Point(1, 0);\n      case TangentDirections.AUTO:\n        return getAutoTargetDirection(linkView, route, options);\n      case TangentDirections.CLOSEST_POINT:\n        return getClosestPointTargetDirection(linkView, route, options);\n      case TangentDirections.OUTWARDS:\n        return getOutwardsTargetDirection(linkView, route, options);\n      default:\n        return options.targetDirection;\n    }\n  }\n  switch (direction) {\n    case Directions.HORIZONTAL:\n      return getHorizontalTargetDirection(linkView, route, options);\n    case Directions.VERTICAL:\n      return getVerticalTargetDirection(linkView, route, options);\n    case Directions.CLOSEST_POINT:\n      return getClosestPointTargetDirection(linkView, route, options);\n    case Directions.OUTWARDS:\n      return getOutwardsTargetDirection(linkView, route, options);\n    case Directions.AUTO:\n    default:\n      return getAutoTargetDirection(linkView, route, options);\n  }\n}\nfunction rotateVector(vector, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const x = cos * vector.x - sin * vector.y;\n  const y = sin * vector.x + cos * vector.y;\n  vector.x = x;\n  vector.y = y;\n}\nfunction angleBetweenVectors(v1, v2) {\n  let cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n  if (cos < -1) cos = -1;\n  if (cos > 1) cos = 1;\n  return Math.acos(cos);\n}\nfunction determinant(v1, v2) {\n  return v1.x * v2.y - v1.y * v2.x;\n}\nfunction createCatmullRomCurves(points, sourceTangent, targetTangent, options) {\n  const {\n    tau,\n    coeff\n  } = options;\n  const distances = [];\n  const tangents = [];\n  const catmullRomCurves = [];\n  const n = points.length - 1;\n  for (let i = 0; i < n; i++) {\n    distances[i] = points[i].distance(points[i + 1]);\n  }\n  tangents[0] = sourceTangent;\n  tangents[n] = targetTangent;\n\n  // The calculation of tangents of vertices\n  for (let i = 1; i < n; i++) {\n    let tpPrev;\n    let tpNext;\n    if (i === 1) {\n      tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);\n    } else {\n      tpPrev = points[i - 1].clone();\n    }\n    if (i === n - 1) {\n      tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);\n    } else {\n      tpNext = points[i + 1].clone();\n    }\n    const v1 = tpPrev.difference(points[i]).normalize();\n    const v2 = tpNext.difference(points[i]).normalize();\n    const vAngle = angleBetweenVectors(v1, v2);\n    let rot = (Math.PI - vAngle) / 2;\n    let t;\n    const vectorDeterminant = determinant(v1, v2);\n    let pointsDeterminant;\n    pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));\n    if (vectorDeterminant < 0) {\n      rot = -rot;\n    }\n    if (vAngle < Math.PI / 2 && (rot < 0 && pointsDeterminant < 0 || rot > 0 && pointsDeterminant > 0)) {\n      rot = rot - Math.PI;\n    }\n    t = v2.clone();\n    rotateVector(t, rot);\n    const t1 = t.clone();\n    const t2 = t.clone();\n    const scaleFactor1 = distances[i - 1] * coeff;\n    const scaleFactor2 = distances[i] * coeff;\n    t1.scale(scaleFactor1, scaleFactor1);\n    t2.scale(scaleFactor2, scaleFactor2);\n    tangents[i] = [t1, t2];\n  }\n\n  // The building of a Catmull-Rom curve based of tangents of points\n  for (let i = 0; i < n; i++) {\n    let p0;\n    let p3;\n    if (i === 0) {\n      p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);\n    } else {\n      p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);\n    }\n    if (i === n - 1) {\n      p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);\n    } else {\n      p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);\n    }\n    catmullRomCurves[i] = [p0, points[i], points[i + 1], p3];\n  }\n  return catmullRomCurves;\n}\n\n// The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)\nfunction catmullRomToBezier(points, options) {\n  const {\n    tau\n  } = options;\n  const bcp1 = new Point();\n  bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);\n  bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);\n  const bcp2 = new Point();\n  bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);\n  bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);\n  return new Curve(points[1], bcp1, bcp2, points[2]);\n}","map":{"version":3,"names":["Path","Point","Curve","Directions","AUTO","HORIZONTAL","VERTICAL","CLOSEST_POINT","OUTWARDS","TangentDirections","UP","DOWN","LEFT","RIGHT","curve","sourcePoint","targetPoint","route","opt","linkView","raw","Boolean","direction","precision","options","coeff","distanceCoefficient","angleTangentCoefficient","tau","tension","sourceTangent","targetTangent","rotate","sourceDirection","normalize","targetDirection","completeRoute","map","p","getSourceTangentDirection","tangentLength","distance","pointsVector","difference","angle","angleBetweenVectors","Math","PI","updatedLength","clone","scale","getTargetTangentDirection","last","length","catmullRomCurves","createCatmullRomCurves","bezierCurves","catmullRomToBezier","path","round","serialize","getHorizontalSourceDirection","sourceBBox","sourceSide","rotation","sourceView","x","model","unrotatedBBox","getNodeUnrotatedBBox","el","center","sideNearestToPoint","getHorizontalTargetDirection","targetBBox","targetSide","targetView","getVerticalSourceDirection","y","getVerticalTargetDirection","getAutoSourceDirection","getAutoTargetDirection","getClosestPointSourceDirection","getClosestPointTargetDirection","getOutwardsSourceDirection","sourceCenter","getOutwardsTargetDirection","targetCenter","rotateVector","vector","cos","sin","v1","v2","dot","magnitude","acos","determinant","points","distances","tangents","n","i","tpPrev","tpNext","offset","vAngle","rot","t","vectorDeterminant","pointsDeterminant","t1","t2","scaleFactor1","scaleFactor2","p0","p3","bcp1","bcp2"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/connectors/curve.mjs"],"sourcesContent":["import { Path, Point, Curve } from '../g/index.mjs';\n\nconst Directions = {\n    AUTO: 'auto',\n    HORIZONTAL: 'horizontal',\n    VERTICAL: 'vertical',\n    CLOSEST_POINT: 'closest-point',\n    OUTWARDS: 'outwards'\n};\n\nconst TangentDirections = {\n    UP: 'up',\n    DOWN: 'down',\n    LEFT: 'left',\n    RIGHT: 'right',\n    AUTO: 'auto',\n    CLOSEST_POINT: 'closest-point',\n    OUTWARDS: 'outwards'\n};\n\nexport const curve = function(sourcePoint, targetPoint, route = [], opt = {}, linkView) {\n    const raw = Boolean(opt.raw);\n    // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.\n    // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.\n    // tension - a Catmull-Rom curve tension parameter.\n    // sourceTangent - a tangent vector along the curve at the sourcePoint.\n    // sourceDirection - a unit direction vector along the curve at the sourcePoint.\n    // targetTangent - a tangent vector along the curve at the targetPoint.\n    // targetDirection - a unit direction vector along the curve at the targetPoint.\n    // precision - a rounding precision for path values.\n    const { direction = Directions.AUTO, precision = 3 } = opt;\n    const options = {\n        coeff: opt.distanceCoefficient || 0.6,\n        angleTangentCoefficient: opt.angleTangentCoefficient || 80,\n        tau: opt.tension || 0.5,\n        sourceTangent: opt.sourceTangent ? new Point(opt.sourceTangent) : null,\n        targetTangent: opt.targetTangent ? new Point(opt.targetTangent) : null,\n        rotate: Boolean(opt.rotate)\n    };\n    if (typeof opt.sourceDirection === 'string')\n        options.sourceDirection = opt.sourceDirection;\n    else if (typeof opt.sourceDirection === 'number')\n        options.sourceDirection = new Point(1, 0).rotate(null, opt.sourceDirection);\n    else\n        options.sourceDirection = opt.sourceDirection ? new Point(opt.sourceDirection).normalize() : null;\n\n    if (typeof opt.targetDirection === 'string')\n        options.targetDirection = opt.targetDirection;\n    else if (typeof opt.targetDirection === 'number')\n        options.targetDirection = new Point(1, 0).rotate(null, opt.targetDirection);\n    else\n        options.targetDirection = opt.targetDirection ? new Point(opt.targetDirection).normalize() : null;\n\n    const completeRoute = [sourcePoint, ...route, targetPoint].map(p => new Point(p));\n\n    // The calculation of a sourceTangent\n    let sourceTangent;\n    if (options.sourceTangent) {\n        sourceTangent = options.sourceTangent;\n    } else {\n        const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);\n        const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;\n        const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();\n        const angle = angleBetweenVectors(sourceDirection, pointsVector);\n        if (angle > Math.PI / 4) {\n            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n            sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);\n        } else {\n            sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);\n        }\n    }\n\n    // The calculation of a targetTangent\n    let targetTangent;\n    if (options.targetTangent) {\n        targetTangent = options.targetTangent;\n    } else {\n        const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);\n        const last = completeRoute.length - 1;\n        const tangentLength = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;\n        const pointsVector = completeRoute[last - 1].difference(completeRoute[last]).normalize();\n        const angle = angleBetweenVectors(targetDirection, pointsVector);\n        if (angle > Math.PI / 4) {\n            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n            targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);\n        } else {\n            targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);\n        }\n    }\n\n    const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);\n    const bezierCurves = catmullRomCurves.map(curve => catmullRomToBezier(curve, options));\n    const path = new Path(bezierCurves).round(precision);\n\n    return (raw) ? path : path.serialize();\n};\ncurve.Directions = Directions;\ncurve.TangentDirections = TangentDirections;\n\nfunction getHorizontalSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        if (sourceBBox.x > route[1].x)\n            sourceSide = 'right';\n        else\n            sourceSide = 'left';\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'left':\n            direction = new Point(-1, 0);\n            break;\n        case 'right':\n        default:\n            direction = new Point(1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getHorizontalTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        if (targetBBox.x > route[route.length - 2].x)\n            targetSide = 'left';\n        else\n            targetSide = 'right';\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n    let direction;\n    switch (targetSide) {\n        case 'left':\n            direction = new Point(-1, 0);\n            break;\n        case 'right':\n        default:\n            direction = new Point(1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getVerticalSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        if (sourceBBox.y > route[1].y)\n            sourceSide = 'bottom';\n        else\n            sourceSide = 'top';\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'top':\n            direction = new Point(0, -1);\n            break;\n        case 'bottom':\n        default:\n            direction = new Point(0, 1);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getVerticalTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        if (targetBBox.y > route[route.length - 2].y)\n            targetSide = 'top';\n        else\n            targetSide = 'bottom';\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n\n    let direction;\n    switch (targetSide) {\n        case 'top':\n            direction = new Point(0, -1);\n            break;\n        case 'bottom':\n        default:\n            direction = new Point(0, 1);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getAutoSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        sourceSide = sourceBBox.sideNearestToPoint(route[1]);\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'top':\n            direction = new Point(0, -1);\n            break;\n        case 'bottom':\n            direction = new Point(0, 1);\n            break;\n        case 'right':\n            direction = new Point(1, 0);\n            break;\n        case 'left':\n            direction = new Point(-1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getAutoTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n    let direction;\n    switch (targetSide) {\n        case 'top':\n            direction = new Point(0, -1);\n            break;\n        case 'bottom':\n            direction = new Point(0, 1);\n            break;\n        case 'right':\n            direction = new Point(1, 0);\n            break;\n        case 'left':\n            direction = new Point(-1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getClosestPointSourceDirection(linkView, route, options) {\n    return route[1].difference(route[0]).normalize();\n}\n\nfunction getClosestPointTargetDirection(linkView, route, options) {\n    const last = route.length - 1;\n    return route[last - 1].difference(route[last]).normalize();\n}\n\nfunction getOutwardsSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n    const sourceCenter = sourceBBox.center();\n    return route[0].difference(sourceCenter).normalize();\n}\n\nfunction getOutwardsTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n    const targetCenter = targetBBox.center();\n    return route[route.length - 1].difference(targetCenter).normalize();\n}\n\nfunction getSourceTangentDirection(linkView, route, direction, options) {\n    if (options.sourceDirection) {\n        switch (options.sourceDirection) {\n            case TangentDirections.UP:\n                return new Point(0, -1);\n            case TangentDirections.DOWN:\n                return new Point(0, 1);\n            case TangentDirections.LEFT:\n                return new Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new Point(1, 0);\n            case TangentDirections.AUTO:\n                return getAutoSourceDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointSourceDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsSourceDirection(linkView, route, options);\n            default:\n                return options.sourceDirection;\n        }\n    }\n\n    switch (direction) {\n        case Directions.HORIZONTAL:\n            return getHorizontalSourceDirection(linkView, route, options);\n        case Directions.VERTICAL:\n            return getVerticalSourceDirection(linkView, route, options);\n        case Directions.CLOSEST_POINT:\n            return getClosestPointSourceDirection(linkView, route, options);\n        case Directions.OUTWARDS:\n            return getOutwardsSourceDirection(linkView, route, options);\n        case Directions.AUTO:\n        default:\n            return getAutoSourceDirection(linkView, route, options);\n    }\n}\n\nfunction getTargetTangentDirection(linkView, route, direction, options) {\n    if (options.targetDirection) {\n        switch (options.targetDirection) {\n            case TangentDirections.UP:\n                return new Point(0, -1);\n            case TangentDirections.DOWN:\n                return new Point(0, 1);\n            case TangentDirections.LEFT:\n                return new Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new Point(1, 0);\n            case TangentDirections.AUTO:\n                return getAutoTargetDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointTargetDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsTargetDirection(linkView, route, options);\n            default:\n                return options.targetDirection;\n        }\n    }\n\n    switch (direction) {\n        case Directions.HORIZONTAL:\n            return getHorizontalTargetDirection(linkView, route, options);\n        case Directions.VERTICAL:\n            return getVerticalTargetDirection(linkView, route, options);\n        case Directions.CLOSEST_POINT:\n            return getClosestPointTargetDirection(linkView, route, options);\n        case Directions.OUTWARDS:\n            return getOutwardsTargetDirection(linkView, route, options);\n        case Directions.AUTO:\n        default:\n            return getAutoTargetDirection(linkView, route, options);\n    }\n}\n\nfunction rotateVector(vector, angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = cos * vector.x - sin * vector.y;\n    const y = sin * vector.x + cos * vector.y;\n    vector.x = x;\n    vector.y = y;\n}\n\nfunction angleBetweenVectors(v1, v2) {\n    let cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n    if (cos < -1) cos = -1;\n    if (cos > 1) cos = 1;\n    return Math.acos(cos);\n}\n\nfunction determinant(v1, v2) {\n    return v1.x * v2.y - v1.y * v2.x;\n}\n\nfunction createCatmullRomCurves(points, sourceTangent, targetTangent, options) {\n    const { tau, coeff } = options;\n    const distances = [];\n    const tangents = [];\n    const catmullRomCurves = [];\n    const n = points.length - 1;\n\n    for (let i = 0; i < n; i++) {\n        distances[i] = points[i].distance(points[i + 1]);\n    }\n\n    tangents[0] = sourceTangent;\n    tangents[n] = targetTangent;\n\n    // The calculation of tangents of vertices\n    for (let i = 1; i < n; i++) {\n        let tpPrev;\n        let tpNext;\n        if (i === 1) {\n            tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);\n        } else {\n            tpPrev = points[i - 1].clone();\n        }\n        if (i === n - 1) {\n            tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);\n        } else {\n            tpNext = points[i + 1].clone();\n        }\n        const v1 = tpPrev.difference(points[i]).normalize();\n        const v2 = tpNext.difference(points[i]).normalize();\n        const vAngle = angleBetweenVectors(v1, v2);\n\n        let rot = (Math.PI - vAngle) / 2;\n        let t;\n        const vectorDeterminant = determinant(v1, v2);\n        let pointsDeterminant;\n        pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));\n        if (vectorDeterminant < 0) {\n            rot = -rot;\n        }\n        if ((vAngle < Math.PI / 2) && ((rot < 0 && pointsDeterminant < 0) || (rot > 0 && pointsDeterminant > 0))) {\n            rot = rot - Math.PI;\n        }\n        t = v2.clone();\n        rotateVector(t, rot);\n\n        const t1 = t.clone();\n        const t2 = t.clone();\n        const scaleFactor1 = distances[i - 1] * coeff;\n        const scaleFactor2 = distances[i] * coeff;\n        t1.scale(scaleFactor1, scaleFactor1);\n        t2.scale(scaleFactor2, scaleFactor2);\n\n        tangents[i] = [t1, t2];\n    }\n\n    // The building of a Catmull-Rom curve based of tangents of points\n    for (let i = 0; i < n; i++) {\n        let p0;\n        let p3;\n        if (i === 0) {\n            p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);\n        } else {\n            p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);\n        }\n        if (i === n - 1) {\n            p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);\n        } else {\n            p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);\n        }\n\n        catmullRomCurves[i] = [p0, points[i], points[i + 1], p3];\n    }\n    return catmullRomCurves;\n}\n\n// The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)\nfunction catmullRomToBezier(points, options) {\n    const { tau } = options;\n\n    const bcp1 = new Point();\n    bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);\n    bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);\n\n    const bcp2 = new Point();\n    bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);\n    bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);\n    return new Curve(\n        points[1],\n        bcp1,\n        bcp2,\n        points[2]\n    );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}