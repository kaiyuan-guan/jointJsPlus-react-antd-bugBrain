{"ast":null,"code":"import { Point } from './point.mjs';\nimport { Rect } from './rect.mjs';\nimport { Line } from './line.mjs';\nimport { Polyline } from './polyline.mjs';\nimport { types } from './types.mjs';\nconst {\n  abs,\n  sqrt,\n  min,\n  max,\n  pow\n} = Math;\nexport const Curve = function (p1, p2, p3, p4) {\n  if (!(this instanceof Curve)) {\n    return new Curve(p1, p2, p3, p4);\n  }\n  if (p1 instanceof Curve) {\n    return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n  }\n  this.start = new Point(p1);\n  this.controlPoint1 = new Point(p2);\n  this.controlPoint2 = new Point(p3);\n  this.end = new Point(p4);\n};\n\n// Curve passing through points.\n// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n// @param {array} points Array of points through which the smooth line will go.\n// @return {array} curves.\nCurve.throughPoints = function () {\n  // Get open-ended Bezier Spline Control Points.\n  // @param knots Input Knot Bezier spline points (At least two points!).\n  // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n  // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n  function getCurveControlPoints(knots) {\n    var firstControlPoints = [];\n    var secondControlPoints = [];\n    var n = knots.length - 1;\n    var i;\n\n    // Special case: Bezier curve should be a straight line.\n    if (n == 1) {\n      // 3P1 = 2P0 + P3\n      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);\n\n      // P2 = 2P1 â€“ P0\n      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n      return [firstControlPoints, secondControlPoints];\n    }\n\n    // Calculate first Bezier control points.\n    // Right hand side vector.\n    var rhs = [];\n\n    // Set right hand side X values.\n    for (i = 1; i < n - 1; i++) {\n      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n    }\n    rhs[0] = knots[0].x + 2 * knots[1].x;\n    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n    // Get first control points X-values.\n    var x = getFirstControlPoints(rhs);\n\n    // Set right hand side Y values.\n    for (i = 1; i < n - 1; ++i) {\n      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n    }\n    rhs[0] = knots[0].y + 2 * knots[1].y;\n    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n    // Get first control points Y-values.\n    var y = getFirstControlPoints(rhs);\n\n    // Fill output arrays.\n    for (i = 0; i < n; i++) {\n      // First control point.\n      firstControlPoints.push(new Point(x[i], y[i]));\n\n      // Second control point.\n      if (i < n - 1) {\n        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n      } else {\n        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n      }\n    }\n    return [firstControlPoints, secondControlPoints];\n  }\n\n  // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n  // @param rhs Right hand side vector.\n  // @return Solution vector.\n  function getFirstControlPoints(rhs) {\n    var n = rhs.length;\n    // `x` is a solution vector.\n    var x = [];\n    var tmp = [];\n    var b = 2.0;\n    x[0] = rhs[0] / b;\n\n    // Decomposition and forward substitution.\n    for (var i = 1; i < n; i++) {\n      tmp[i] = 1 / b;\n      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n      x[i] = (rhs[i] - x[i - 1]) / b;\n    }\n    for (i = 1; i < n; i++) {\n      // Backsubstitution.\n      x[n - i - 1] -= tmp[n - i] * x[n - i];\n    }\n    return x;\n  }\n  return function (points) {\n    if (!points || Array.isArray(points) && points.length < 2) {\n      throw new Error('At least 2 points are required');\n    }\n    var controlPoints = getCurveControlPoints(points);\n    var curves = [];\n    var n = controlPoints[0].length;\n    for (var i = 0; i < n; i++) {\n      var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n      var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n      curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n    }\n    return curves;\n  };\n}();\nCurve.prototype = {\n  type: types.Curve,\n  // Returns a bbox that tightly envelops the curve.\n  bbox: function () {\n    var start = this.start;\n    var controlPoint1 = this.controlPoint1;\n    var controlPoint2 = this.controlPoint2;\n    var end = this.end;\n    var x0 = start.x;\n    var y0 = start.y;\n    var x1 = controlPoint1.x;\n    var y1 = controlPoint1.y;\n    var x2 = controlPoint2.x;\n    var y2 = controlPoint2.y;\n    var x3 = end.x;\n    var y3 = end.y;\n    var points = new Array(); // local extremes\n    var tvalues = new Array(); // t values of local extremes\n    var bounds = [new Array(), new Array()];\n    var a, b, c, t;\n    var t1, t2;\n    var b2ac, sqrtb2ac;\n    for (var i = 0; i < 2; ++i) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2;\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n        c = 3 * y1 - 3 * y0;\n      }\n      if (abs(a) < 1e-12) {\n        // Numerical robustness\n        if (abs(b) < 1e-12) {\n          // Numerical robustness\n          continue;\n        }\n        t = -c / b;\n        if (0 < t && t < 1) tvalues.push(t);\n        continue;\n      }\n      b2ac = b * b - 4 * c * a;\n      sqrtb2ac = sqrt(b2ac);\n      if (b2ac < 0) continue;\n      t1 = (-b + sqrtb2ac) / (2 * a);\n      if (0 < t1 && t1 < 1) tvalues.push(t1);\n      t2 = (-b - sqrtb2ac) / (2 * a);\n      if (0 < t2 && t2 < 1) tvalues.push(t2);\n    }\n    var j = tvalues.length;\n    var jlen = j;\n    var mt;\n    var x, y;\n    while (j--) {\n      t = tvalues[j];\n      mt = 1 - t;\n      x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n      bounds[0][j] = x;\n      y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n      bounds[1][j] = y;\n      points[j] = {\n        X: x,\n        Y: y\n      };\n    }\n    tvalues[jlen] = 0;\n    tvalues[jlen + 1] = 1;\n    points[jlen] = {\n      X: x0,\n      Y: y0\n    };\n    points[jlen + 1] = {\n      X: x3,\n      Y: y3\n    };\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    tvalues.length = jlen + 2;\n    bounds[0].length = jlen + 2;\n    bounds[1].length = jlen + 2;\n    points.length = jlen + 2;\n    var left = min.apply(null, bounds[0]);\n    var top = min.apply(null, bounds[1]);\n    var right = max.apply(null, bounds[0]);\n    var bottom = max.apply(null, bounds[1]);\n    return new Rect(left, top, right - left, bottom - top);\n  },\n  clone: function () {\n    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n  },\n  // Returns the point on the curve closest to point `p`\n  closestPoint: function (p, opt) {\n    return this.pointAtT(this.closestPointT(p, opt));\n  },\n  closestPointLength: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    var localOpt = {\n      precision: precision,\n      subdivisions: subdivisions\n    };\n    return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n  },\n  closestPointNormalizedLength: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    var localOpt = {\n      precision: precision,\n      subdivisions: subdivisions\n    };\n    var cpLength = this.closestPointLength(p, localOpt);\n    if (!cpLength) return 0;\n    var length = this.length(localOpt);\n    if (length === 0) return 0;\n    return cpLength / length;\n  },\n  // Returns `t` of the point on the curve closest to point `p`\n  closestPointT: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    // does not use localOpt\n\n    // identify the subdivision that contains the point:\n    var investigatedSubdivision;\n    var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n    var investigatedSubdivisionEndT;\n    var distFromStart; // distance of point from start of baseline\n    var distFromEnd; // distance of point from end of baseline\n    var chordLength; // distance between start and end of the subdivision\n    var minSumDist; // lowest observed sum of the two distances\n    var n = subdivisions.length;\n    var subdivisionSize = n ? 1 / n : 0;\n    for (var i = 0; i < n; i++) {\n      var currentSubdivision = subdivisions[i];\n      var startDist = currentSubdivision.start.distance(p);\n      var endDist = currentSubdivision.end.distance(p);\n      var sumDist = startDist + endDist;\n\n      // check that the point is closest to current subdivision and not any other\n      if (!minSumDist || sumDist < minSumDist) {\n        investigatedSubdivision = currentSubdivision;\n        investigatedSubdivisionStartT = i * subdivisionSize;\n        investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n        distFromStart = startDist;\n        distFromEnd = endDist;\n        chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n        minSumDist = sumDist;\n      }\n    }\n    var precisionRatio = pow(10, -precision);\n\n    // recursively divide investigated subdivision:\n    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n    // then return the closest endpoint of that final subdivision\n    while (true) {\n      // check if we have reached at least one required observed precision\n      // - calculated as: the difference in distances from point to start and end divided by the distance\n      // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n      // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n      // - this criterion works well for points lying far away from the curve\n      var startPrecisionRatio = distFromStart ? abs(distFromStart - distFromEnd) / distFromStart : 0;\n      var endPrecisionRatio = distFromEnd ? abs(distFromStart - distFromEnd) / distFromEnd : 0;\n      var hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio;\n\n      // check if we have reached at least one required minimal distance\n      // - calculated as: the subdivision chord length multiplied by precisionRatio\n      // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n      // - this is a backup criterion that works well for points lying \"almost at\" the curve\n      var hasMinimalStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;\n      var hasMinimalEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;\n      var hasMinimalDistance = hasMinimalStartDistance || hasMinimalEndDistance;\n\n      // do we stop now?\n      if (hasRequiredPrecision || hasMinimalDistance) {\n        return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;\n      }\n\n      // otherwise, set up for next iteration\n      var divided = investigatedSubdivision.divide(0.5);\n      subdivisionSize /= 2;\n      var startDist1 = divided[0].start.distance(p);\n      var endDist1 = divided[0].end.distance(p);\n      var sumDist1 = startDist1 + endDist1;\n      var startDist2 = divided[1].start.distance(p);\n      var endDist2 = divided[1].end.distance(p);\n      var sumDist2 = startDist2 + endDist2;\n      if (sumDist1 <= sumDist2) {\n        investigatedSubdivision = divided[0];\n        investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n\n        distFromStart = startDist1;\n        distFromEnd = endDist1;\n      } else {\n        investigatedSubdivision = divided[1];\n        investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n        distFromStart = startDist2;\n        distFromEnd = endDist2;\n      }\n    }\n  },\n  closestPointTangent: function (p, opt) {\n    return this.tangentAtT(this.closestPointT(p, opt));\n  },\n  // Returns `true` if the area surrounded by the curve contains the point `p`.\n  // Implements the even-odd algorithm (self-intersections are \"outside\").\n  // Closes open curves (always imagines a closing segment).\n  // Precision may be adjusted by passing an `opt` object.\n  containsPoint: function (p, opt) {\n    var polyline = this.toPolyline(opt);\n    return polyline.containsPoint(p);\n  },\n  // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n  // For a function that uses `t`, use Curve.divideAtT().\n  divideAt: function (ratio, opt) {\n    if (ratio <= 0) return this.divideAtT(0);\n    if (ratio >= 1) return this.divideAtT(1);\n    var t = this.tAt(ratio, opt);\n    return this.divideAtT(t);\n  },\n  // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  divideAtLength: function (length, opt) {\n    var t = this.tAtLength(length, opt);\n    return this.divideAtT(t);\n  },\n  // Divides the curve into two at point defined by `t` between 0 and 1.\n  // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n  // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n  divideAtT: function (t) {\n    var start = this.start;\n    var controlPoint1 = this.controlPoint1;\n    var controlPoint2 = this.controlPoint2;\n    var end = this.end;\n\n    // shortcuts for `t` values that are out of range\n    if (t <= 0) {\n      return [new Curve(start, start, start, start), new Curve(start, controlPoint1, controlPoint2, end)];\n    }\n    if (t >= 1) {\n      return [new Curve(start, controlPoint1, controlPoint2, end), new Curve(end, end, end, end)];\n    }\n    var dividerPoints = this.getSkeletonPoints(t);\n    var startControl1 = dividerPoints.startControlPoint1;\n    var startControl2 = dividerPoints.startControlPoint2;\n    var divider = dividerPoints.divider;\n    var dividerControl1 = dividerPoints.dividerControlPoint1;\n    var dividerControl2 = dividerPoints.dividerControlPoint2;\n\n    // return array with two new curves\n    return [new Curve(start, startControl1, startControl2, divider), new Curve(divider, dividerControl1, dividerControl2, end)];\n  },\n  // Returns the distance between the curve's start and end points.\n  endpointDistance: function () {\n    return this.start.distance(this.end);\n  },\n  // Checks whether two curves are exactly the same.\n  equals: function (c) {\n    return !!c && this.start.x === c.start.x && this.start.y === c.start.y && this.controlPoint1.x === c.controlPoint1.x && this.controlPoint1.y === c.controlPoint1.y && this.controlPoint2.x === c.controlPoint2.x && this.controlPoint2.y === c.controlPoint2.y && this.end.x === c.end.x && this.end.y === c.end.y;\n  },\n  // Returns five helper points necessary for curve division.\n  getSkeletonPoints: function (t) {\n    var start = this.start;\n    var control1 = this.controlPoint1;\n    var control2 = this.controlPoint2;\n    var end = this.end;\n\n    // shortcuts for `t` values that are out of range\n    if (t <= 0) {\n      return {\n        startControlPoint1: start.clone(),\n        startControlPoint2: start.clone(),\n        divider: start.clone(),\n        dividerControlPoint1: control1.clone(),\n        dividerControlPoint2: control2.clone()\n      };\n    }\n    if (t >= 1) {\n      return {\n        startControlPoint1: control1.clone(),\n        startControlPoint2: control2.clone(),\n        divider: end.clone(),\n        dividerControlPoint1: end.clone(),\n        dividerControlPoint2: end.clone()\n      };\n    }\n    var midpoint1 = new Line(start, control1).pointAt(t);\n    var midpoint2 = new Line(control1, control2).pointAt(t);\n    var midpoint3 = new Line(control2, end).pointAt(t);\n    var subControl1 = new Line(midpoint1, midpoint2).pointAt(t);\n    var subControl2 = new Line(midpoint2, midpoint3).pointAt(t);\n    var divider = new Line(subControl1, subControl2).pointAt(t);\n    var output = {\n      startControlPoint1: midpoint1,\n      startControlPoint2: subControl1,\n      divider: divider,\n      dividerControlPoint1: subControl2,\n      dividerControlPoint2: midpoint3\n    };\n    return output;\n  },\n  // Returns a list of curves whose flattened length is better than `opt.precision`.\n  // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n  // (Observed difference is not real precision, but close enough as long as special cases are covered)\n  // As a rule of thumb, increasing `precision` by 1 requires 2 more iterations (= levels of division operations)\n  // - Precision 0 (endpointDistance) - 0 iterations => total of 2^0 - 1 = 0 operations (1 subdivision)\n  // - Precision 1 (<10% error) - 2 iterations => total of 2^2 - 1 = 3 operations (4 subdivisions)\n  // - Precision 2 (<1% error) - 4 iterations => total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n  // - Precision 3 (<0.1% error) - 6 iterations => total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n  // - Precision 4 (<0.01% error) - 8 iterations => total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n  // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n  getSubdivisions: function (opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    // not using opt.subdivisions\n    // not using localOpt\n\n    var start = this.start;\n    var control1 = this.controlPoint1;\n    var control2 = this.controlPoint2;\n    var end = this.end;\n    var subdivisions = [new Curve(start, control1, control2, end)];\n    if (precision === 0) return subdivisions;\n\n    // special case #1: point-like curves\n    // - no need to calculate subdivisions, they would all be identical\n    var isPoint = !this.isDifferentiable();\n    if (isPoint) return subdivisions;\n    var previousLength = this.endpointDistance();\n    var precisionRatio = pow(10, -precision);\n\n    // special case #2: sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n    // - not a problem for further iterations because cubic curves cannot have more than two local extrema\n    // - (i.e. cubic curves cannot intersect the baseline more than once)\n    // - therefore starting from iteration = 2 ensures that subsequent iterations do not produce sampling with equal length\n    // - (unless it's a straight-line curve, see below)\n    var minIterations = 2; // = 2*1\n\n    // special case #3: straight-line curves have the same observed length in all iterations\n    // - this causes observed precision ratio to always be 0 (= lower than `precisionRatio`, which is our exit condition)\n    // - we enforce the expected number of iterations = 2 * precision\n    var isLine = control1.cross(start, end) === 0 && control2.cross(start, end) === 0;\n    if (isLine) {\n      minIterations = 2 * precision;\n    }\n\n    // recursively divide curve at `t = 0.5`\n    // until we reach `minIterations`\n    // and until the difference between observed length at subsequent iterations is lower than `precision`\n    var iteration = 0;\n    while (true) {\n      iteration += 1;\n\n      // divide all subdivisions\n      var newSubdivisions = [];\n      var numSubdivisions = subdivisions.length;\n      for (var i = 0; i < numSubdivisions; i++) {\n        var currentSubdivision = subdivisions[i];\n        var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n        newSubdivisions.push(divided[0], divided[1]);\n      }\n\n      // measure new length\n      var length = 0;\n      var numNewSubdivisions = newSubdivisions.length;\n      for (var j = 0; j < numNewSubdivisions; j++) {\n        var currentNewSubdivision = newSubdivisions[j];\n        length += currentNewSubdivision.endpointDistance();\n      }\n\n      // check if we have reached minimum number of iterations\n      if (iteration >= minIterations) {\n        // check if we have reached required observed precision\n        var observedPrecisionRatio = length !== 0 ? (length - previousLength) / length : 0;\n        if (observedPrecisionRatio < precisionRatio) {\n          return newSubdivisions;\n        }\n      }\n\n      // otherwise, set up for next iteration\n      subdivisions = newSubdivisions;\n      previousLength = length;\n    }\n  },\n  isDifferentiable: function () {\n    var start = this.start;\n    var control1 = this.controlPoint1;\n    var control2 = this.controlPoint2;\n    var end = this.end;\n    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n  },\n  // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n  length: function (opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    // not using localOpt\n\n    var length = 0;\n    var n = subdivisions.length;\n    for (var i = 0; i < n; i++) {\n      var currentSubdivision = subdivisions[i];\n      length += currentSubdivision.endpointDistance();\n    }\n    return length;\n  },\n  // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n  lengthAtT: function (t, opt) {\n    if (t <= 0) return 0;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    // not using opt.subdivisions\n    // not using localOpt\n\n    var subCurve = this.divide(t)[0];\n    var subCurveLength = subCurve.length({\n      precision: precision\n    });\n    return subCurveLength;\n  },\n  // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n  // Mirrors Line.pointAt() function.\n  // For a function that tracks `t`, use Curve.pointAtT().\n  pointAt: function (ratio, opt) {\n    if (ratio <= 0) return this.start.clone();\n    if (ratio >= 1) return this.end.clone();\n    var t = this.tAt(ratio, opt);\n    return this.pointAtT(t);\n  },\n  // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  pointAtLength: function (length, opt) {\n    var t = this.tAtLength(length, opt);\n    return this.pointAtT(t);\n  },\n  // Returns the point at provided `t` between 0 and 1.\n  // `t` does not track distance along curve as it does in Line objects.\n  // Non-linear relationship, speeds up and slows down as curve warps!\n  // For linear length-based solution, use Curve.pointAt().\n  pointAtT: function (t) {\n    if (t <= 0) return this.start.clone();\n    if (t >= 1) return this.end.clone();\n    return this.getSkeletonPoints(t).divider;\n  },\n  // Default precision\n  PRECISION: 3,\n  round: function (precision) {\n    this.start.round(precision);\n    this.controlPoint1.round(precision);\n    this.controlPoint2.round(precision);\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.start.scale(sx, sy, origin);\n    this.controlPoint1.scale(sx, sy, origin);\n    this.controlPoint2.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n  tangentAt: function (ratio, opt) {\n    if (!this.isDifferentiable()) return null;\n    if (ratio < 0) ratio = 0;else if (ratio > 1) ratio = 1;\n    var t = this.tAt(ratio, opt);\n    return this.tangentAtT(t);\n  },\n  // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n  tangentAtLength: function (length, opt) {\n    if (!this.isDifferentiable()) return null;\n    var t = this.tAtLength(length, opt);\n    return this.tangentAtT(t);\n  },\n  // Returns a tangent line at requested `t`.\n  tangentAtT: function (t) {\n    if (!this.isDifferentiable()) return null;\n    if (t < 0) t = 0;else if (t > 1) t = 1;\n    var skeletonPoints = this.getSkeletonPoints(t);\n    var p1 = skeletonPoints.startControlPoint2;\n    var p2 = skeletonPoints.dividerControlPoint1;\n    var tangentStart = skeletonPoints.divider;\n    var tangentLine = new Line(p1, p2);\n    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n\n    return tangentLine;\n  },\n  // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  tAt: function (ratio, opt) {\n    if (ratio <= 0) return 0;\n    if (ratio >= 1) return 1;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    var localOpt = {\n      precision: precision,\n      subdivisions: subdivisions\n    };\n    var curveLength = this.length(localOpt);\n    var length = curveLength * ratio;\n    return this.tAtLength(length, localOpt);\n  },\n  // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  // Uses `precision` to approximate length within `precision` (always underestimates)\n  // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n  // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n  // - Precision 0 (chooses one of the two endpoints) - 0 levels\n  // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n  // - Precision 2 (<1% error) - 3 levels\n  // - Precision 3 (<0.1% error) - 7 levels\n  // - Precision 4 (<0.01% error) - 15 levels\n  tAtLength: function (length, opt) {\n    var fromStart = true;\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n      length = -length; // absolute value\n    }\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    var localOpt = {\n      precision: precision,\n      subdivisions: subdivisions\n    };\n\n    // identify the subdivision that contains the point at requested `length`:\n    var investigatedSubdivision;\n    var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n    var investigatedSubdivisionEndT;\n    //var baseline; // straightened version of subdivision to investigate\n    //var baselinePoint; // point on the baseline that is the requested distance away from start\n    var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n    var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n    var l = 0; // length so far\n    var n = subdivisions.length;\n    var subdivisionSize = 1 / n;\n    for (var i = 0; i < n; i++) {\n      var index = fromStart ? i : n - 1 - i;\n      var currentSubdivision = subdivisions[i];\n      var d = currentSubdivision.endpointDistance(); // length of current subdivision\n\n      if (length <= l + d) {\n        investigatedSubdivision = currentSubdivision;\n        investigatedSubdivisionStartT = index * subdivisionSize;\n        investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n        baselinePointDistFromStart = fromStart ? length - l : d + l - length;\n        baselinePointDistFromEnd = fromStart ? d + l - length : length - l;\n        break;\n      }\n      l += d;\n    }\n    if (!investigatedSubdivision) return fromStart ? 1 : 0; // length requested is out of range - return maximum t\n    // note that precision affects what length is recorded\n    // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n    // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n    var curveLength = this.length(localOpt);\n    var precisionRatio = pow(10, -precision);\n\n    // recursively divide investigated subdivision:\n    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n    // then return the closest endpoint of that final subdivision\n    while (true) {\n      // check if we have reached required observed precision\n      var observedPrecisionRatio;\n      observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromStart / curveLength : 0;\n      if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;\n      observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromEnd / curveLength : 0;\n      if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;\n\n      // otherwise, set up for next iteration\n      var newBaselinePointDistFromStart;\n      var newBaselinePointDistFromEnd;\n      var divided = investigatedSubdivision.divide(0.5);\n      subdivisionSize /= 2;\n      var baseline1Length = divided[0].endpointDistance();\n      var baseline2Length = divided[1].endpointDistance();\n      if (baselinePointDistFromStart <= baseline1Length) {\n        // point at requested length is inside divided[0]\n        investigatedSubdivision = divided[0];\n        investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n\n        newBaselinePointDistFromStart = baselinePointDistFromStart;\n        newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n      } else {\n        // point at requested length is inside divided[1]\n        investigatedSubdivision = divided[1];\n        investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n        newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n        newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n      }\n      baselinePointDistFromStart = newBaselinePointDistFromStart;\n      baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n    }\n  },\n  // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n  // Flattened length is no more than 10^(-precision) away from real curve length.\n  toPoints: function (opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    // not using localOpt\n\n    var points = [subdivisions[0].start.clone()];\n    var n = subdivisions.length;\n    for (var i = 0; i < n; i++) {\n      var currentSubdivision = subdivisions[i];\n      points.push(currentSubdivision.end.clone());\n    }\n    return points;\n  },\n  // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n  // Flattened length is no more than 10^(-precision) away from real curve length.\n  toPolyline: function (opt) {\n    return new Polyline(this.toPoints(opt));\n  },\n  toString: function () {\n    return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n  },\n  translate: function (tx, ty) {\n    this.start.translate(tx, ty);\n    this.controlPoint1.translate(tx, ty);\n    this.controlPoint2.translate(tx, ty);\n    this.end.translate(tx, ty);\n    return this;\n  }\n};\nCurve.prototype.divide = Curve.prototype.divideAtT;","map":{"version":3,"names":["Point","Rect","Line","Polyline","types","abs","sqrt","min","max","pow","Math","Curve","p1","p2","p3","p4","start","controlPoint1","controlPoint2","end","throughPoints","getCurveControlPoints","knots","firstControlPoints","secondControlPoints","n","length","i","x","y","rhs","getFirstControlPoints","push","tmp","b","points","Array","isArray","Error","controlPoints","curves","prototype","type","bbox","x0","y0","x1","y1","x2","y2","x3","y3","tvalues","bounds","a","c","t","t1","t2","b2ac","sqrtb2ac","j","jlen","mt","X","Y","left","apply","top","right","bottom","clone","closestPoint","p","opt","pointAtT","closestPointT","closestPointLength","precision","undefined","PRECISION","subdivisions","getSubdivisions","localOpt","lengthAtT","closestPointNormalizedLength","cpLength","investigatedSubdivision","investigatedSubdivisionStartT","investigatedSubdivisionEndT","distFromStart","distFromEnd","chordLength","minSumDist","subdivisionSize","currentSubdivision","startDist","distance","endDist","sumDist","precisionRatio","startPrecisionRatio","endPrecisionRatio","hasRequiredPrecision","hasMinimalStartDistance","hasMinimalEndDistance","hasMinimalDistance","divided","divide","startDist1","endDist1","sumDist1","startDist2","endDist2","sumDist2","closestPointTangent","tangentAtT","containsPoint","polyline","toPolyline","divideAt","ratio","divideAtT","tAt","divideAtLength","tAtLength","dividerPoints","getSkeletonPoints","startControl1","startControlPoint1","startControl2","startControlPoint2","divider","dividerControl1","dividerControlPoint1","dividerControl2","dividerControlPoint2","endpointDistance","equals","control1","control2","midpoint1","pointAt","midpoint2","midpoint3","subControl1","subControl2","output","isPoint","isDifferentiable","previousLength","minIterations","isLine","cross","iteration","newSubdivisions","numSubdivisions","numNewSubdivisions","currentNewSubdivision","observedPrecisionRatio","subCurve","subCurveLength","pointAtLength","round","scale","sx","sy","origin","tangentAt","tangentAtLength","skeletonPoints","tangentStart","tangentLine","translate","curveLength","fromStart","baselinePointDistFromStart","baselinePointDistFromEnd","l","index","d","newBaselinePointDistFromStart","newBaselinePointDistFromEnd","baseline1Length","baseline2Length","toPoints","toString","tx","ty"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/g/curve.mjs"],"sourcesContent":["import { Point } from './point.mjs';\nimport { Rect } from './rect.mjs';\nimport { Line } from './line.mjs';\nimport { Polyline } from './polyline.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    abs,\n    sqrt,\n    min,\n    max,\n    pow\n} = Math;\n\nexport const Curve = function(p1, p2, p3, p4) {\n\n    if (!(this instanceof Curve)) {\n        return new Curve(p1, p2, p3, p4);\n    }\n\n    if (p1 instanceof Curve) {\n        return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n    }\n\n    this.start = new Point(p1);\n    this.controlPoint1 = new Point(p2);\n    this.controlPoint2 = new Point(p3);\n    this.end = new Point(p4);\n};\n\n// Curve passing through points.\n// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n// @param {array} points Array of points through which the smooth line will go.\n// @return {array} curves.\nCurve.throughPoints = (function() {\n\n    // Get open-ended Bezier Spline Control Points.\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    function getCurveControlPoints(knots) {\n\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new Point(\n                (2 * knots[0].x + knots[1].x) / 3,\n                (2 * knots[0].y + knots[1].y) / 3\n            );\n\n            // P2 = 2P1 â€“ P0\n            secondControlPoints[0] = new Point(\n                2 * firstControlPoints[0].x - knots[0].x,\n                2 * firstControlPoints[0].y - knots[0].y\n            );\n\n            return [firstControlPoints, secondControlPoints];\n        }\n\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n\n        // Set right hand side X values.\n        for (i = 1; i < n - 1; i++) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n        // Get first control points X-values.\n        var x = getFirstControlPoints(rhs);\n\n        // Set right hand side Y values.\n        for (i = 1; i < n - 1; ++i) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n        // Get first control points Y-values.\n        var y = getFirstControlPoints(rhs);\n\n        // Fill output arrays.\n        for (i = 0; i < n; i++) {\n            // First control point.\n            firstControlPoints.push(new Point(x[i], y[i]));\n\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new Point(\n                    2 * knots [i + 1].x - x[i + 1],\n                    2 * knots[i + 1].y - y[i + 1]\n                ));\n\n            } else {\n                secondControlPoints.push(new Point(\n                    (knots[n].x + x[n - 1]) / 2,\n                    (knots[n].y + y[n - 1]) / 2\n                ));\n            }\n        }\n\n        return [firstControlPoints, secondControlPoints];\n    }\n\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    function getFirstControlPoints(rhs) {\n\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n\n        x[0] = rhs[0] / b;\n\n        // Decomposition and forward substitution.\n        for (var i = 1; i < n; i++) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (i = 1; i < n; i++) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n\n        return x;\n    }\n\n    return function(points) {\n\n        if (!points || (Array.isArray(points) && points.length < 2)) {\n            throw new Error('At least 2 points are required');\n        }\n\n        var controlPoints = getCurveControlPoints(points);\n\n        var curves = [];\n        var n = controlPoints[0].length;\n        for (var i = 0; i < n; i++) {\n\n            var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n            var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n\n            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n        }\n\n        return curves;\n    };\n})();\n\nCurve.prototype = {\n\n    type: types.Curve,\n\n    // Returns a bbox that tightly envelops the curve.\n    bbox: function() {\n\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n\n        var x0 = start.x;\n        var y0 = start.y;\n        var x1 = controlPoint1.x;\n        var y1 = controlPoint1.y;\n        var x2 = controlPoint2.x;\n        var y2 = controlPoint2.y;\n        var x3 = end.x;\n        var y3 = end.y;\n\n        var points = new Array(); // local extremes\n        var tvalues = new Array(); // t values of local extremes\n        var bounds = [new Array(), new Array()];\n\n        var a, b, c, t;\n        var t1, t2;\n        var b2ac, sqrtb2ac;\n\n        for (var i = 0; i < 2; ++i) {\n\n            if (i === 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n\n            } else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n\n            if (abs(a) < 1e-12) { // Numerical robustness\n                if (abs(b) < 1e-12) { // Numerical robustness\n                    continue;\n                }\n\n                t = -c / b;\n                if ((0 < t) && (t < 1)) tvalues.push(t);\n\n                continue;\n            }\n\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = sqrt(b2ac);\n\n            if (b2ac < 0) continue;\n\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if ((0 < t1) && (t1 < 1)) tvalues.push(t1);\n\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if ((0 < t2) && (t2 < 1)) tvalues.push(t2);\n        }\n\n        var j = tvalues.length;\n        var jlen = j;\n        var mt;\n        var x, y;\n\n        while (j--) {\n            t = tvalues[j];\n            mt = 1 - t;\n\n            x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n            bounds[0][j] = x;\n\n            y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n            bounds[1][j] = y;\n\n            points[j] = { X: x, Y: y };\n        }\n\n        tvalues[jlen] = 0;\n        tvalues[jlen + 1] = 1;\n\n        points[jlen] = { X: x0, Y: y0 };\n        points[jlen + 1] = { X: x3, Y: y3 };\n\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n\n        tvalues.length = jlen + 2;\n        bounds[0].length = jlen + 2;\n        bounds[1].length = jlen + 2;\n        points.length = jlen + 2;\n\n        var left = min.apply(null, bounds[0]);\n        var top = min.apply(null, bounds[1]);\n        var right = max.apply(null, bounds[0]);\n        var bottom = max.apply(null, bounds[1]);\n\n        return new Rect(left, top, (right - left), (bottom - top));\n    },\n\n    clone: function() {\n\n        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    },\n\n    // Returns the point on the curve closest to point `p`\n    closestPoint: function(p, opt) {\n\n        return this.pointAtT(this.closestPointT(p, opt));\n    },\n\n    closestPointLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n    },\n\n    closestPointNormalizedLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (!cpLength) return 0;\n\n        var length = this.length(localOpt);\n        if (length === 0) return 0;\n\n        return cpLength / length;\n    },\n\n    // Returns `t` of the point on the curve closest to point `p`\n    closestPointT: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // does not use localOpt\n\n        // identify the subdivision that contains the point:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        var distFromStart; // distance of point from start of baseline\n        var distFromEnd; // distance of point from end of baseline\n        var chordLength; // distance between start and end of the subdivision\n        var minSumDist; // lowest observed sum of the two distances\n        var n = subdivisions.length;\n        var subdivisionSize = (n ? (1 / n) : 0);\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n\n            var startDist = currentSubdivision.start.distance(p);\n            var endDist = currentSubdivision.end.distance(p);\n            var sumDist = startDist + endDist;\n\n            // check that the point is closest to current subdivision and not any other\n            if (!minSumDist || (sumDist < minSumDist)) {\n                investigatedSubdivision = currentSubdivision;\n\n                investigatedSubdivisionStartT = i * subdivisionSize;\n                investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n\n                distFromStart = startDist;\n                distFromEnd = endDist;\n\n                chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n\n                minSumDist = sumDist;\n            }\n        }\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while (true) {\n\n            // check if we have reached at least one required observed precision\n            // - calculated as: the difference in distances from point to start and end divided by the distance\n            // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n            // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n            // - this criterion works well for points lying far away from the curve\n            var startPrecisionRatio = (distFromStart ? (abs(distFromStart - distFromEnd) / distFromStart) : 0);\n            var endPrecisionRatio = (distFromEnd ? (abs(distFromStart - distFromEnd) / distFromEnd) : 0);\n            var hasRequiredPrecision = ((startPrecisionRatio < precisionRatio) || (endPrecisionRatio < precisionRatio));\n\n            // check if we have reached at least one required minimal distance\n            // - calculated as: the subdivision chord length multiplied by precisionRatio\n            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n            // - this is a backup criterion that works well for points lying \"almost at\" the curve\n            var hasMinimalStartDistance = (distFromStart ? (distFromStart < (chordLength * precisionRatio)) : true);\n            var hasMinimalEndDistance = (distFromEnd ? (distFromEnd < (chordLength * precisionRatio)) : true);\n            var hasMinimalDistance = (hasMinimalStartDistance || hasMinimalEndDistance);\n\n            // do we stop now?\n            if (hasRequiredPrecision || hasMinimalDistance) {\n                return ((distFromStart <= distFromEnd) ? investigatedSubdivisionStartT : investigatedSubdivisionEndT);\n            }\n\n            // otherwise, set up for next iteration\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n\n            var startDist1 = divided[0].start.distance(p);\n            var endDist1 = divided[0].end.distance(p);\n            var sumDist1 = startDist1 + endDist1;\n\n            var startDist2 = divided[1].start.distance(p);\n            var endDist2 = divided[1].end.distance(p);\n            var sumDist2 = startDist2 + endDist2;\n\n            if (sumDist1 <= sumDist2) {\n                investigatedSubdivision = divided[0];\n\n                investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n\n                distFromStart = startDist1;\n                distFromEnd = endDist1;\n\n            } else {\n                investigatedSubdivision = divided[1];\n\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n                distFromStart = startDist2;\n                distFromEnd = endDist2;\n            }\n        }\n    },\n\n    closestPointTangent: function(p, opt) {\n\n        return this.tangentAtT(this.closestPointT(p, opt));\n    },\n\n    // Returns `true` if the area surrounded by the curve contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open curves (always imagines a closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n\n        var polyline = this.toPolyline(opt);\n        return polyline.containsPoint(p);\n    },\n\n    // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // For a function that uses `t`, use Curve.divideAtT().\n    divideAt: function(ratio, opt) {\n\n        if (ratio <= 0) return this.divideAtT(0);\n        if (ratio >= 1) return this.divideAtT(1);\n\n        var t = this.tAt(ratio, opt);\n\n        return this.divideAtT(t);\n    },\n\n    // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n\n        var t = this.tAtLength(length, opt);\n\n        return this.divideAtT(t);\n    },\n\n    // Divides the curve into two at point defined by `t` between 0 and 1.\n    // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n    // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n    divideAtT: function(t) {\n\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return [\n                new Curve(start, start, start, start),\n                new Curve(start, controlPoint1, controlPoint2, end)\n            ];\n        }\n\n        if (t >= 1) {\n            return [\n                new Curve(start, controlPoint1, controlPoint2, end),\n                new Curve(end, end, end, end)\n            ];\n        }\n\n        var dividerPoints = this.getSkeletonPoints(t);\n\n        var startControl1 = dividerPoints.startControlPoint1;\n        var startControl2 = dividerPoints.startControlPoint2;\n        var divider = dividerPoints.divider;\n        var dividerControl1 = dividerPoints.dividerControlPoint1;\n        var dividerControl2 = dividerPoints.dividerControlPoint2;\n\n        // return array with two new curves\n        return [\n            new Curve(start, startControl1, startControl2, divider),\n            new Curve(divider, dividerControl1, dividerControl2, end)\n        ];\n    },\n\n    // Returns the distance between the curve's start and end points.\n    endpointDistance: function() {\n\n        return this.start.distance(this.end);\n    },\n\n    // Checks whether two curves are exactly the same.\n    equals: function(c) {\n\n        return !!c &&\n            this.start.x === c.start.x &&\n            this.start.y === c.start.y &&\n            this.controlPoint1.x === c.controlPoint1.x &&\n            this.controlPoint1.y === c.controlPoint1.y &&\n            this.controlPoint2.x === c.controlPoint2.x &&\n            this.controlPoint2.y === c.controlPoint2.y &&\n            this.end.x === c.end.x &&\n            this.end.y === c.end.y;\n    },\n\n    // Returns five helper points necessary for curve division.\n    getSkeletonPoints: function(t) {\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return {\n                startControlPoint1: start.clone(),\n                startControlPoint2: start.clone(),\n                divider: start.clone(),\n                dividerControlPoint1: control1.clone(),\n                dividerControlPoint2: control2.clone()\n            };\n        }\n\n        if (t >= 1) {\n            return {\n                startControlPoint1: control1.clone(),\n                startControlPoint2: control2.clone(),\n                divider: end.clone(),\n                dividerControlPoint1: end.clone(),\n                dividerControlPoint2: end.clone()\n            };\n        }\n\n        var midpoint1 = (new Line(start, control1)).pointAt(t);\n        var midpoint2 = (new Line(control1, control2)).pointAt(t);\n        var midpoint3 = (new Line(control2, end)).pointAt(t);\n\n        var subControl1 = (new Line(midpoint1, midpoint2)).pointAt(t);\n        var subControl2 = (new Line(midpoint2, midpoint3)).pointAt(t);\n\n        var divider = (new Line(subControl1, subControl2)).pointAt(t);\n\n        var output = {\n            startControlPoint1: midpoint1,\n            startControlPoint2: subControl1,\n            divider: divider,\n            dividerControlPoint1: subControl2,\n            dividerControlPoint2: midpoint3\n        };\n\n        return output;\n    },\n\n    // Returns a list of curves whose flattened length is better than `opt.precision`.\n    // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n    // (Observed difference is not real precision, but close enough as long as special cases are covered)\n    // As a rule of thumb, increasing `precision` by 1 requires 2 more iterations (= levels of division operations)\n    // - Precision 0 (endpointDistance) - 0 iterations => total of 2^0 - 1 = 0 operations (1 subdivision)\n    // - Precision 1 (<10% error) - 2 iterations => total of 2^2 - 1 = 3 operations (4 subdivisions)\n    // - Precision 2 (<1% error) - 4 iterations => total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n    // - Precision 3 (<0.1% error) - 6 iterations => total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n    // - Precision 4 (<0.01% error) - 8 iterations => total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n    // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n    getSubdivisions: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        var subdivisions = [new Curve(start, control1, control2, end)];\n        if (precision === 0) return subdivisions;\n\n        // special case #1: point-like curves\n        // - no need to calculate subdivisions, they would all be identical\n        var isPoint = !this.isDifferentiable();\n        if (isPoint) return subdivisions;\n\n        var previousLength = this.endpointDistance();\n\n        var precisionRatio = pow(10, -precision);\n\n        // special case #2: sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n        // - not a problem for further iterations because cubic curves cannot have more than two local extrema\n        // - (i.e. cubic curves cannot intersect the baseline more than once)\n        // - therefore starting from iteration = 2 ensures that subsequent iterations do not produce sampling with equal length\n        // - (unless it's a straight-line curve, see below)\n        var minIterations = 2; // = 2*1\n\n        // special case #3: straight-line curves have the same observed length in all iterations\n        // - this causes observed precision ratio to always be 0 (= lower than `precisionRatio`, which is our exit condition)\n        // - we enforce the expected number of iterations = 2 * precision\n        var isLine = ((control1.cross(start, end) === 0) && (control2.cross(start, end) === 0));\n        if (isLine) {\n            minIterations = (2 * precision);\n        }\n\n        // recursively divide curve at `t = 0.5`\n        // until we reach `minIterations`\n        // and until the difference between observed length at subsequent iterations is lower than `precision`\n        var iteration = 0;\n        while (true) {\n            iteration += 1;\n\n            // divide all subdivisions\n            var newSubdivisions = [];\n            var numSubdivisions = subdivisions.length;\n            for (var i = 0; i < numSubdivisions; i++) {\n\n                var currentSubdivision = subdivisions[i];\n                var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n                newSubdivisions.push(divided[0], divided[1]);\n            }\n\n            // measure new length\n            var length = 0;\n            var numNewSubdivisions = newSubdivisions.length;\n            for (var j = 0; j < numNewSubdivisions; j++) {\n\n                var currentNewSubdivision = newSubdivisions[j];\n                length += currentNewSubdivision.endpointDistance();\n            }\n\n            // check if we have reached minimum number of iterations\n            if (iteration >= minIterations) {\n\n                // check if we have reached required observed precision\n                var observedPrecisionRatio = ((length !== 0) ? ((length - previousLength) / length) : 0);\n                if (observedPrecisionRatio < precisionRatio) {\n                    return newSubdivisions;\n                }\n            }\n\n            // otherwise, set up for next iteration\n            subdivisions = newSubdivisions;\n            previousLength = length;\n        }\n    },\n\n    isDifferentiable: function() {\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n\n    // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n    length: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // not using localOpt\n\n        var length = 0;\n        var n = subdivisions.length;\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n            length += currentSubdivision.endpointDistance();\n        }\n\n        return length;\n    },\n\n    // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n    lengthAtT: function(t, opt) {\n\n        if (t <= 0) return 0;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n\n        var subCurve = this.divide(t)[0];\n        var subCurveLength = subCurve.length({ precision: precision });\n\n        return subCurveLength;\n    },\n\n    // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Mirrors Line.pointAt() function.\n    // For a function that tracks `t`, use Curve.pointAtT().\n    pointAt: function(ratio, opt) {\n\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n\n        var t = this.tAt(ratio, opt);\n\n        return this.pointAtT(t);\n    },\n\n    // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    pointAtLength: function(length, opt) {\n\n        var t = this.tAtLength(length, opt);\n\n        return this.pointAtT(t);\n    },\n\n    // Returns the point at provided `t` between 0 and 1.\n    // `t` does not track distance along curve as it does in Line objects.\n    // Non-linear relationship, speeds up and slows down as curve warps!\n    // For linear length-based solution, use Curve.pointAt().\n    pointAtT: function(t) {\n\n        if (t <= 0) return this.start.clone();\n        if (t >= 1) return this.end.clone();\n\n        return this.getSkeletonPoints(t).divider;\n    },\n\n    // Default precision\n    PRECISION: 3,\n\n    round: function(precision) {\n\n        this.start.round(precision);\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.start.scale(sx, sy, origin);\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAt: function(ratio, opt) {\n\n        if (!this.isDifferentiable()) return null;\n\n        if (ratio < 0) ratio = 0;\n        else if (ratio > 1) ratio = 1;\n\n        var t = this.tAt(ratio, opt);\n\n        return this.tangentAtT(t);\n    },\n\n    // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAtLength: function(length, opt) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var t = this.tAtLength(length, opt);\n\n        return this.tangentAtT(t);\n    },\n\n    // Returns a tangent line at requested `t`.\n    tangentAtT: function(t) {\n\n        if (!this.isDifferentiable()) return null;\n\n        if (t < 0) t = 0;\n        else if (t > 1) t = 1;\n\n        var skeletonPoints = this.getSkeletonPoints(t);\n\n        var p1 = skeletonPoints.startControlPoint2;\n        var p2 = skeletonPoints.dividerControlPoint1;\n\n        var tangentStart = skeletonPoints.divider;\n\n        var tangentLine = new Line(p1, p2);\n        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    tAt: function(ratio, opt) {\n\n        if (ratio <= 0) return 0;\n        if (ratio >= 1) return 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        var curveLength = this.length(localOpt);\n        var length = curveLength * ratio;\n\n        return this.tAtLength(length, localOpt);\n    },\n\n    // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Uses `precision` to approximate length within `precision` (always underestimates)\n    // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n    // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n    // - Precision 0 (chooses one of the two endpoints) - 0 levels\n    // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n    // - Precision 2 (<1% error) - 3 levels\n    // - Precision 3 (<0.1% error) - 7 levels\n    // - Precision 4 (<0.01% error) - 15 levels\n    tAtLength: function(length, opt) {\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        // identify the subdivision that contains the point at requested `length`:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        //var baseline; // straightened version of subdivision to investigate\n        //var baselinePoint; // point on the baseline that is the requested distance away from start\n        var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n        var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n        var l = 0; // length so far\n        var n = subdivisions.length;\n        var subdivisionSize = 1 / n;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var currentSubdivision = subdivisions[i];\n            var d = currentSubdivision.endpointDistance(); // length of current subdivision\n\n            if (length <= (l + d)) {\n                investigatedSubdivision = currentSubdivision;\n\n                investigatedSubdivisionStartT = index * subdivisionSize;\n                investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n\n                baselinePointDistFromStart = (fromStart ? (length - l) : ((d + l) - length));\n                baselinePointDistFromEnd = (fromStart ? ((d + l) - length) : (length - l));\n\n                break;\n            }\n\n            l += d;\n        }\n\n        if (!investigatedSubdivision) return (fromStart ? 1 : 0); // length requested is out of range - return maximum t\n        // note that precision affects what length is recorded\n        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n        var curveLength = this.length(localOpt);\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while (true) {\n\n            // check if we have reached required observed precision\n            var observedPrecisionRatio;\n\n            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromStart / curveLength) : 0);\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;\n            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromEnd / curveLength) : 0);\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;\n\n            // otherwise, set up for next iteration\n            var newBaselinePointDistFromStart;\n            var newBaselinePointDistFromEnd;\n\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n\n            var baseline1Length = divided[0].endpointDistance();\n            var baseline2Length = divided[1].endpointDistance();\n\n            if (baselinePointDistFromStart <= baseline1Length) { // point at requested length is inside divided[0]\n                investigatedSubdivision = divided[0];\n\n                investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n\n                newBaselinePointDistFromStart = baselinePointDistFromStart;\n                newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n\n            } else { // point at requested length is inside divided[1]\n                investigatedSubdivision = divided[1];\n\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n                newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n                newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n            }\n\n            baselinePointDistFromStart = newBaselinePointDistFromStart;\n            baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n        }\n    },\n\n    // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPoints: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // not using localOpt\n\n        var points = [subdivisions[0].start.clone()];\n        var n = subdivisions.length;\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n            points.push(currentSubdivision.end.clone());\n        }\n\n        return points;\n    },\n\n    // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPolyline: function(opt) {\n\n        return new Polyline(this.toPoints(opt));\n    },\n\n    toString: function() {\n\n        return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.start.translate(tx, ty);\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nCurve.prototype.divide = Curve.prototype.divideAtT;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}