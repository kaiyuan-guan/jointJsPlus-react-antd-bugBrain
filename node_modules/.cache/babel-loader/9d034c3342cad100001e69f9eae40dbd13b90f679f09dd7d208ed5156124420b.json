{"ast":null,"code":"import { manhattan } from './manhattan.mjs';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\nvar config = {\n  maxAllowedDirectionChange: 45,\n  // cost of a diagonal step\n  diagonalCost: function () {\n    var step = this.step;\n    return Math.ceil(Math.sqrt(step * step << 1));\n  },\n  // an array of directions to find next points on the route\n  // different from start/end directions\n  directions: function () {\n    var step = this.step;\n    var cost = this.cost();\n    var diagonalCost = this.diagonalCost();\n    return [{\n      offsetX: step,\n      offsetY: 0,\n      cost: cost\n    }, {\n      offsetX: step,\n      offsetY: step,\n      cost: diagonalCost\n    }, {\n      offsetX: 0,\n      offsetY: step,\n      cost: cost\n    }, {\n      offsetX: -step,\n      offsetY: step,\n      cost: diagonalCost\n    }, {\n      offsetX: -step,\n      offsetY: 0,\n      cost: cost\n    }, {\n      offsetX: -step,\n      offsetY: -step,\n      cost: diagonalCost\n    }, {\n      offsetX: 0,\n      offsetY: -step,\n      cost: cost\n    }, {\n      offsetX: step,\n      offsetY: -step,\n      cost: diagonalCost\n    }];\n  },\n  // a simple route used in situations when main routing method fails\n  // (exceed max number of loop iterations, inaccessible)\n  fallbackRoute: function (from, to, opt) {\n    // Find a route which breaks by 45 degrees ignoring all obstacles.\n\n    var theta = from.theta(to);\n    var route = [];\n    var a = {\n      x: to.x,\n      y: from.y\n    };\n    var b = {\n      x: from.x,\n      y: to.y\n    };\n    if (theta % 180 > 90) {\n      var t = a;\n      a = b;\n      b = t;\n    }\n    var p1 = theta % 90 < 45 ? a : b;\n    var l1 = new g.Line(from, p1);\n    var alpha = 90 * Math.ceil(theta / 90);\n    var p2 = g.Point.fromPolar(l1.squaredLength(), g.toRad(alpha + 135), p1);\n    var l2 = new g.Line(to, p2);\n    var intersectionPoint = l1.intersection(l2);\n    var point = intersectionPoint ? intersectionPoint : to;\n    var directionFrom = intersectionPoint ? point : from;\n    var quadrant = 360 / opt.directions.length;\n    var angleTheta = directionFrom.theta(to);\n    var normalizedAngle = g.normalizeAngle(angleTheta + quadrant / 2);\n    var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n    opt.previousDirectionAngle = directionAngle;\n    if (point) route.push(point.round());\n    route.push(to);\n    return route;\n  }\n};\n\n// public function\nexport const metro = function (vertices, opt, linkView) {\n  if (!util.isFunction(manhattan)) {\n    throw new Error('Metro requires the manhattan router.');\n  }\n  return manhattan(vertices, util.assign({}, config, opt), linkView);\n};","map":{"version":3,"names":["manhattan","util","g","config","maxAllowedDirectionChange","diagonalCost","step","Math","ceil","sqrt","directions","cost","offsetX","offsetY","fallbackRoute","from","to","opt","theta","route","a","x","y","b","t","p1","l1","Line","alpha","p2","Point","fromPolar","squaredLength","toRad","l2","intersectionPoint","intersection","point","directionFrom","quadrant","length","angleTheta","normalizedAngle","normalizeAngle","directionAngle","floor","previousDirectionAngle","push","round","metro","vertices","linkView","isFunction","Error","assign"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/routers/metro.mjs"],"sourcesContent":["import { manhattan } from './manhattan.mjs';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\nvar config = {\n\n    maxAllowedDirectionChange: 45,\n\n    // cost of a diagonal step\n    diagonalCost: function() {\n\n        var step = this.step;\n        return Math.ceil(Math.sqrt(step * step << 1));\n    },\n\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n\n        var step = this.step;\n        var cost = this.cost();\n        var diagonalCost = this.diagonalCost();\n\n        return [\n            { offsetX: step, offsetY: 0, cost: cost },\n            { offsetX: step, offsetY: step, cost: diagonalCost },\n            { offsetX: 0, offsetY: step, cost: cost },\n            { offsetX: -step, offsetY: step, cost: diagonalCost },\n            { offsetX: -step, offsetY: 0, cost: cost },\n            { offsetX: -step, offsetY: -step, cost: diagonalCost },\n            { offsetX: 0, offsetY: -step, cost: cost },\n            { offsetX: step, offsetY: -step, cost: diagonalCost }\n        ];\n    },\n\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n\n        // Find a route which breaks by 45 degrees ignoring all obstacles.\n\n        var theta = from.theta(to);\n\n        var route = [];\n\n        var a = { x: to.x, y: from.y };\n        var b = { x: from.x, y: to.y };\n\n        if (theta % 180 > 90) {\n            var t = a;\n            a = b;\n            b = t;\n        }\n\n        var p1 = (theta % 90) < 45 ? a : b;\n        var l1 = new g.Line(from, p1);\n\n        var alpha = 90 * Math.ceil(theta / 90);\n\n        var p2 = g.Point.fromPolar(l1.squaredLength(), g.toRad(alpha + 135), p1);\n        var l2 = new g.Line(to, p2);\n\n        var intersectionPoint = l1.intersection(l2);\n        var point = intersectionPoint ? intersectionPoint : to;\n\n        var directionFrom = intersectionPoint ? point : from;\n\n        var quadrant = 360 / opt.directions.length;\n        var angleTheta = directionFrom.theta(to);\n        var normalizedAngle = g.normalizeAngle(angleTheta + (quadrant / 2));\n        var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n\n        opt.previousDirectionAngle = directionAngle;\n\n        if (point) route.push(point.round());\n        route.push(to);\n\n        return route;\n    }\n};\n\n// public function\nexport const metro = function(vertices, opt, linkView) {\n\n    if (!util.isFunction(manhattan)) {\n        throw new Error('Metro requires the manhattan router.');\n    }\n\n    return manhattan(vertices, util.assign({}, config, opt), linkView);\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}