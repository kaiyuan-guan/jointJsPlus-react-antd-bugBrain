{"ast":null,"code":"import { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { types } from './types.mjs';\nconst {\n  sqrt,\n  round,\n  pow\n} = Math;\nexport const Ellipse = function (c, a, b) {\n  if (!(this instanceof Ellipse)) {\n    return new Ellipse(c, a, b);\n  }\n  if (c instanceof Ellipse) {\n    return new Ellipse(new Point(c.x, c.y), c.a, c.b);\n  }\n  c = new Point(c);\n  this.x = c.x;\n  this.y = c.y;\n  this.a = a;\n  this.b = b;\n};\nEllipse.fromRect = function (rect) {\n  rect = new Rect(rect);\n  return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);\n};\nEllipse.prototype = {\n  type: types.Ellipse,\n  bbox: function () {\n    return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n  },\n  /**\n   * @returns {g.Point}\n   */\n  center: function () {\n    return new Point(this.x, this.y);\n  },\n  clone: function () {\n    return new Ellipse(this);\n  },\n  /**\n   * @param {g.Point} p\n   * @returns {boolean}\n   */\n  containsPoint: function (p) {\n    return this.normalizedDistance(p) <= 1;\n  },\n  equals: function (ellipse) {\n    return !!ellipse && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;\n  },\n  // inflate by dx and dy\n  // @param dx {delta_x} representing additional size to x\n  // @param dy {delta_y} representing additional size to y -\n  // dy param is not required -> in that case y is sized by dx\n  inflate: function (dx, dy) {\n    if (dx === undefined) {\n      dx = 0;\n    }\n    if (dy === undefined) {\n      dy = dx;\n    }\n    this.a += 2 * dx;\n    this.b += 2 * dy;\n    return this;\n  },\n  intersectionWithLine: function (line) {\n    var intersections = [];\n    var a1 = line.start;\n    var a2 = line.end;\n    var rx = this.a;\n    var ry = this.b;\n    var dir = line.vector();\n    var diff = a1.difference(new Point(this));\n    var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n    var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n    var a = dir.dot(mDir);\n    var b = dir.dot(mDiff);\n    var c = diff.dot(mDiff) - 1.0;\n    var d = b * b - a * c;\n    if (d < 0) {\n      return null;\n    } else if (d > 0) {\n      var root = sqrt(d);\n      var ta = (-b - root) / a;\n      var tb = (-b + root) / a;\n      if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n        // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n        return null;\n      } else {\n        if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));\n        if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));\n      }\n    } else {\n      var t = -b / a;\n      if (0 <= t && t <= 1) {\n        intersections.push(a1.lerp(a2, t));\n      } else {\n        // outside\n        return null;\n      }\n    }\n    return intersections;\n  },\n  // Find point on me where line from my center to\n  // point p intersects my boundary.\n  // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n  intersectionWithLineFromCenterToPoint: function (p, angle) {\n    p = new Point(p);\n    if (angle) p.rotate(new Point(this.x, this.y), angle);\n    var dx = p.x - this.x;\n    var dy = p.y - this.y;\n    var result;\n    if (dx === 0) {\n      result = this.bbox().pointNearestToPoint(p);\n      if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n      return result;\n    }\n    var m = dy / dx;\n    var mSquared = m * m;\n    var aSquared = this.a * this.a;\n    var bSquared = this.b * this.b;\n    var x = sqrt(1 / (1 / aSquared + mSquared / bSquared));\n    x = dx < 0 ? -x : x;\n    var y = m * x;\n    result = new Point(this.x + x, this.y + y);\n    if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n    return result;\n  },\n  /**\n   * @param {g.Point} point\n   * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n   */\n  normalizedDistance: function (point) {\n    var x0 = point.x;\n    var y0 = point.y;\n    var a = this.a;\n    var b = this.b;\n    var x = this.x;\n    var y = this.y;\n    return (x0 - x) * (x0 - x) / (a * a) + (y0 - y) * (y0 - y) / (b * b);\n  },\n  round: function (precision) {\n    let f = 1; // case 0\n    if (precision) {\n      switch (precision) {\n        case 1:\n          f = 10;\n          break;\n        case 2:\n          f = 100;\n          break;\n        case 3:\n          f = 1000;\n          break;\n        default:\n          f = pow(10, precision);\n          break;\n      }\n    }\n    this.x = round(this.x * f) / f;\n    this.y = round(this.y * f) / f;\n    this.a = round(this.a * f) / f;\n    this.b = round(this.b * f) / f;\n    return this;\n  },\n  /** Compute angle between tangent and x axis\n   * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n   * @returns {number} angle between tangent and x axis\n   */\n  tangentTheta: function (p) {\n    var refPointDelta = 30;\n    var x0 = p.x;\n    var y0 = p.y;\n    var a = this.a;\n    var b = this.b;\n    var center = this.bbox().center();\n    var m = center.x;\n    var n = center.y;\n    var q1 = x0 > center.x + a / 2;\n    var q3 = x0 < center.x - a / 2;\n    var y, x;\n    if (q1 || q3) {\n      y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n      x = a * a / (x0 - m) - a * a * (y0 - n) * (y - n) / (b * b * (x0 - m)) + m;\n    } else {\n      x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n      y = b * b / (y0 - n) - b * b * (x0 - m) * (x - m) / (a * a * (y0 - n)) + n;\n    }\n    return new Point(x, y).theta(p);\n  },\n  toString: function () {\n    return new Point(this.x, this.y).toString() + ' ' + this.a + ' ' + this.b;\n  }\n};\n\n// For backwards compatibility:\nexport const ellipse = Ellipse;","map":{"version":3,"names":["Rect","Point","types","sqrt","round","pow","Math","Ellipse","c","a","b","x","y","fromRect","rect","center","width","height","prototype","type","bbox","clone","containsPoint","p","normalizedDistance","equals","ellipse","inflate","dx","dy","undefined","intersectionWithLine","line","intersections","a1","start","a2","end","rx","ry","dir","vector","diff","difference","mDir","mDiff","dot","d","root","ta","tb","push","lerp","t","intersectionWithLineFromCenterToPoint","angle","rotate","result","pointNearestToPoint","m","mSquared","aSquared","bSquared","point","x0","y0","precision","f","tangentTheta","refPointDelta","n","q1","q3","theta","toString"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/g/ellipse.mjs"],"sourcesContent":["import { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    sqrt,\n    round,\n    pow\n} = Math;\n\nexport const Ellipse = function(c, a, b) {\n\n    if (!(this instanceof Ellipse)) {\n        return new Ellipse(c, a, b);\n    }\n\n    if (c instanceof Ellipse) {\n        return new Ellipse(new Point(c.x, c.y), c.a, c.b);\n    }\n\n    c = new Point(c);\n    this.x = c.x;\n    this.y = c.y;\n    this.a = a;\n    this.b = b;\n};\n\nEllipse.fromRect = function(rect) {\n\n    rect = new Rect(rect);\n    return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);\n};\n\nEllipse.prototype = {\n\n    type: types.Ellipse,\n\n    bbox: function() {\n\n        return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n    },\n\n    /**\n     * @returns {g.Point}\n     */\n    center: function() {\n\n        return new Point(this.x, this.y);\n    },\n\n    clone: function() {\n\n        return new Ellipse(this);\n    },\n\n    /**\n     * @param {g.Point} p\n     * @returns {boolean}\n     */\n    containsPoint: function(p) {\n\n        return this.normalizedDistance(p) <= 1;\n    },\n\n    equals: function(ellipse) {\n\n        return !!ellipse &&\n            ellipse.x === this.x &&\n            ellipse.y === this.y &&\n            ellipse.a === this.a &&\n            ellipse.b === this.b;\n    },\n\n    // inflate by dx and dy\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n        if (dx === undefined) {\n            dx = 0;\n        }\n\n        if (dy === undefined) {\n            dy = dx;\n        }\n\n        this.a += 2 * dx;\n        this.b += 2 * dy;\n\n        return this;\n    },\n\n    intersectionWithLine: function(line) {\n\n        var intersections = [];\n        var a1 = line.start;\n        var a2 = line.end;\n        var rx = this.a;\n        var ry = this.b;\n        var dir = line.vector();\n        var diff = a1.difference(new Point(this));\n        var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n        var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n\n        var a = dir.dot(mDir);\n        var b = dir.dot(mDiff);\n        var c = diff.dot(mDiff) - 1.0;\n        var d = b * b - a * c;\n\n        if (d < 0) {\n            return null;\n        } else if (d > 0) {\n            var root = sqrt(d);\n            var ta = (-b - root) / a;\n            var tb = (-b + root) / a;\n\n            if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n                // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n                return null;\n            } else {\n                if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));\n                if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));\n            }\n        } else {\n            var t = -b / a;\n            if (0 <= t && t <= 1) {\n                intersections.push(a1.lerp(a2, t));\n            } else {\n                // outside\n                return null;\n            }\n        }\n\n        return intersections;\n    },\n\n    // Find point on me where line from my center to\n    // point p intersects my boundary.\n    // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n        p = new Point(p);\n\n        if (angle) p.rotate(new Point(this.x, this.y), angle);\n\n        var dx = p.x - this.x;\n        var dy = p.y - this.y;\n        var result;\n\n        if (dx === 0) {\n            result = this.bbox().pointNearestToPoint(p);\n            if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n            return result;\n        }\n\n        var m = dy / dx;\n        var mSquared = m * m;\n        var aSquared = this.a * this.a;\n        var bSquared = this.b * this.b;\n\n        var x = sqrt(1 / ((1 / aSquared) + (mSquared / bSquared)));\n        x = dx < 0 ? -x : x;\n\n        var y = m * x;\n        result = new Point(this.x + x, this.y + y);\n\n        if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n        return result;\n    },\n\n    /**\n     * @param {g.Point} point\n     * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n     */\n    normalizedDistance: function(point) {\n\n        var x0 = point.x;\n        var y0 = point.y;\n        var a = this.a;\n        var b = this.b;\n        var x = this.x;\n        var y = this.y;\n\n        return ((x0 - x) * (x0 - x)) / (a * a) + ((y0 - y) * (y0 - y)) / (b * b);\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.a = round(this.a * f) / f;\n        this.b = round(this.b * f) / f;\n        return this;\n    },\n\n    /** Compute angle between tangent and x axis\n     * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n     * @returns {number} angle between tangent and x axis\n     */\n    tangentTheta: function(p) {\n\n        var refPointDelta = 30;\n        var x0 = p.x;\n        var y0 = p.y;\n        var a = this.a;\n        var b = this.b;\n        var center = this.bbox().center();\n        var m = center.x;\n        var n = center.y;\n\n        var q1 = x0 > center.x + a / 2;\n        var q3 = x0 < center.x - a / 2;\n\n        var y, x;\n        if (q1 || q3) {\n            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n            x = (a * a / (x0 - m)) - (a * a * (y0 - n) * (y - n)) / (b * b * (x0 - m)) + m;\n\n        } else {\n            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n            y = (b * b / (y0 - n)) - (b * b * (x0 - m) * (x - m)) / (a * a * (y0 - n)) + n;\n        }\n\n        return (new Point(x, y)).theta(p);\n\n    },\n\n    toString: function() {\n\n        return (new Point(this.x, this.y)).toString() + ' ' + this.a + ' ' + this.b;\n    }\n};\n\n// For backwards compatibility:\nexport const ellipse = Ellipse;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}