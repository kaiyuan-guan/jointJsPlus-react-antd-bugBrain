{"ast":null,"code":"import V from '../V/index.mjs';\nimport { isNumber, assign, nextFrame, isObject, cancelFrame, defaults, defaultsDeep, addClassNamePrefix, normalizeSides, isFunction, isPlainObject, getByPath, sortElements, isString, guid, normalizeEvent, normalizeWheel, cap, debounce, omit, result, camelCase, cloneDeep, invoke, hashCode, filter as _filter, parseDOMJSON, toArray, has } from '../util/index.mjs';\nimport { ViewBase } from '../mvc/ViewBase.mjs';\nimport { Rect, Point, toRad } from '../g/index.mjs';\nimport { View, views } from '../mvc/index.mjs';\nimport { CellView } from './CellView.mjs';\nimport { ElementView } from './ElementView.mjs';\nimport { LinkView } from './LinkView.mjs';\nimport { Cell } from './Cell.mjs';\nimport { Graph } from './Graph.mjs';\nimport { LayersNames, PaperLayer } from './PaperLayer.mjs';\nimport * as highlighters from '../highlighters/index.mjs';\nimport * as linkAnchors from '../linkAnchors/index.mjs';\nimport * as connectionPoints from '../connectionPoints/index.mjs';\nimport * as anchors from '../anchors/index.mjs';\nimport $ from '../mvc/Dom/index.mjs';\nimport { GridLayer } from './layers/GridLayer.mjs';\nconst sortingTypes = {\n  NONE: 'sorting-none',\n  APPROX: 'sorting-approximate',\n  EXACT: 'sorting-exact'\n};\nconst WHEEL_CAP = 50;\nconst WHEEL_WAIT_MS = 20;\nconst MOUNT_BATCH_SIZE = 1000;\nconst UPDATE_BATCH_SIZE = Infinity;\nconst MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER\n\nconst HighlightingTypes = CellView.Highlighting;\nconst defaultHighlighting = {\n  [HighlightingTypes.DEFAULT]: {\n    name: 'stroke',\n    options: {\n      padding: 3\n    }\n  },\n  [HighlightingTypes.MAGNET_AVAILABILITY]: {\n    name: 'addClass',\n    options: {\n      className: 'available-magnet'\n    }\n  },\n  [HighlightingTypes.ELEMENT_AVAILABILITY]: {\n    name: 'addClass',\n    options: {\n      className: 'available-cell'\n    }\n  }\n};\nconst defaultLayers = [{\n  name: LayersNames.GRID\n}, {\n  name: LayersNames.BACK\n}, {\n  name: LayersNames.CELLS\n}, {\n  name: LayersNames.LABELS\n}, {\n  name: LayersNames.FRONT\n}, {\n  name: LayersNames.TOOLS\n}];\nexport const Paper = View.extend({\n  className: 'paper',\n  options: {\n    width: 800,\n    height: 600,\n    gridSize: 1,\n    // Whether or not to draw the grid lines on the paper's DOM element.\n    // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }\n    drawGrid: false,\n    // If not set, the size of the visual grid is the same as the `gridSize`.\n    drawGridSize: null,\n    // Whether or not to draw the background on the paper's DOM element.\n    // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }\n    background: false,\n    elementView: ElementView,\n    linkView: LinkView,\n    snapLabels: false,\n    // false, true\n    snapLinks: false,\n    // false, true, { radius: value }\n    snapLinksSelf: false,\n    // false, true, { radius: value }\n\n    // Should the link labels be rendered into its own layer?\n    // `false` - the labels are part of the links\n    // `true` - the labels are appended to LayersName.LABELS\n    // [LayersName] - the labels are appended to the layer specified\n    labelsLayer: false,\n    // When set to FALSE, an element may not have more than 1 link with the same source and target element.\n    multiLinks: true,\n    // For adding custom guard logic.\n    guard: function (evt, view) {\n      // FALSE means the event isn't guarded.\n      return false;\n    },\n    highlighting: defaultHighlighting,\n    // Prevent the default context menu from being displayed.\n    preventContextMenu: true,\n    // Prevent the default action for blank:pointer<action>.\n    preventDefaultBlankAction: true,\n    // Prevent the default action for cell:pointer<action>.\n    preventDefaultViewAction: true,\n    // Restrict the translation of elements by given bounding box.\n    // Option accepts a boolean:\n    //  true - the translation is restricted to the paper area\n    //  false - no restrictions\n    // A method:\n    // restrictTranslate: function(elementView) {\n    //     var parentId = elementView.model.get('parent');\n    //     return parentId && this.model.getCell(parentId).getBBox();\n    // },\n    // Or a bounding box:\n    // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }\n    restrictTranslate: false,\n    // Marks all available magnets with 'available-magnet' class name and all available cells with\n    // 'available-cell' class name. Marks them when dragging a link is started and unmark\n    // when the dragging is stopped.\n    markAvailable: false,\n    // Defines what link model is added to the graph after an user clicks on an active magnet.\n    // Value could be the mvc.model or a function returning the mvc.model\n    // defaultLink: (elementView, magnet) => {\n    //   return condition ? new customLink1() : new customLink2()\n    // }\n    defaultLink: function () {\n      // Do not create hard dependency on the joint.shapes.standard namespace (by importing the standard.Link model directly)\n      const {\n        cellNamespace\n      } = this.model.get('cells');\n      const ctor = getByPath(cellNamespace, ['standard', 'Link']);\n      if (!ctor) throw new Error('dia.Paper: no default link model found. Use `options.defaultLink` to specify a default link model.');\n      return new ctor();\n    },\n    // A connector that is used by links with no connector defined on the model.\n    // e.g. { name: 'rounded', args: { radius: 5 }} or a function\n    defaultConnector: {\n      name: 'normal'\n    },\n    // A router that is used by links with no router defined on the model.\n    // e.g. { name: 'oneSide', args: { padding: 10 }} or a function\n    defaultRouter: {\n      name: 'normal'\n    },\n    defaultAnchor: {\n      name: 'center'\n    },\n    defaultLinkAnchor: {\n      name: 'connectionRatio'\n    },\n    defaultConnectionPoint: {\n      name: 'boundary'\n    },\n    /* CONNECTING */\n\n    connectionStrategy: null,\n    // Check whether to add a new link to the graph when user clicks on an a magnet.\n    validateMagnet: function (_cellView, magnet, _evt) {\n      return magnet.getAttribute('magnet') !== 'passive';\n    },\n    // Check whether to allow or disallow the link connection while an arrowhead end (source/target)\n    // being changed.\n    validateConnection: function (cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {\n      return (end === 'target' ? cellViewT : cellViewS) instanceof ElementView;\n    },\n    /* EMBEDDING */\n\n    // Enables embedding. Re-parent the dragged element with elements under it and makes sure that\n    // all links and elements are visible taken the level of embedding into account.\n    embeddingMode: false,\n    // Check whether to allow or disallow the element embedding while an element being translated.\n    validateEmbedding: function (childView, parentView) {\n      // by default all elements can be in relation child-parent\n      return true;\n    },\n    // Check whether to allow or disallow an embedded element to be unembedded / to become a root.\n    validateUnembedding: function (childView) {\n      // by default all elements can become roots\n      return true;\n    },\n    // Determines the way how a cell finds a suitable parent when it's dragged over the paper.\n    // The cell with the highest z-index (visually on the top) will be chosen.\n    findParentBy: 'bbox',\n    // 'bbox'|'center'|'origin'|'corner'|'topRight'|'bottomLeft'\n\n    // If enabled only the element on the very front is taken into account for the embedding.\n    // If disabled the elements under the dragged view are tested one by one\n    // (from front to back) until a valid parent found.\n    frontParentOnly: true,\n    // Interactive flags. See online docs for the complete list of interactive flags.\n    interactive: {\n      labelMove: false\n    },\n    // When set to true the links can be pinned to the paper.\n    // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };\n    linkPinning: true,\n    // Custom validation after an interaction with a link ends.\n    // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)\n    // (linkView, paper) => boolean\n    allowLink: null,\n    // Allowed number of mousemove events after which the pointerclick event will be still triggered.\n    clickThreshold: 0,\n    // Number of required mousemove events before the first pointermove event will be triggered.\n    moveThreshold: 0,\n    // Number of required mousemove events before a link is created out of the magnet.\n    // Or string `onleave` so the link is created when the pointer leaves the magnet\n    magnetThreshold: 0,\n    // Rendering Options\n\n    sorting: sortingTypes.APPROX,\n    frozen: false,\n    autoFreeze: false,\n    // no docs yet\n    onViewUpdate: function (view, flag, priority, opt, paper) {\n      // Do not update connected links when:\n      // 1. the view was just inserted (added to the graph and rendered)\n      // 2. the view was just mounted (added back to the paper by viewport function)\n      // 3. the change was marked as `isolate`.\n      // 4. the view model was just removed from the graph\n      if (flag & (view.FLAG_INSERT | view.FLAG_REMOVE) || opt.mounting || opt.isolate) return;\n      paper.requestConnectedLinksUpdate(view, priority, opt);\n    },\n    // no docs yet\n    onViewPostponed: function (view, flag, paper) {\n      return paper.forcePostponedViewUpdate(view, flag);\n    },\n    beforeRender: null,\n    // function(opt, paper) { },\n\n    afterRender: null,\n    // function(stats, opt, paper) {\n\n    viewport: null,\n    // Default namespaces\n\n    cellViewNamespace: null,\n    routerNamespace: null,\n    connectorNamespace: null,\n    highlighterNamespace: highlighters,\n    anchorNamespace: anchors,\n    linkAnchorNamespace: linkAnchors,\n    connectionPointNamespace: connectionPoints,\n    overflow: false\n  },\n  events: {\n    'dblclick': 'pointerdblclick',\n    'dbltap': 'pointerdblclick',\n    'contextmenu': 'contextmenu',\n    'mousedown': 'pointerdown',\n    'touchstart': 'pointerdown',\n    'mouseover': 'mouseover',\n    'mouseout': 'mouseout',\n    'mouseenter': 'mouseenter',\n    'mouseleave': 'mouseleave',\n    'wheel': 'mousewheel',\n    'mouseenter .joint-cell': 'mouseenter',\n    'mouseleave .joint-cell': 'mouseleave',\n    'mouseenter .joint-tools': 'mouseenter',\n    'mouseleave .joint-tools': 'mouseleave',\n    'dblclick .joint-cell [magnet]': 'magnetpointerdblclick',\n    'contextmenu .joint-cell [magnet]': 'magnetcontextmenu',\n    'mousedown .joint-link .label': 'onlabel',\n    // interaction with link label\n    'touchstart .joint-link .label': 'onlabel',\n    'dragstart .joint-cell image': 'onImageDragStart' // firefox fix\n  },\n  documentEvents: {\n    'mousemove': 'pointermove',\n    'touchmove': 'pointermove',\n    'mouseup': 'pointerup',\n    'touchend': 'pointerup',\n    'touchcancel': 'pointerup'\n  },\n  /* CSS within the SVG document\n  * 1. Adding vector-effect: non-scaling-stroke; to prevent the stroke width from scaling for\n  *    elements that use the `scalable` group.\n  */\n  stylesheet: /*css*/`\n        .joint-element .scalable * {\n            vector-effect: non-scaling-stroke;\n        }\n    `,\n  svg: null,\n  viewport: null,\n  defs: null,\n  tools: null,\n  layers: null,\n  // For storing the current transformation matrix (CTM) of the paper's viewport.\n  _viewportMatrix: null,\n  // For verifying whether the CTM is up-to-date. The viewport transform attribute\n  // could have been manipulated directly.\n  _viewportTransformString: null,\n  // Updates data (priorities, unmounted views etc.)\n  _updates: null,\n  // Paper Layers\n  _layers: null,\n  SORT_DELAYING_BATCHES: ['add', 'to-front', 'to-back'],\n  UPDATE_DELAYING_BATCHES: ['translate'],\n  // If you interact with these elements,\n  // the default interaction such as `element move` is prevented.\n  FORM_CONTROL_TAG_NAMES: ['TEXTAREA', 'INPUT', 'BUTTON', 'SELECT', 'OPTION'],\n  // If you interact with these elements, the events are not propagated to the paper\n  // i.e. paper events such as `element:pointerdown` are not triggered.\n  GUARDED_TAG_NAMES: [\n  // Guard <select> for consistency. When you click on it:\n  // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open\n  // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).\n  //          on close. However, if you open and then close by clicking elsewhere on the page,\n  //           no other event is triggered.\n  // Safari: when you open it, it triggers `pointerdown`. That's it.\n  'SELECT'],\n  MIN_SCALE: 1e-6,\n  init: function () {\n    const {\n      options\n    } = this;\n    if (!options.cellViewNamespace) {\n      /* eslint-disable no-undef */\n      options.cellViewNamespace = typeof joint !== 'undefined' && has(joint, 'shapes') ? joint.shapes : null;\n      /* eslint-enable no-undef */\n    }\n    const model = this.model = options.model || new Graph();\n\n    // Layers (SVGGroups)\n    this._layers = {};\n    this.cloneOptions();\n    this.render();\n    this._setDimensions();\n    this.startListening();\n\n    // Hash of all cell views.\n    this._views = {};\n\n    // Mouse wheel events buffer\n    this._mw_evt_buffer = {\n      event: null,\n      deltas: []\n    };\n\n    // Render existing cells in the graph\n    this.resetViews(model.attributes.cells.models);\n    // Start the Rendering Loop\n    if (!this.isFrozen() && this.isAsync()) this.updateViewsAsync();\n  },\n  _resetUpdates: function () {\n    return this._updates = {\n      id: null,\n      priorities: [{}, {}, {}],\n      unmountedCids: [],\n      mountedCids: [],\n      unmounted: {},\n      mounted: {},\n      count: 0,\n      keyFrozen: false,\n      freezeKey: null,\n      sort: false,\n      disabled: false,\n      idle: false\n    };\n  },\n  startListening: function () {\n    var model = this.model;\n    this.listenTo(model, 'add', this.onCellAdded).listenTo(model, 'remove', this.onCellRemoved).listenTo(model, 'change', this.onCellChange).listenTo(model, 'reset', this.onGraphReset).listenTo(model, 'sort', this.onGraphSort).listenTo(model, 'batch:stop', this.onGraphBatchStop);\n    this.on('cell:highlight', this.onCellHighlight).on('cell:unhighlight', this.onCellUnhighlight).on('transform', this.update);\n  },\n  onCellAdded: function (cell, _, opt) {\n    var position = opt.position;\n    if (this.isAsync() || !isNumber(position)) {\n      this.renderView(cell, opt);\n    } else {\n      if (opt.maxPosition === position) this.freeze({\n        key: 'addCells'\n      });\n      this.renderView(cell, opt);\n      if (position === 0) this.unfreeze({\n        key: 'addCells'\n      });\n    }\n  },\n  onCellRemoved: function (cell, _, opt) {\n    const view = this.findViewByModel(cell);\n    if (view) this.requestViewUpdate(view, view.FLAG_REMOVE, view.UPDATE_PRIORITY, opt);\n  },\n  onCellChange: function (cell, opt) {\n    if (cell === this.model.attributes.cells) return;\n    if (cell.hasChanged('z') && this.options.sorting === sortingTypes.APPROX) {\n      const view = this.findViewByModel(cell);\n      if (view) this.requestViewUpdate(view, view.FLAG_INSERT, view.UPDATE_PRIORITY, opt);\n    }\n  },\n  onGraphReset: function (collection, opt) {\n    this.resetLayers();\n    this.resetViews(collection.models, opt);\n  },\n  onGraphSort: function () {\n    if (this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;\n    this.sortViews();\n  },\n  onGraphBatchStop: function (data) {\n    if (this.isFrozen()) return;\n    var name = data && data.batchName;\n    var graph = this.model;\n    if (!this.isAsync()) {\n      var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;\n      if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {\n        this.updateViews(data);\n      }\n    }\n    var sortDelayingBatches = this.SORT_DELAYING_BATCHES;\n    if (sortDelayingBatches.includes(name) && !graph.hasActiveBatch(sortDelayingBatches)) {\n      this.sortViews();\n    }\n  },\n  cloneOptions: function () {\n    const {\n      options\n    } = this;\n    const {\n      defaultConnector,\n      defaultRouter,\n      defaultConnectionPoint,\n      defaultAnchor,\n      defaultLinkAnchor,\n      highlighting,\n      cellViewNamespace,\n      interactive\n    } = options;\n\n    // Default cellView namespace for ES5\n    /* eslint-disable no-undef */\n    if (!cellViewNamespace && typeof joint !== 'undefined' && has(joint, 'shapes')) {\n      options.cellViewNamespace = joint.shapes;\n    }\n    /* eslint-enable no-undef */\n\n    // Here if a function was provided, we can not clone it, as this would result in loosing the function.\n    // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.\n    if (!isFunction(defaultConnector)) {\n      options.defaultConnector = cloneDeep(defaultConnector);\n    }\n    if (!isFunction(defaultRouter)) {\n      options.defaultRouter = cloneDeep(defaultRouter);\n    }\n    if (!isFunction(defaultConnectionPoint)) {\n      options.defaultConnectionPoint = cloneDeep(defaultConnectionPoint);\n    }\n    if (!isFunction(defaultAnchor)) {\n      options.defaultAnchor = cloneDeep(defaultAnchor);\n    }\n    if (!isFunction(defaultLinkAnchor)) {\n      options.defaultLinkAnchor = cloneDeep(defaultLinkAnchor);\n    }\n    if (isPlainObject(interactive)) {\n      options.interactive = assign({}, interactive);\n    }\n    if (isPlainObject(highlighting)) {\n      // Return the default highlighting options into the user specified options.\n      options.highlighting = defaultsDeep({}, highlighting, defaultHighlighting);\n    }\n  },\n  children: function () {\n    var ns = V.namespace;\n    return [{\n      namespaceURI: ns.xhtml,\n      tagName: 'div',\n      className: addClassNamePrefix('paper-background'),\n      selector: 'background',\n      style: {\n        position: 'absolute',\n        inset: 0\n      }\n    }, {\n      namespaceURI: ns.svg,\n      tagName: 'svg',\n      attributes: {\n        'width': '100%',\n        'height': '100%',\n        'xmlns:xlink': ns.xlink\n      },\n      selector: 'svg',\n      style: {\n        position: 'absolute',\n        inset: 0\n      },\n      children: [{\n        // Append `<defs>` element to the SVG document. This is useful for filters and gradients.\n        // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).\n        tagName: 'defs',\n        selector: 'defs'\n      }, {\n        tagName: 'g',\n        className: addClassNamePrefix('layers'),\n        selector: 'layers'\n      }]\n    }];\n  },\n  hasLayerView(layerName) {\n    return layerName in this._layers;\n  },\n  getLayerView(layerName) {\n    const {\n      _layers\n    } = this;\n    if (layerName in _layers) return _layers[layerName];\n    throw new Error(`dia.Paper: Unknown layer \"${layerName}\"`);\n  },\n  getLayerNode(layerName) {\n    return this.getLayerView(layerName).el;\n  },\n  render: function () {\n    this.renderChildren();\n    const {\n      el,\n      childNodes,\n      options,\n      stylesheet\n    } = this;\n    const {\n      svg,\n      defs,\n      layers\n    } = childNodes;\n    el.style.position = 'relative';\n    svg.style.overflow = options.overflow ? 'visible' : 'hidden';\n    this.svg = svg;\n    this.defs = defs;\n    this.layers = layers;\n    this.renderLayers();\n    V.ensureId(svg);\n    this.addStylesheet(stylesheet);\n    if (options.background) {\n      this.drawBackground(options.background);\n    }\n    if (options.drawGrid) {\n      this.setGrid(options.drawGrid);\n    }\n    return this;\n  },\n  addStylesheet: function (css) {\n    if (!css) return;\n    V(this.svg).prepend(V.createSVGStyle(css));\n  },\n  createLayer(name) {\n    switch (name) {\n      case LayersNames.GRID:\n        return new GridLayer({\n          name,\n          paper: this,\n          patterns: this.constructor.gridPatterns\n        });\n      default:\n        return new PaperLayer({\n          name\n        });\n    }\n  },\n  renderLayers: function (layers = defaultLayers) {\n    this.removeLayers();\n    // TODO: Layers to be read from the graph `layers` attribute\n    layers.forEach(({\n      name,\n      sorted\n    }) => {\n      const layerView = this.createLayer(name);\n      this.layers.appendChild(layerView.el);\n      this._layers[name] = layerView;\n    });\n    // Throws an exception if doesn't exist\n    const cellsLayerView = this.getLayerView(LayersNames.CELLS);\n    const toolsLayerView = this.getLayerView(LayersNames.TOOLS);\n    const labelsLayerView = this.getLayerView(LayersNames.LABELS);\n    // backwards compatibility\n    this.tools = toolsLayerView.el;\n    this.cells = this.viewport = cellsLayerView.el;\n    // user-select: none;\n    cellsLayerView.vel.addClass(addClassNamePrefix('viewport'));\n    labelsLayerView.vel.addClass(addClassNamePrefix('viewport'));\n    cellsLayerView.el.style.webkitUserSelect = 'none';\n    cellsLayerView.el.style.userSelect = 'none';\n    labelsLayerView.el.style.webkitUserSelect = 'none';\n    labelsLayerView.el.style.userSelect = 'none';\n  },\n  removeLayers: function () {\n    const {\n      _layers\n    } = this;\n    Object.keys(_layers).forEach(name => {\n      _layers[name].remove();\n      delete _layers[name];\n    });\n  },\n  resetLayers: function () {\n    const {\n      _layers\n    } = this;\n    Object.keys(_layers).forEach(name => {\n      _layers[name].removePivots();\n    });\n  },\n  update: function () {\n    if (this._background) {\n      this.updateBackgroundImage(this._background);\n    }\n    return this;\n  },\n  scale: function (sx, sy, data) {\n    const ctm = this.matrix();\n    // getter\n    if (sx === undefined) {\n      return V.matrixToScale(ctm);\n    }\n    // setter\n    if (sy === undefined) {\n      sy = sx;\n    }\n    sx = Math.max(sx || 0, this.MIN_SCALE);\n    sy = Math.max(sy || 0, this.MIN_SCALE);\n    ctm.a = sx;\n    ctm.d = sy;\n    this.matrix(ctm, data);\n    return this;\n  },\n  scaleUniformAtPoint: function (scale, point, data) {\n    const {\n      a: sx,\n      d: sy,\n      e: tx,\n      f: ty\n    } = this.matrix();\n    scale = Math.max(scale || 0, this.MIN_SCALE);\n    if (scale === sx && scale === sy) {\n      // The scale is the same as the current one.\n      return this;\n    }\n    const matrix = V.createSVGMatrix().translate(tx - point.x * (scale - sx), ty - point.y * (scale - sy)).scale(scale, scale);\n    this.matrix(matrix, data);\n    return this;\n  },\n  translate: function (tx, ty, data) {\n    const ctm = this.matrix();\n    // getter\n    if (tx === undefined) {\n      return V.matrixToTranslate(ctm);\n    }\n    // setter\n    tx || (tx = 0);\n    ty || (ty = 0);\n    if (ctm.e === tx && ctm.f === ty) return this;\n    ctm.e = tx;\n    ctm.f = ty;\n    this.matrix(ctm, data);\n    return this;\n  },\n  matrix: function (ctm, data = {}) {\n    var viewport = this.layers;\n\n    // Getter:\n    if (ctm === undefined) {\n      var transformString = viewport.getAttribute('transform');\n      if ((this._viewportTransformString || null) === transformString) {\n        // It's ok to return the cached matrix. The transform attribute has not changed since\n        // the matrix was stored.\n        ctm = this._viewportMatrix;\n      } else {\n        // The viewport transform attribute has changed. Measure the matrix and cache again.\n        ctm = viewport.getCTM();\n        this._viewportMatrix = ctm;\n        this._viewportTransformString = transformString;\n      }\n\n      // Clone the cached current transformation matrix.\n      // If no matrix previously stored the identity matrix is returned.\n      return V.createSVGMatrix(ctm);\n    }\n\n    // Setter:\n    const prev = this.matrix();\n    const current = V.createSVGMatrix(ctm);\n    const currentTransformString = this._viewportTransformString;\n    const ctmString = V.matrixToTransformString(current);\n    if (ctmString === currentTransformString) {\n      // The new transform string is the same as the current one.\n      // No need to update the transform attribute.\n      return this;\n    }\n    if (!currentTransformString && V.matrixToTransformString() === ctmString) {\n      // The current transform string is empty and the new one is an identity matrix.\n      // No need to update the transform attribute.\n      return this;\n    }\n    const {\n      a,\n      d,\n      e,\n      f\n    } = current;\n    viewport.setAttribute('transform', ctmString);\n    this._viewportMatrix = current;\n    this._viewportTransformString = viewport.getAttribute('transform');\n\n    // scale event\n    if (a !== prev.a || d !== prev.d) {\n      this.trigger('scale', a, d, data);\n    }\n\n    // translate event\n    if (e !== prev.e || f !== prev.f) {\n      this.trigger('translate', e, f, data);\n    }\n    this.trigger('transform', current, data);\n    return this;\n  },\n  clientMatrix: function () {\n    return V.createSVGMatrix(this.cells.getScreenCTM());\n  },\n  requestConnectedLinksUpdate: function (view, priority, opt) {\n    if (view instanceof CellView) {\n      var model = view.model;\n      var links = this.model.getConnectedLinks(model);\n      for (var j = 0, n = links.length; j < n; j++) {\n        var link = links[j];\n        var linkView = this.findViewByModel(link);\n        if (!linkView) continue;\n        var flagLabels = ['UPDATE'];\n        if (link.getTargetCell() === model) flagLabels.push('TARGET');\n        if (link.getSourceCell() === model) flagLabels.push('SOURCE');\n        var nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);\n        this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);\n      }\n    }\n  },\n  forcePostponedViewUpdate: function (view, flag) {\n    if (!view || !(view instanceof CellView)) return false;\n    var model = view.model;\n    if (model.isElement()) return false;\n    if ((flag & view.getFlag(['SOURCE', 'TARGET'])) === 0) {\n      var dumpOptions = {\n        silent: true\n      };\n      // LinkView is waiting for the target or the source cellView to be rendered\n      // This can happen when the cells are not in the viewport.\n      var sourceFlag = 0;\n      var sourceView = this.findViewByModel(model.getSourceCell());\n      if (sourceView && !this.isViewMounted(sourceView)) {\n        sourceFlag = this.dumpView(sourceView, dumpOptions);\n        view.updateEndMagnet('source');\n      }\n      var targetFlag = 0;\n      var targetView = this.findViewByModel(model.getTargetCell());\n      if (targetView && !this.isViewMounted(targetView)) {\n        targetFlag = this.dumpView(targetView, dumpOptions);\n        view.updateEndMagnet('target');\n      }\n      if (sourceFlag === 0 && targetFlag === 0) {\n        // If leftover flag is 0, all view updates were done.\n        return !this.dumpView(view, dumpOptions);\n      }\n    }\n    return false;\n  },\n  requestViewUpdate: function (view, flag, priority, opt) {\n    opt || (opt = {});\n    this.scheduleViewUpdate(view, flag, priority, opt);\n    var isAsync = this.isAsync();\n    if (this.isFrozen() || isAsync && opt.async !== false) return;\n    if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;\n    var stats = this.updateViews(opt);\n    if (isAsync) this.notifyAfterRender(stats, opt);\n  },\n  scheduleViewUpdate: function (view, type, priority, opt) {\n    const {\n      _updates: updates,\n      options\n    } = this;\n    if (updates.idle) {\n      if (options.autoFreeze) {\n        updates.idle = false;\n        this.unfreeze();\n      }\n    }\n    const {\n      FLAG_REMOVE,\n      FLAG_INSERT,\n      UPDATE_PRIORITY,\n      cid\n    } = view;\n    let priorityUpdates = updates.priorities[priority];\n    if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};\n    // Move higher priority updates to this priority\n    if (priority > UPDATE_PRIORITY) {\n      // Not the default priority for this view. It's most likely a link view\n      // connected to another link view, which triggered the update.\n      // TODO: If there is an update scheduled with a lower priority already, we should\n      // change the requested priority to the lowest one. Does not seem to be critical\n      // right now, as it \"only\" results in multiple updates on the same view.\n      for (let i = priority - 1; i >= UPDATE_PRIORITY; i--) {\n        const prevPriorityUpdates = updates.priorities[i];\n        if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;\n        priorityUpdates[cid] |= prevPriorityUpdates[cid];\n        delete prevPriorityUpdates[cid];\n      }\n    }\n    let currentType = priorityUpdates[cid] || 0;\n    // Prevent cycling\n    if ((currentType & type) === type) return;\n    if (!currentType) updates.count++;\n    if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {\n      // When a view is removed we need to remove the insert flag as this is a reinsert\n      priorityUpdates[cid] ^= FLAG_INSERT;\n    } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {\n      // When a view is added we need to remove the remove flag as this is view was previously removed\n      priorityUpdates[cid] ^= FLAG_REMOVE;\n    }\n    priorityUpdates[cid] |= type;\n    const viewUpdateFn = options.onViewUpdate;\n    if (typeof viewUpdateFn === 'function') viewUpdateFn.call(this, view, type, priority, opt || {}, this);\n  },\n  dumpViewUpdate: function (view) {\n    if (!view) return 0;\n    var updates = this._updates;\n    var cid = view.cid;\n    var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];\n    var flag = this.registerMountedView(view) | priorityUpdates[cid];\n    delete priorityUpdates[cid];\n    return flag;\n  },\n  dumpView: function (view, opt = {}) {\n    const flag = this.dumpViewUpdate(view);\n    if (!flag) return 0;\n    const shouldNotify = !opt.silent;\n    if (shouldNotify) this.notifyBeforeRender(opt);\n    const leftover = this.updateView(view, flag, opt);\n    if (shouldNotify) {\n      const stats = {\n        updated: 1,\n        priority: view.UPDATE_PRIORITY\n      };\n      this.notifyAfterRender(stats, opt);\n    }\n    return leftover;\n  },\n  updateView: function (view, flag, opt) {\n    if (!view) return 0;\n    const {\n      FLAG_REMOVE,\n      FLAG_INSERT,\n      FLAG_INIT,\n      model\n    } = view;\n    if (view instanceof CellView) {\n      if (flag & FLAG_REMOVE) {\n        this.removeView(model);\n        return 0;\n      }\n      if (flag & FLAG_INSERT) {\n        const isInitialInsert = !!(flag & FLAG_INIT);\n        if (isInitialInsert) {\n          flag ^= FLAG_INIT;\n        }\n        this.insertView(view, isInitialInsert);\n        flag ^= FLAG_INSERT;\n      }\n    }\n    if (!flag) return 0;\n    return view.confirmUpdate(flag, opt || {});\n  },\n  requireView: function (model, opt) {\n    var view = this.findViewByModel(model);\n    if (!view) return null;\n    this.dumpView(view, opt);\n    return view;\n  },\n  registerUnmountedView: function (view) {\n    var cid = view.cid;\n    var updates = this._updates;\n    if (cid in updates.unmounted) return 0;\n    var flag = updates.unmounted[cid] |= view.FLAG_INSERT;\n    updates.unmountedCids.push(cid);\n    delete updates.mounted[cid];\n    return flag;\n  },\n  registerMountedView: function (view) {\n    var cid = view.cid;\n    var updates = this._updates;\n    if (cid in updates.mounted) return 0;\n    updates.mounted[cid] = true;\n    updates.mountedCids.push(cid);\n    var flag = updates.unmounted[cid] || 0;\n    delete updates.unmounted[cid];\n    return flag;\n  },\n  isViewMounted: function (view) {\n    if (!view) return false;\n    var cid = view.cid;\n    var updates = this._updates;\n    return cid in updates.mounted;\n  },\n  dumpViews: function (opt) {\n    var passingOpt = defaults({}, opt, {\n      viewport: null\n    });\n    this.checkViewport(passingOpt);\n    this.updateViews(passingOpt);\n  },\n  // Synchronous views update\n  updateViews: function (opt) {\n    this.notifyBeforeRender(opt);\n    let batchStats;\n    let updateCount = 0;\n    let batchCount = 0;\n    let priority = MIN_PRIORITY;\n    do {\n      batchCount++;\n      batchStats = this.updateViewsBatch(opt);\n      updateCount += batchStats.updated;\n      priority = Math.min(batchStats.priority, priority);\n    } while (!batchStats.empty);\n    const stats = {\n      updated: updateCount,\n      batches: batchCount,\n      priority\n    };\n    this.notifyAfterRender(stats, opt);\n    return stats;\n  },\n  hasScheduledUpdates: function () {\n    const priorities = this._updates.priorities;\n    const priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n    let i = priorityIndexes.length;\n    while (i > 0 && i--) {\n      // a faster way how to check if an object is empty\n      for (let _key in priorities[priorityIndexes[i]]) return true;\n    }\n    return false;\n  },\n  updateViewsAsync: function (opt, data) {\n    opt || (opt = {});\n    data || (data = {\n      processed: 0,\n      priority: MIN_PRIORITY\n    });\n    const {\n      _updates: updates,\n      options\n    } = this;\n    const id = updates.id;\n    if (id) {\n      cancelFrame(id);\n      if (data.processed === 0 && this.hasScheduledUpdates()) {\n        this.notifyBeforeRender(opt);\n      }\n      const stats = this.updateViewsBatch(opt);\n      const passingOpt = defaults({}, opt, {\n        mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,\n        unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted\n      });\n      const checkStats = this.checkViewport(passingOpt);\n      const unmountCount = checkStats.unmounted;\n      const mountCount = checkStats.mounted;\n      let processed = data.processed;\n      const total = updates.count;\n      if (stats.updated > 0) {\n        // Some updates have been just processed\n        processed += stats.updated + stats.unmounted;\n        stats.processed = processed;\n        data.priority = Math.min(stats.priority, data.priority);\n        if (stats.empty && mountCount === 0) {\n          stats.unmounted += unmountCount;\n          stats.mounted += mountCount;\n          stats.priority = data.priority;\n          this.notifyAfterRender(stats, opt);\n          data.processed = 0;\n          data.priority = MIN_PRIORITY;\n          updates.count = 0;\n        } else {\n          data.processed = processed;\n        }\n      } else {\n        if (!updates.idle) {\n          if (options.autoFreeze) {\n            this.freeze();\n            updates.idle = true;\n            this.trigger('render:idle', opt);\n          }\n        }\n      }\n      // Progress callback\n      const progressFn = opt.progress;\n      if (total && typeof progressFn === 'function') {\n        progressFn.call(this, stats.empty, processed, total, stats, this);\n      }\n      // The current frame could have been canceled in a callback\n      if (updates.id !== id) return;\n    }\n    if (updates.disabled) {\n      throw new Error('dia.Paper: can not unfreeze the paper after it was removed');\n    }\n    updates.id = nextFrame(this.updateViewsAsync, this, opt, data);\n  },\n  notifyBeforeRender: function (opt = {}) {\n    let beforeFn = opt.beforeRender;\n    if (typeof beforeFn !== 'function') {\n      beforeFn = this.options.beforeRender;\n      if (typeof beforeFn !== 'function') return;\n    }\n    beforeFn.call(this, opt, this);\n  },\n  notifyAfterRender: function (stats, opt = {}) {\n    let afterFn = opt.afterRender;\n    if (typeof afterFn !== 'function') {\n      afterFn = this.options.afterRender;\n    }\n    if (typeof afterFn === 'function') {\n      afterFn.call(this, stats, opt, this);\n    }\n    this.trigger('render:done', stats, opt);\n  },\n  updateViewsBatch: function (opt) {\n    opt || (opt = {});\n    var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;\n    var updates = this._updates;\n    var updateCount = 0;\n    var postponeCount = 0;\n    var unmountCount = 0;\n    var mountCount = 0;\n    var maxPriority = MIN_PRIORITY;\n    var empty = true;\n    var options = this.options;\n    var priorities = updates.priorities;\n    var viewportFn = 'viewport' in opt ? opt.viewport : options.viewport;\n    if (typeof viewportFn !== 'function') viewportFn = null;\n    var postponeViewFn = options.onViewPostponed;\n    if (typeof postponeViewFn !== 'function') postponeViewFn = null;\n    var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n    main: for (var i = 0, n = priorityIndexes.length; i < n; i++) {\n      var priority = +priorityIndexes[i];\n      var priorityUpdates = priorities[priority];\n      for (var cid in priorityUpdates) {\n        if (updateCount >= batchSize) {\n          empty = false;\n          break main;\n        }\n        var view = views[cid];\n        if (!view) {\n          // This should not occur\n          delete priorityUpdates[cid];\n          continue;\n        }\n        var currentFlag = priorityUpdates[cid];\n        if ((currentFlag & view.FLAG_REMOVE) === 0) {\n          // We should never check a view for viewport if we are about to remove the view\n          var isDetached = (cid in updates.unmounted);\n          if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, !isDetached, this)) {\n            // Unmount View\n            if (!isDetached) {\n              this.registerUnmountedView(view);\n              this.detachView(view);\n            }\n            updates.unmounted[cid] |= currentFlag;\n            delete priorityUpdates[cid];\n            unmountCount++;\n            continue;\n          }\n          // Mount View\n          if (isDetached) {\n            currentFlag |= view.FLAG_INSERT;\n            mountCount++;\n          }\n          currentFlag |= this.registerMountedView(view);\n        }\n        var leftoverFlag = this.updateView(view, currentFlag, opt);\n        if (leftoverFlag > 0) {\n          // View update has not finished completely\n          priorityUpdates[cid] = leftoverFlag;\n          if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {\n            postponeCount++;\n            empty = false;\n            continue;\n          }\n        }\n        if (maxPriority > priority) maxPriority = priority;\n        updateCount++;\n        delete priorityUpdates[cid];\n      }\n    }\n    return {\n      priority: maxPriority,\n      updated: updateCount,\n      postponed: postponeCount,\n      unmounted: unmountCount,\n      mounted: mountCount,\n      empty: empty\n    };\n  },\n  getUnmountedViews: function () {\n    const updates = this._updates;\n    const unmountedCids = Object.keys(updates.unmounted);\n    const n = unmountedCids.length;\n    const unmountedViews = new Array(n);\n    for (var i = 0; i < n; i++) {\n      unmountedViews[i] = views[unmountedCids[i]];\n    }\n    return unmountedViews;\n  },\n  getMountedViews: function () {\n    const updates = this._updates;\n    const mountedCids = Object.keys(updates.mounted);\n    const n = mountedCids.length;\n    const mountedViews = new Array(n);\n    for (var i = 0; i < n; i++) {\n      mountedViews[i] = views[mountedCids[i]];\n    }\n    return mountedViews;\n  },\n  checkUnmountedViews: function (viewportFn, opt) {\n    opt || (opt = {});\n    var mountCount = 0;\n    if (typeof viewportFn !== 'function') viewportFn = null;\n    var batchSize = 'mountBatchSize' in opt ? opt.mountBatchSize : Infinity;\n    var updates = this._updates;\n    var unmountedCids = updates.unmountedCids;\n    var unmounted = updates.unmounted;\n    for (var i = 0, n = Math.min(unmountedCids.length, batchSize); i < n; i++) {\n      var cid = unmountedCids[i];\n      if (!(cid in unmounted)) continue;\n      var view = views[cid];\n      if (!view) continue;\n      if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, false, this)) {\n        // Push at the end of all unmounted ids, so this can be check later again\n        unmountedCids.push(cid);\n        continue;\n      }\n      mountCount++;\n      var flag = this.registerMountedView(view);\n      if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, {\n        mounting: true\n      });\n    }\n    // Get rid of views, that have been mounted\n    unmountedCids.splice(0, i);\n    return mountCount;\n  },\n  checkMountedViews: function (viewportFn, opt) {\n    opt || (opt = {});\n    var unmountCount = 0;\n    if (typeof viewportFn !== 'function') return unmountCount;\n    var batchSize = 'unmountBatchSize' in opt ? opt.unmountBatchSize : Infinity;\n    var updates = this._updates;\n    var mountedCids = updates.mountedCids;\n    var mounted = updates.mounted;\n    for (var i = 0, n = Math.min(mountedCids.length, batchSize); i < n; i++) {\n      var cid = mountedCids[i];\n      if (!(cid in mounted)) continue;\n      var view = views[cid];\n      if (!view) continue;\n      if (!view.DETACHABLE || viewportFn.call(this, view, true, this)) {\n        // Push at the end of all mounted ids, so this can be check later again\n        mountedCids.push(cid);\n        continue;\n      }\n      unmountCount++;\n      var flag = this.registerUnmountedView(view);\n      if (flag) this.detachView(view);\n    }\n    // Get rid of views, that have been unmounted\n    mountedCids.splice(0, i);\n    return unmountCount;\n  },\n  checkViewVisibility: function (cellView, opt = {}) {\n    let viewportFn = 'viewport' in opt ? opt.viewport : this.options.viewport;\n    if (typeof viewportFn !== 'function') viewportFn = null;\n    const updates = this._updates;\n    const {\n      mounted,\n      unmounted\n    } = updates;\n    const visible = !cellView.DETACHABLE || !viewportFn || viewportFn.call(this, cellView, false, this);\n    let isUnmounted = false;\n    let isMounted = false;\n    if (cellView.cid in mounted && !visible) {\n      const flag = this.registerUnmountedView(cellView);\n      if (flag) this.detachView(cellView);\n      const i = updates.mountedCids.indexOf(cellView.cid);\n      updates.mountedCids.splice(i, 1);\n      isUnmounted = true;\n    }\n    if (!isUnmounted && cellView.cid in unmounted && visible) {\n      const i = updates.unmountedCids.indexOf(cellView.cid);\n      updates.unmountedCids.splice(i, 1);\n      var flag = this.registerMountedView(cellView);\n      if (flag) this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, {\n        mounting: true\n      });\n      isMounted = true;\n    }\n    return {\n      mounted: isMounted ? 1 : 0,\n      unmounted: isUnmounted ? 1 : 0\n    };\n  },\n  checkViewport: function (opt) {\n    var passingOpt = defaults({}, opt, {\n      mountBatchSize: Infinity,\n      unmountBatchSize: Infinity\n    });\n    var viewportFn = 'viewport' in passingOpt ? passingOpt.viewport : this.options.viewport;\n    var unmountedCount = this.checkMountedViews(viewportFn, passingOpt);\n    if (unmountedCount > 0) {\n      // Do not check views, that have been just unmounted and pushed at the end of the cids array\n      var unmountedCids = this._updates.unmountedCids;\n      passingOpt.mountBatchSize = Math.min(unmountedCids.length - unmountedCount, passingOpt.mountBatchSize);\n    }\n    var mountedCount = this.checkUnmountedViews(viewportFn, passingOpt);\n    return {\n      mounted: mountedCount,\n      unmounted: unmountedCount\n    };\n  },\n  freeze: function (opt) {\n    opt || (opt = {});\n    var updates = this._updates;\n    var key = opt.key;\n    var isFrozen = this.options.frozen;\n    var freezeKey = updates.freezeKey;\n    if (key && key !== freezeKey) {\n      // key passed, but the paper is already freezed with another key\n      if (isFrozen && freezeKey) return;\n      updates.freezeKey = key;\n      updates.keyFrozen = isFrozen;\n    }\n    this.options.frozen = true;\n    var id = updates.id;\n    updates.id = null;\n    if (this.isAsync() && id) cancelFrame(id);\n  },\n  unfreeze: function (opt) {\n    opt || (opt = {});\n    var updates = this._updates;\n    var key = opt.key;\n    var freezeKey = updates.freezeKey;\n    // key passed, but the paper is already freezed with another key\n    if (key && freezeKey && key !== freezeKey) return;\n    updates.freezeKey = null;\n    // key passed, but the paper is already freezed\n    if (key && key === freezeKey && updates.keyFrozen) return;\n    if (this.isAsync()) {\n      this.freeze();\n      this.updateViewsAsync(opt);\n    } else {\n      this.updateViews(opt);\n    }\n    this.options.frozen = updates.keyFrozen = false;\n    if (updates.sort) {\n      this.sortViews();\n      updates.sort = false;\n    }\n  },\n  isAsync: function () {\n    return !!this.options.async;\n  },\n  isFrozen: function () {\n    return !!this.options.frozen;\n  },\n  isExactSorting: function () {\n    return this.options.sorting === sortingTypes.EXACT;\n  },\n  onRemove: function () {\n    this.freeze();\n    this._updates.disabled = true;\n    //clean up all DOM elements/views to prevent memory leaks\n    this.removeLayers();\n    this.removeViews();\n  },\n  getComputedSize: function () {\n    var options = this.options;\n    var w = options.width;\n    var h = options.height;\n    if (!isNumber(w)) w = this.el.clientWidth;\n    if (!isNumber(h)) h = this.el.clientHeight;\n    return {\n      width: w,\n      height: h\n    };\n  },\n  setDimensions: function (width, height, data = {}) {\n    const {\n      options\n    } = this;\n    const {\n      width: currentWidth,\n      height: currentHeight\n    } = options;\n    let w = width === undefined ? currentWidth : width;\n    let h = height === undefined ? currentHeight : height;\n    if (currentWidth === w && currentHeight === h) return;\n    options.width = w;\n    options.height = h;\n    this._setDimensions();\n    const computedSize = this.getComputedSize();\n    this.trigger('resize', computedSize.width, computedSize.height, data);\n  },\n  _setDimensions: function () {\n    const {\n      options\n    } = this;\n    let w = options.width;\n    let h = options.height;\n    if (isNumber(w)) w = `${Math.round(w)}px`;\n    if (isNumber(h)) h = `${Math.round(h)}px`;\n    this.$el.css({\n      width: w === null ? '' : w,\n      height: h === null ? '' : h\n    });\n  },\n  // Expand/shrink the paper to fit the content.\n  // Alternatively signature function(opt)\n  fitToContent: function (gridWidth, gridHeight, padding, opt) {\n    if (isObject(gridWidth)) {\n      // first parameter is an option object\n      opt = gridWidth;\n    } else {\n      // Support for a deprecated signature\n      opt = assign({\n        gridWidth,\n        gridHeight,\n        padding\n      }, opt);\n    }\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.getFitToContentArea(opt);\n    const {\n      sx,\n      sy\n    } = this.scale();\n    this.translate(-x * sx, -y * sy, opt);\n    this.setDimensions(width * sx, height * sy, opt);\n    return new Rect(x, y, width, height);\n  },\n  getFitToContentArea: function (opt = {}) {\n    // Calculate the paper size to accommodate all the graph's elements.\n\n    const gridWidth = opt.gridWidth || 1;\n    const gridHeight = opt.gridHeight || 1;\n    const padding = normalizeSides(opt.padding || 0);\n    const minWidth = Math.max(opt.minWidth || 0, gridWidth);\n    const minHeight = Math.max(opt.minHeight || 0, gridHeight);\n    const maxWidth = opt.maxWidth || Number.MAX_VALUE;\n    const maxHeight = opt.maxHeight || Number.MAX_VALUE;\n    const newOrigin = opt.allowNewOrigin;\n    const area = 'contentArea' in opt ? new Rect(opt.contentArea) : this.getContentArea(opt);\n    const {\n      sx,\n      sy\n    } = this.scale();\n    area.x *= sx;\n    area.y *= sy;\n    area.width *= sx;\n    area.height *= sy;\n    let calcWidth = Math.ceil((area.width + area.x) / gridWidth);\n    let calcHeight = Math.ceil((area.height + area.y) / gridHeight);\n    if (!opt.allowNegativeBottomRight) {\n      calcWidth = Math.max(calcWidth, 1);\n      calcHeight = Math.max(calcHeight, 1);\n    }\n    calcWidth *= gridWidth;\n    calcHeight *= gridHeight;\n    let tx = 0;\n    if (newOrigin === 'negative' && area.x < 0 || newOrigin === 'positive' && area.x >= 0 || newOrigin === 'any') {\n      tx = Math.ceil(-area.x / gridWidth) * gridWidth;\n      tx += padding.left;\n      calcWidth += tx;\n    }\n    let ty = 0;\n    if (newOrigin === 'negative' && area.y < 0 || newOrigin === 'positive' && area.y >= 0 || newOrigin === 'any') {\n      ty = Math.ceil(-area.y / gridHeight) * gridHeight;\n      ty += padding.top;\n      calcHeight += ty;\n    }\n    calcWidth += padding.right;\n    calcHeight += padding.bottom;\n\n    // Make sure the resulting width and height are greater than minimum.\n    calcWidth = Math.max(calcWidth, minWidth);\n    calcHeight = Math.max(calcHeight, minHeight);\n\n    // Make sure the resulting width and height are lesser than maximum.\n    calcWidth = Math.min(calcWidth, maxWidth);\n    calcHeight = Math.min(calcHeight, maxHeight);\n    return new Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);\n  },\n  transformToFitContent: function (opt) {\n    opt || (opt = {});\n    let contentBBox, contentLocalOrigin;\n    if ('contentArea' in opt) {\n      const contentArea = opt.contentArea;\n      contentBBox = this.localToPaperRect(contentArea);\n      contentLocalOrigin = new Point(contentArea);\n    } else {\n      contentBBox = this.getContentBBox(opt);\n      contentLocalOrigin = this.paperToLocalPoint(contentBBox);\n    }\n    if (!contentBBox.width || !contentBBox.height) return;\n    defaults(opt, {\n      padding: 0,\n      preserveAspectRatio: true,\n      scaleGrid: null,\n      minScale: 0,\n      maxScale: Number.MAX_VALUE,\n      verticalAlign: 'top',\n      horizontalAlign: 'left'\n      //minScaleX\n      //minScaleY\n      //maxScaleX\n      //maxScaleY\n      //fittingBBox\n    });\n    const padding = normalizeSides(opt.padding);\n    const minScaleX = opt.minScaleX || opt.minScale;\n    const maxScaleX = opt.maxScaleX || opt.maxScale;\n    const minScaleY = opt.minScaleY || opt.minScale;\n    const maxScaleY = opt.maxScaleY || opt.maxScale;\n    let fittingBBox;\n    if (opt.fittingBBox) {\n      fittingBBox = opt.fittingBBox;\n    } else {\n      const currentTranslate = this.translate();\n      const computedSize = this.getComputedSize();\n      fittingBBox = {\n        x: currentTranslate.tx,\n        y: currentTranslate.ty,\n        width: computedSize.width,\n        height: computedSize.height\n      };\n    }\n    fittingBBox = new Rect(fittingBBox).moveAndExpand({\n      x: padding.left,\n      y: padding.top,\n      width: -padding.left - padding.right,\n      height: -padding.top - padding.bottom\n    });\n    const ctm = this.matrix();\n    const {\n      a: sx,\n      d: sy,\n      e: tx,\n      f: ty\n    } = ctm;\n    let newSx = fittingBBox.width / contentBBox.width * sx;\n    let newSy = fittingBBox.height / contentBBox.height * sy;\n    if (opt.preserveAspectRatio) {\n      newSx = newSy = Math.min(newSx, newSy);\n    }\n\n    // snap scale to a grid\n    if (opt.scaleGrid) {\n      const gridSize = opt.scaleGrid;\n      newSx = gridSize * Math.floor(newSx / gridSize);\n      newSy = gridSize * Math.floor(newSy / gridSize);\n    }\n\n    // scale min/max boundaries\n    newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));\n    newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));\n    const scaleDiff = {\n      x: newSx / sx,\n      y: newSy / sy\n    };\n    let newOx = fittingBBox.x - contentLocalOrigin.x * newSx - tx;\n    let newOy = fittingBBox.y - contentLocalOrigin.y * newSy - ty;\n    switch (opt.verticalAlign) {\n      case 'middle':\n        newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;\n        break;\n      case 'bottom':\n        newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);\n        break;\n      case 'top':\n      default:\n        break;\n    }\n    switch (opt.horizontalAlign) {\n      case 'middle':\n        newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;\n        break;\n      case 'right':\n        newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);\n        break;\n      case 'left':\n      default:\n        break;\n    }\n    ctm.a = newSx;\n    ctm.d = newSy;\n    ctm.e = newOx;\n    ctm.f = newOy;\n    this.matrix(ctm, opt);\n  },\n  scaleContentToFit: function (opt) {\n    this.transformToFitContent(opt);\n  },\n  // Return the dimensions of the content area in local units (without transformations).\n  getContentArea: function (opt) {\n    if (opt && opt.useModelGeometry) {\n      return this.model.getBBox() || new Rect();\n    }\n    return V(this.cells).getBBox();\n  },\n  // Return the dimensions of the content bbox in the paper units (as it appears on screen).\n  getContentBBox: function (opt) {\n    return this.localToPaperRect(this.getContentArea(opt));\n  },\n  // Returns a geometry rectangle representing the entire\n  // paper area (coordinates from the left paper border to the right one\n  // and the top border to the bottom one).\n  getArea: function () {\n    return this.paperToLocalRect(this.getComputedSize());\n  },\n  getRestrictedArea: function (...args) {\n    const {\n      restrictTranslate\n    } = this.options;\n    let restrictedArea;\n    if (isFunction(restrictTranslate)) {\n      // A method returning a bounding box\n      restrictedArea = restrictTranslate.apply(this, args);\n    } else if (restrictTranslate === true) {\n      // The paper area\n      restrictedArea = this.getArea();\n    } else if (!restrictTranslate) {\n      // falsy value\n      restrictedArea = null;\n    } else {\n      // any other value\n      restrictedArea = new Rect(restrictTranslate);\n    }\n    return restrictedArea;\n  },\n  createViewForModel: function (cell) {\n    const {\n      options\n    } = this;\n    // A class taken from the paper options.\n    var optionalViewClass;\n\n    // A default basic class (either dia.ElementView or dia.LinkView)\n    var defaultViewClass;\n\n    // A special class defined for this model in the corresponding namespace.\n    // e.g. joint.shapes.standard.Rectangle searches for joint.shapes.standard.RectangleView\n    var namespace = options.cellViewNamespace;\n    var type = cell.get('type') + 'View';\n    var namespaceViewClass = getByPath(namespace, type, '.');\n    if (cell.isLink()) {\n      optionalViewClass = options.linkView;\n      defaultViewClass = LinkView;\n    } else {\n      optionalViewClass = options.elementView;\n      defaultViewClass = ElementView;\n    }\n\n    // a) the paper options view is a class (deprecated)\n    //  1. search the namespace for a view\n    //  2. if no view was found, use view from the paper options\n    // b) the paper options view is a function\n    //  1. call the function from the paper options\n    //  2. if no view was return, search the namespace for a view\n    //  3. if no view was found, use the default\n    var ViewClass = optionalViewClass.prototype instanceof ViewBase ? namespaceViewClass || optionalViewClass : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;\n    return new ViewClass({\n      model: cell,\n      interactive: options.interactive,\n      labelsLayer: options.labelsLayer === true ? LayersNames.LABELS : options.labelsLayer\n    });\n  },\n  removeView: function (cell) {\n    const {\n      id\n    } = cell;\n    const {\n      _views,\n      _updates\n    } = this;\n    const view = _views[id];\n    if (view) {\n      var {\n        cid\n      } = view;\n      const {\n        mounted,\n        unmounted\n      } = _updates;\n      view.remove();\n      delete _views[id];\n      delete mounted[cid];\n      delete unmounted[cid];\n    }\n    return view;\n  },\n  renderView: function (cell, opt) {\n    const {\n      id\n    } = cell;\n    const views = this._views;\n    let view, flag;\n    let create = true;\n    if (id in views) {\n      view = views[id];\n      if (view.model === cell) {\n        flag = view.FLAG_INSERT;\n        create = false;\n      } else {\n        // The view for this `id` already exist.\n        // The cell is a new instance of the model with identical id\n        // We simply remove the existing view and create a new one\n        this.removeView(cell);\n      }\n    }\n    if (create) {\n      view = views[id] = this.createViewForModel(cell);\n      view.paper = this;\n      flag = this.registerUnmountedView(view) | this.FLAG_INIT | view.getFlag(result(view, 'initFlag'));\n    }\n    this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);\n    return view;\n  },\n  onImageDragStart: function () {\n    // This is the only way to prevent image dragging in Firefox that works.\n    // Setting -moz-user-select: none, draggable=\"false\" attribute or user-drag: none didn't help.\n\n    return false;\n  },\n  resetViews: function (cells, opt) {\n    opt || (opt = {});\n    cells || (cells = []);\n    this._resetUpdates();\n    // clearing views removes any event listeners\n    this.removeViews();\n    // Allows to unfreeze normally while in the idle state using autoFreeze option\n    const key = this.options.autoFreeze ? null : 'reset';\n    this.freeze({\n      key\n    });\n    for (var i = 0, n = cells.length; i < n; i++) {\n      this.renderView(cells[i], opt);\n    }\n    this.unfreeze({\n      key\n    });\n    this.sortViews();\n  },\n  removeViews: function () {\n    invoke(this._views, 'remove');\n    this._views = {};\n  },\n  sortViews: function () {\n    if (!this.isExactSorting()) {\n      // noop\n      return;\n    }\n    if (this.isFrozen()) {\n      // sort views once unfrozen\n      this._updates.sort = true;\n      return;\n    }\n    this.sortViewsExact();\n  },\n  sortViewsExact: function () {\n    // Run insertion sort algorithm in order to efficiently sort DOM elements according to their\n    // associated model `z` attribute.\n\n    var cellNodes = Array.from(this.cells.childNodes).filter(node => node.getAttribute('model-id'));\n    var cells = this.model.get('cells');\n    sortElements(cellNodes, function (a, b) {\n      var cellA = cells.get(a.getAttribute('model-id'));\n      var cellB = cells.get(b.getAttribute('model-id'));\n      var zA = cellA.attributes.z || 0;\n      var zB = cellB.attributes.z || 0;\n      return zA === zB ? 0 : zA < zB ? -1 : 1;\n    });\n  },\n  insertView: function (view, isInitialInsert) {\n    const layerView = this.getLayerView(LayersNames.CELLS);\n    const {\n      el,\n      model\n    } = view;\n    switch (this.options.sorting) {\n      case sortingTypes.APPROX:\n        layerView.insertSortedNode(el, model.get('z'));\n        break;\n      case sortingTypes.EXACT:\n      default:\n        layerView.insertNode(el);\n        break;\n    }\n    view.onMount(isInitialInsert);\n  },\n  detachView(view) {\n    view.unmount();\n    view.onDetach();\n  },\n  // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also\n  // be a selector or a jQuery object.\n  findView: function ($el) {\n    var el = isString($el) ? this.cells.querySelector($el) : $el instanceof $ ? $el[0] : $el;\n    var id = this.findAttribute('model-id', el);\n    if (id) return this._views[id];\n    return undefined;\n  },\n  // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.\n  findViewByModel: function (cell) {\n    var id = isString(cell) || isNumber(cell) ? cell : cell && cell.id;\n    return this._views[id];\n  },\n  // Find all views at given point\n  findViewsFromPoint: function (p) {\n    p = new Point(p);\n    var views = this.model.getElements().map(this.findViewByModel, this);\n    return views.filter(function (view) {\n      return view && view.vel.getBBox({\n        target: this.cells\n      }).containsPoint(p);\n    }, this);\n  },\n  // Find all views in given area\n  findViewsInArea: function (rect, opt) {\n    opt = defaults(opt || {}, {\n      strict: false\n    });\n    rect = new Rect(rect);\n    var views = this.model.getElements().map(this.findViewByModel, this);\n    var method = opt.strict ? 'containsRect' : 'intersect';\n    return views.filter(function (view) {\n      return view && rect[method](view.vel.getBBox({\n        target: this.cells\n      }));\n    }, this);\n  },\n  removeTools: function () {\n    this.dispatchToolsEvent('remove');\n    return this;\n  },\n  hideTools: function () {\n    this.dispatchToolsEvent('hide');\n    return this;\n  },\n  showTools: function () {\n    this.dispatchToolsEvent('show');\n    return this;\n  },\n  dispatchToolsEvent: function (event, ...args) {\n    if (typeof event !== 'string') return;\n    this.trigger('tools:event', event, ...args);\n  },\n  getModelById: function (id) {\n    return this.model.getCell(id);\n  },\n  snapToGrid: function (x, y) {\n    // Convert global coordinates to the local ones of the `viewport`. Otherwise,\n    // improper transformation would be applied when the viewport gets transformed (scaled/rotated).\n    return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);\n  },\n  localToPaperPoint: function (x, y) {\n    // allow `x` to be a point and `y` undefined\n    var localPoint = new Point(x, y);\n    var paperPoint = V.transformPoint(localPoint, this.matrix());\n    return paperPoint;\n  },\n  localToPaperRect: function (x, y, width, height) {\n    // allow `x` to be a rectangle and rest arguments undefined\n    var localRect = new Rect(x, y, width, height);\n    var paperRect = V.transformRect(localRect, this.matrix());\n    return paperRect;\n  },\n  paperToLocalPoint: function (x, y) {\n    // allow `x` to be a point and `y` undefined\n    var paperPoint = new Point(x, y);\n    var localPoint = V.transformPoint(paperPoint, this.matrix().inverse());\n    return localPoint;\n  },\n  paperToLocalRect: function (x, y, width, height) {\n    // allow `x` to be a rectangle and rest arguments undefined\n    var paperRect = new Rect(x, y, width, height);\n    var localRect = V.transformRect(paperRect, this.matrix().inverse());\n    return localRect;\n  },\n  localToClientPoint: function (x, y) {\n    // allow `x` to be a point and `y` undefined\n    var localPoint = new Point(x, y);\n    var clientPoint = V.transformPoint(localPoint, this.clientMatrix());\n    return clientPoint;\n  },\n  localToClientRect: function (x, y, width, height) {\n    // allow `x` to be a point and `y` undefined\n    var localRect = new Rect(x, y, width, height);\n    var clientRect = V.transformRect(localRect, this.clientMatrix());\n    return clientRect;\n  },\n  // Transform client coordinates to the paper local coordinates.\n  // Useful when you have a mouse event object and you'd like to get coordinates\n  // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.\n  // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\n  clientToLocalPoint: function (x, y) {\n    // allow `x` to be a point and `y` undefined\n    var clientPoint = new Point(x, y);\n    var localPoint = V.transformPoint(clientPoint, this.clientMatrix().inverse());\n    return localPoint;\n  },\n  clientToLocalRect: function (x, y, width, height) {\n    // allow `x` to be a point and `y` undefined\n    var clientRect = new Rect(x, y, width, height);\n    var localRect = V.transformRect(clientRect, this.clientMatrix().inverse());\n    return localRect;\n  },\n  localToPagePoint: function (x, y) {\n    return this.localToPaperPoint(x, y).offset(this.pageOffset());\n  },\n  localToPageRect: function (x, y, width, height) {\n    return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());\n  },\n  pageToLocalPoint: function (x, y) {\n    var pagePoint = new Point(x, y);\n    var paperPoint = pagePoint.difference(this.pageOffset());\n    return this.paperToLocalPoint(paperPoint);\n  },\n  pageToLocalRect: function (x, y, width, height) {\n    var pageOffset = this.pageOffset();\n    var paperRect = new Rect(x, y, width, height);\n    paperRect.x -= pageOffset.x;\n    paperRect.y -= pageOffset.y;\n    return this.paperToLocalRect(paperRect);\n  },\n  clientOffset: function () {\n    var clientRect = this.svg.getBoundingClientRect();\n    return new Point(clientRect.left, clientRect.top);\n  },\n  pageOffset: function () {\n    return this.clientOffset().offset(window.scrollX, window.scrollY);\n  },\n  linkAllowed: function (linkView) {\n    if (!(linkView instanceof LinkView)) {\n      throw new Error('Must provide a linkView.');\n    }\n    var link = linkView.model;\n    var paperOptions = this.options;\n    var graph = this.model;\n    var ns = graph.constructor.validations;\n    if (!paperOptions.multiLinks) {\n      if (!ns.multiLinks.call(this, graph, link)) return false;\n    }\n    if (!paperOptions.linkPinning) {\n      // Link pinning is not allowed and the link is not connected to the target.\n      if (!ns.linkPinning.call(this, graph, link)) return false;\n    }\n    if (typeof paperOptions.allowLink === 'function') {\n      if (!paperOptions.allowLink.call(this, linkView, this)) return false;\n    }\n    return true;\n  },\n  getDefaultLink: function (cellView, magnet) {\n    return isFunction(this.options.defaultLink)\n    // default link is a function producing link model\n    ? this.options.defaultLink.call(this, cellView, magnet)\n    // default link is the mvc model\n    : this.options.defaultLink.clone();\n  },\n  // Cell highlighting.\n  // ------------------\n\n  resolveHighlighter: function (opt = {}) {\n    let {\n      highlighter: highlighterDef,\n      type\n    } = opt;\n    const {\n      highlighting,\n      highlighterNamespace\n    } = this.options;\n\n    /*\n        Expecting opt.highlighter to have the following structure:\n        {\n            name: 'highlighter-name',\n            options: {\n                some: 'value'\n            }\n        }\n    */\n    if (highlighterDef === undefined) {\n      // Is highlighting disabled?\n      if (!highlighting) return false;\n      // check for built-in types\n      if (type) {\n        highlighterDef = highlighting[type];\n        // Is a specific type highlight disabled?\n        if (highlighterDef === false) return false;\n      }\n      if (!highlighterDef) {\n        // Type not defined use default highlight\n        highlighterDef = highlighting['default'];\n      }\n    }\n\n    // Do nothing if opt.highlighter is falsy.\n    // This allows the case to not highlight cell(s) in certain cases.\n    // For example, if you want to NOT highlight when embedding elements\n    // or use a custom highlighter.\n    if (!highlighterDef) return false;\n\n    // Allow specifying a highlighter by name.\n    if (isString(highlighterDef)) {\n      highlighterDef = {\n        name: highlighterDef\n      };\n    }\n    const name = highlighterDef.name;\n    const highlighter = highlighterNamespace[name];\n\n    // Highlighter validation\n    if (!highlighter) {\n      throw new Error('Unknown highlighter (\"' + name + '\")');\n    }\n    if (typeof highlighter.highlight !== 'function') {\n      throw new Error('Highlighter (\"' + name + '\") is missing required highlight() method');\n    }\n    if (typeof highlighter.unhighlight !== 'function') {\n      throw new Error('Highlighter (\"' + name + '\") is missing required unhighlight() method');\n    }\n    return {\n      highlighter,\n      options: highlighterDef.options || {},\n      name\n    };\n  },\n  onCellHighlight: function (cellView, magnetEl, opt) {\n    const highlighterDescriptor = this.resolveHighlighter(opt);\n    if (!highlighterDescriptor) return;\n    const {\n      highlighter,\n      options\n    } = highlighterDescriptor;\n    highlighter.highlight(cellView, magnetEl, options);\n  },\n  onCellUnhighlight: function (cellView, magnetEl, opt) {\n    const highlighterDescriptor = this.resolveHighlighter(opt);\n    if (!highlighterDescriptor) return;\n    const {\n      highlighter,\n      options\n    } = highlighterDescriptor;\n    highlighter.unhighlight(cellView, magnetEl, options);\n  },\n  // Interaction.\n  // ------------\n\n  pointerdblclick: function (evt) {\n    evt.preventDefault();\n\n    // magnetpointerdblclick can stop propagation\n\n    evt = normalizeEvent(evt);\n    var view = this.findView(evt.target);\n    if (this.guard(evt, view)) return;\n    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n    if (view) {\n      view.pointerdblclick(evt, localPoint.x, localPoint.y);\n    } else {\n      this.trigger('blank:pointerdblclick', evt, localPoint.x, localPoint.y);\n    }\n  },\n  pointerclick: function (evt) {\n    // magnetpointerclick can stop propagation\n\n    var data = this.eventData(evt);\n    // Trigger event only if mouse has not moved.\n    if (data.mousemoved <= this.options.clickThreshold) {\n      evt = normalizeEvent(evt);\n      var view = this.findView(evt.target);\n      if (this.guard(evt, view)) return;\n      var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n      if (view) {\n        view.pointerclick(evt, localPoint.x, localPoint.y);\n      } else {\n        this.trigger('blank:pointerclick', evt, localPoint.x, localPoint.y);\n      }\n    }\n  },\n  contextmenu: function (evt) {\n    if (this.options.preventContextMenu) evt.preventDefault();\n    if (this.contextMenuFired) {\n      this.contextMenuFired = false;\n      return;\n    }\n    evt = normalizeEvent(evt);\n    this.contextMenuTrigger(evt);\n  },\n  contextMenuTrigger: function (evt) {\n    var view = this.findView(evt.target);\n    if (this.guard(evt, view)) return;\n    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n    if (view) {\n      view.contextmenu(evt, localPoint.x, localPoint.y);\n    } else {\n      this.trigger('blank:contextmenu', evt, localPoint.x, localPoint.y);\n    }\n  },\n  pointerdown: function (evt) {\n    evt = normalizeEvent(evt);\n    const {\n      target,\n      button\n    } = evt;\n    const view = this.findView(target);\n    const isContextMenu = button === 2;\n    if (view) {\n      if (!isContextMenu && this.guard(evt, view)) return;\n      const isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);\n      if (this.options.preventDefaultViewAction && !isTargetFormNode) {\n        // If the target is a form element, we do not want to prevent the default action.\n        // For example, we want to be able to select text in a text input or\n        // to be able to click on a checkbox.\n        evt.preventDefault();\n      }\n      if (isTargetFormNode) {\n        // If the target is a form element, we do not want to start dragging the element.\n        // For example, we want to be able to select text by dragging the mouse.\n        view.preventDefaultInteraction(evt);\n      }\n\n      // Custom event\n      const eventEvt = this.customEventTrigger(evt, view);\n      if (eventEvt) {\n        // `onevent` could have stopped propagation\n        if (eventEvt.isPropagationStopped()) return;\n        evt.data = eventEvt.data;\n      }\n\n      // Element magnet\n      const magnetNode = target.closest('[magnet]');\n      if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {\n        const magnetEvt = normalizeEvent(new $.Event(evt.originalEvent, {\n          data: evt.data,\n          // Originally the event listener was attached to the magnet element.\n          currentTarget: magnetNode\n        }));\n        this.onmagnet(magnetEvt);\n        if (magnetEvt.isDefaultPrevented()) {\n          evt.preventDefault();\n        }\n        // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed\n        if (magnetEvt.isPropagationStopped()) {\n          // `magnet:pointermove` and `magnet:pointerup` events must be fired\n          if (isContextMenu) return;\n          this.delegateDragEvents(view, magnetEvt.data);\n          return;\n        }\n        evt.data = magnetEvt.data;\n      }\n    }\n    if (isContextMenu) {\n      this.contextMenuFired = true;\n      const contextmenuEvt = new $.Event(evt.originalEvent, {\n        type: 'contextmenu',\n        data: evt.data\n      });\n      this.contextMenuTrigger(contextmenuEvt);\n    } else {\n      const localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n      if (view) {\n        view.pointerdown(evt, localPoint.x, localPoint.y);\n      } else {\n        if (this.options.preventDefaultBlankAction) {\n          evt.preventDefault();\n        }\n        this.trigger('blank:pointerdown', evt, localPoint.x, localPoint.y);\n      }\n      this.delegateDragEvents(view, evt.data);\n    }\n  },\n  pointermove: function (evt) {\n    // mouse moved counter\n    var data = this.eventData(evt);\n    if (!data.mousemoved) {\n      data.mousemoved = 0;\n      // Make sure that events like `mouseenter` and `mouseleave` are\n      // not triggered while the user is dragging a cellView.\n      this.undelegateEvents();\n      // Note: the events are undelegated after the first `pointermove` event.\n      // Not on `pointerdown` to make sure that `dbltap` is recognized.\n    }\n    var mousemoved = ++data.mousemoved;\n    if (mousemoved <= this.options.moveThreshold) return;\n    evt = normalizeEvent(evt);\n    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n    var view = data.sourceView;\n    if (view) {\n      view.pointermove(evt, localPoint.x, localPoint.y);\n    } else {\n      this.trigger('blank:pointermove', evt, localPoint.x, localPoint.y);\n    }\n    this.eventData(evt, data);\n  },\n  pointerup: function (evt) {\n    this.undelegateDocumentEvents();\n    var normalizedEvt = normalizeEvent(evt);\n    var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n    var view = this.eventData(evt).sourceView;\n    if (view) {\n      view.pointerup(normalizedEvt, localPoint.x, localPoint.y);\n    } else {\n      this.trigger('blank:pointerup', normalizedEvt, localPoint.x, localPoint.y);\n    }\n    if (!normalizedEvt.isPropagationStopped()) {\n      this.pointerclick(new $.Event(evt.originalEvent, {\n        type: 'click',\n        data: evt.data\n      }));\n    }\n    this.delegateEvents();\n  },\n  mouseover: function (evt) {\n    evt = normalizeEvent(evt);\n    var view = this.findView(evt.target);\n    if (this.guard(evt, view)) return;\n    if (view) {\n      view.mouseover(evt);\n    } else {\n      if (this.el === evt.target) return; // prevent border of paper from triggering this\n      this.trigger('blank:mouseover', evt);\n    }\n  },\n  mouseout: function (evt) {\n    evt = normalizeEvent(evt);\n    var view = this.findView(evt.target);\n    if (this.guard(evt, view)) return;\n    if (view) {\n      view.mouseout(evt);\n    } else {\n      if (this.el === evt.target) return; // prevent border of paper from triggering this\n      this.trigger('blank:mouseout', evt);\n    }\n  },\n  mouseenter: function (evt) {\n    evt = normalizeEvent(evt);\n    const {\n      target,\n      // The EventTarget the pointing device entered to\n      relatedTarget,\n      // The EventTarget the pointing device exited from\n      currentTarget // The EventTarget on which the event listener was registered\n    } = evt;\n    const view = this.findView(target);\n    if (this.guard(evt, view)) return;\n    const relatedView = this.findView(relatedTarget);\n    if (view) {\n      if (relatedView === view) {\n        // Mouse left a cell tool\n        return;\n      }\n      view.mouseenter(evt);\n      if (this.el.contains(relatedTarget)) {\n        // The pointer remains inside the paper.\n        return;\n      }\n    }\n    if (relatedView) {\n      return;\n    }\n    // prevent double `mouseenter` event if the `relatedTarget` is outside the paper\n    // (mouseenter method would be fired twice)\n    if (currentTarget === this.el) {\n      // `paper` (more descriptive), not `blank`\n      this.trigger('paper:mouseenter', evt);\n    }\n  },\n  mouseleave: function (evt) {\n    evt = normalizeEvent(evt);\n    const {\n      target,\n      // The EventTarget the pointing device exited from\n      relatedTarget,\n      // The EventTarget the pointing device entered to\n      currentTarget // The EventTarget on which the event listener was registered\n    } = evt;\n    const view = this.findView(target);\n    if (this.guard(evt, view)) return;\n    const relatedView = this.findView(relatedTarget);\n    if (view) {\n      if (relatedView === view) {\n        // Mouse entered a cell tool\n        return;\n      }\n      view.mouseleave(evt);\n      if (this.el.contains(relatedTarget)) {\n        // The pointer has exited a cellView. The pointer is still inside of the paper.\n        return;\n      }\n    }\n    if (relatedView) {\n      // The pointer has entered a new cellView\n      return;\n    }\n    // prevent double `mouseleave` event if the `relatedTarget` is outside the paper\n    // (mouseleave method would be fired twice)\n    if (currentTarget === this.el) {\n      // There is no cellView under the pointer, nor the blank area of the paper\n      this.trigger('paper:mouseleave', evt);\n    }\n  },\n  _processMouseWheelEvtBuf: debounce(function () {\n    const {\n      event,\n      deltas\n    } = this._mw_evt_buffer;\n    const deltaY = deltas.reduce((acc, deltaY) => acc + cap(deltaY, WHEEL_CAP), 0);\n    const scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom\n    const {\n      x,\n      y\n    } = this.clientToLocalPoint(event.clientX, event.clientY);\n    this.trigger('paper:pinch', event, x, y, scale);\n    this._mw_evt_buffer = {\n      event: null,\n      deltas: []\n    };\n  }, WHEEL_WAIT_MS, {\n    maxWait: WHEEL_WAIT_MS\n  }),\n  mousewheel: function (evt) {\n    evt = normalizeEvent(evt);\n    const view = this.findView(evt.target);\n    if (this.guard(evt, view)) return;\n    const originalEvent = evt.originalEvent;\n    const localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);\n    const {\n      deltaX,\n      deltaY\n    } = normalizeWheel(originalEvent);\n    const pinchHandlers = this._events['paper:pinch'];\n\n    // Touchpad devices will send a fake CTRL press when a pinch is performed\n    //\n    // We also check if there are any subscribers to paper:pinch event. If there are none,\n    // just skip the entire block of code (we don't want to blindly call\n    // .preventDefault() if we really don't have to).\n    if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {\n      // This is a pinch gesture, it's safe to assume that we must call .preventDefault()\n      originalEvent.preventDefault();\n      this._mw_evt_buffer.event = evt;\n      this._mw_evt_buffer.deltas.push(deltaY);\n      this._processMouseWheelEvtBuf();\n    } else {\n      const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));\n      if (view) {\n        view.mousewheel(evt, localPoint.x, localPoint.y, delta);\n      } else {\n        this.trigger('blank:mousewheel', evt, localPoint.x, localPoint.y, delta);\n      }\n      this.trigger('paper:pan', evt, deltaX, deltaY);\n    }\n  },\n  onevent: function (evt) {\n    var eventNode = evt.currentTarget;\n    var eventName = eventNode.getAttribute('event');\n    if (eventName) {\n      var view = this.findView(eventNode);\n      if (view) {\n        evt = normalizeEvent(evt);\n        if (this.guard(evt, view)) return;\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n        view.onevent(evt, eventName, localPoint.x, localPoint.y);\n      }\n    }\n  },\n  magnetEvent: function (evt, handler) {\n    var magnetNode = evt.currentTarget;\n    var magnetValue = magnetNode.getAttribute('magnet');\n    if (magnetValue) {\n      var view = this.findView(magnetNode);\n      if (view) {\n        evt = normalizeEvent(evt);\n        if (this.guard(evt, view)) return;\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n        handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);\n      }\n    }\n  },\n  onmagnet: function (evt) {\n    if (evt.button === 2) {\n      this.contextMenuFired = true;\n      this.magnetContextMenuFired = true;\n      const contextmenuEvt = new $.Event(evt.originalEvent, {\n        type: 'contextmenu',\n        data: evt.data,\n        currentTarget: evt.currentTarget\n      });\n      this.magnetContextMenuTrigger(contextmenuEvt);\n      if (contextmenuEvt.isPropagationStopped()) {\n        evt.stopPropagation();\n      }\n    } else {\n      this.magnetEvent(evt, function (view, evt, _, x, y) {\n        view.onmagnet(evt, x, y);\n      });\n    }\n  },\n  magnetpointerdblclick: function (evt) {\n    this.magnetEvent(evt, function (view, evt, magnet, x, y) {\n      view.magnetpointerdblclick(evt, magnet, x, y);\n    });\n  },\n  magnetcontextmenu: function (evt) {\n    if (this.options.preventContextMenu) evt.preventDefault();\n    if (this.magnetContextMenuFired) {\n      this.magnetContextMenuFired = false;\n      return;\n    }\n    this.magnetContextMenuTrigger(evt);\n  },\n  magnetContextMenuTrigger: function (evt) {\n    this.magnetEvent(evt, function (view, evt, magnet, x, y) {\n      view.magnetcontextmenu(evt, magnet, x, y);\n    });\n  },\n  onlabel: function (evt) {\n    var labelNode = evt.currentTarget;\n    var view = this.findView(labelNode);\n    if (!view) return;\n    evt = normalizeEvent(evt);\n    if (this.guard(evt, view)) return;\n\n    // Custom event\n    const eventEvt = this.customEventTrigger(evt, view, labelNode);\n    if (eventEvt) {\n      // `onevent` could have stopped propagation\n      if (eventEvt.isPropagationStopped()) return;\n      evt.data = eventEvt.data;\n    }\n    var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n    view.onlabel(evt, localPoint.x, localPoint.y);\n  },\n  getPointerArgs(evt) {\n    const normalizedEvt = normalizeEvent(evt);\n    const {\n      x,\n      y\n    } = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n    return [normalizedEvt, x, y];\n  },\n  delegateDragEvents: function (view, data) {\n    data || (data = {});\n    this.eventData({\n      data: data\n    }, {\n      sourceView: view || null,\n      mousemoved: 0\n    });\n    this.delegateDocumentEvents(null, data);\n  },\n  // Guard the specified event. If the event should be ignored, guard returns `true`.\n  // Otherwise, it returns `false`.\n  guard: function (evt, view) {\n    if (evt.type === 'mousedown' && evt.button === 2) {\n      // handled as `contextmenu` type\n      return true;\n    }\n    if (this.options.guard && this.options.guard(evt, view)) {\n      return true;\n    }\n    if (evt.data && evt.data.guarded !== undefined) {\n      return evt.data.guarded;\n    }\n    const {\n      target\n    } = evt;\n    if (this.GUARDED_TAG_NAMES.includes(target.tagName)) {\n      return true;\n    }\n    if (view && view.model && view.model instanceof Cell) {\n      return false;\n    }\n    if (this.el === target || this.svg.contains(target)) {\n      return false;\n    }\n    return true; // Event guarded. Paper should not react on it in any way.\n  },\n  setGridSize: function (gridSize) {\n    const {\n      options\n    } = this;\n    options.gridSize = gridSize;\n    if (options.drawGrid && !options.drawGridSize) {\n      // Do not redraw the grid if the `drawGridSize` is set.\n      this.getLayerView(LayersNames.GRID).renderGrid();\n    }\n    return this;\n  },\n  setGrid: function (drawGrid) {\n    this.getLayerView(LayersNames.GRID).setGrid(drawGrid);\n    return this;\n  },\n  updateBackgroundImage: function (opt) {\n    opt = opt || {};\n    var backgroundPosition = opt.position || 'center';\n    var backgroundSize = opt.size || 'auto auto';\n    var currentScale = this.scale();\n    var currentTranslate = this.translate();\n\n    // backgroundPosition\n    if (isObject(backgroundPosition)) {\n      var x = currentTranslate.tx + currentScale.sx * (backgroundPosition.x || 0);\n      var y = currentTranslate.ty + currentScale.sy * (backgroundPosition.y || 0);\n      backgroundPosition = x + 'px ' + y + 'px';\n    }\n\n    // backgroundSize\n    if (isObject(backgroundSize)) {\n      backgroundSize = new Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);\n      backgroundSize = backgroundSize.width + 'px ' + backgroundSize.height + 'px';\n    }\n    const {\n      background\n    } = this.childNodes;\n    background.style.backgroundSize = backgroundSize;\n    background.style.backgroundPosition = backgroundPosition;\n  },\n  drawBackgroundImage: function (img, opt) {\n    // Clear the background image if no image provided\n    if (!(img instanceof HTMLImageElement)) {\n      this.childNodes.background.style.backgroundImage = '';\n      return;\n    }\n    if (!this._background || this._background.id !== opt.id) {\n      // Draw only the last image requested (see drawBackground())\n      return;\n    }\n    opt = opt || {};\n    var backgroundImage;\n    var backgroundSize = opt.size;\n    var backgroundRepeat = opt.repeat || 'no-repeat';\n    var backgroundOpacity = opt.opacity || 1;\n    var backgroundQuality = Math.abs(opt.quality) || 1;\n    var backgroundPattern = this.constructor.backgroundPatterns[camelCase(backgroundRepeat)];\n    if (isFunction(backgroundPattern)) {\n      // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom\n      img.width *= backgroundQuality;\n      img.height *= backgroundQuality;\n      var canvas = backgroundPattern(img, opt);\n      if (!(canvas instanceof HTMLCanvasElement)) {\n        throw new Error('dia.Paper: background pattern must return an HTML Canvas instance');\n      }\n      backgroundImage = canvas.toDataURL('image/png');\n      backgroundRepeat = 'repeat';\n      if (isObject(backgroundSize)) {\n        // recalculate the tile size if an object passed in\n        backgroundSize.width *= canvas.width / img.width;\n        backgroundSize.height *= canvas.height / img.height;\n      } else if (backgroundSize === undefined) {\n        // calculate the tile size if no provided\n        opt.size = {\n          width: canvas.width / backgroundQuality,\n          height: canvas.height / backgroundQuality\n        };\n      }\n    } else {\n      // backgroundRepeat:\n      // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'\n      backgroundImage = img.src;\n      if (backgroundSize === undefined) {\n        // pass the image size for  the backgroundSize if no size provided\n        opt.size = {\n          width: img.width,\n          height: img.height\n        };\n      }\n    }\n    this.childNodes.background.style.opacity = backgroundOpacity;\n    this.childNodes.background.style.backgroundRepeat = backgroundRepeat;\n    this.childNodes.background.style.backgroundImage = `url(${backgroundImage})`;\n    this.updateBackgroundImage(opt);\n  },\n  updateBackgroundColor: function (color) {\n    this.$el.css('backgroundColor', color || '');\n  },\n  drawBackground: function (opt) {\n    opt = opt || {};\n    this.updateBackgroundColor(opt.color);\n    if (opt.image) {\n      opt = this._background = cloneDeep(opt);\n      guid(opt);\n      var img = document.createElement('img');\n      img.onload = this.drawBackgroundImage.bind(this, img, opt);\n      img.src = opt.image;\n    } else {\n      this.drawBackgroundImage(null);\n      this._background = null;\n    }\n    return this;\n  },\n  setInteractivity: function (value) {\n    this.options.interactive = value;\n    invoke(this._views, 'setInteractivity', value);\n  },\n  // Paper definitions.\n  // ------------------\n\n  isDefined: function (defId) {\n    return !!this.svg.getElementById(defId);\n  },\n  defineFilter: function (filter) {\n    if (!isObject(filter)) {\n      throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');\n    }\n    var filterId = filter.id;\n    var name = filter.name;\n    // Generate a hash code from the stringified filter definition. This gives us\n    // a unique filter ID for different definitions.\n    if (!filterId) {\n      filterId = name + this.svg.id + hashCode(JSON.stringify(filter));\n    }\n    // If the filter already exists in the document,\n    // we're done and we can just use it (reference it using `url()`).\n    // If not, create one.\n    if (!this.isDefined(filterId)) {\n      var namespace = _filter;\n      var filterSVGString = namespace[name] && namespace[name](filter.args || {});\n      if (!filterSVGString) {\n        throw new Error('Non-existing filter ' + name);\n      }\n\n      // SVG <filter/> attributes\n      var filterAttrs = assign({\n        filterUnits: 'userSpaceOnUse'\n      }, filter.attrs, {\n        id: filterId\n      });\n      V(filterSVGString, filterAttrs).appendTo(this.defs);\n    }\n    return filterId;\n  },\n  defineGradient: function (gradient) {\n    if (!isObject(gradient)) {\n      throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');\n    }\n    const {\n      svg,\n      defs\n    } = this;\n    const {\n      type,\n      // Generate a hash code from the stringified filter definition. This gives us\n      // a unique filter ID for different definitions.\n      id = type + svg.id + hashCode(JSON.stringify(gradient)),\n      stops,\n      attrs = {}\n    } = gradient;\n    // If the gradient already exists in the document,\n    // we're done and we can just use it (reference it using `url()`).\n    if (this.isDefined(id)) return id;\n    // If not, create one.\n    const stopVEls = toArray(stops).map(({\n      offset,\n      color,\n      opacity\n    }) => {\n      return V('stop').attr({\n        'offset': offset,\n        'stop-color': color,\n        'stop-opacity': Number.isFinite(opacity) ? opacity : 1\n      });\n    });\n    const gradientVEl = V(type, attrs, stopVEls);\n    gradientVEl.id = id;\n    gradientVEl.appendTo(defs);\n    return id;\n  },\n  definePattern: function (pattern) {\n    if (!isObject(pattern)) {\n      throw new TypeError('dia.Paper: definePattern() requires 1. argument to be an object.');\n    }\n    const {\n      svg,\n      defs\n    } = this;\n    const {\n      // Generate a hash code from the stringified filter definition. This gives us\n      // a unique filter ID for different definitions.\n      id = svg.id + hashCode(JSON.stringify(pattern)),\n      markup,\n      attrs = {}\n    } = pattern;\n    if (!markup) {\n      throw new TypeError('dia.Paper: definePattern() requires markup.');\n    }\n    // If the gradient already exists in the document,\n    // we're done and we can just use it (reference it using `url()`).\n    if (this.isDefined(id)) return id;\n    // If not, create one.\n    const patternVEl = V('pattern', {\n      patternUnits: 'userSpaceOnUse'\n    });\n    patternVEl.id = id;\n    patternVEl.attr(attrs);\n    if (typeof markup === 'string') {\n      patternVEl.append(V(markup));\n    } else {\n      const {\n        fragment\n      } = parseDOMJSON(markup);\n      patternVEl.append(fragment);\n    }\n    patternVEl.appendTo(defs);\n    return id;\n  },\n  defineMarker: function (marker) {\n    if (!isObject(marker)) {\n      throw new TypeError('dia.Paper: defineMarker() requires the first argument to be an object.');\n    }\n    const {\n      svg,\n      defs\n    } = this;\n    const {\n      // Generate a hash code from the stringified filter definition. This gives us\n      // a unique filter ID for different definitions.\n      id = svg.id + hashCode(JSON.stringify(marker)),\n      // user-provided markup\n      // (e.g. defined when creating link via `attrs/line/sourceMarker/markup`)\n      markup,\n      // user-provided attributes\n      // (e.g. defined when creating link via `attrs/line/sourceMarker/attrs`)\n      // note: `transform` attrs are ignored by browsers\n      attrs = {},\n      // deprecated - use `attrs/markerUnits` instead (which has higher priority)\n      markerUnits = 'userSpaceOnUse'\n    } = marker;\n    // If the marker already exists in the document,\n    // we're done and we can just use it (reference it using `url()`).\n    if (this.isDefined(id)) return id;\n    // If not, create one.\n    const markerVEl = V('marker', {\n      orient: 'auto',\n      overflow: 'visible',\n      markerUnits: markerUnits\n    });\n    markerVEl.id = id;\n    markerVEl.attr(attrs);\n    let markerContentVEl;\n    if (markup) {\n      let markupVEl;\n      if (typeof markup === 'string') {\n        // Marker object has a `markup` property of type string.\n        // - Construct V from the provided string.\n        markupVEl = V(markup);\n        // `markupVEl` is now either a single VEl, or an array of VEls.\n        // - Coerce it to an array.\n        markupVEl = Array.isArray(markupVEl) ? markupVEl : [markupVEl];\n      } else {\n        // Marker object has a `markup` property of type object.\n        // - Construct V from the object by parsing it as DOM JSON.\n        const {\n          fragment\n        } = parseDOMJSON(markup);\n        markupVEl = V(fragment).children();\n      }\n      // `markupVEl` is an array with one or more VEls inside.\n      // - If there are multiple VEls, wrap them in a newly-constructed <g> element\n      if (markupVEl.length > 1) {\n        markerContentVEl = V('g').append(markupVEl);\n      } else {\n        markerContentVEl = markupVEl[0];\n      }\n    } else {\n      // Marker object is a flat structure.\n      // - Construct a new V of type `marker.type`.\n      const {\n        type = 'path'\n      } = marker;\n      markerContentVEl = V(type);\n    }\n    // `markerContentVEl` is a single VEl.\n    // Assign additional attributes to it (= context attributes + marker attributes):\n    // - Attribute values are taken from non-special properties of `marker`.\n    const markerAttrs = omit(marker, 'type', 'id', 'markup', 'attrs', 'markerUnits');\n    const markerAttrsKeys = Object.keys(markerAttrs);\n    markerAttrsKeys.forEach(key => {\n      const value = markerAttrs[key];\n      const markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority\n      if (markupValue == null) {\n        // Default logic:\n        markerContentVEl.attr(key, value);\n      } else {\n        // Properties with special logic should be added as cases to this switch block:\n        switch (key) {\n          case 'transform':\n            // - Prepend `transform` to existing value.\n            markerContentVEl.attr(key, value + ' ' + markupValue);\n            break;\n        }\n      }\n    });\n    markerContentVEl.appendTo(markerVEl);\n    markerVEl.appendTo(defs);\n    return id;\n  },\n  customEventTrigger: function (evt, view, rootNode = view.el) {\n    const eventNode = evt.target.closest('[event]');\n    if (eventNode && rootNode !== eventNode && view.el.contains(eventNode)) {\n      const eventEvt = normalizeEvent(new $.Event(evt.originalEvent, {\n        data: evt.data,\n        // Originally the event listener was attached to the event element.\n        currentTarget: eventNode\n      }));\n      this.onevent(eventEvt);\n      if (eventEvt.isDefaultPrevented()) {\n        evt.preventDefault();\n      }\n      return eventEvt;\n    }\n    return null;\n  }\n}, {\n  sorting: sortingTypes,\n  Layers: LayersNames,\n  backgroundPatterns: {\n    flipXy: function (img) {\n      // d b\n      // q p\n\n      var canvas = document.createElement('canvas');\n      var imgWidth = img.width;\n      var imgHeight = img.height;\n      canvas.width = 2 * imgWidth;\n      canvas.height = 2 * imgHeight;\n      var ctx = canvas.getContext('2d');\n      // top-left image\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      // xy-flipped bottom-right image\n      ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      // x-flipped top-right image\n      ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      // y-flipped bottom-left image\n      ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      return canvas;\n    },\n    flipX: function (img) {\n      // d b\n      // d b\n\n      var canvas = document.createElement('canvas');\n      var imgWidth = img.width;\n      var imgHeight = img.height;\n      canvas.width = imgWidth * 2;\n      canvas.height = imgHeight;\n      var ctx = canvas.getContext('2d');\n      // left image\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      // flipped right image\n      ctx.translate(2 * imgWidth, 0);\n      ctx.scale(-1, 1);\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      return canvas;\n    },\n    flipY: function (img) {\n      // d d\n      // q q\n\n      var canvas = document.createElement('canvas');\n      var imgWidth = img.width;\n      var imgHeight = img.height;\n      canvas.width = imgWidth;\n      canvas.height = imgHeight * 2;\n      var ctx = canvas.getContext('2d');\n      // top image\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      // flipped bottom image\n      ctx.translate(0, 2 * imgHeight);\n      ctx.scale(1, -1);\n      ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n      return canvas;\n    },\n    watermark: function (img, opt) {\n      //   d\n      // d\n\n      opt = opt || {};\n      var imgWidth = img.width;\n      var imgHeight = img.height;\n      var canvas = document.createElement('canvas');\n      canvas.width = imgWidth * 3;\n      canvas.height = imgHeight * 3;\n      var ctx = canvas.getContext('2d');\n      var angle = isNumber(opt.watermarkAngle) ? -opt.watermarkAngle : -20;\n      var radians = toRad(angle);\n      var stepX = canvas.width / 4;\n      var stepY = canvas.height / 4;\n      for (var i = 0; i < 4; i++) {\n        for (var j = 0; j < 4; j++) {\n          if ((i + j) % 2 > 0) {\n            // reset the current transformations\n            ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);\n            ctx.rotate(radians);\n            ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);\n          }\n        }\n      }\n      return canvas;\n    }\n  },\n  gridPatterns: {\n    dot: [{\n      color: '#AAAAAA',\n      thickness: 1,\n      markup: 'rect',\n      render: function (el, opt) {\n        V(el).attr({\n          width: opt.thickness,\n          height: opt.thickness,\n          fill: opt.color\n        });\n      }\n    }],\n    fixedDot: [{\n      color: '#AAAAAA',\n      thickness: 1,\n      markup: 'rect',\n      render: function (el, opt) {\n        V(el).attr({\n          fill: opt.color\n        });\n      },\n      update: function (el, opt, paper) {\n        const {\n          sx,\n          sy\n        } = paper.scale();\n        const width = sx <= 1 ? opt.thickness : opt.thickness / sx;\n        const height = sy <= 1 ? opt.thickness : opt.thickness / sy;\n        V(el).attr({\n          width,\n          height\n        });\n      }\n    }],\n    mesh: [{\n      color: '#AAAAAA',\n      thickness: 1,\n      markup: 'path',\n      render: function (el, opt) {\n        var d;\n        var width = opt.width;\n        var height = opt.height;\n        var thickness = opt.thickness;\n        if (width - thickness >= 0 && height - thickness >= 0) {\n          d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n        } else {\n          d = 'M 0 0 0 0';\n        }\n        V(el).attr({\n          'd': d,\n          stroke: opt.color,\n          'stroke-width': opt.thickness\n        });\n      }\n    }],\n    doubleMesh: [{\n      color: '#AAAAAA',\n      thickness: 1,\n      markup: 'path',\n      render: function (el, opt) {\n        var d;\n        var width = opt.width;\n        var height = opt.height;\n        var thickness = opt.thickness;\n        if (width - thickness >= 0 && height - thickness >= 0) {\n          d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n        } else {\n          d = 'M 0 0 0 0';\n        }\n        V(el).attr({\n          'd': d,\n          stroke: opt.color,\n          'stroke-width': opt.thickness\n        });\n      }\n    }, {\n      color: '#000000',\n      thickness: 3,\n      scaleFactor: 4,\n      markup: 'path',\n      render: function (el, opt) {\n        var d;\n        var width = opt.width;\n        var height = opt.height;\n        var thickness = opt.thickness;\n        if (width - thickness >= 0 && height - thickness >= 0) {\n          d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n        } else {\n          d = 'M 0 0 0 0';\n        }\n        V(el).attr({\n          'd': d,\n          stroke: opt.color,\n          'stroke-width': opt.thickness\n        });\n      }\n    }]\n  }\n});","map":{"version":3,"names":["V","isNumber","assign","nextFrame","isObject","cancelFrame","defaults","defaultsDeep","addClassNamePrefix","normalizeSides","isFunction","isPlainObject","getByPath","sortElements","isString","guid","normalizeEvent","normalizeWheel","cap","debounce","omit","result","camelCase","cloneDeep","invoke","hashCode","filter","_filter","parseDOMJSON","toArray","has","ViewBase","Rect","Point","toRad","View","views","CellView","ElementView","LinkView","Cell","Graph","LayersNames","PaperLayer","highlighters","linkAnchors","connectionPoints","anchors","$","GridLayer","sortingTypes","NONE","APPROX","EXACT","WHEEL_CAP","WHEEL_WAIT_MS","MOUNT_BATCH_SIZE","UPDATE_BATCH_SIZE","Infinity","MIN_PRIORITY","HighlightingTypes","Highlighting","defaultHighlighting","DEFAULT","name","options","padding","MAGNET_AVAILABILITY","className","ELEMENT_AVAILABILITY","defaultLayers","GRID","BACK","CELLS","LABELS","FRONT","TOOLS","Paper","extend","width","height","gridSize","drawGrid","drawGridSize","background","elementView","linkView","snapLabels","snapLinks","snapLinksSelf","labelsLayer","multiLinks","guard","evt","view","highlighting","preventContextMenu","preventDefaultBlankAction","preventDefaultViewAction","restrictTranslate","markAvailable","defaultLink","cellNamespace","model","get","ctor","Error","defaultConnector","defaultRouter","defaultAnchor","defaultLinkAnchor","defaultConnectionPoint","connectionStrategy","validateMagnet","_cellView","magnet","_evt","getAttribute","validateConnection","cellViewS","_magnetS","cellViewT","_magnetT","end","_linkView","embeddingMode","validateEmbedding","childView","parentView","validateUnembedding","findParentBy","frontParentOnly","interactive","labelMove","linkPinning","allowLink","clickThreshold","moveThreshold","magnetThreshold","sorting","frozen","autoFreeze","onViewUpdate","flag","priority","opt","paper","FLAG_INSERT","FLAG_REMOVE","mounting","isolate","requestConnectedLinksUpdate","onViewPostponed","forcePostponedViewUpdate","beforeRender","afterRender","viewport","cellViewNamespace","routerNamespace","connectorNamespace","highlighterNamespace","anchorNamespace","linkAnchorNamespace","connectionPointNamespace","overflow","events","documentEvents","stylesheet","svg","defs","tools","layers","_viewportMatrix","_viewportTransformString","_updates","_layers","SORT_DELAYING_BATCHES","UPDATE_DELAYING_BATCHES","FORM_CONTROL_TAG_NAMES","GUARDED_TAG_NAMES","MIN_SCALE","init","joint","shapes","cloneOptions","render","_setDimensions","startListening","_views","_mw_evt_buffer","event","deltas","resetViews","attributes","cells","models","isFrozen","isAsync","updateViewsAsync","_resetUpdates","id","priorities","unmountedCids","mountedCids","unmounted","mounted","count","keyFrozen","freezeKey","sort","disabled","idle","listenTo","onCellAdded","onCellRemoved","onCellChange","onGraphReset","onGraphSort","onGraphBatchStop","on","onCellHighlight","onCellUnhighlight","update","cell","_","position","renderView","maxPosition","freeze","key","unfreeze","findViewByModel","requestViewUpdate","UPDATE_PRIORITY","hasChanged","collection","resetLayers","hasActiveBatch","sortViews","data","batchName","graph","updateDelayingBatches","includes","updateViews","sortDelayingBatches","children","ns","namespace","namespaceURI","xhtml","tagName","selector","style","inset","xlink","hasLayerView","layerName","getLayerView","getLayerNode","el","renderChildren","childNodes","renderLayers","ensureId","addStylesheet","drawBackground","setGrid","css","prepend","createSVGStyle","createLayer","patterns","constructor","gridPatterns","removeLayers","forEach","sorted","layerView","appendChild","cellsLayerView","toolsLayerView","labelsLayerView","vel","addClass","webkitUserSelect","userSelect","Object","keys","remove","removePivots","_background","updateBackgroundImage","scale","sx","sy","ctm","matrix","undefined","matrixToScale","Math","max","a","d","scaleUniformAtPoint","point","e","tx","f","ty","createSVGMatrix","translate","x","y","matrixToTranslate","transformString","getCTM","prev","current","currentTransformString","ctmString","matrixToTransformString","setAttribute","trigger","clientMatrix","getScreenCTM","links","getConnectedLinks","j","n","length","link","flagLabels","getTargetCell","push","getSourceCell","nextPriority","scheduleViewUpdate","getFlag","isElement","dumpOptions","silent","sourceFlag","sourceView","isViewMounted","dumpView","updateEndMagnet","targetFlag","targetView","async","stats","notifyAfterRender","type","updates","cid","priorityUpdates","i","prevPriorityUpdates","currentType","viewUpdateFn","call","dumpViewUpdate","registerMountedView","shouldNotify","notifyBeforeRender","leftover","updateView","updated","FLAG_INIT","removeView","isInitialInsert","insertView","confirmUpdate","requireView","registerUnmountedView","dumpViews","passingOpt","checkViewport","batchStats","updateCount","batchCount","updateViewsBatch","min","empty","batches","hasScheduledUpdates","priorityIndexes","_key","processed","mountBatchSize","unmountBatchSize","checkStats","unmountCount","mountCount","total","progressFn","progress","beforeFn","afterFn","batchSize","postponeCount","maxPriority","viewportFn","postponeViewFn","main","currentFlag","isDetached","DETACHABLE","detachView","leftoverFlag","postponed","getUnmountedViews","unmountedViews","Array","getMountedViews","mountedViews","checkUnmountedViews","splice","checkMountedViews","checkViewVisibility","cellView","visible","isUnmounted","isMounted","indexOf","unmountedCount","mountedCount","isExactSorting","onRemove","removeViews","getComputedSize","w","h","clientWidth","clientHeight","setDimensions","currentWidth","currentHeight","computedSize","round","$el","fitToContent","gridWidth","gridHeight","getFitToContentArea","minWidth","minHeight","maxWidth","Number","MAX_VALUE","maxHeight","newOrigin","allowNewOrigin","area","contentArea","getContentArea","calcWidth","ceil","calcHeight","allowNegativeBottomRight","left","top","right","bottom","transformToFitContent","contentBBox","contentLocalOrigin","localToPaperRect","getContentBBox","paperToLocalPoint","preserveAspectRatio","scaleGrid","minScale","maxScale","verticalAlign","horizontalAlign","minScaleX","maxScaleX","minScaleY","maxScaleY","fittingBBox","currentTranslate","moveAndExpand","newSx","newSy","floor","scaleDiff","newOx","newOy","scaleContentToFit","useModelGeometry","getBBox","getArea","paperToLocalRect","getRestrictedArea","args","restrictedArea","apply","createViewForModel","optionalViewClass","defaultViewClass","namespaceViewClass","isLink","ViewClass","prototype","create","onImageDragStart","sortViewsExact","cellNodes","from","node","b","cellA","cellB","zA","z","zB","insertSortedNode","insertNode","onMount","unmount","onDetach","findView","querySelector","findAttribute","findViewsFromPoint","p","getElements","map","target","containsPoint","findViewsInArea","rect","strict","method","removeTools","dispatchToolsEvent","hideTools","showTools","getModelById","getCell","snapToGrid","clientToLocalPoint","localToPaperPoint","localPoint","paperPoint","transformPoint","localRect","paperRect","transformRect","inverse","localToClientPoint","clientPoint","localToClientRect","clientRect","clientToLocalRect","localToPagePoint","offset","pageOffset","localToPageRect","pageToLocalPoint","pagePoint","difference","pageToLocalRect","clientOffset","getBoundingClientRect","window","scrollX","scrollY","linkAllowed","paperOptions","validations","getDefaultLink","clone","resolveHighlighter","highlighter","highlighterDef","highlight","unhighlight","magnetEl","highlighterDescriptor","pointerdblclick","preventDefault","clientX","clientY","pointerclick","eventData","mousemoved","contextmenu","contextMenuFired","contextMenuTrigger","pointerdown","button","isContextMenu","isTargetFormNode","preventDefaultInteraction","eventEvt","customEventTrigger","isPropagationStopped","magnetNode","closest","contains","magnetEvt","Event","originalEvent","currentTarget","onmagnet","isDefaultPrevented","delegateDragEvents","contextmenuEvt","pointermove","undelegateEvents","pointerup","undelegateDocumentEvents","normalizedEvt","delegateEvents","mouseover","mouseout","mouseenter","relatedTarget","relatedView","mouseleave","_processMouseWheelEvtBuf","deltaY","reduce","acc","pow","maxWait","mousewheel","deltaX","pinchHandlers","_events","ctrlKey","delta","wheelDelta","onevent","eventNode","eventName","magnetEvent","handler","magnetValue","magnetContextMenuFired","magnetContextMenuTrigger","stopPropagation","magnetpointerdblclick","magnetcontextmenu","onlabel","labelNode","getPointerArgs","delegateDocumentEvents","guarded","setGridSize","renderGrid","backgroundPosition","backgroundSize","size","currentScale","drawBackgroundImage","img","HTMLImageElement","backgroundImage","backgroundRepeat","repeat","backgroundOpacity","opacity","backgroundQuality","abs","quality","backgroundPattern","backgroundPatterns","canvas","HTMLCanvasElement","toDataURL","src","updateBackgroundColor","color","image","document","createElement","onload","bind","setInteractivity","value","isDefined","defId","getElementById","defineFilter","TypeError","filterId","JSON","stringify","filterSVGString","filterAttrs","filterUnits","attrs","appendTo","defineGradient","gradient","stops","stopVEls","attr","isFinite","gradientVEl","definePattern","pattern","markup","patternVEl","patternUnits","append","fragment","defineMarker","marker","markerUnits","markerVEl","orient","markerContentVEl","markupVEl","isArray","markerAttrs","markerAttrsKeys","markupValue","rootNode","Layers","flipXy","imgWidth","imgHeight","ctx","getContext","drawImage","setTransform","flipX","flipY","watermark","angle","watermarkAngle","radians","stepX","stepY","rotate","dot","thickness","fill","fixedDot","mesh","join","stroke","doubleMesh","scaleFactor"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/dia/Paper.mjs"],"sourcesContent":["import V from '../V/index.mjs';\nimport {\n    isNumber,\n    assign,\n    nextFrame,\n    isObject,\n    cancelFrame,\n    defaults,\n    defaultsDeep,\n    addClassNamePrefix,\n    normalizeSides,\n    isFunction,\n    isPlainObject,\n    getByPath,\n    sortElements,\n    isString,\n    guid,\n    normalizeEvent,\n    normalizeWheel,\n    cap,\n    debounce,\n    omit,\n    result,\n    camelCase,\n    cloneDeep,\n    invoke,\n    hashCode,\n    filter as _filter,\n    parseDOMJSON,\n    toArray,\n    has\n} from '../util/index.mjs';\nimport { ViewBase } from '../mvc/ViewBase.mjs';\nimport { Rect, Point, toRad } from '../g/index.mjs';\nimport { View, views } from '../mvc/index.mjs';\nimport { CellView } from './CellView.mjs';\nimport { ElementView } from './ElementView.mjs';\nimport { LinkView } from './LinkView.mjs';\nimport { Cell } from './Cell.mjs';\nimport { Graph } from './Graph.mjs';\nimport { LayersNames, PaperLayer } from './PaperLayer.mjs';\nimport * as highlighters from '../highlighters/index.mjs';\nimport * as linkAnchors from '../linkAnchors/index.mjs';\nimport * as connectionPoints from '../connectionPoints/index.mjs';\nimport * as anchors from '../anchors/index.mjs';\n\nimport $ from '../mvc/Dom/index.mjs';\nimport { GridLayer } from './layers/GridLayer.mjs';\n\nconst sortingTypes = {\n    NONE: 'sorting-none',\n    APPROX: 'sorting-approximate',\n    EXACT: 'sorting-exact'\n};\n\nconst WHEEL_CAP = 50;\nconst WHEEL_WAIT_MS = 20;\nconst MOUNT_BATCH_SIZE = 1000;\nconst UPDATE_BATCH_SIZE = Infinity;\nconst MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER\n\nconst HighlightingTypes = CellView.Highlighting;\n\nconst defaultHighlighting = {\n    [HighlightingTypes.DEFAULT]: {\n        name: 'stroke',\n        options: {\n            padding: 3\n        }\n    },\n    [HighlightingTypes.MAGNET_AVAILABILITY]: {\n        name: 'addClass',\n        options: {\n            className: 'available-magnet'\n        }\n    },\n    [HighlightingTypes.ELEMENT_AVAILABILITY]: {\n        name: 'addClass',\n        options: {\n            className: 'available-cell'\n        }\n    }\n};\n\nconst defaultLayers = [{\n    name: LayersNames.GRID,\n}, {\n    name: LayersNames.BACK,\n}, {\n    name: LayersNames.CELLS,\n}, {\n    name: LayersNames.LABELS,\n}, {\n    name: LayersNames.FRONT\n}, {\n    name: LayersNames.TOOLS\n}];\n\nexport const Paper = View.extend({\n\n    className: 'paper',\n\n    options: {\n\n        width: 800,\n        height: 600,\n        gridSize: 1,\n        // Whether or not to draw the grid lines on the paper's DOM element.\n        // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }\n        drawGrid: false,\n        // If not set, the size of the visual grid is the same as the `gridSize`.\n        drawGridSize: null,\n\n        // Whether or not to draw the background on the paper's DOM element.\n        // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }\n        background: false,\n\n        elementView: ElementView,\n        linkView: LinkView,\n        snapLabels: false, // false, true\n        snapLinks: false, // false, true, { radius: value }\n        snapLinksSelf: false, // false, true, { radius: value }\n\n        // Should the link labels be rendered into its own layer?\n        // `false` - the labels are part of the links\n        // `true` - the labels are appended to LayersName.LABELS\n        // [LayersName] - the labels are appended to the layer specified\n        labelsLayer: false,\n\n        // When set to FALSE, an element may not have more than 1 link with the same source and target element.\n        multiLinks: true,\n\n        // For adding custom guard logic.\n        guard: function(evt, view) {\n\n            // FALSE means the event isn't guarded.\n            return false;\n        },\n\n        highlighting: defaultHighlighting,\n\n        // Prevent the default context menu from being displayed.\n        preventContextMenu: true,\n\n        // Prevent the default action for blank:pointer<action>.\n        preventDefaultBlankAction: true,\n\n        // Prevent the default action for cell:pointer<action>.\n        preventDefaultViewAction: true,\n\n        // Restrict the translation of elements by given bounding box.\n        // Option accepts a boolean:\n        //  true - the translation is restricted to the paper area\n        //  false - no restrictions\n        // A method:\n        // restrictTranslate: function(elementView) {\n        //     var parentId = elementView.model.get('parent');\n        //     return parentId && this.model.getCell(parentId).getBBox();\n        // },\n        // Or a bounding box:\n        // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }\n        restrictTranslate: false,\n\n        // Marks all available magnets with 'available-magnet' class name and all available cells with\n        // 'available-cell' class name. Marks them when dragging a link is started and unmark\n        // when the dragging is stopped.\n        markAvailable: false,\n\n        // Defines what link model is added to the graph after an user clicks on an active magnet.\n        // Value could be the mvc.model or a function returning the mvc.model\n        // defaultLink: (elementView, magnet) => {\n        //   return condition ? new customLink1() : new customLink2()\n        // }\n        defaultLink: function() {\n            // Do not create hard dependency on the joint.shapes.standard namespace (by importing the standard.Link model directly)\n            const { cellNamespace } = this.model.get('cells');\n            const ctor = getByPath(cellNamespace, ['standard', 'Link']);\n            if (!ctor) throw new Error('dia.Paper: no default link model found. Use `options.defaultLink` to specify a default link model.');\n            return new ctor();\n        },\n\n        // A connector that is used by links with no connector defined on the model.\n        // e.g. { name: 'rounded', args: { radius: 5 }} or a function\n        defaultConnector: { name: 'normal' },\n\n        // A router that is used by links with no router defined on the model.\n        // e.g. { name: 'oneSide', args: { padding: 10 }} or a function\n        defaultRouter: { name: 'normal' },\n\n        defaultAnchor: { name: 'center' },\n\n        defaultLinkAnchor: { name: 'connectionRatio' },\n\n        defaultConnectionPoint: { name: 'boundary' },\n\n        /* CONNECTING */\n\n        connectionStrategy: null,\n\n        // Check whether to add a new link to the graph when user clicks on an a magnet.\n        validateMagnet: function(_cellView, magnet, _evt) {\n            return magnet.getAttribute('magnet') !== 'passive';\n        },\n\n        // Check whether to allow or disallow the link connection while an arrowhead end (source/target)\n        // being changed.\n        validateConnection: function(cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {\n            return (end === 'target' ? cellViewT : cellViewS) instanceof ElementView;\n        },\n\n        /* EMBEDDING */\n\n        // Enables embedding. Re-parent the dragged element with elements under it and makes sure that\n        // all links and elements are visible taken the level of embedding into account.\n        embeddingMode: false,\n\n        // Check whether to allow or disallow the element embedding while an element being translated.\n        validateEmbedding: function(childView, parentView) {\n            // by default all elements can be in relation child-parent\n            return true;\n        },\n\n        // Check whether to allow or disallow an embedded element to be unembedded / to become a root.\n        validateUnembedding: function(childView) {\n            // by default all elements can become roots\n            return true;\n        },\n\n        // Determines the way how a cell finds a suitable parent when it's dragged over the paper.\n        // The cell with the highest z-index (visually on the top) will be chosen.\n        findParentBy: 'bbox', // 'bbox'|'center'|'origin'|'corner'|'topRight'|'bottomLeft'\n\n        // If enabled only the element on the very front is taken into account for the embedding.\n        // If disabled the elements under the dragged view are tested one by one\n        // (from front to back) until a valid parent found.\n        frontParentOnly: true,\n\n        // Interactive flags. See online docs for the complete list of interactive flags.\n        interactive: {\n            labelMove: false\n        },\n\n        // When set to true the links can be pinned to the paper.\n        // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };\n        linkPinning: true,\n\n        // Custom validation after an interaction with a link ends.\n        // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)\n        // (linkView, paper) => boolean\n        allowLink: null,\n\n        // Allowed number of mousemove events after which the pointerclick event will be still triggered.\n        clickThreshold: 0,\n\n        // Number of required mousemove events before the first pointermove event will be triggered.\n        moveThreshold: 0,\n\n        // Number of required mousemove events before a link is created out of the magnet.\n        // Or string `onleave` so the link is created when the pointer leaves the magnet\n        magnetThreshold: 0,\n\n        // Rendering Options\n\n        sorting: sortingTypes.APPROX,\n\n        frozen: false,\n\n        autoFreeze: false,\n\n        // no docs yet\n        onViewUpdate: function(view, flag, priority, opt, paper) {\n            // Do not update connected links when:\n            // 1. the view was just inserted (added to the graph and rendered)\n            // 2. the view was just mounted (added back to the paper by viewport function)\n            // 3. the change was marked as `isolate`.\n            // 4. the view model was just removed from the graph\n            if ((flag & (view.FLAG_INSERT | view.FLAG_REMOVE)) || opt.mounting || opt.isolate) return;\n            paper.requestConnectedLinksUpdate(view, priority, opt);\n        },\n\n        // no docs yet\n        onViewPostponed: function(view, flag, paper) {\n            return paper.forcePostponedViewUpdate(view, flag);\n        },\n\n        beforeRender: null, // function(opt, paper) { },\n\n        afterRender: null, // function(stats, opt, paper) {\n\n        viewport: null,\n\n        // Default namespaces\n\n        cellViewNamespace: null,\n\n        routerNamespace: null,\n\n        connectorNamespace: null,\n\n        highlighterNamespace: highlighters,\n\n        anchorNamespace: anchors,\n\n        linkAnchorNamespace: linkAnchors,\n\n        connectionPointNamespace: connectionPoints,\n\n        overflow: false\n    },\n\n    events: {\n        'dblclick': 'pointerdblclick',\n        'dbltap': 'pointerdblclick',\n        'contextmenu': 'contextmenu',\n        'mousedown': 'pointerdown',\n        'touchstart': 'pointerdown',\n        'mouseover': 'mouseover',\n        'mouseout': 'mouseout',\n        'mouseenter': 'mouseenter',\n        'mouseleave': 'mouseleave',\n        'wheel': 'mousewheel',\n        'mouseenter .joint-cell': 'mouseenter',\n        'mouseleave .joint-cell': 'mouseleave',\n        'mouseenter .joint-tools': 'mouseenter',\n        'mouseleave .joint-tools': 'mouseleave',\n        'dblclick .joint-cell [magnet]': 'magnetpointerdblclick',\n        'contextmenu .joint-cell [magnet]': 'magnetcontextmenu',\n        'mousedown .joint-link .label': 'onlabel', // interaction with link label\n        'touchstart .joint-link .label': 'onlabel',\n        'dragstart .joint-cell image': 'onImageDragStart' // firefox fix\n    },\n\n    documentEvents: {\n        'mousemove': 'pointermove',\n        'touchmove': 'pointermove',\n        'mouseup': 'pointerup',\n        'touchend': 'pointerup',\n        'touchcancel': 'pointerup'\n    },\n\n    /* CSS within the SVG document\n    * 1. Adding vector-effect: non-scaling-stroke; to prevent the stroke width from scaling for\n    *    elements that use the `scalable` group.\n    */\n    stylesheet: /*css*/`\n        .joint-element .scalable * {\n            vector-effect: non-scaling-stroke;\n        }\n    `,\n\n    svg: null,\n    viewport: null,\n    defs: null,\n    tools: null,\n    layers: null,\n\n    // For storing the current transformation matrix (CTM) of the paper's viewport.\n    _viewportMatrix: null,\n    // For verifying whether the CTM is up-to-date. The viewport transform attribute\n    // could have been manipulated directly.\n    _viewportTransformString: null,\n    // Updates data (priorities, unmounted views etc.)\n    _updates: null,\n    // Paper Layers\n    _layers: null,\n\n    SORT_DELAYING_BATCHES: ['add', 'to-front', 'to-back'],\n    UPDATE_DELAYING_BATCHES: ['translate'],\n    // If you interact with these elements,\n    // the default interaction such as `element move` is prevented.\n    FORM_CONTROL_TAG_NAMES: ['TEXTAREA', 'INPUT', 'BUTTON', 'SELECT', 'OPTION'] ,\n    // If you interact with these elements, the events are not propagated to the paper\n    // i.e. paper events such as `element:pointerdown` are not triggered.\n    GUARDED_TAG_NAMES: [\n        // Guard <select> for consistency. When you click on it:\n        // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open\n        // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).\n        //          on close. However, if you open and then close by clicking elsewhere on the page,\n        //           no other event is triggered.\n        // Safari: when you open it, it triggers `pointerdown`. That's it.\n        'SELECT',\n    ],\n    MIN_SCALE: 1e-6,\n\n    init: function() {\n\n        const { options } = this;\n        if (!options.cellViewNamespace) {\n            /* eslint-disable no-undef */\n            options.cellViewNamespace = typeof joint !== 'undefined' && has(joint, 'shapes') ? joint.shapes : null;\n            /* eslint-enable no-undef */\n        }\n\n        const model = this.model = options.model || new Graph;\n\n        // Layers (SVGGroups)\n        this._layers = {};\n\n        this.cloneOptions();\n        this.render();\n        this._setDimensions();\n        this.startListening();\n\n        // Hash of all cell views.\n        this._views = {};\n\n        // Mouse wheel events buffer\n        this._mw_evt_buffer = {\n            event: null,\n            deltas: [],\n        };\n\n        // Render existing cells in the graph\n        this.resetViews(model.attributes.cells.models);\n        // Start the Rendering Loop\n        if (!this.isFrozen() && this.isAsync()) this.updateViewsAsync();\n    },\n\n    _resetUpdates: function() {\n        return this._updates = {\n            id: null,\n            priorities: [{}, {}, {}],\n            unmountedCids: [],\n            mountedCids: [],\n            unmounted: {},\n            mounted: {},\n            count: 0,\n            keyFrozen: false,\n            freezeKey: null,\n            sort: false,\n            disabled: false,\n            idle: false\n        };\n    },\n\n    startListening: function() {\n        var model = this.model;\n        this.listenTo(model, 'add', this.onCellAdded)\n            .listenTo(model, 'remove', this.onCellRemoved)\n            .listenTo(model, 'change', this.onCellChange)\n            .listenTo(model, 'reset', this.onGraphReset)\n            .listenTo(model, 'sort', this.onGraphSort)\n            .listenTo(model, 'batch:stop', this.onGraphBatchStop);\n        this.on('cell:highlight', this.onCellHighlight)\n            .on('cell:unhighlight', this.onCellUnhighlight)\n            .on('transform', this.update);\n    },\n\n    onCellAdded: function(cell, _, opt) {\n        var position = opt.position;\n        if (this.isAsync() || !isNumber(position)) {\n            this.renderView(cell, opt);\n        } else {\n            if (opt.maxPosition === position) this.freeze({ key: 'addCells' });\n            this.renderView(cell, opt);\n            if (position === 0) this.unfreeze({ key: 'addCells' });\n        }\n    },\n\n    onCellRemoved: function(cell, _, opt) {\n        const view = this.findViewByModel(cell);\n        if (view) this.requestViewUpdate(view, view.FLAG_REMOVE, view.UPDATE_PRIORITY, opt);\n    },\n\n    onCellChange: function(cell, opt) {\n        if (cell === this.model.attributes.cells) return;\n        if (cell.hasChanged('z') && this.options.sorting === sortingTypes.APPROX) {\n            const view = this.findViewByModel(cell);\n            if (view) this.requestViewUpdate(view, view.FLAG_INSERT, view.UPDATE_PRIORITY, opt);\n        }\n    },\n\n    onGraphReset: function(collection, opt) {\n        this.resetLayers();\n        this.resetViews(collection.models, opt);\n    },\n\n    onGraphSort: function() {\n        if (this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;\n        this.sortViews();\n    },\n\n    onGraphBatchStop: function(data) {\n        if (this.isFrozen()) return;\n        var name = data && data.batchName;\n        var graph = this.model;\n        if (!this.isAsync()) {\n            var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;\n            if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {\n                this.updateViews(data);\n            }\n        }\n        var sortDelayingBatches = this.SORT_DELAYING_BATCHES;\n        if (sortDelayingBatches.includes(name) && !graph.hasActiveBatch(sortDelayingBatches)) {\n            this.sortViews();\n        }\n    },\n\n    cloneOptions: function() {\n\n        const { options } = this;\n        const {\n            defaultConnector,\n            defaultRouter,\n            defaultConnectionPoint,\n            defaultAnchor,\n            defaultLinkAnchor,\n            highlighting,\n            cellViewNamespace,\n            interactive\n        } = options;\n\n        // Default cellView namespace for ES5\n        /* eslint-disable no-undef */\n        if (!cellViewNamespace && typeof joint !== 'undefined' && has(joint, 'shapes')) {\n            options.cellViewNamespace = joint.shapes;\n        }\n        /* eslint-enable no-undef */\n\n        // Here if a function was provided, we can not clone it, as this would result in loosing the function.\n        // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.\n        if (!isFunction(defaultConnector)) {\n            options.defaultConnector = cloneDeep(defaultConnector);\n        }\n        if (!isFunction(defaultRouter)) {\n            options.defaultRouter = cloneDeep(defaultRouter);\n        }\n        if (!isFunction(defaultConnectionPoint)) {\n            options.defaultConnectionPoint = cloneDeep(defaultConnectionPoint);\n        }\n        if (!isFunction(defaultAnchor)) {\n            options.defaultAnchor = cloneDeep(defaultAnchor);\n        }\n        if (!isFunction(defaultLinkAnchor)) {\n            options.defaultLinkAnchor = cloneDeep(defaultLinkAnchor);\n        }\n        if (isPlainObject(interactive)) {\n            options.interactive = assign({}, interactive);\n        }\n        if (isPlainObject(highlighting)) {\n            // Return the default highlighting options into the user specified options.\n            options.highlighting = defaultsDeep({}, highlighting, defaultHighlighting);\n        }\n    },\n\n    children: function() {\n        var ns = V.namespace;\n        return [{\n            namespaceURI: ns.xhtml,\n            tagName: 'div',\n            className: addClassNamePrefix('paper-background'),\n            selector: 'background',\n            style: {\n                position: 'absolute',\n                inset: 0\n            }\n        }, {\n            namespaceURI: ns.svg,\n            tagName: 'svg',\n            attributes: {\n                'width': '100%',\n                'height': '100%',\n                'xmlns:xlink': ns.xlink\n            },\n            selector: 'svg',\n            style: {\n                position: 'absolute',\n                inset: 0\n            },\n            children: [{\n                // Append `<defs>` element to the SVG document. This is useful for filters and gradients.\n                // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).\n                tagName: 'defs',\n                selector: 'defs'\n            }, {\n                tagName: 'g',\n                className: addClassNamePrefix('layers'),\n                selector: 'layers'\n            }]\n        }];\n    },\n\n    hasLayerView(layerName) {\n        return  (layerName in this._layers);\n    },\n\n    getLayerView(layerName) {\n        const { _layers } = this;\n        if (layerName in _layers) return _layers[layerName];\n        throw new Error(`dia.Paper: Unknown layer \"${layerName}\"`);\n    },\n\n    getLayerNode(layerName) {\n        return this.getLayerView(layerName).el;\n    },\n\n    render: function() {\n\n        this.renderChildren();\n        const { el, childNodes, options, stylesheet } = this;\n        const { svg, defs, layers } = childNodes;\n\n        el.style.position = 'relative';\n        svg.style.overflow = options.overflow ? 'visible' : 'hidden';\n\n        this.svg = svg;\n        this.defs = defs;\n        this.layers = layers;\n\n        this.renderLayers();\n\n        V.ensureId(svg);\n\n        this.addStylesheet(stylesheet);\n\n        if (options.background) {\n            this.drawBackground(options.background);\n        }\n\n        if (options.drawGrid) {\n            this.setGrid(options.drawGrid);\n        }\n\n        return this;\n    },\n\n    addStylesheet: function(css) {\n        if (!css) return;\n        V(this.svg).prepend(V.createSVGStyle(css));\n    },\n\n    createLayer(name) {\n        switch (name) {\n            case LayersNames.GRID:\n                return new GridLayer({ name, paper: this, patterns: this.constructor.gridPatterns });\n            default:\n                return new PaperLayer({ name });\n        }\n    },\n\n    renderLayers: function(layers = defaultLayers) {\n        this.removeLayers();\n        // TODO: Layers to be read from the graph `layers` attribute\n        layers.forEach(({ name, sorted }) => {\n            const layerView = this.createLayer(name);\n            this.layers.appendChild(layerView.el);\n            this._layers[name] = layerView;\n        });\n        // Throws an exception if doesn't exist\n        const cellsLayerView = this.getLayerView(LayersNames.CELLS);\n        const toolsLayerView = this.getLayerView(LayersNames.TOOLS);\n        const labelsLayerView = this.getLayerView(LayersNames.LABELS);\n        // backwards compatibility\n        this.tools = toolsLayerView.el;\n        this.cells = this.viewport = cellsLayerView.el;\n        // user-select: none;\n        cellsLayerView.vel.addClass(addClassNamePrefix('viewport'));\n        labelsLayerView.vel.addClass(addClassNamePrefix('viewport'));\n        cellsLayerView.el.style.webkitUserSelect = 'none';\n        cellsLayerView.el.style.userSelect = 'none';\n        labelsLayerView.el.style.webkitUserSelect = 'none';\n        labelsLayerView.el.style.userSelect = 'none';\n    },\n\n    removeLayers: function() {\n        const { _layers } = this;\n        Object.keys(_layers).forEach(name => {\n            _layers[name].remove();\n            delete _layers[name];\n        });\n    },\n\n    resetLayers: function() {\n        const { _layers } = this;\n        Object.keys(_layers).forEach(name => {\n            _layers[name].removePivots();\n        });\n    },\n\n    update: function() {\n\n        if (this._background) {\n            this.updateBackgroundImage(this._background);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, data) {\n        const ctm = this.matrix();\n        // getter\n        if (sx === undefined) {\n            return V.matrixToScale(ctm);\n        }\n        // setter\n        if (sy === undefined) {\n            sy = sx;\n        }\n        sx = Math.max(sx || 0, this.MIN_SCALE);\n        sy = Math.max(sy || 0, this.MIN_SCALE);\n        ctm.a = sx;\n        ctm.d = sy;\n        this.matrix(ctm, data);\n        return this;\n    },\n\n    scaleUniformAtPoint: function(scale, point, data) {\n        const { a: sx, d: sy, e: tx, f: ty } = this.matrix();\n        scale = Math.max(scale || 0, this.MIN_SCALE);\n        if (scale === sx && scale === sy) {\n            // The scale is the same as the current one.\n            return this;\n        }\n        const matrix = V.createSVGMatrix()\n            .translate(\n                tx - point.x * (scale - sx),\n                ty - point.y * (scale - sy)\n            )\n            .scale(scale, scale);\n        this.matrix(matrix, data);\n        return this;\n    },\n\n    translate: function(tx, ty, data) {\n        const ctm = this.matrix();\n        // getter\n        if (tx === undefined) {\n            return V.matrixToTranslate(ctm);\n        }\n        // setter\n        tx || (tx = 0);\n        ty || (ty = 0);\n        if (ctm.e === tx && ctm.f === ty) return this;\n        ctm.e = tx;\n        ctm.f = ty;\n        this.matrix(ctm, data);\n        return this;\n    },\n\n    matrix: function(ctm, data = {}) {\n\n        var viewport = this.layers;\n\n        // Getter:\n        if (ctm === undefined) {\n\n            var transformString = viewport.getAttribute('transform');\n\n            if ((this._viewportTransformString || null) === transformString) {\n                // It's ok to return the cached matrix. The transform attribute has not changed since\n                // the matrix was stored.\n                ctm = this._viewportMatrix;\n            } else {\n                // The viewport transform attribute has changed. Measure the matrix and cache again.\n                ctm = viewport.getCTM();\n                this._viewportMatrix = ctm;\n                this._viewportTransformString = transformString;\n            }\n\n            // Clone the cached current transformation matrix.\n            // If no matrix previously stored the identity matrix is returned.\n            return V.createSVGMatrix(ctm);\n        }\n\n        // Setter:\n        const prev = this.matrix();\n        const current = V.createSVGMatrix(ctm);\n        const currentTransformString = this._viewportTransformString;\n        const ctmString = V.matrixToTransformString(current);\n        if (ctmString === currentTransformString) {\n            // The new transform string is the same as the current one.\n            // No need to update the transform attribute.\n            return this;\n        }\n        if (!currentTransformString && V.matrixToTransformString() === ctmString) {\n            // The current transform string is empty and the new one is an identity matrix.\n            // No need to update the transform attribute.\n            return this;\n        }\n\n        const { a, d, e, f } = current;\n\n        viewport.setAttribute('transform', ctmString);\n        this._viewportMatrix = current;\n        this._viewportTransformString = viewport.getAttribute('transform');\n\n        // scale event\n        if (a !== prev.a || d !== prev.d) {\n            this.trigger('scale', a, d, data);\n        }\n\n        // translate event\n        if (e !== prev.e || f !== prev.f) {\n            this.trigger('translate', e, f, data);\n        }\n\n        this.trigger('transform', current, data);\n        return this;\n    },\n\n    clientMatrix: function() {\n\n        return V.createSVGMatrix(this.cells.getScreenCTM());\n    },\n\n    requestConnectedLinksUpdate: function(view, priority, opt) {\n        if (view instanceof CellView) {\n            var model = view.model;\n            var links = this.model.getConnectedLinks(model);\n            for (var j = 0, n = links.length; j < n; j++) {\n                var link = links[j];\n                var linkView = this.findViewByModel(link);\n                if (!linkView) continue;\n                var flagLabels = ['UPDATE'];\n                if (link.getTargetCell() === model) flagLabels.push('TARGET');\n                if (link.getSourceCell() === model) flagLabels.push('SOURCE');\n                var nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);\n                this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);\n            }\n        }\n    },\n\n    forcePostponedViewUpdate: function(view, flag) {\n        if (!view || !(view instanceof CellView)) return false;\n        var model = view.model;\n        if (model.isElement()) return false;\n        if ((flag & view.getFlag(['SOURCE', 'TARGET'])) === 0) {\n            var dumpOptions = { silent: true };\n            // LinkView is waiting for the target or the source cellView to be rendered\n            // This can happen when the cells are not in the viewport.\n            var sourceFlag = 0;\n            var sourceView = this.findViewByModel(model.getSourceCell());\n            if (sourceView && !this.isViewMounted(sourceView)) {\n                sourceFlag = this.dumpView(sourceView, dumpOptions);\n                view.updateEndMagnet('source');\n            }\n            var targetFlag = 0;\n            var targetView = this.findViewByModel(model.getTargetCell());\n            if (targetView && !this.isViewMounted(targetView)) {\n                targetFlag = this.dumpView(targetView, dumpOptions);\n                view.updateEndMagnet('target');\n            }\n            if (sourceFlag === 0 && targetFlag === 0) {\n                // If leftover flag is 0, all view updates were done.\n                return !this.dumpView(view, dumpOptions);\n            }\n        }\n        return false;\n    },\n\n    requestViewUpdate: function(view, flag, priority, opt) {\n        opt || (opt = {});\n        this.scheduleViewUpdate(view, flag, priority, opt);\n        var isAsync = this.isAsync();\n        if (this.isFrozen() || (isAsync && opt.async !== false)) return;\n        if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;\n        var stats = this.updateViews(opt);\n        if (isAsync) this.notifyAfterRender(stats, opt);\n    },\n\n    scheduleViewUpdate: function(view, type, priority, opt) {\n        const { _updates: updates, options } = this;\n        if (updates.idle) {\n            if (options.autoFreeze) {\n                updates.idle = false;\n                this.unfreeze();\n            }\n        }\n        const { FLAG_REMOVE, FLAG_INSERT, UPDATE_PRIORITY, cid } = view;\n        let priorityUpdates = updates.priorities[priority];\n        if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};\n        // Move higher priority updates to this priority\n        if (priority > UPDATE_PRIORITY) {\n            // Not the default priority for this view. It's most likely a link view\n            // connected to another link view, which triggered the update.\n            // TODO: If there is an update scheduled with a lower priority already, we should\n            // change the requested priority to the lowest one. Does not seem to be critical\n            // right now, as it \"only\" results in multiple updates on the same view.\n            for (let i = priority - 1; i >= UPDATE_PRIORITY; i--) {\n                const prevPriorityUpdates = updates.priorities[i];\n                if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;\n                priorityUpdates[cid] |= prevPriorityUpdates[cid];\n                delete prevPriorityUpdates[cid];\n            }\n        }\n        let currentType = priorityUpdates[cid] || 0;\n        // Prevent cycling\n        if ((currentType & type) === type) return;\n        if (!currentType) updates.count++;\n        if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {\n            // When a view is removed we need to remove the insert flag as this is a reinsert\n            priorityUpdates[cid] ^= FLAG_INSERT;\n        } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {\n            // When a view is added we need to remove the remove flag as this is view was previously removed\n            priorityUpdates[cid] ^= FLAG_REMOVE;\n        }\n        priorityUpdates[cid] |= type;\n        const viewUpdateFn = options.onViewUpdate;\n        if (typeof viewUpdateFn === 'function') viewUpdateFn.call(this, view, type, priority, opt || {}, this);\n    },\n\n    dumpViewUpdate: function(view) {\n        if (!view) return 0;\n        var updates = this._updates;\n        var cid = view.cid;\n        var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];\n        var flag = this.registerMountedView(view) | priorityUpdates[cid];\n        delete priorityUpdates[cid];\n        return flag;\n    },\n\n    dumpView: function(view, opt = {}) {\n        const flag = this.dumpViewUpdate(view);\n        if (!flag) return 0;\n        const shouldNotify = !opt.silent;\n        if (shouldNotify) this.notifyBeforeRender(opt);\n        const leftover = this.updateView(view, flag, opt);\n        if (shouldNotify) {\n            const stats = { updated: 1, priority: view.UPDATE_PRIORITY };\n            this.notifyAfterRender(stats, opt);\n        }\n        return leftover;\n    },\n\n    updateView: function(view, flag, opt) {\n        if (!view) return 0;\n        const { FLAG_REMOVE, FLAG_INSERT, FLAG_INIT, model } = view;\n        if (view instanceof CellView) {\n            if (flag & FLAG_REMOVE) {\n                this.removeView(model);\n                return 0;\n            }\n            if (flag & FLAG_INSERT) {\n                const isInitialInsert = !!(flag & FLAG_INIT);\n                if (isInitialInsert) {\n                    flag ^= FLAG_INIT;\n                }\n                this.insertView(view, isInitialInsert);\n                flag ^= FLAG_INSERT;\n            }\n        }\n        if (!flag) return 0;\n        return view.confirmUpdate(flag, opt || {});\n    },\n\n    requireView: function(model, opt) {\n        var view = this.findViewByModel(model);\n        if (!view) return null;\n        this.dumpView(view, opt);\n        return view;\n    },\n\n    registerUnmountedView: function(view) {\n        var cid = view.cid;\n        var updates = this._updates;\n        if (cid in updates.unmounted) return 0;\n        var flag = updates.unmounted[cid] |= view.FLAG_INSERT;\n        updates.unmountedCids.push(cid);\n        delete updates.mounted[cid];\n        return flag;\n    },\n\n    registerMountedView: function(view) {\n        var cid = view.cid;\n        var updates = this._updates;\n        if (cid in updates.mounted) return 0;\n        updates.mounted[cid] = true;\n        updates.mountedCids.push(cid);\n        var flag = updates.unmounted[cid] || 0;\n        delete updates.unmounted[cid];\n        return flag;\n    },\n\n    isViewMounted: function(view) {\n        if (!view) return false;\n        var cid = view.cid;\n        var updates = this._updates;\n        return (cid in updates.mounted);\n    },\n\n    dumpViews: function(opt) {\n        var passingOpt = defaults({}, opt, { viewport: null });\n        this.checkViewport(passingOpt);\n        this.updateViews(passingOpt);\n    },\n\n    // Synchronous views update\n    updateViews: function(opt) {\n        this.notifyBeforeRender(opt);\n        let batchStats;\n        let updateCount = 0;\n        let batchCount = 0;\n        let priority = MIN_PRIORITY;\n        do {\n            batchCount++;\n            batchStats = this.updateViewsBatch(opt);\n            updateCount += batchStats.updated;\n            priority = Math.min(batchStats.priority, priority);\n        } while (!batchStats.empty);\n        const stats = { updated: updateCount, batches: batchCount, priority };\n        this.notifyAfterRender(stats, opt);\n        return stats;\n    },\n\n    hasScheduledUpdates: function() {\n        const priorities = this._updates.priorities;\n        const priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n        let i = priorityIndexes.length;\n        while (i > 0 && i--) {\n            // a faster way how to check if an object is empty\n            for (let _key in priorities[priorityIndexes[i]]) return true;\n        }\n        return false;\n    },\n\n    updateViewsAsync: function(opt, data) {\n        opt || (opt = {});\n        data || (data = { processed: 0, priority: MIN_PRIORITY });\n        const { _updates: updates, options } = this;\n        const id = updates.id;\n        if (id) {\n            cancelFrame(id);\n            if (data.processed === 0 && this.hasScheduledUpdates()) {\n                this.notifyBeforeRender(opt);\n            }\n            const stats = this.updateViewsBatch(opt);\n            const passingOpt = defaults({}, opt, {\n                mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,\n                unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted\n            });\n            const checkStats = this.checkViewport(passingOpt);\n            const unmountCount = checkStats.unmounted;\n            const mountCount = checkStats.mounted;\n            let processed = data.processed;\n            const total = updates.count;\n            if (stats.updated > 0) {\n                // Some updates have been just processed\n                processed += stats.updated + stats.unmounted;\n                stats.processed = processed;\n                data.priority = Math.min(stats.priority, data.priority);\n                if (stats.empty && mountCount === 0) {\n                    stats.unmounted += unmountCount;\n                    stats.mounted += mountCount;\n                    stats.priority = data.priority;\n                    this.notifyAfterRender(stats, opt);\n                    data.processed = 0;\n                    data.priority = MIN_PRIORITY;\n                    updates.count = 0;\n                } else {\n                    data.processed = processed;\n                }\n            } else {\n                if (!updates.idle) {\n                    if (options.autoFreeze) {\n                        this.freeze();\n                        updates.idle = true;\n                        this.trigger('render:idle', opt);\n                    }\n                }\n            }\n            // Progress callback\n            const progressFn = opt.progress;\n            if (total && typeof progressFn === 'function') {\n                progressFn.call(this, stats.empty, processed, total, stats, this);\n            }\n            // The current frame could have been canceled in a callback\n            if (updates.id !== id) return;\n        }\n        if (updates.disabled) {\n            throw new Error('dia.Paper: can not unfreeze the paper after it was removed');\n        }\n        updates.id = nextFrame(this.updateViewsAsync, this, opt, data);\n    },\n\n    notifyBeforeRender: function(opt = {}) {\n        let beforeFn = opt.beforeRender;\n        if (typeof beforeFn !== 'function') {\n            beforeFn = this.options.beforeRender;\n            if (typeof beforeFn !== 'function') return;\n        }\n        beforeFn.call(this, opt, this);\n    },\n\n    notifyAfterRender: function(stats, opt = {}) {\n        let afterFn = opt.afterRender;\n        if (typeof afterFn !== 'function') {\n            afterFn = this.options.afterRender;\n        }\n        if (typeof afterFn === 'function') {\n            afterFn.call(this, stats, opt, this);\n        }\n        this.trigger('render:done', stats, opt);\n    },\n\n    updateViewsBatch: function(opt) {\n        opt || (opt = {});\n        var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;\n        var updates = this._updates;\n        var updateCount = 0;\n        var postponeCount = 0;\n        var unmountCount = 0;\n        var mountCount = 0;\n        var maxPriority = MIN_PRIORITY;\n        var empty = true;\n        var options = this.options;\n        var priorities = updates.priorities;\n        var viewportFn = 'viewport' in opt ? opt.viewport : options.viewport;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        var postponeViewFn = options.onViewPostponed;\n        if (typeof postponeViewFn !== 'function') postponeViewFn = null;\n        var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n        main: for (var i = 0, n = priorityIndexes.length; i < n; i++) {\n            var priority = +priorityIndexes[i];\n            var priorityUpdates = priorities[priority];\n            for (var cid in priorityUpdates) {\n                if (updateCount >= batchSize) {\n                    empty = false;\n                    break main;\n                }\n                var view = views[cid];\n                if (!view) {\n                    // This should not occur\n                    delete priorityUpdates[cid];\n                    continue;\n                }\n                var currentFlag = priorityUpdates[cid];\n                if ((currentFlag & view.FLAG_REMOVE) === 0) {\n                    // We should never check a view for viewport if we are about to remove the view\n                    var isDetached = cid in updates.unmounted;\n                    if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, !isDetached, this)) {\n                        // Unmount View\n                        if (!isDetached) {\n                            this.registerUnmountedView(view);\n                            this.detachView(view);\n                        }\n                        updates.unmounted[cid] |= currentFlag;\n                        delete priorityUpdates[cid];\n                        unmountCount++;\n                        continue;\n                    }\n                    // Mount View\n                    if (isDetached) {\n                        currentFlag |= view.FLAG_INSERT;\n                        mountCount++;\n                    }\n                    currentFlag |= this.registerMountedView(view);\n                }\n                var leftoverFlag = this.updateView(view, currentFlag, opt);\n                if (leftoverFlag > 0) {\n                    // View update has not finished completely\n                    priorityUpdates[cid] = leftoverFlag;\n                    if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {\n                        postponeCount++;\n                        empty = false;\n                        continue;\n                    }\n                }\n                if (maxPriority > priority) maxPriority = priority;\n                updateCount++;\n                delete priorityUpdates[cid];\n            }\n        }\n        return {\n            priority: maxPriority,\n            updated: updateCount,\n            postponed: postponeCount,\n            unmounted: unmountCount,\n            mounted: mountCount,\n            empty: empty\n        };\n    },\n\n    getUnmountedViews: function() {\n        const updates = this._updates;\n        const unmountedCids = Object.keys(updates.unmounted);\n        const n = unmountedCids.length;\n        const unmountedViews = new Array(n);\n        for (var i = 0; i < n; i++) {\n            unmountedViews[i] = views[unmountedCids[i]];\n        }\n        return unmountedViews;\n    },\n\n    getMountedViews: function() {\n        const updates = this._updates;\n        const mountedCids = Object.keys(updates.mounted);\n        const n = mountedCids.length;\n        const mountedViews = new Array(n);\n        for (var i = 0; i < n; i++) {\n            mountedViews[i] = views[mountedCids[i]];\n        }\n        return mountedViews;\n    },\n\n    checkUnmountedViews: function(viewportFn, opt) {\n        opt || (opt  = {});\n        var mountCount = 0;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        var batchSize = 'mountBatchSize' in opt ? opt.mountBatchSize : Infinity;\n        var updates = this._updates;\n        var unmountedCids = updates.unmountedCids;\n        var unmounted = updates.unmounted;\n        for (var i = 0, n = Math.min(unmountedCids.length, batchSize); i < n; i++) {\n            var cid = unmountedCids[i];\n            if (!(cid in unmounted)) continue;\n            var view = views[cid];\n            if (!view) continue;\n            if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, false, this)) {\n                // Push at the end of all unmounted ids, so this can be check later again\n                unmountedCids.push(cid);\n                continue;\n            }\n            mountCount++;\n            var flag = this.registerMountedView(view);\n            if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, { mounting: true });\n        }\n        // Get rid of views, that have been mounted\n        unmountedCids.splice(0, i);\n        return mountCount;\n    },\n\n    checkMountedViews: function(viewportFn, opt) {\n        opt || (opt = {});\n        var unmountCount = 0;\n        if (typeof viewportFn !== 'function') return unmountCount;\n        var batchSize = 'unmountBatchSize' in opt ? opt.unmountBatchSize : Infinity;\n        var updates = this._updates;\n        var mountedCids = updates.mountedCids;\n        var mounted = updates.mounted;\n        for (var i = 0, n = Math.min(mountedCids.length, batchSize); i < n; i++) {\n            var cid = mountedCids[i];\n            if (!(cid in mounted)) continue;\n            var view = views[cid];\n            if (!view) continue;\n            if (!view.DETACHABLE || viewportFn.call(this, view, true, this)) {\n                // Push at the end of all mounted ids, so this can be check later again\n                mountedCids.push(cid);\n                continue;\n            }\n            unmountCount++;\n            var flag = this.registerUnmountedView(view);\n            if (flag) this.detachView(view);\n        }\n        // Get rid of views, that have been unmounted\n        mountedCids.splice(0, i);\n        return unmountCount;\n    },\n\n    checkViewVisibility: function(cellView, opt = {}) {\n        let viewportFn = 'viewport' in opt ? opt.viewport : this.options.viewport;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        const updates = this._updates;\n        const { mounted, unmounted } = updates;\n        const visible = !cellView.DETACHABLE || !viewportFn || viewportFn.call(this, cellView, false, this);\n\n        let isUnmounted = false;\n        let isMounted = false;\n\n        if (cellView.cid in mounted && !visible) {\n            const flag = this.registerUnmountedView(cellView);\n            if (flag) this.detachView(cellView);\n            const i = updates.mountedCids.indexOf(cellView.cid);\n            updates.mountedCids.splice(i, 1);\n            isUnmounted = true;\n        }\n\n        if (!isUnmounted && cellView.cid in unmounted && visible) {\n            const i = updates.unmountedCids.indexOf(cellView.cid);\n            updates.unmountedCids.splice(i, 1);\n            var flag = this.registerMountedView(cellView);\n            if (flag) this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, { mounting: true });\n            isMounted = true;\n        }\n\n        return {\n            mounted: isMounted ? 1 : 0,\n            unmounted: isUnmounted ? 1 : 0\n        };\n    },\n\n    checkViewport: function(opt) {\n        var passingOpt = defaults({}, opt, {\n            mountBatchSize: Infinity,\n            unmountBatchSize: Infinity\n        });\n        var viewportFn = 'viewport' in passingOpt ? passingOpt.viewport : this.options.viewport;\n        var unmountedCount = this.checkMountedViews(viewportFn, passingOpt);\n        if (unmountedCount > 0) {\n            // Do not check views, that have been just unmounted and pushed at the end of the cids array\n            var unmountedCids = this._updates.unmountedCids;\n            passingOpt.mountBatchSize = Math.min(unmountedCids.length - unmountedCount, passingOpt.mountBatchSize);\n        }\n        var mountedCount = this.checkUnmountedViews(viewportFn, passingOpt);\n        return {\n            mounted: mountedCount,\n            unmounted: unmountedCount\n        };\n    },\n\n    freeze: function(opt) {\n        opt || (opt = {});\n        var updates = this._updates;\n        var key = opt.key;\n        var isFrozen = this.options.frozen;\n        var freezeKey = updates.freezeKey;\n        if (key && key !== freezeKey)  {\n            // key passed, but the paper is already freezed with another key\n            if (isFrozen && freezeKey) return;\n            updates.freezeKey = key;\n            updates.keyFrozen = isFrozen;\n        }\n        this.options.frozen = true;\n        var id = updates.id;\n        updates.id = null;\n        if (this.isAsync() && id) cancelFrame(id);\n    },\n\n    unfreeze: function(opt) {\n        opt || (opt = {});\n        var updates = this._updates;\n        var key = opt.key;\n        var freezeKey = updates.freezeKey;\n        // key passed, but the paper is already freezed with another key\n        if (key && freezeKey && key !== freezeKey) return;\n        updates.freezeKey = null;\n        // key passed, but the paper is already freezed\n        if (key && key === freezeKey && updates.keyFrozen) return;\n        if (this.isAsync()) {\n            this.freeze();\n            this.updateViewsAsync(opt);\n        } else {\n            this.updateViews(opt);\n        }\n        this.options.frozen = updates.keyFrozen = false;\n        if (updates.sort) {\n            this.sortViews();\n            updates.sort = false;\n        }\n    },\n\n    isAsync: function() {\n        return !!this.options.async;\n    },\n\n    isFrozen: function() {\n        return !!this.options.frozen;\n    },\n\n    isExactSorting: function() {\n        return this.options.sorting === sortingTypes.EXACT;\n    },\n\n    onRemove: function() {\n\n        this.freeze();\n        this._updates.disabled = true;\n        //clean up all DOM elements/views to prevent memory leaks\n        this.removeLayers();\n        this.removeViews();\n    },\n\n    getComputedSize: function() {\n\n        var options = this.options;\n        var w = options.width;\n        var h = options.height;\n        if (!isNumber(w)) w = this.el.clientWidth;\n        if (!isNumber(h)) h = this.el.clientHeight;\n        return { width: w, height: h };\n    },\n\n    setDimensions: function(width, height, data = {}) {\n        const { options } = this;\n        const { width: currentWidth, height: currentHeight } = options;\n        let w = (width === undefined) ? currentWidth : width;\n        let h = (height === undefined) ? currentHeight : height;\n        if (currentWidth === w && currentHeight === h) return;\n        options.width = w;\n        options.height = h;\n        this._setDimensions();\n        const computedSize = this.getComputedSize();\n        this.trigger('resize', computedSize.width, computedSize.height, data);\n    },\n\n    _setDimensions: function() {\n        const { options } = this;\n        let w = options.width;\n        let h = options.height;\n        if (isNumber(w)) w = `${Math.round(w)}px`;\n        if (isNumber(h)) h = `${Math.round(h)}px`;\n        this.$el.css({\n            width: (w === null) ? '' : w,\n            height: (h === null) ? '' : h\n        });\n    },\n\n    // Expand/shrink the paper to fit the content.\n    // Alternatively signature function(opt)\n    fitToContent: function(gridWidth, gridHeight, padding, opt) {\n\n        if (isObject(gridWidth)) {\n            // first parameter is an option object\n            opt = gridWidth;\n        } else {\n            // Support for a deprecated signature\n            opt = assign({ gridWidth, gridHeight, padding }, opt);\n        }\n\n        const { x, y, width, height } = this.getFitToContentArea(opt);\n        const { sx, sy } = this.scale();\n\n        this.translate(-x * sx, -y * sy, opt);\n        this.setDimensions(width * sx, height * sy, opt);\n\n        return new Rect(x, y, width, height);\n    },\n\n    getFitToContentArea: function(opt = {}) {\n\n        // Calculate the paper size to accommodate all the graph's elements.\n\n        const gridWidth = opt.gridWidth || 1;\n        const gridHeight = opt.gridHeight || 1;\n        const padding = normalizeSides(opt.padding || 0);\n\n        const minWidth = Math.max(opt.minWidth || 0, gridWidth);\n        const minHeight = Math.max(opt.minHeight || 0, gridHeight);\n        const maxWidth = opt.maxWidth || Number.MAX_VALUE;\n        const maxHeight = opt.maxHeight || Number.MAX_VALUE;\n        const newOrigin = opt.allowNewOrigin;\n\n        const area = ('contentArea' in opt) ? new Rect(opt.contentArea) : this.getContentArea(opt);\n        const { sx, sy } = this.scale();\n        area.x *= sx;\n        area.y *= sy;\n        area.width *= sx;\n        area.height *= sy;\n\n        let calcWidth = Math.ceil((area.width + area.x) / gridWidth);\n        let calcHeight = Math.ceil((area.height + area.y) / gridHeight);\n        if (!opt.allowNegativeBottomRight) {\n            calcWidth = Math.max(calcWidth, 1);\n            calcHeight = Math.max(calcHeight, 1);\n        }\n        calcWidth *= gridWidth;\n        calcHeight *= gridHeight;\n\n        let tx = 0;\n        if ((newOrigin === 'negative' && area.x < 0) || (newOrigin === 'positive' && area.x >= 0) || newOrigin === 'any') {\n            tx = Math.ceil(-area.x / gridWidth) * gridWidth;\n            tx += padding.left;\n            calcWidth += tx;\n        }\n\n        let ty = 0;\n        if ((newOrigin === 'negative' && area.y < 0) || (newOrigin === 'positive' && area.y >= 0) || newOrigin === 'any') {\n            ty = Math.ceil(-area.y / gridHeight) * gridHeight;\n            ty += padding.top;\n            calcHeight += ty;\n        }\n\n        calcWidth += padding.right;\n        calcHeight += padding.bottom;\n\n        // Make sure the resulting width and height are greater than minimum.\n        calcWidth = Math.max(calcWidth, minWidth);\n        calcHeight = Math.max(calcHeight, minHeight);\n\n        // Make sure the resulting width and height are lesser than maximum.\n        calcWidth = Math.min(calcWidth, maxWidth);\n        calcHeight = Math.min(calcHeight, maxHeight);\n\n        return new Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);\n    },\n\n    transformToFitContent: function(opt) {\n        opt || (opt = {});\n\n        let contentBBox, contentLocalOrigin;\n        if ('contentArea' in opt) {\n            const contentArea = opt.contentArea;\n            contentBBox = this.localToPaperRect(contentArea);\n            contentLocalOrigin = new Point(contentArea);\n        } else {\n            contentBBox = this.getContentBBox(opt);\n            contentLocalOrigin = this.paperToLocalPoint(contentBBox);\n        }\n\n        if (!contentBBox.width || !contentBBox.height) return;\n\n        defaults(opt, {\n            padding: 0,\n            preserveAspectRatio: true,\n            scaleGrid: null,\n            minScale: 0,\n            maxScale: Number.MAX_VALUE,\n            verticalAlign: 'top',\n            horizontalAlign: 'left',\n            //minScaleX\n            //minScaleY\n            //maxScaleX\n            //maxScaleY\n            //fittingBBox\n        });\n\n        const padding = normalizeSides(opt.padding);\n\n        const minScaleX = opt.minScaleX || opt.minScale;\n        const maxScaleX = opt.maxScaleX || opt.maxScale;\n        const minScaleY = opt.minScaleY || opt.minScale;\n        const maxScaleY = opt.maxScaleY || opt.maxScale;\n\n        let fittingBBox;\n        if (opt.fittingBBox) {\n            fittingBBox = opt.fittingBBox;\n        } else {\n            const currentTranslate = this.translate();\n            const computedSize = this.getComputedSize();\n            fittingBBox = {\n                x: currentTranslate.tx,\n                y: currentTranslate.ty,\n                width: computedSize.width,\n                height: computedSize.height\n            };\n        }\n\n        fittingBBox = new Rect(fittingBBox).moveAndExpand({\n            x: padding.left,\n            y: padding.top,\n            width: -padding.left - padding.right,\n            height: -padding.top - padding.bottom\n        });\n\n        const ctm = this.matrix();\n        const { a: sx, d: sy, e: tx, f: ty } = ctm;\n\n        let newSx = fittingBBox.width / contentBBox.width * sx;\n        let newSy = fittingBBox.height / contentBBox.height * sy;\n\n        if (opt.preserveAspectRatio) {\n            newSx = newSy = Math.min(newSx, newSy);\n        }\n\n        // snap scale to a grid\n        if (opt.scaleGrid) {\n\n            const gridSize = opt.scaleGrid;\n\n            newSx = gridSize * Math.floor(newSx / gridSize);\n            newSy = gridSize * Math.floor(newSy / gridSize);\n        }\n\n        // scale min/max boundaries\n        newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));\n        newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));\n\n        const scaleDiff = {\n            x: newSx / sx,\n            y: newSy / sy\n        };\n\n        let newOx = fittingBBox.x - contentLocalOrigin.x * newSx - tx;\n        let newOy = fittingBBox.y - contentLocalOrigin.y * newSy - ty;\n\n        switch (opt.verticalAlign) {\n            case 'middle':\n                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;\n                break;\n            case 'bottom':\n                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);\n                break;\n            case 'top':\n            default:\n                break;\n        }\n\n        switch (opt.horizontalAlign) {\n            case 'middle':\n                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;\n                break;\n            case 'right':\n                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);\n                break;\n            case 'left':\n            default:\n                break;\n        }\n\n        ctm.a = newSx;\n        ctm.d = newSy;\n        ctm.e = newOx;\n        ctm.f = newOy;\n        this.matrix(ctm, opt);\n    },\n\n    scaleContentToFit: function(opt) {\n        this.transformToFitContent(opt);\n    },\n\n    // Return the dimensions of the content area in local units (without transformations).\n    getContentArea: function(opt) {\n\n        if (opt && opt.useModelGeometry) {\n            return this.model.getBBox() || new Rect();\n        }\n\n        return V(this.cells).getBBox();\n    },\n\n    // Return the dimensions of the content bbox in the paper units (as it appears on screen).\n    getContentBBox: function(opt) {\n\n        return this.localToPaperRect(this.getContentArea(opt));\n    },\n\n    // Returns a geometry rectangle representing the entire\n    // paper area (coordinates from the left paper border to the right one\n    // and the top border to the bottom one).\n    getArea: function() {\n\n        return this.paperToLocalRect(this.getComputedSize());\n    },\n\n    getRestrictedArea: function(...args) {\n\n        const { restrictTranslate } = this.options;\n\n        let restrictedArea;\n        if (isFunction(restrictTranslate)) {\n            // A method returning a bounding box\n            restrictedArea = restrictTranslate.apply(this, args);\n        } else if (restrictTranslate === true) {\n            // The paper area\n            restrictedArea = this.getArea();\n        } else if (!restrictTranslate) {\n            // falsy value\n            restrictedArea = null;\n        } else {\n            // any other value\n            restrictedArea = new Rect(restrictTranslate);\n        }\n\n        return restrictedArea;\n    },\n\n    createViewForModel: function(cell) {\n\n        const { options } = this;\n        // A class taken from the paper options.\n        var optionalViewClass;\n\n        // A default basic class (either dia.ElementView or dia.LinkView)\n        var defaultViewClass;\n\n        // A special class defined for this model in the corresponding namespace.\n        // e.g. joint.shapes.standard.Rectangle searches for joint.shapes.standard.RectangleView\n        var namespace = options.cellViewNamespace;\n        var type = cell.get('type') + 'View';\n        var namespaceViewClass = getByPath(namespace, type, '.');\n\n        if (cell.isLink()) {\n            optionalViewClass = options.linkView;\n            defaultViewClass = LinkView;\n        } else {\n            optionalViewClass = options.elementView;\n            defaultViewClass = ElementView;\n        }\n\n        // a) the paper options view is a class (deprecated)\n        //  1. search the namespace for a view\n        //  2. if no view was found, use view from the paper options\n        // b) the paper options view is a function\n        //  1. call the function from the paper options\n        //  2. if no view was return, search the namespace for a view\n        //  3. if no view was found, use the default\n        var ViewClass = (optionalViewClass.prototype instanceof ViewBase)\n            ? namespaceViewClass || optionalViewClass\n            : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;\n\n        return new ViewClass({\n            model: cell,\n            interactive: options.interactive,\n            labelsLayer: options.labelsLayer === true ? LayersNames.LABELS : options.labelsLayer\n        });\n    },\n\n    removeView: function(cell) {\n\n        const { id } = cell;\n        const { _views, _updates } = this;\n        const view = _views[id];\n        if (view) {\n            var { cid } = view;\n            const { mounted, unmounted } = _updates;\n            view.remove();\n            delete _views[id];\n            delete mounted[cid];\n            delete unmounted[cid];\n        }\n        return view;\n    },\n\n    renderView: function(cell, opt) {\n\n        const { id } = cell;\n        const views = this._views;\n        let view, flag;\n        let create = true;\n        if (id in views) {\n            view = views[id];\n            if (view.model === cell) {\n                flag = view.FLAG_INSERT;\n                create = false;\n            } else {\n                // The view for this `id` already exist.\n                // The cell is a new instance of the model with identical id\n                // We simply remove the existing view and create a new one\n                this.removeView(cell);\n            }\n        }\n        if (create) {\n            view = views[id] = this.createViewForModel(cell);\n            view.paper = this;\n            flag = this.registerUnmountedView(view) | this.FLAG_INIT | view.getFlag(result(view, 'initFlag'));\n        }\n        this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);\n        return view;\n    },\n\n    onImageDragStart: function() {\n        // This is the only way to prevent image dragging in Firefox that works.\n        // Setting -moz-user-select: none, draggable=\"false\" attribute or user-drag: none didn't help.\n\n        return false;\n    },\n\n    resetViews: function(cells, opt) {\n        opt || (opt = {});\n        cells || (cells = []);\n        this._resetUpdates();\n        // clearing views removes any event listeners\n        this.removeViews();\n        // Allows to unfreeze normally while in the idle state using autoFreeze option\n        const key = this.options.autoFreeze ? null : 'reset';\n        this.freeze({ key });\n        for (var i = 0, n = cells.length; i < n; i++) {\n            this.renderView(cells[i], opt);\n        }\n        this.unfreeze({ key });\n        this.sortViews();\n    },\n\n    removeViews: function() {\n\n        invoke(this._views, 'remove');\n\n        this._views = {};\n    },\n\n    sortViews: function() {\n\n        if (!this.isExactSorting()) {\n            // noop\n            return;\n        }\n        if (this.isFrozen()) {\n            // sort views once unfrozen\n            this._updates.sort = true;\n            return;\n        }\n        this.sortViewsExact();\n    },\n\n    sortViewsExact: function() {\n\n        // Run insertion sort algorithm in order to efficiently sort DOM elements according to their\n        // associated model `z` attribute.\n\n        var cellNodes = Array.from(this.cells.childNodes).filter(node => node.getAttribute('model-id'));\n        var cells = this.model.get('cells');\n\n        sortElements(cellNodes, function(a, b) {\n            var cellA = cells.get(a.getAttribute('model-id'));\n            var cellB = cells.get(b.getAttribute('model-id'));\n            var zA = cellA.attributes.z || 0;\n            var zB = cellB.attributes.z || 0;\n            return (zA === zB) ? 0 : (zA < zB) ? -1 : 1;\n        });\n    },\n\n    insertView: function(view, isInitialInsert) {\n        const layerView = this.getLayerView(LayersNames.CELLS);\n        const { el, model } = view;\n        switch (this.options.sorting) {\n            case sortingTypes.APPROX:\n                layerView.insertSortedNode(el, model.get('z'));\n                break;\n            case sortingTypes.EXACT:\n            default:\n                layerView.insertNode(el);\n                break;\n        }\n        view.onMount(isInitialInsert);\n    },\n\n    detachView(view) {\n        view.unmount();\n        view.onDetach();\n    },\n\n    // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also\n    // be a selector or a jQuery object.\n    findView: function($el) {\n\n        var el = isString($el)\n            ? this.cells.querySelector($el)\n            : $el instanceof $ ? $el[0] : $el;\n\n        var id = this.findAttribute('model-id', el);\n        if (id) return this._views[id];\n\n        return undefined;\n    },\n\n    // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.\n    findViewByModel: function(cell) {\n\n        var id = (isString(cell) || isNumber(cell)) ? cell : (cell && cell.id);\n\n        return this._views[id];\n    },\n\n    // Find all views at given point\n    findViewsFromPoint: function(p) {\n\n        p = new Point(p);\n\n        var views = this.model.getElements().map(this.findViewByModel, this);\n\n        return views.filter(function(view) {\n            return view && view.vel.getBBox({ target: this.cells }).containsPoint(p);\n        }, this);\n    },\n\n    // Find all views in given area\n    findViewsInArea: function(rect, opt) {\n\n        opt = defaults(opt || {}, { strict: false });\n        rect = new Rect(rect);\n\n        var views = this.model.getElements().map(this.findViewByModel, this);\n        var method = opt.strict ? 'containsRect' : 'intersect';\n\n        return views.filter(function(view) {\n            return view && rect[method](view.vel.getBBox({ target: this.cells }));\n        }, this);\n    },\n\n    removeTools: function() {\n        this.dispatchToolsEvent('remove');\n        return this;\n    },\n\n    hideTools: function() {\n        this.dispatchToolsEvent('hide');\n        return this;\n    },\n\n    showTools: function() {\n        this.dispatchToolsEvent('show');\n        return this;\n    },\n\n    dispatchToolsEvent: function(event, ...args) {\n        if (typeof event !== 'string') return;\n        this.trigger('tools:event', event, ...args);\n    },\n\n\n    getModelById: function(id) {\n\n        return this.model.getCell(id);\n    },\n\n    snapToGrid: function(x, y) {\n\n        // Convert global coordinates to the local ones of the `viewport`. Otherwise,\n        // improper transformation would be applied when the viewport gets transformed (scaled/rotated).\n        return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);\n    },\n\n    localToPaperPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var localPoint = new Point(x, y);\n        var paperPoint = V.transformPoint(localPoint, this.matrix());\n        return paperPoint;\n    },\n\n    localToPaperRect: function(x, y, width, height) {\n        // allow `x` to be a rectangle and rest arguments undefined\n        var localRect = new Rect(x, y, width, height);\n        var paperRect = V.transformRect(localRect, this.matrix());\n        return paperRect;\n    },\n\n    paperToLocalPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var paperPoint = new Point(x, y);\n        var localPoint = V.transformPoint(paperPoint, this.matrix().inverse());\n        return localPoint;\n    },\n\n    paperToLocalRect: function(x, y, width, height) {\n        // allow `x` to be a rectangle and rest arguments undefined\n        var paperRect = new Rect(x, y, width, height);\n        var localRect = V.transformRect(paperRect, this.matrix().inverse());\n        return localRect;\n    },\n\n    localToClientPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var localPoint = new Point(x, y);\n        var clientPoint = V.transformPoint(localPoint, this.clientMatrix());\n        return clientPoint;\n    },\n\n    localToClientRect: function(x, y, width, height) {\n        // allow `x` to be a point and `y` undefined\n        var localRect = new Rect(x, y, width, height);\n        var clientRect = V.transformRect(localRect, this.clientMatrix());\n        return clientRect;\n    },\n\n    // Transform client coordinates to the paper local coordinates.\n    // Useful when you have a mouse event object and you'd like to get coordinates\n    // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.\n    // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\n    clientToLocalPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var clientPoint = new Point(x, y);\n        var localPoint = V.transformPoint(clientPoint, this.clientMatrix().inverse());\n        return localPoint;\n    },\n\n    clientToLocalRect: function(x, y, width, height) {\n        // allow `x` to be a point and `y` undefined\n        var clientRect = new Rect(x, y, width, height);\n        var localRect = V.transformRect(clientRect, this.clientMatrix().inverse());\n        return localRect;\n    },\n\n    localToPagePoint: function(x, y) {\n\n        return this.localToPaperPoint(x, y).offset(this.pageOffset());\n    },\n\n    localToPageRect: function(x, y, width, height) {\n\n        return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());\n    },\n\n    pageToLocalPoint: function(x, y) {\n\n        var pagePoint = new Point(x, y);\n        var paperPoint = pagePoint.difference(this.pageOffset());\n        return this.paperToLocalPoint(paperPoint);\n    },\n\n    pageToLocalRect: function(x, y, width, height) {\n\n        var pageOffset = this.pageOffset();\n        var paperRect = new Rect(x, y, width, height);\n        paperRect.x -= pageOffset.x;\n        paperRect.y -= pageOffset.y;\n        return this.paperToLocalRect(paperRect);\n    },\n\n    clientOffset: function() {\n\n        var clientRect = this.svg.getBoundingClientRect();\n        return new Point(clientRect.left, clientRect.top);\n    },\n\n    pageOffset: function() {\n\n        return this.clientOffset().offset(window.scrollX, window.scrollY);\n    },\n\n    linkAllowed: function(linkView) {\n\n        if (!(linkView instanceof LinkView)) {\n            throw new Error('Must provide a linkView.');\n        }\n\n        var link = linkView.model;\n        var paperOptions = this.options;\n        var graph = this.model;\n        var ns = graph.constructor.validations;\n\n        if (!paperOptions.multiLinks) {\n            if (!ns.multiLinks.call(this, graph, link)) return false;\n        }\n\n        if (!paperOptions.linkPinning) {\n            // Link pinning is not allowed and the link is not connected to the target.\n            if (!ns.linkPinning.call(this, graph, link)) return false;\n        }\n\n        if (typeof paperOptions.allowLink === 'function') {\n            if (!paperOptions.allowLink.call(this, linkView, this)) return false;\n        }\n\n        return true;\n    },\n\n    getDefaultLink: function(cellView, magnet) {\n\n        return isFunction(this.options.defaultLink)\n        // default link is a function producing link model\n            ? this.options.defaultLink.call(this, cellView, magnet)\n        // default link is the mvc model\n            : this.options.defaultLink.clone();\n    },\n\n    // Cell highlighting.\n    // ------------------\n\n    resolveHighlighter: function(opt = {}) {\n\n        let { highlighter: highlighterDef, type } = opt;\n        const { highlighting,highlighterNamespace  } = this.options;\n\n        /*\n            Expecting opt.highlighter to have the following structure:\n            {\n                name: 'highlighter-name',\n                options: {\n                    some: 'value'\n                }\n            }\n        */\n        if (highlighterDef === undefined) {\n\n            // Is highlighting disabled?\n            if (!highlighting) return false;\n            // check for built-in types\n            if (type) {\n                highlighterDef = highlighting[type];\n                // Is a specific type highlight disabled?\n                if (highlighterDef === false) return false;\n            }\n            if (!highlighterDef) {\n                // Type not defined use default highlight\n                highlighterDef = highlighting['default'];\n            }\n        }\n\n        // Do nothing if opt.highlighter is falsy.\n        // This allows the case to not highlight cell(s) in certain cases.\n        // For example, if you want to NOT highlight when embedding elements\n        // or use a custom highlighter.\n        if (!highlighterDef) return false;\n\n        // Allow specifying a highlighter by name.\n        if (isString(highlighterDef)) {\n            highlighterDef = {\n                name: highlighterDef\n            };\n        }\n\n        const name = highlighterDef.name;\n        const highlighter = highlighterNamespace[name];\n\n        // Highlighter validation\n        if (!highlighter) {\n            throw new Error('Unknown highlighter (\"' + name + '\")');\n        }\n        if (typeof highlighter.highlight !== 'function') {\n            throw new Error('Highlighter (\"' + name + '\") is missing required highlight() method');\n        }\n        if (typeof highlighter.unhighlight !== 'function') {\n            throw new Error('Highlighter (\"' + name + '\") is missing required unhighlight() method');\n        }\n\n        return {\n            highlighter,\n            options: highlighterDef.options || {},\n            name\n        };\n    },\n\n    onCellHighlight: function(cellView, magnetEl, opt) {\n        const highlighterDescriptor = this.resolveHighlighter(opt);\n        if (!highlighterDescriptor) return;\n        const { highlighter, options } = highlighterDescriptor;\n        highlighter.highlight(cellView, magnetEl, options);\n    },\n\n    onCellUnhighlight: function(cellView, magnetEl, opt) {\n        const highlighterDescriptor = this.resolveHighlighter(opt);\n        if (!highlighterDescriptor) return;\n        const { highlighter, options } = highlighterDescriptor;\n        highlighter.unhighlight(cellView, magnetEl, options);\n    },\n\n    // Interaction.\n    // ------------\n\n    pointerdblclick: function(evt) {\n\n        evt.preventDefault();\n\n        // magnetpointerdblclick can stop propagation\n\n        evt = normalizeEvent(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        if (view) {\n            view.pointerdblclick(evt, localPoint.x, localPoint.y);\n\n        } else {\n            this.trigger('blank:pointerdblclick', evt, localPoint.x, localPoint.y);\n        }\n    },\n\n    pointerclick: function(evt) {\n\n        // magnetpointerclick can stop propagation\n\n        var data = this.eventData(evt);\n        // Trigger event only if mouse has not moved.\n        if (data.mousemoved <= this.options.clickThreshold) {\n\n            evt = normalizeEvent(evt);\n\n            var view = this.findView(evt.target);\n            if (this.guard(evt, view)) return;\n\n            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n            if (view) {\n                view.pointerclick(evt, localPoint.x, localPoint.y);\n\n            } else {\n                this.trigger('blank:pointerclick', evt, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    contextmenu: function(evt) {\n\n        if (this.options.preventContextMenu) evt.preventDefault();\n\n        if (this.contextMenuFired) {\n            this.contextMenuFired = false;\n            return;\n        }\n\n        evt = normalizeEvent(evt);\n\n        this.contextMenuTrigger(evt);\n    },\n\n    contextMenuTrigger: function(evt) {\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        if (view) {\n            view.contextmenu(evt, localPoint.x, localPoint.y);\n\n        } else {\n            this.trigger('blank:contextmenu', evt, localPoint.x, localPoint.y);\n        }\n    },\n\n    pointerdown: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        const { target, button } = evt;\n        const view = this.findView(target);\n        const isContextMenu = (button === 2);\n\n        if (view) {\n\n            if (!isContextMenu && this.guard(evt, view)) return;\n\n            const isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);\n\n            if (this.options.preventDefaultViewAction && !isTargetFormNode) {\n                // If the target is a form element, we do not want to prevent the default action.\n                // For example, we want to be able to select text in a text input or\n                // to be able to click on a checkbox.\n                evt.preventDefault();\n            }\n\n            if (isTargetFormNode) {\n                // If the target is a form element, we do not want to start dragging the element.\n                // For example, we want to be able to select text by dragging the mouse.\n                view.preventDefaultInteraction(evt);\n            }\n\n            // Custom event\n            const eventEvt = this.customEventTrigger(evt, view);\n            if (eventEvt) {\n            // `onevent` could have stopped propagation\n                if (eventEvt.isPropagationStopped()) return;\n\n                evt.data = eventEvt.data;\n            }\n\n            // Element magnet\n            const magnetNode = target.closest('[magnet]');\n            if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {\n                const magnetEvt = normalizeEvent(new $.Event(evt.originalEvent, {\n                    data: evt.data,\n                    // Originally the event listener was attached to the magnet element.\n                    currentTarget: magnetNode\n                }));\n                this.onmagnet(magnetEvt);\n                if (magnetEvt.isDefaultPrevented()) {\n                    evt.preventDefault();\n                }\n                // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed\n                if (magnetEvt.isPropagationStopped()) {\n                    // `magnet:pointermove` and `magnet:pointerup` events must be fired\n                    if (isContextMenu) return;\n                    this.delegateDragEvents(view, magnetEvt.data);\n                    return;\n                }\n                evt.data = magnetEvt.data;\n            }\n        }\n\n        if (isContextMenu) {\n            this.contextMenuFired = true;\n            const contextmenuEvt = new $.Event(evt.originalEvent, { type: 'contextmenu', data: evt.data });\n            this.contextMenuTrigger(contextmenuEvt);\n        } else {\n            const localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n            if (view) {\n                view.pointerdown(evt, localPoint.x, localPoint.y);\n            } else {\n                if (this.options.preventDefaultBlankAction) {\n                    evt.preventDefault();\n                }\n                this.trigger('blank:pointerdown', evt, localPoint.x, localPoint.y);\n            }\n\n            this.delegateDragEvents(view, evt.data);\n        }\n\n    },\n\n    pointermove: function(evt) {\n\n        // mouse moved counter\n        var data = this.eventData(evt);\n        if (!data.mousemoved) {\n            data.mousemoved = 0;\n            // Make sure that events like `mouseenter` and `mouseleave` are\n            // not triggered while the user is dragging a cellView.\n            this.undelegateEvents();\n            // Note: the events are undelegated after the first `pointermove` event.\n            // Not on `pointerdown` to make sure that `dbltap` is recognized.\n        }\n\n        var mousemoved = ++data.mousemoved;\n\n        if (mousemoved <= this.options.moveThreshold) return;\n\n        evt = normalizeEvent(evt);\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        var view = data.sourceView;\n        if (view) {\n            view.pointermove(evt, localPoint.x, localPoint.y);\n        } else {\n            this.trigger('blank:pointermove', evt, localPoint.x, localPoint.y);\n        }\n\n        this.eventData(evt, data);\n    },\n\n    pointerup: function(evt) {\n\n        this.undelegateDocumentEvents();\n\n        var normalizedEvt = normalizeEvent(evt);\n\n        var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n\n        var view = this.eventData(evt).sourceView;\n        if (view) {\n            view.pointerup(normalizedEvt, localPoint.x, localPoint.y);\n        } else {\n            this.trigger('blank:pointerup', normalizedEvt, localPoint.x, localPoint.y);\n        }\n\n        if (!normalizedEvt.isPropagationStopped()) {\n            this.pointerclick(new $.Event(evt.originalEvent, { type: 'click', data: evt.data }));\n        }\n\n        this.delegateEvents();\n    },\n\n    mouseover: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        if (view) {\n            view.mouseover(evt);\n\n        } else {\n            if (this.el === evt.target) return; // prevent border of paper from triggering this\n            this.trigger('blank:mouseover', evt);\n        }\n    },\n\n    mouseout: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        if (view) {\n            view.mouseout(evt);\n\n        } else {\n            if (this.el === evt.target) return; // prevent border of paper from triggering this\n            this.trigger('blank:mouseout', evt);\n        }\n    },\n\n    mouseenter: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        const {\n            target, // The EventTarget the pointing device entered to\n            relatedTarget, // The EventTarget the pointing device exited from\n            currentTarget // The EventTarget on which the event listener was registered\n        } = evt;\n        const view = this.findView(target);\n        if (this.guard(evt, view)) return;\n        const relatedView = this.findView(relatedTarget);\n        if (view) {\n            if (relatedView === view) {\n                // Mouse left a cell tool\n                return;\n            }\n            view.mouseenter(evt);\n            if (this.el.contains(relatedTarget)) {\n                // The pointer remains inside the paper.\n                return;\n            }\n        }\n        if (relatedView) {\n            return;\n        }\n        // prevent double `mouseenter` event if the `relatedTarget` is outside the paper\n        // (mouseenter method would be fired twice)\n        if (currentTarget === this.el) {\n            // `paper` (more descriptive), not `blank`\n            this.trigger('paper:mouseenter', evt);\n        }\n    },\n\n    mouseleave: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        const {\n            target, // The EventTarget the pointing device exited from\n            relatedTarget, // The EventTarget the pointing device entered to\n            currentTarget // The EventTarget on which the event listener was registered\n        } = evt;\n        const view = this.findView(target);\n        if (this.guard(evt, view)) return;\n        const relatedView = this.findView(relatedTarget);\n        if (view) {\n            if (relatedView === view) {\n                // Mouse entered a cell tool\n                return;\n            }\n            view.mouseleave(evt);\n            if (this.el.contains(relatedTarget)) {\n                // The pointer has exited a cellView. The pointer is still inside of the paper.\n                return;\n            }\n        }\n        if (relatedView) {\n            // The pointer has entered a new cellView\n            return;\n        }\n        // prevent double `mouseleave` event if the `relatedTarget` is outside the paper\n        // (mouseleave method would be fired twice)\n        if (currentTarget === this.el) {\n            // There is no cellView under the pointer, nor the blank area of the paper\n            this.trigger('paper:mouseleave', evt);\n        }\n    },\n\n    _processMouseWheelEvtBuf: debounce(function() {\n        const { event, deltas } = this._mw_evt_buffer;\n        const deltaY = deltas.reduce((acc, deltaY) => acc + cap(deltaY, WHEEL_CAP), 0);\n\n        const scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom\n        const { x, y } = this.clientToLocalPoint(event.clientX, event.clientY);\n        this.trigger('paper:pinch', event, x, y, scale);\n\n        this._mw_evt_buffer = {\n            event: null,\n            deltas: [],\n        };\n    }, WHEEL_WAIT_MS, { maxWait: WHEEL_WAIT_MS }),\n\n    mousewheel: function(evt) {\n\n        evt = normalizeEvent(evt);\n\n        const view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        const originalEvent = evt.originalEvent;\n        const localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);\n        const { deltaX, deltaY } = normalizeWheel(originalEvent);\n\n        const pinchHandlers = this._events['paper:pinch'];\n\n        // Touchpad devices will send a fake CTRL press when a pinch is performed\n        //\n        // We also check if there are any subscribers to paper:pinch event. If there are none,\n        // just skip the entire block of code (we don't want to blindly call\n        // .preventDefault() if we really don't have to).\n        if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {\n            // This is a pinch gesture, it's safe to assume that we must call .preventDefault()\n            originalEvent.preventDefault();\n            this._mw_evt_buffer.event = evt;\n            this._mw_evt_buffer.deltas.push(deltaY);\n            this._processMouseWheelEvtBuf();\n        } else {\n            const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));\n            if (view) {\n                view.mousewheel(evt, localPoint.x, localPoint.y, delta);\n\n            } else {\n                this.trigger('blank:mousewheel', evt, localPoint.x, localPoint.y, delta);\n            }\n\n            this.trigger('paper:pan', evt, deltaX, deltaY);\n        }\n    },\n\n    onevent: function(evt) {\n\n        var eventNode = evt.currentTarget;\n        var eventName = eventNode.getAttribute('event');\n        if (eventName) {\n            var view = this.findView(eventNode);\n            if (view) {\n\n                evt = normalizeEvent(evt);\n                if (this.guard(evt, view)) return;\n\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                view.onevent(evt, eventName, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    magnetEvent: function(evt, handler) {\n\n        var magnetNode = evt.currentTarget;\n        var magnetValue = magnetNode.getAttribute('magnet');\n        if (magnetValue) {\n            var view = this.findView(magnetNode);\n            if (view) {\n                evt = normalizeEvent(evt);\n                if (this.guard(evt, view)) return;\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    onmagnet: function(evt) {\n\n        if (evt.button === 2) {\n            this.contextMenuFired = true;\n            this.magnetContextMenuFired = true;\n            const contextmenuEvt = new $.Event(evt.originalEvent, {\n                type: 'contextmenu',\n                data: evt.data,\n                currentTarget: evt.currentTarget,\n            });\n            this.magnetContextMenuTrigger(contextmenuEvt);\n            if (contextmenuEvt.isPropagationStopped()) {\n                evt.stopPropagation();\n            }\n        } else {\n            this.magnetEvent(evt, function(view, evt, _, x, y) {\n                view.onmagnet(evt, x, y);\n            });\n        }\n    },\n\n    magnetpointerdblclick: function(evt) {\n\n        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n            view.magnetpointerdblclick(evt, magnet, x, y);\n        });\n    },\n\n    magnetcontextmenu: function(evt) {\n        if (this.options.preventContextMenu) evt.preventDefault();\n\n        if (this.magnetContextMenuFired) {\n            this.magnetContextMenuFired = false;\n            return;\n        }\n\n        this.magnetContextMenuTrigger(evt);\n    },\n\n    magnetContextMenuTrigger: function(evt) {\n        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n            view.magnetcontextmenu(evt, magnet, x, y);\n        });\n    },\n\n    onlabel: function(evt) {\n\n        var labelNode = evt.currentTarget;\n\n        var view = this.findView(labelNode);\n        if (!view) return;\n\n        evt = normalizeEvent(evt);\n        if (this.guard(evt, view)) return;\n\n        // Custom event\n        const eventEvt = this.customEventTrigger(evt, view, labelNode);\n        if (eventEvt) {\n            // `onevent` could have stopped propagation\n            if (eventEvt.isPropagationStopped()) return;\n\n            evt.data = eventEvt.data;\n        }\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n        view.onlabel(evt, localPoint.x, localPoint.y);\n    },\n\n    getPointerArgs(evt) {\n        const normalizedEvt = normalizeEvent(evt);\n        const { x, y } = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n        return [normalizedEvt, x, y];\n    },\n\n    delegateDragEvents: function(view, data) {\n\n        data || (data = {});\n        this.eventData({ data: data }, { sourceView: view || null, mousemoved: 0 });\n        this.delegateDocumentEvents(null, data);\n    },\n\n    // Guard the specified event. If the event should be ignored, guard returns `true`.\n    // Otherwise, it returns `false`.\n    guard: function(evt, view) {\n\n        if (evt.type === 'mousedown' && evt.button === 2) {\n            // handled as `contextmenu` type\n            return true;\n        }\n\n        if (this.options.guard && this.options.guard(evt, view)) {\n            return true;\n        }\n\n        if (evt.data && evt.data.guarded !== undefined) {\n            return evt.data.guarded;\n        }\n\n        const { target } = evt;\n\n        if (this.GUARDED_TAG_NAMES.includes(target.tagName)) {\n            return true;\n        }\n\n        if (view && view.model && (view.model instanceof Cell)) {\n            return false;\n        }\n\n        if (this.el === target || this.svg.contains(target)) {\n            return false;\n        }\n\n        return true;    // Event guarded. Paper should not react on it in any way.\n    },\n\n    setGridSize: function(gridSize) {\n        const { options } = this;\n        options.gridSize = gridSize;\n        if (options.drawGrid && !options.drawGridSize) {\n            // Do not redraw the grid if the `drawGridSize` is set.\n            this.getLayerView(LayersNames.GRID).renderGrid();\n        }\n        return this;\n    },\n\n    setGrid: function(drawGrid) {\n        this.getLayerView(LayersNames.GRID).setGrid(drawGrid);\n        return this;\n    },\n\n    updateBackgroundImage: function(opt) {\n\n        opt = opt || {};\n\n        var backgroundPosition = opt.position || 'center';\n        var backgroundSize = opt.size || 'auto auto';\n\n        var currentScale = this.scale();\n        var currentTranslate = this.translate();\n\n        // backgroundPosition\n        if (isObject(backgroundPosition)) {\n            var x = currentTranslate.tx + (currentScale.sx * (backgroundPosition.x || 0));\n            var y = currentTranslate.ty + (currentScale.sy * (backgroundPosition.y || 0));\n            backgroundPosition = x + 'px ' + y + 'px';\n        }\n\n        // backgroundSize\n        if (isObject(backgroundSize)) {\n            backgroundSize = new Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);\n            backgroundSize = backgroundSize.width + 'px ' + backgroundSize.height + 'px';\n        }\n\n        const { background } = this.childNodes;\n        background.style.backgroundSize = backgroundSize;\n        background.style.backgroundPosition = backgroundPosition;\n    },\n\n    drawBackgroundImage: function(img, opt) {\n\n        // Clear the background image if no image provided\n        if (!(img instanceof HTMLImageElement)) {\n            this.childNodes.background.style.backgroundImage = '';\n            return;\n        }\n\n        if (!this._background || this._background.id !== opt.id) {\n            // Draw only the last image requested (see drawBackground())\n            return;\n        }\n\n        opt = opt || {};\n\n        var backgroundImage;\n        var backgroundSize = opt.size;\n        var backgroundRepeat = opt.repeat || 'no-repeat';\n        var backgroundOpacity = opt.opacity || 1;\n        var backgroundQuality = Math.abs(opt.quality) || 1;\n        var backgroundPattern = this.constructor.backgroundPatterns[camelCase(backgroundRepeat)];\n\n        if (isFunction(backgroundPattern)) {\n            // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom\n            img.width *= backgroundQuality;\n            img.height *= backgroundQuality;\n            var canvas = backgroundPattern(img, opt);\n            if (!(canvas instanceof HTMLCanvasElement)) {\n                throw new Error('dia.Paper: background pattern must return an HTML Canvas instance');\n            }\n\n            backgroundImage = canvas.toDataURL('image/png');\n            backgroundRepeat = 'repeat';\n            if (isObject(backgroundSize)) {\n                // recalculate the tile size if an object passed in\n                backgroundSize.width *= canvas.width / img.width;\n                backgroundSize.height *= canvas.height / img.height;\n            } else if (backgroundSize === undefined) {\n                // calculate the tile size if no provided\n                opt.size = {\n                    width: canvas.width / backgroundQuality,\n                    height: canvas.height / backgroundQuality\n                };\n            }\n        } else {\n            // backgroundRepeat:\n            // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'\n            backgroundImage = img.src;\n            if (backgroundSize === undefined) {\n                // pass the image size for  the backgroundSize if no size provided\n                opt.size = {\n                    width: img.width,\n                    height: img.height\n                };\n            }\n        }\n\n        this.childNodes.background.style.opacity = backgroundOpacity;\n        this.childNodes.background.style.backgroundRepeat = backgroundRepeat;\n        this.childNodes.background.style.backgroundImage = `url(${backgroundImage})`;\n\n        this.updateBackgroundImage(opt);\n    },\n\n    updateBackgroundColor: function(color) {\n\n        this.$el.css('backgroundColor', color || '');\n    },\n\n    drawBackground: function(opt) {\n\n        opt = opt || {};\n\n        this.updateBackgroundColor(opt.color);\n\n        if (opt.image) {\n            opt = this._background = cloneDeep(opt);\n            guid(opt);\n            var img = document.createElement('img');\n            img.onload = this.drawBackgroundImage.bind(this, img, opt);\n            img.src = opt.image;\n        } else {\n            this.drawBackgroundImage(null);\n            this._background = null;\n        }\n\n        return this;\n    },\n\n    setInteractivity: function(value) {\n\n        this.options.interactive = value;\n\n        invoke(this._views, 'setInteractivity', value);\n    },\n\n    // Paper definitions.\n    // ------------------\n\n    isDefined: function(defId) {\n\n        return !!this.svg.getElementById(defId);\n    },\n\n    defineFilter: function(filter) {\n\n        if (!isObject(filter)) {\n            throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');\n        }\n\n        var filterId = filter.id;\n        var name = filter.name;\n        // Generate a hash code from the stringified filter definition. This gives us\n        // a unique filter ID for different definitions.\n        if (!filterId) {\n            filterId = name + this.svg.id + hashCode(JSON.stringify(filter));\n        }\n        // If the filter already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        // If not, create one.\n        if (!this.isDefined(filterId)) {\n\n            var namespace = _filter;\n            var filterSVGString = namespace[name] && namespace[name](filter.args || {});\n            if (!filterSVGString) {\n                throw new Error('Non-existing filter ' + name);\n            }\n\n            // SVG <filter/> attributes\n            var filterAttrs = assign({\n                filterUnits: 'userSpaceOnUse',\n            }, filter.attrs, {\n                id: filterId\n            });\n\n            V(filterSVGString, filterAttrs).appendTo(this.defs);\n        }\n\n        return filterId;\n    },\n\n    defineGradient: function(gradient) {\n        if (!isObject(gradient)) {\n            throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            type,\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = type + svg.id + hashCode(JSON.stringify(gradient)),\n            stops,\n            attrs = {}\n        } = gradient;\n        // If the gradient already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const stopVEls = toArray(stops).map(({ offset, color, opacity }) => {\n            return V('stop').attr({\n                'offset': offset,\n                'stop-color': color,\n                'stop-opacity': Number.isFinite(opacity) ? opacity : 1\n            });\n        });\n        const gradientVEl = V(type, attrs, stopVEls);\n        gradientVEl.id = id;\n        gradientVEl.appendTo(defs);\n        return id;\n    },\n\n    definePattern: function(pattern) {\n        if (!isObject(pattern)) {\n            throw new TypeError('dia.Paper: definePattern() requires 1. argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = svg.id + hashCode(JSON.stringify(pattern)),\n            markup,\n            attrs = {}\n        } = pattern;\n        if (!markup) {\n            throw new TypeError('dia.Paper: definePattern() requires markup.');\n        }\n        // If the gradient already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const patternVEl = V('pattern', {\n            patternUnits: 'userSpaceOnUse'\n        });\n        patternVEl.id = id;\n        patternVEl.attr(attrs);\n        if (typeof markup === 'string') {\n            patternVEl.append(V(markup));\n        } else {\n            const { fragment } = parseDOMJSON(markup);\n            patternVEl.append(fragment);\n        }\n        patternVEl.appendTo(defs);\n        return id;\n    },\n\n    defineMarker: function(marker) {\n        if (!isObject(marker)) {\n            throw new TypeError('dia.Paper: defineMarker() requires the first argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = svg.id + hashCode(JSON.stringify(marker)),\n            // user-provided markup\n            // (e.g. defined when creating link via `attrs/line/sourceMarker/markup`)\n            markup,\n            // user-provided attributes\n            // (e.g. defined when creating link via `attrs/line/sourceMarker/attrs`)\n            // note: `transform` attrs are ignored by browsers\n            attrs = {},\n            // deprecated - use `attrs/markerUnits` instead (which has higher priority)\n            markerUnits = 'userSpaceOnUse'\n        } = marker;\n        // If the marker already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const markerVEl = V('marker', {\n            orient: 'auto',\n            overflow: 'visible',\n            markerUnits: markerUnits\n        });\n        markerVEl.id = id;\n        markerVEl.attr(attrs);\n        let markerContentVEl;\n        if (markup) {\n            let markupVEl;\n            if (typeof markup === 'string') {\n                // Marker object has a `markup` property of type string.\n                // - Construct V from the provided string.\n                markupVEl = V(markup);\n                // `markupVEl` is now either a single VEl, or an array of VEls.\n                // - Coerce it to an array.\n                markupVEl = (Array.isArray(markupVEl) ? markupVEl : [markupVEl]);\n            } else {\n                // Marker object has a `markup` property of type object.\n                // - Construct V from the object by parsing it as DOM JSON.\n                const { fragment } = parseDOMJSON(markup);\n                markupVEl = V(fragment).children();\n            }\n            // `markupVEl` is an array with one or more VEls inside.\n            // - If there are multiple VEls, wrap them in a newly-constructed <g> element\n            if (markupVEl.length > 1) {\n                markerContentVEl = V('g').append(markupVEl);\n            } else {\n                markerContentVEl = markupVEl[0];\n            }\n        } else {\n            // Marker object is a flat structure.\n            // - Construct a new V of type `marker.type`.\n            const { type = 'path' } = marker;\n            markerContentVEl = V(type);\n        }\n        // `markerContentVEl` is a single VEl.\n        // Assign additional attributes to it (= context attributes + marker attributes):\n        // - Attribute values are taken from non-special properties of `marker`.\n        const markerAttrs = omit(marker, 'type', 'id', 'markup', 'attrs', 'markerUnits');\n        const markerAttrsKeys = Object.keys(markerAttrs);\n        markerAttrsKeys.forEach((key) => {\n            const value = markerAttrs[key];\n            const markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority\n            if (markupValue == null) {\n                // Default logic:\n                markerContentVEl.attr(key, value);\n            } else {\n                // Properties with special logic should be added as cases to this switch block:\n                switch(key) {\n                    case 'transform':\n                        // - Prepend `transform` to existing value.\n                        markerContentVEl.attr(key, (value + ' ' + markupValue));\n                        break;\n                }\n            }\n        });\n        markerContentVEl.appendTo(markerVEl);\n        markerVEl.appendTo(defs);\n        return id;\n    },\n\n    customEventTrigger: function(evt, view, rootNode = view.el) {\n\n        const eventNode = evt.target.closest('[event]');\n\n        if (eventNode && rootNode !== eventNode && view.el.contains(eventNode)) {\n            const eventEvt = normalizeEvent(new $.Event(evt.originalEvent, {\n                data: evt.data,\n                // Originally the event listener was attached to the event element.\n                currentTarget: eventNode\n            }));\n\n            this.onevent(eventEvt);\n\n            if (eventEvt.isDefaultPrevented()) {\n                evt.preventDefault();\n            }\n\n            return eventEvt;\n        }\n\n        return null;\n    }\n\n}, {\n\n    sorting: sortingTypes,\n\n    Layers: LayersNames,\n\n    backgroundPatterns: {\n\n        flipXy: function(img) {\n            // d b\n            // q p\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = 2 * imgWidth;\n            canvas.height = 2 * imgHeight;\n\n            var ctx = canvas.getContext('2d');\n            // top-left image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // xy-flipped bottom-right image\n            ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // x-flipped top-right image\n            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // y-flipped bottom-left image\n            ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        flipX: function(img) {\n            // d b\n            // d b\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = imgWidth * 2;\n            canvas.height = imgHeight;\n\n            var ctx = canvas.getContext('2d');\n            // left image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // flipped right image\n            ctx.translate(2 * imgWidth, 0);\n            ctx.scale(-1, 1);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        flipY: function(img) {\n            // d d\n            // q q\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = imgWidth;\n            canvas.height = imgHeight * 2;\n\n            var ctx = canvas.getContext('2d');\n            // top image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // flipped bottom image\n            ctx.translate(0, 2 * imgHeight);\n            ctx.scale(1, -1);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        watermark: function(img, opt) {\n            //   d\n            // d\n\n            opt = opt || {};\n\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            var canvas = document.createElement('canvas');\n            canvas.width = imgWidth * 3;\n            canvas.height = imgHeight * 3;\n\n            var ctx = canvas.getContext('2d');\n            var angle = isNumber(opt.watermarkAngle) ? -opt.watermarkAngle : -20;\n            var radians = toRad(angle);\n            var stepX = canvas.width / 4;\n            var stepY = canvas.height / 4;\n\n            for (var i = 0; i < 4; i++) {\n                for (var j = 0; j < 4; j++) {\n                    if ((i + j) % 2 > 0) {\n                        // reset the current transformations\n                        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);\n                        ctx.rotate(radians);\n                        ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);\n                    }\n                }\n            }\n\n            return canvas;\n        }\n    },\n\n    gridPatterns: {\n        dot: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'rect',\n            render: function(el, opt) {\n                V(el).attr({\n                    width: opt.thickness,\n                    height: opt.thickness,\n                    fill: opt.color\n                });\n            }\n        }],\n        fixedDot: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'rect',\n            render: function(el, opt) {\n                V(el).attr({ fill: opt.color });\n            },\n            update: function(el, opt, paper) {\n                const { sx, sy } = paper.scale();\n                const width = sx <= 1 ? opt.thickness : opt.thickness / sx;\n                const height = sy <= 1 ? opt.thickness : opt.thickness / sy;\n                V(el).attr({ width, height });\n            }\n        }],\n        mesh: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'path',\n            render: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }],\n        doubleMesh: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'path',\n            render: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }, {\n            color: '#000000',\n            thickness: 3,\n            scaleFactor: 4,\n            markup: 'path',\n            render: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                V(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }]\n    }\n});\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}