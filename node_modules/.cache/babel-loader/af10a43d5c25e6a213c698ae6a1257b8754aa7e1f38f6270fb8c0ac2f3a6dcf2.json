{"ast":null,"code":"import { Point } from './point.mjs';\nimport { Rect } from './rect.mjs';\nimport { bearing } from './line.bearing.mjs';\nimport { squaredLength } from './line.squaredLength.mjs';\nimport { length } from './line.length.mjs';\nimport { types } from './types.mjs';\nconst {\n  max,\n  min\n} = Math;\nexport const Line = function (p1, p2) {\n  if (!(this instanceof Line)) {\n    return new Line(p1, p2);\n  }\n  if (p1 instanceof Line) {\n    return new Line(p1.start, p1.end);\n  }\n  this.start = new Point(p1);\n  this.end = new Point(p2);\n};\nLine.prototype = {\n  type: types.Line,\n  // @returns the angle of incline of the line.\n  angle: function () {\n    var horizontalPoint = new Point(this.start.x + 1, this.start.y);\n    return this.start.angleBetween(this.end, horizontalPoint);\n  },\n  bbox: function () {\n    var left = min(this.start.x, this.end.x);\n    var top = min(this.start.y, this.end.y);\n    var right = max(this.start.x, this.end.x);\n    var bottom = max(this.start.y, this.end.y);\n    return new Rect(left, top, right - left, bottom - top);\n  },\n  // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n  // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n  bearing: function () {\n    return bearing(this.start, this.end);\n  },\n  clone: function () {\n    return new Line(this.start, this.end);\n  },\n  // @return {point} the closest point on the line to point `p`\n  closestPoint: function (p) {\n    return this.pointAt(this.closestPointNormalizedLength(p));\n  },\n  closestPointLength: function (p) {\n    return this.closestPointNormalizedLength(p) * this.length();\n  },\n  // @return {number} the normalized length of the closest point on the line to point `p`\n  closestPointNormalizedLength: function (p) {\n    var product = this.vector().dot(new Line(this.start, p).vector());\n    var cpNormalizedLength = min(1, max(0, product / this.squaredLength()));\n\n    // cpNormalizedLength returns `NaN` if this line has zero length\n    // we can work with that - if `NaN`, return 0\n    if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n    // (`NaN` is the only value that is not equal to itself)\n\n    return cpNormalizedLength;\n  },\n  closestPointTangent: function (p) {\n    return this.tangentAt(this.closestPointNormalizedLength(p));\n  },\n  // Returns `true` if the point lies on the line.\n  containsPoint: function (p) {\n    var start = this.start;\n    var end = this.end;\n    if (start.cross(p, end) !== 0) return false;\n    // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n\n    var length = this.length();\n    if (new Line(start, p).length() > length) return false;\n    if (new Line(p, end).length() > length) return false;\n    // else: `p` lies between start and end of the line\n\n    return true;\n  },\n  // Divides the line into two at requested `ratio` between 0 and 1.\n  divideAt: function (ratio) {\n    var dividerPoint = this.pointAt(ratio);\n\n    // return array with two lines\n    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];\n  },\n  // Divides the line into two at requested `length`.\n  divideAtLength: function (length) {\n    var dividerPoint = this.pointAtLength(length);\n\n    // return array with two new lines\n    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];\n  },\n  equals: function (l) {\n    return !!l && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;\n  },\n  // @return {point} Point where I'm intersecting a line.\n  // @return [point] Points where I'm intersecting a rectangle.\n  // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n  intersect: function (shape, opt) {\n    if (shape && shape.intersectionWithLine) {\n      var intersection = shape.intersectionWithLine(this, opt);\n\n      // Backwards compatibility\n      if (intersection && shape instanceof Line) {\n        intersection = intersection[0];\n      }\n      return intersection;\n    }\n    return null;\n  },\n  intersectionWithLine: function (line) {\n    var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n    var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n    var det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;\n    var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n    var alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;\n    var beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;\n    if (det === 0 || alpha * det < 0 || beta * det < 0) {\n      // No intersection found.\n      return null;\n    }\n    if (det > 0) {\n      if (alpha > det || beta > det) {\n        return null;\n      }\n    } else {\n      if (alpha < det || beta < det) {\n        return null;\n      }\n    }\n    return [new Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det)];\n  },\n  isDifferentiable: function () {\n    return !this.start.equals(this.end);\n  },\n  // @return {double} length of the line\n  length: function () {\n    return length(this.start, this.end);\n  },\n  // @return {point} my midpoint\n  midpoint: function () {\n    return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n  },\n  parallel: function (distance) {\n    const l = this.clone();\n    if (!this.isDifferentiable()) return l;\n    const {\n      start,\n      end\n    } = l;\n    const eRef = start.clone().rotate(end, 270);\n    const sRef = end.clone().rotate(start, 90);\n    start.move(sRef, distance);\n    end.move(eRef, distance);\n    return l;\n  },\n  // @return {point} my point at 't' <0,1>\n  pointAt: function (t) {\n    var start = this.start;\n    var end = this.end;\n    if (t <= 0) return start.clone();\n    if (t >= 1) return end.clone();\n    return start.lerp(end, t);\n  },\n  pointAtLength: function (length) {\n    var start = this.start;\n    var end = this.end;\n    var fromStart = true;\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n      length = -length; // absolute value\n    }\n    var lineLength = this.length();\n    if (length >= lineLength) return fromStart ? end.clone() : start.clone();\n    return this.pointAt((fromStart ? length : lineLength - length) / lineLength);\n  },\n  // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n  pointOffset: function (p) {\n    // Find the sign of the determinant of vectors (start,end), where p is the query point.\n    p = new Point(p);\n    var start = this.start;\n    var end = this.end;\n    var determinant = (end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x);\n    return determinant / this.length();\n  },\n  rotate: function (origin, angle) {\n    this.start.rotate(origin, angle);\n    this.end.rotate(origin, angle);\n    return this;\n  },\n  round: function (precision) {\n    this.start.round(precision);\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.start.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  // @return {number} scale the line so that it has the requested length\n  setLength: function (length) {\n    var currentLength = this.length();\n    if (!currentLength) return this;\n    var scaleFactor = length / currentLength;\n    return this.scale(scaleFactor, scaleFactor, this.start);\n  },\n  // @return {integer} length without sqrt\n  // @note for applications where the exact length is not necessary (e.g. compare only)\n  squaredLength: function () {\n    return squaredLength(this.start, this.end);\n  },\n  tangentAt: function (t) {\n    if (!this.isDifferentiable()) return null;\n    var start = this.start;\n    var end = this.end;\n    var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n\n    var tangentLine = new Line(start, end);\n    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n    return tangentLine;\n  },\n  tangentAtLength: function (length) {\n    if (!this.isDifferentiable()) return null;\n    var start = this.start;\n    var end = this.end;\n    var tangentStart = this.pointAtLength(length);\n    var tangentLine = new Line(start, end);\n    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n    return tangentLine;\n  },\n  toString: function () {\n    return this.start.toString() + ' ' + this.end.toString();\n  },\n  serialize: function () {\n    return this.start.serialize() + ' ' + this.end.serialize();\n  },\n  translate: function (tx, ty) {\n    this.start.translate(tx, ty);\n    this.end.translate(tx, ty);\n    return this;\n  },\n  // @return vector {point} of the line\n  vector: function () {\n    return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n  }\n};\n\n// For backwards compatibility:\nLine.prototype.intersection = Line.prototype.intersect;\n\n// For backwards compatibility:\nexport const line = Line;","map":{"version":3,"names":["Point","Rect","bearing","squaredLength","length","types","max","min","Math","Line","p1","p2","start","end","prototype","type","angle","horizontalPoint","x","y","angleBetween","bbox","left","top","right","bottom","clone","closestPoint","p","pointAt","closestPointNormalizedLength","closestPointLength","product","vector","dot","cpNormalizedLength","closestPointTangent","tangentAt","containsPoint","cross","divideAt","ratio","dividerPoint","divideAtLength","pointAtLength","equals","l","intersect","shape","opt","intersectionWithLine","intersection","line","pt1Dir","pt2Dir","det","deltaPt","alpha","beta","isDifferentiable","midpoint","parallel","distance","eRef","rotate","sRef","move","t","lerp","fromStart","lineLength","pointOffset","determinant","origin","round","precision","scale","sx","sy","setLength","currentLength","scaleFactor","tangentStart","tangentLine","translate","tangentAtLength","toString","serialize","tx","ty"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/g/line.mjs"],"sourcesContent":["import { Point } from './point.mjs';\nimport { Rect } from './rect.mjs';\nimport { bearing } from './line.bearing.mjs';\nimport { squaredLength } from './line.squaredLength.mjs';\nimport { length } from './line.length.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    max,\n    min\n} = Math;\n\nexport const Line = function(p1, p2) {\n\n    if (!(this instanceof Line)) {\n        return new Line(p1, p2);\n    }\n\n    if (p1 instanceof Line) {\n        return new Line(p1.start, p1.end);\n    }\n\n    this.start = new Point(p1);\n    this.end = new Point(p2);\n};\n\nLine.prototype = {\n\n    type: types.Line,\n\n    // @returns the angle of incline of the line.\n    angle: function() {\n\n        var horizontalPoint = new Point(this.start.x + 1, this.start.y);\n        return this.start.angleBetween(this.end, horizontalPoint);\n    },\n\n    bbox: function() {\n\n        var left = min(this.start.x, this.end.x);\n        var top = min(this.start.y, this.end.y);\n        var right = max(this.start.x, this.end.x);\n        var bottom = max(this.start.y, this.end.y);\n\n        return new Rect(left, top, (right - left), (bottom - top));\n    },\n\n    // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n    // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n    bearing: function() {\n        return bearing(this.start, this.end);\n    },\n\n    clone: function() {\n\n        return new Line(this.start, this.end);\n    },\n\n    // @return {point} the closest point on the line to point `p`\n    closestPoint: function(p) {\n\n        return this.pointAt(this.closestPointNormalizedLength(p));\n    },\n\n    closestPointLength: function(p) {\n\n        return this.closestPointNormalizedLength(p) * this.length();\n    },\n\n    // @return {number} the normalized length of the closest point on the line to point `p`\n    closestPointNormalizedLength: function(p) {\n\n        var product = this.vector().dot((new Line(this.start, p)).vector());\n        var cpNormalizedLength = min(1, max(0, product / this.squaredLength()));\n\n        // cpNormalizedLength returns `NaN` if this line has zero length\n        // we can work with that - if `NaN`, return 0\n        if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n        // (`NaN` is the only value that is not equal to itself)\n\n        return cpNormalizedLength;\n    },\n\n    closestPointTangent: function(p) {\n\n        return this.tangentAt(this.closestPointNormalizedLength(p));\n    },\n\n    // Returns `true` if the point lies on the line.\n    containsPoint: function(p) {\n\n        var start = this.start;\n        var end = this.end;\n\n        if (start.cross(p, end) !== 0) return false;\n        // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n\n        var length = this.length();\n        if ((new Line(start, p)).length() > length) return false;\n        if ((new Line(p, end)).length() > length) return false;\n        // else: `p` lies between start and end of the line\n\n        return true;\n    },\n\n    // Divides the line into two at requested `ratio` between 0 and 1.\n    divideAt: function(ratio) {\n\n        var dividerPoint = this.pointAt(ratio);\n\n        // return array with two lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n\n    // Divides the line into two at requested `length`.\n    divideAtLength: function(length) {\n\n        var dividerPoint = this.pointAtLength(length);\n\n        // return array with two new lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n\n    equals: function(l) {\n\n        return !!l &&\n            this.start.x === l.start.x &&\n            this.start.y === l.start.y &&\n            this.end.x === l.end.x &&\n            this.end.y === l.end.y;\n    },\n\n    // @return {point} Point where I'm intersecting a line.\n    // @return [point] Points where I'm intersecting a rectangle.\n    // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n    intersect: function(shape, opt) {\n\n        if (shape && shape.intersectionWithLine) {\n            var intersection = shape.intersectionWithLine(this, opt);\n\n            // Backwards compatibility\n            if (intersection && (shape instanceof Line)) {\n                intersection = intersection[0];\n            }\n\n            return intersection;\n        }\n\n        return null;\n    },\n\n    intersectionWithLine: function(line) {\n\n        var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n        var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n        var det = (pt1Dir.x * pt2Dir.y) - (pt1Dir.y * pt2Dir.x);\n        var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n        var alpha = (deltaPt.x * pt2Dir.y) - (deltaPt.y * pt2Dir.x);\n        var beta = (deltaPt.x * pt1Dir.y) - (deltaPt.y * pt1Dir.x);\n\n        if (det === 0 || alpha * det < 0 || beta * det < 0) {\n            // No intersection found.\n            return null;\n        }\n\n        if (det > 0) {\n            if (alpha > det || beta > det) {\n                return null;\n            }\n\n        } else {\n            if (alpha < det || beta < det) {\n                return null;\n            }\n        }\n\n        return [new Point(\n            this.start.x + (alpha * pt1Dir.x / det),\n            this.start.y + (alpha * pt1Dir.y / det)\n        )];\n    },\n\n    isDifferentiable: function() {\n\n        return !this.start.equals(this.end);\n    },\n\n    // @return {double} length of the line\n    length: function() {\n        return length(this.start, this.end);\n    },\n\n    // @return {point} my midpoint\n    midpoint: function() {\n\n        return new Point(\n            (this.start.x + this.end.x) / 2,\n            (this.start.y + this.end.y) / 2\n        );\n    },\n\n    parallel: function(distance) {\n        const l = this.clone();\n        if (!this.isDifferentiable()) return l;\n        const { start, end } = l;\n        const eRef = start.clone().rotate(end, 270);\n        const sRef = end.clone().rotate(start, 90);\n        start.move(sRef, distance);\n        end.move(eRef, distance);\n        return l;\n    },\n\n    // @return {point} my point at 't' <0,1>\n    pointAt: function(t) {\n\n        var start = this.start;\n        var end = this.end;\n\n        if (t <= 0) return start.clone();\n        if (t >= 1) return end.clone();\n\n        return start.lerp(end, t);\n    },\n\n    pointAtLength: function(length) {\n\n        var start = this.start;\n        var end = this.end;\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var lineLength = this.length();\n        if (length >= lineLength) return (fromStart ? end.clone() : start.clone());\n\n        return this.pointAt((fromStart ? (length) : (lineLength - length)) / lineLength);\n    },\n\n    // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n    pointOffset: function(p) {\n\n        // Find the sign of the determinant of vectors (start,end), where p is the query point.\n        p = new Point(p);\n        var start = this.start;\n        var end = this.end;\n        var determinant = ((end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x));\n\n        return determinant / this.length();\n    },\n\n    rotate: function(origin, angle) {\n\n        this.start.rotate(origin, angle);\n        this.end.rotate(origin, angle);\n        return this;\n    },\n\n    round: function(precision) {\n\n        this.start.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.start.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    // @return {number} scale the line so that it has the requested length\n    setLength: function(length) {\n\n        var currentLength = this.length();\n        if (!currentLength) return this;\n\n        var scaleFactor = length / currentLength;\n        return this.scale(scaleFactor, scaleFactor, this.start);\n    },\n\n    // @return {integer} length without sqrt\n    // @note for applications where the exact length is not necessary (e.g. compare only)\n    squaredLength: function() {\n        return squaredLength(this.start, this.end);\n    },\n\n    tangentAt: function(t) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var start = this.start;\n        var end = this.end;\n\n        var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    tangentAtLength: function(length) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var start = this.start;\n        var end = this.end;\n\n        var tangentStart = this.pointAtLength(length);\n\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    toString: function() {\n\n        return this.start.toString() + ' ' + this.end.toString();\n    },\n\n    serialize: function() {\n\n        return this.start.serialize() + ' ' + this.end.serialize();\n    },\n\n    translate: function(tx, ty) {\n\n        this.start.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    },\n\n    // @return vector {point} of the line\n    vector: function() {\n\n        return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n    }\n};\n\n// For backwards compatibility:\nLine.prototype.intersection = Line.prototype.intersect;\n\n\n// For backwards compatibility:\nexport const line = Line;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}