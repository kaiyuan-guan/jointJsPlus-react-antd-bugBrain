{"ast":null,"code":"import * as g from '../g/index.mjs';\nconst CornerTypes = {\n  POINT: 'point',\n  CUBIC: 'cubic',\n  LINE: 'line',\n  GAP: 'gap'\n};\nconst DEFINED_CORNER_TYPES = Object.values(CornerTypes);\nconst CORNER_RADIUS = 10;\nconst PRECISION = 1;\nexport const straight = function (sourcePoint, targetPoint, routePoints = [], opt = {}) {\n  const {\n    cornerType = CornerTypes.POINT,\n    cornerRadius = CORNER_RADIUS,\n    cornerPreserveAspectRatio = false,\n    precision = PRECISION,\n    raw = false\n  } = opt;\n  if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) {\n    // unknown `cornerType` provided => error\n    throw new Error('Invalid `cornerType` provided to `straight` connector.');\n  }\n  let path;\n  if (cornerType === CornerTypes.POINT || !cornerRadius) {\n    // default option => normal connector\n    // simply connect all points with straight lines\n    const points = [sourcePoint].concat(routePoints).concat([targetPoint]);\n    const polyline = new g.Polyline(points);\n    path = new g.Path(polyline);\n  } else {\n    // `cornerType` is not unknown and not 'point' (default) => must be one of other valid types\n    path = new g.Path();\n\n    // add initial gap segment = to source point\n    path.appendSegment(g.Path.createSegment('M', sourcePoint));\n    let nextDistance;\n    const routePointsLength = routePoints.length;\n    for (let i = 0; i < routePointsLength; i++) {\n      const curr = new g.Point(routePoints[i]);\n      const prev = routePoints[i - 1] || sourcePoint;\n      const next = routePoints[i + 1] || targetPoint;\n      const prevDistance = nextDistance || curr.distance(prev) / 2; // try to re-use previously-computed `nextDistance`\n      nextDistance = curr.distance(next) / 2;\n      let startMove, endMove;\n      if (!cornerPreserveAspectRatio) {\n        // `startMove` and `endMove` may be different\n        // (this happens when next or previous path point is closer than `2 * cornerRadius`)\n        startMove = -Math.min(cornerRadius, prevDistance);\n        endMove = -Math.min(cornerRadius, nextDistance);\n      } else {\n        // force `startMove` and `endMove` to be the same\n        startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);\n      }\n\n      // to find `cornerStart` and `cornerEnd`, the logic is as follows (using `cornerStart` as example):\n      // - find a point lying on the line `prev - startMove` such that...\n      // - ...the point lies `abs(startMove)` distance away from `curr`...\n      // - ...and its coordinates are rounded to whole numbers\n      const cornerStart = curr.clone().move(prev, startMove).round(precision);\n      const cornerEnd = curr.clone().move(next, endMove).round(precision);\n\n      // add in-between straight segment = from previous route point to corner start point\n      // (may have zero length)\n      path.appendSegment(g.Path.createSegment('L', cornerStart));\n\n      // add corner segment = from corner start point to corner end point\n      switch (cornerType) {\n        case CornerTypes.CUBIC:\n          {\n            // corner is rounded\n            const _13 = 1 / 3;\n            const _23 = 2 / 3;\n            const control1 = new g.Point(_13 * cornerStart.x + _23 * curr.x, _23 * curr.y + _13 * cornerStart.y);\n            const control2 = new g.Point(_13 * cornerEnd.x + _23 * curr.x, _23 * curr.y + _13 * cornerEnd.y);\n            path.appendSegment(g.Path.createSegment('C', control1, control2, cornerEnd));\n            break;\n          }\n        case CornerTypes.LINE:\n          {\n            // corner has bevel\n            path.appendSegment(g.Path.createSegment('L', cornerEnd));\n            break;\n          }\n        case CornerTypes.GAP:\n          {\n            // corner has empty space\n            path.appendSegment(g.Path.createSegment('M', cornerEnd));\n            break;\n          }\n        // default: no segment is created\n      }\n    }\n\n    // add final straight segment = from last corner end point to target point\n    // (= or from start point to end point, if there are no route points)\n    // (may have zero length)\n    path.appendSegment(g.Path.createSegment('L', targetPoint));\n  }\n  return raw ? path : path.serialize();\n};","map":{"version":3,"names":["g","CornerTypes","POINT","CUBIC","LINE","GAP","DEFINED_CORNER_TYPES","Object","values","CORNER_RADIUS","PRECISION","straight","sourcePoint","targetPoint","routePoints","opt","cornerType","cornerRadius","cornerPreserveAspectRatio","precision","raw","indexOf","Error","path","points","concat","polyline","Polyline","Path","appendSegment","createSegment","nextDistance","routePointsLength","length","i","curr","Point","prev","next","prevDistance","distance","startMove","endMove","Math","min","cornerStart","clone","move","round","cornerEnd","_13","_23","control1","x","y","control2","serialize"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/connectors/straight.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\n\nconst CornerTypes = {\n    POINT: 'point',\n    CUBIC: 'cubic',\n    LINE: 'line',\n    GAP: 'gap'\n};\n\nconst DEFINED_CORNER_TYPES = Object.values(CornerTypes);\n\nconst CORNER_RADIUS = 10;\nconst PRECISION = 1;\n\nexport const straight = function(sourcePoint, targetPoint, routePoints = [], opt = {}) {\n\n    const {\n        cornerType = CornerTypes.POINT,\n        cornerRadius = CORNER_RADIUS,\n        cornerPreserveAspectRatio = false,\n        precision = PRECISION,\n        raw = false\n    } = opt;\n\n    if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) {\n        // unknown `cornerType` provided => error\n        throw new Error('Invalid `cornerType` provided to `straight` connector.');\n    }\n\n    let path;\n\n    if ((cornerType === CornerTypes.POINT) || !cornerRadius) {\n        // default option => normal connector\n        // simply connect all points with straight lines\n        const points = [sourcePoint].concat(routePoints).concat([targetPoint]);\n        const polyline = new g.Polyline(points);\n        path = new g.Path(polyline);\n\n    } else {\n        // `cornerType` is not unknown and not 'point' (default) => must be one of other valid types\n        path = new g.Path();\n\n        // add initial gap segment = to source point\n        path.appendSegment(g.Path.createSegment('M', sourcePoint));\n\n        let nextDistance;\n        const routePointsLength = routePoints.length;\n        for (let i = 0; i < routePointsLength; i++) {\n\n            const curr = new g.Point(routePoints[i]);\n            const prev = (routePoints[i - 1] || sourcePoint);\n            const next = (routePoints[i + 1] || targetPoint);\n            const prevDistance = (nextDistance || (curr.distance(prev) / 2)); // try to re-use previously-computed `nextDistance`\n            nextDistance = (curr.distance(next) / 2);\n\n            let startMove, endMove;\n            if (!cornerPreserveAspectRatio) {\n                // `startMove` and `endMove` may be different\n                // (this happens when next or previous path point is closer than `2 * cornerRadius`)\n                startMove = -Math.min(cornerRadius, prevDistance);\n                endMove = -Math.min(cornerRadius, nextDistance);\n            } else {\n                // force `startMove` and `endMove` to be the same\n                startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);\n            }\n\n            // to find `cornerStart` and `cornerEnd`, the logic is as follows (using `cornerStart` as example):\n            // - find a point lying on the line `prev - startMove` such that...\n            // - ...the point lies `abs(startMove)` distance away from `curr`...\n            // - ...and its coordinates are rounded to whole numbers\n            const cornerStart = curr.clone().move(prev, startMove).round(precision);\n            const cornerEnd = curr.clone().move(next, endMove).round(precision);\n\n            // add in-between straight segment = from previous route point to corner start point\n            // (may have zero length)\n            path.appendSegment(g.Path.createSegment('L', cornerStart));\n\n            // add corner segment = from corner start point to corner end point\n            switch (cornerType) {\n                case CornerTypes.CUBIC: {\n                    // corner is rounded\n                    const _13 = (1 / 3);\n                    const _23 = (2 / 3);\n                    const control1 = new g.Point((_13 * cornerStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * cornerStart.y));\n                    const control2 = new g.Point((_13 * cornerEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * cornerEnd.y));\n                    path.appendSegment(g.Path.createSegment('C', control1, control2, cornerEnd));\n                    break;\n                }\n                case CornerTypes.LINE: {\n                    // corner has bevel\n                    path.appendSegment(g.Path.createSegment('L', cornerEnd));\n                    break;\n                }\n                case CornerTypes.GAP: {\n                    // corner has empty space\n                    path.appendSegment(g.Path.createSegment('M', cornerEnd));\n                    break;\n                }\n                // default: no segment is created\n            }\n        }\n\n        // add final straight segment = from last corner end point to target point\n        // (= or from start point to end point, if there are no route points)\n        // (may have zero length)\n        path.appendSegment(g.Path.createSegment('L', targetPoint));\n    }\n\n    return ((raw) ? path : path.serialize());\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}