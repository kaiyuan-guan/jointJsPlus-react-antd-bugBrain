{"ast":null,"code":"// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).\nimport { Polyline } from './polyline.mjs';\nimport { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { Line } from './line.mjs';\nimport { Curve } from './curve.mjs';\nimport { types } from './types.mjs';\nimport { extend } from './extend.mjs';\nexport const Path = function (arg) {\n  if (!(this instanceof Path)) {\n    return new Path(arg);\n  }\n  if (typeof arg === 'string') {\n    // create from a path data string\n    return new Path.parse(arg);\n  }\n  this.segments = [];\n  var i;\n  var n;\n  if (!arg) {\n    // don't do anything\n  } else if (Array.isArray(arg) && arg.length !== 0) {\n    // if arg is a non-empty array\n    // flatten one level deep\n    // so we can chain arbitrary Path.createSegment results\n    arg = arg.reduce(function (acc, val) {\n      return acc.concat(val);\n    }, []);\n    n = arg.length;\n    if (arg[0].isSegment) {\n      // create from an array of segments\n      for (i = 0; i < n; i++) {\n        var segment = arg[i];\n        this.appendSegment(segment);\n      }\n    } else {\n      // create from an array of Curves and/or Lines\n      var previousObj = null;\n      for (i = 0; i < n; i++) {\n        var obj = arg[i];\n        if (!(obj instanceof Line || obj instanceof Curve)) {\n          throw new Error('Cannot construct a path segment from the provided object.');\n        }\n        if (i === 0) this.appendSegment(Path.createSegment('M', obj.start));\n\n        // if objects do not link up, moveto segments are inserted to cover the gaps\n        if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path.createSegment('M', obj.start));\n        if (obj instanceof Line) {\n          this.appendSegment(Path.createSegment('L', obj.end));\n        } else if (obj instanceof Curve) {\n          this.appendSegment(Path.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));\n        }\n        previousObj = obj;\n      }\n    }\n  } else if (arg.isSegment) {\n    // create from a single segment\n    this.appendSegment(arg);\n  } else if (arg instanceof Line) {\n    // create from a single Line\n    this.appendSegment(Path.createSegment('M', arg.start));\n    this.appendSegment(Path.createSegment('L', arg.end));\n  } else if (arg instanceof Curve) {\n    // create from a single Curve\n    this.appendSegment(Path.createSegment('M', arg.start));\n    this.appendSegment(Path.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));\n  } else if (arg instanceof Polyline) {\n    // create from a Polyline\n    if (!(arg.points && arg.points.length !== 0)) return; // if Polyline has no points, leave Path empty\n\n    n = arg.points.length;\n    for (i = 0; i < n; i++) {\n      var point = arg.points[i];\n      if (i === 0) this.appendSegment(Path.createSegment('M', point));else this.appendSegment(Path.createSegment('L', point));\n    }\n  } else {\n    // unknown object\n    throw new Error('Cannot construct a path from the provided object.');\n  }\n};\n\n// More permissive than V.normalizePathData and Path.prototype.serialize.\n// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n// Allows for command argument chaining.\n// Throws an error if wrong number of arguments is provided with a command.\n// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\nPath.parse = function (pathData) {\n  if (!pathData) return new Path();\n  var path = new Path();\n  var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n  var commands = pathData.match(commandRe);\n  var numCommands = commands.length;\n  for (var i = 0; i < numCommands; i++) {\n    var command = commands[i];\n    var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n    var args = command.match(argRe);\n    var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n    path.appendSegment(segment);\n  }\n  return path;\n};\n\n// Create a segment or an array of segments.\n// Accepts unlimited points/coords arguments after `type`.\nPath.createSegment = function (type) {\n  if (!type) throw new Error('Type must be provided.');\n  var segmentConstructor = Path.segmentTypes[type];\n  if (!segmentConstructor) throw new Error(type + ' is not a recognized path segment type.');\n  var args = [];\n  var n = arguments.length;\n  for (var i = 1; i < n; i++) {\n    // do not add first element (`type`) to args array\n    args.push(arguments[i]);\n  }\n  return applyToNew(segmentConstructor, args);\n};\nPath.prototype = {\n  type: types.Path,\n  // Accepts one segment or an array of segments as argument.\n  // Throws an error if argument is not a segment or an array of segments.\n  appendSegment: function (arg) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    // works even if path has no segments\n\n    var currentSegment;\n    var previousSegment = numSegments !== 0 ? segments[numSegments - 1] : null; // if we are appending to an empty path, previousSegment is null\n    var nextSegment = null;\n    if (!Array.isArray(arg)) {\n      // arg is a segment\n      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n      segments.push(currentSegment);\n    } else {\n      // arg is an array of segments\n      // flatten one level deep\n      // so we can chain arbitrary Path.createSegment results\n      arg = arg.reduce(function (acc, val) {\n        return acc.concat(val);\n      }, []);\n      if (!arg[0].isSegment) throw new Error('Segments required.');\n      var n = arg.length;\n      for (var i = 0; i < n; i++) {\n        var currentArg = arg[i];\n        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n        segments.push(currentSegment);\n        previousSegment = currentSegment;\n      }\n    }\n  },\n  // Returns the bbox of the path.\n  // If path has no segments, returns null.\n  // If path has only invisible segments, returns bbox of the end point of last segment.\n  bbox: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var bbox;\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      if (segment.isVisible) {\n        var segmentBBox = segment.bbox();\n        bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n      }\n    }\n    if (bbox) return bbox;\n\n    // if the path has only invisible elements, return end point of last segment\n    var lastSegment = segments[numSegments - 1];\n    return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n  },\n  // Returns a new path that is a clone of this path.\n  clone: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    // works even if path has no segments\n\n    var path = new Path();\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i].clone();\n      path.appendSegment(segment);\n    }\n    return path;\n  },\n  closestPoint: function (p, opt) {\n    var t = this.closestPointT(p, opt);\n    if (!t) return null;\n    return this.pointAtT(t);\n  },\n  closestPointLength: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var t = this.closestPointT(p, localOpt);\n    if (!t) return 0;\n    return this.lengthAtT(t, localOpt);\n  },\n  closestPointNormalizedLength: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var cpLength = this.closestPointLength(p, localOpt);\n    if (cpLength === 0) return 0; // shortcut\n\n    var length = this.length(localOpt);\n    if (length === 0) return 0; // prevents division by zero\n\n    return cpLength / length;\n  },\n  // Private function.\n  closestPointT: function (p, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    // not using localOpt\n\n    var closestPointT;\n    var minSquaredDistance = Infinity;\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var subdivisions = segmentSubdivisions[i];\n      if (segment.isVisible) {\n        var segmentClosestPointT = segment.closestPointT(p, {\n          precision: precision,\n          subdivisions: subdivisions\n        });\n        var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();\n        if (squaredDistance < minSquaredDistance) {\n          closestPointT = {\n            segmentIndex: i,\n            value: segmentClosestPointT\n          };\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n    if (closestPointT) return closestPointT;\n\n    // if no visible segment, return end of last segment\n    return {\n      segmentIndex: numSegments - 1,\n      value: 1\n    };\n  },\n  closestPointTangent: function (p, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    // not using localOpt\n\n    var closestPointTangent;\n    var minSquaredDistance = Infinity;\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var subdivisions = segmentSubdivisions[i];\n      if (segment.isDifferentiable()) {\n        var segmentClosestPointT = segment.closestPointT(p, {\n          precision: precision,\n          subdivisions: subdivisions\n        });\n        var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();\n        if (squaredDistance < minSquaredDistance) {\n          closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n    if (closestPointTangent) return closestPointTangent;\n\n    // if no valid segment, return null\n    return null;\n  },\n  // Returns `true` if the area surrounded by the path contains the point `p`.\n  // Implements the even-odd algorithm (self-intersections are \"outside\").\n  // Closes open paths (always imagines a final closing segment).\n  // Precision may be adjusted by passing an `opt` object.\n  containsPoint: function (p, opt) {\n    var polylines = this.toPolylines(opt);\n    if (!polylines) return false; // shortcut (this path has no polylines)\n\n    var numPolylines = polylines.length;\n\n    // how many component polylines does `p` lie within?\n    var numIntersections = 0;\n    for (var i = 0; i < numPolylines; i++) {\n      var polyline = polylines[i];\n      if (polyline.containsPoint(p)) {\n        // `p` lies within this polyline\n        numIntersections++;\n      }\n    }\n\n    // returns `true` for odd numbers of intersections (even-odd algorithm)\n    return numIntersections % 2 === 1;\n  },\n  // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n  divideAt: function (ratio, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (ratio < 0) ratio = 0;\n    if (ratio > 1) ratio = 1;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var pathLength = this.length(localOpt);\n    var length = pathLength * ratio;\n    return this.divideAtLength(length, localOpt);\n  },\n  // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  divideAtLength: function (length, opt) {\n    var numSegments = this.segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var fromStart = true;\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n      length = -length; // absolute value\n    }\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    // not using localOpt\n\n    var i;\n    var segment;\n\n    // identify the segment to divide:\n\n    var l = 0; // length so far\n    var divided;\n    var dividedSegmentIndex;\n    var lastValidSegment; // visible AND differentiable\n    var lastValidSegmentIndex;\n    var t;\n    for (i = 0; i < numSegments; i++) {\n      var index = fromStart ? i : numSegments - 1 - i;\n      segment = this.getSegment(index);\n      var subdivisions = segmentSubdivisions[index];\n      var d = segment.length({\n        precision: precision,\n        subdivisions: subdivisions\n      });\n      if (segment.isDifferentiable()) {\n        // segment is not just a point\n        lastValidSegment = segment;\n        lastValidSegmentIndex = index;\n        if (length <= l + d) {\n          dividedSegmentIndex = index;\n          divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - l), {\n            precision: precision,\n            subdivisions: subdivisions\n          });\n          break;\n        }\n      }\n      l += d;\n    }\n    if (!lastValidSegment) {\n      // no valid segment found\n      return null;\n    }\n\n    // else: the path contains at least one valid segment\n\n    if (!divided) {\n      // the desired length is greater than the length of the path\n      dividedSegmentIndex = lastValidSegmentIndex;\n      t = fromStart ? 1 : 0;\n      divided = lastValidSegment.divideAtT(t);\n    }\n\n    // create a copy of this path and replace the identified segment with its two divided parts:\n\n    var pathCopy = this.clone();\n    pathCopy.replaceSegment(dividedSegmentIndex, divided);\n    var divisionStartIndex = dividedSegmentIndex;\n    var divisionMidIndex = dividedSegmentIndex + 1;\n    var divisionEndIndex = dividedSegmentIndex + 2;\n\n    // do not insert the part if it looks like a point\n    if (!divided[0].isDifferentiable()) {\n      pathCopy.removeSegment(divisionStartIndex);\n      divisionMidIndex -= 1;\n      divisionEndIndex -= 1;\n    }\n\n    // insert a Moveto segment to ensure secondPath will be valid:\n    var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n    pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n    divisionEndIndex += 1;\n\n    // do not insert the part if it looks like a point\n    if (!divided[1].isDifferentiable()) {\n      pathCopy.removeSegment(divisionEndIndex - 1);\n      divisionEndIndex -= 1;\n    }\n\n    // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n    var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n    for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {\n      var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n      segment = pathCopy.getSegment(i);\n      if (segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n        // pathCopy segment's subpathStartSegment is different from original segment's one\n        // convert this Closepath segment to a Lineto and replace it in pathCopy\n        var convertedSegment = Path.createSegment('L', originalSegment.end);\n        pathCopy.replaceSegment(i, convertedSegment);\n      }\n    }\n\n    // distribute pathCopy segments into two paths and return those:\n\n    var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n    var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n    return [firstPath, secondPath];\n  },\n  // Checks whether two paths are exactly the same.\n  // If `p` is undefined or null, returns false.\n  equals: function (p) {\n    if (!p) return false;\n    var segments = this.segments;\n    var otherSegments = p.segments;\n    var numSegments = segments.length;\n    if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var otherSegment = otherSegments[i];\n\n      // as soon as an inequality is found in segments, return false\n      if (segment.type !== otherSegment.type || !segment.equals(otherSegment)) return false;\n    }\n\n    // if no inequality found in segments, return true\n    return true;\n  },\n  // Accepts negative indices.\n  // Throws an error if path has no segments.\n  // Throws an error if index is out of range.\n  getSegment: function (index) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) throw new Error('Path has no segments.');\n    if (index < 0) index = numSegments + index; // convert negative indices to positive\n    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n    return segments[index];\n  },\n  // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n  getSegmentSubdivisions: function (opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    // works even if path has no segments\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    // not using opt.segmentSubdivisions\n    // not using localOpt\n\n    var segmentSubdivisions = [];\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var subdivisions = segment.getSubdivisions({\n        precision: precision\n      });\n      segmentSubdivisions.push(subdivisions);\n    }\n    return segmentSubdivisions;\n  },\n  // Returns an array of subpaths of this path.\n  // Invalid paths are validated first.\n  // Returns `[]` if path has no segments.\n  getSubpaths: function () {\n    const validatedPath = this.clone().validate();\n    const segments = validatedPath.segments;\n    const numSegments = segments.length;\n    const subpaths = [];\n    for (let i = 0; i < numSegments; i++) {\n      const segment = segments[i];\n      if (segment.isSubpathStart) {\n        // we encountered a subpath start segment\n        // create a new path for segment, and push it to list of subpaths\n        subpaths.push(new Path(segment));\n      } else {\n        // append current segment to the last subpath\n        subpaths[subpaths.length - 1].appendSegment(segment);\n      }\n    }\n    return subpaths;\n  },\n  // Insert `arg` at given `index`.\n  // `index = 0` means insert at the beginning.\n  // `index = segments.length` means insert at the end.\n  // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n  // Accepts one segment or an array of segments as argument.\n  // Throws an error if index is out of range.\n  // Throws an error if argument is not a segment or an array of segments.\n  insertSegment: function (index, arg) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    // works even if path has no segments\n\n    // note that these are incremented compared to getSegments()\n    // we can insert after last element (note that this changes the meaning of index -1)\n    if (index < 0) index = numSegments + index + 1; // convert negative indices to positive\n    if (index > numSegments || index < 0) throw new Error('Index out of range.');\n    var currentSegment;\n    var previousSegment = null;\n    var nextSegment = null;\n    if (numSegments !== 0) {\n      if (index >= 1) {\n        previousSegment = segments[index - 1];\n        nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n      } else {\n        // if index === 0\n        // previousSegment is null\n        nextSegment = segments[0];\n      }\n    }\n    if (!Array.isArray(arg)) {\n      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n      segments.splice(index, 0, currentSegment);\n    } else {\n      // flatten one level deep\n      // so we can chain arbitrary Path.createSegment results\n      arg = arg.reduce(function (acc, val) {\n        return acc.concat(val);\n      }, []);\n      if (!arg[0].isSegment) throw new Error('Segments required.');\n      var n = arg.length;\n      for (var i = 0; i < n; i++) {\n        var currentArg = arg[i];\n        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n        segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n        previousSegment = currentSegment;\n      }\n    }\n  },\n  intersectionWithLine: function (line, opt) {\n    var intersection = null;\n    var polylines = this.toPolylines(opt);\n    if (!polylines) return null;\n    for (var i = 0, n = polylines.length; i < n; i++) {\n      var polyline = polylines[i];\n      var polylineIntersection = line.intersect(polyline);\n      if (polylineIntersection) {\n        intersection || (intersection = []);\n        if (Array.isArray(polylineIntersection)) {\n          Array.prototype.push.apply(intersection, polylineIntersection);\n        } else {\n          intersection.push(polylineIntersection);\n        }\n      }\n    }\n    return intersection;\n  },\n  isDifferentiable: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      // as soon as a differentiable segment is found in segments, return true\n      if (segment.isDifferentiable()) return true;\n    }\n\n    // if no differentiable segment is found in segments, return false\n    return false;\n  },\n  // Checks whether current path segments are valid.\n  // Note that d is allowed to be empty - should disable rendering of the path.\n  isValid: function () {\n    var segments = this.segments;\n    var isValid = segments.length === 0 || segments[0].type === 'M'; // either empty or first segment is a Moveto\n    return isValid;\n  },\n  // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n  // If path has no segments, returns 0.\n  length: function (opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return 0; // if segments is an empty array\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    // not using localOpt\n\n    var length = 0;\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        subdivisions: subdivisions\n      });\n    }\n    return length;\n  },\n  // Private function.\n  lengthAtT: function (t, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return 0; // if segments is an empty array\n\n    var segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) return 0; // regardless of t.value\n\n    var tValue = t.value;\n    if (segmentIndex >= numSegments) {\n      segmentIndex = numSegments - 1;\n      tValue = 1;\n    } else if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    // not using localOpt\n\n    var subdivisions;\n    var length = 0;\n    for (var i = 0; i < segmentIndex; i++) {\n      var segment = segments[i];\n      subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        precisison: precision,\n        subdivisions: subdivisions\n      });\n    }\n    segment = segments[segmentIndex];\n    subdivisions = segmentSubdivisions[segmentIndex];\n    length += segment.lengthAtT(tValue, {\n      precisison: precision,\n      subdivisions: subdivisions\n    });\n    return length;\n  },\n  // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n  pointAt: function (ratio, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (ratio <= 0) return this.start.clone();\n    if (ratio >= 1) return this.end.clone();\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var pathLength = this.length(localOpt);\n    var length = pathLength * ratio;\n    return this.pointAtLength(length, localOpt);\n  },\n  // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n  // Accepts negative length.\n  pointAtLength: function (length, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (length === 0) return this.start.clone();\n    var fromStart = true;\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n      length = -length; // absolute value\n    }\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    // not using localOpt\n\n    var lastVisibleSegment;\n    var l = 0; // length so far\n    for (var i = 0; i < numSegments; i++) {\n      var index = fromStart ? i : numSegments - 1 - i;\n      var segment = segments[index];\n      var subdivisions = segmentSubdivisions[index];\n      var d = segment.length({\n        precision: precision,\n        subdivisions: subdivisions\n      });\n      if (segment.isVisible) {\n        if (length <= l + d) {\n          return segment.pointAtLength((fromStart ? 1 : -1) * (length - l), {\n            precision: precision,\n            subdivisions: subdivisions\n          });\n        }\n        lastVisibleSegment = segment;\n      }\n      l += d;\n    }\n\n    // if length requested is higher than the length of the path, return last visible segment endpoint\n    if (lastVisibleSegment) return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;\n\n    // if no visible segment, return last segment end point (no matter if fromStart or no)\n    var lastSegment = segments[numSegments - 1];\n    return lastSegment.end.clone();\n  },\n  // Private function.\n  pointAtT: function (t) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) return segments[0].pointAtT(0);\n    if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);\n    var tValue = t.value;\n    if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n    return segments[segmentIndex].pointAtT(tValue);\n  },\n  // Default precision\n  PRECISION: 3,\n  // Helper method for adding segments.\n  prepareSegment: function (segment, previousSegment, nextSegment) {\n    // insert after previous segment and before previous segment's next segment\n    segment.previousSegment = previousSegment;\n    segment.nextSegment = nextSegment;\n    if (previousSegment) previousSegment.nextSegment = segment;\n    if (nextSegment) nextSegment.previousSegment = segment;\n    var updateSubpathStart = segment;\n    if (segment.isSubpathStart) {\n      segment.subpathStartSegment = segment; // assign self as subpath start segment\n      updateSubpathStart = nextSegment; // start updating from next segment\n    }\n\n    // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n    if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);\n    return segment;\n  },\n  // Remove the segment at `index`.\n  // Accepts negative indices, from `-1` to `-segments.length`.\n  // Throws an error if path has no segments.\n  // Throws an error if index is out of range.\n  removeSegment: function (index) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) throw new Error('Path has no segments.');\n    if (index < 0) index = numSegments + index; // convert negative indices to positive\n    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n    var removedSegment = segments.splice(index, 1)[0];\n    var previousSegment = removedSegment.previousSegment;\n    var nextSegment = removedSegment.nextSegment;\n\n    // link the previous and next segments together (if present)\n    if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null\n    if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null\n\n    // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n    if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n  },\n  // Replace the segment at `index` with `arg`.\n  // Accepts negative indices, from `-1` to `-segments.length`.\n  // Accepts one segment or an array of segments as argument.\n  // Throws an error if path has no segments.\n  // Throws an error if index is out of range.\n  // Throws an error if argument is not a segment or an array of segments.\n  replaceSegment: function (index, arg) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) throw new Error('Path has no segments.');\n    if (index < 0) index = numSegments + index; // convert negative indices to positive\n    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n    var currentSegment;\n    var replacedSegment = segments[index];\n    var previousSegment = replacedSegment.previousSegment;\n    var nextSegment = replacedSegment.nextSegment;\n    var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n\n    if (!Array.isArray(arg)) {\n      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n      segments.splice(index, 1, currentSegment); // directly replace\n\n      if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n    } else {\n      // flatten one level deep\n      // so we can chain arbitrary Path.createSegment results\n      arg = arg.reduce(function (acc, val) {\n        return acc.concat(val);\n      }, []);\n      if (!arg[0].isSegment) throw new Error('Segments required.');\n      segments.splice(index, 1);\n      var n = arg.length;\n      for (var i = 0; i < n; i++) {\n        var currentArg = arg[i];\n        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n        segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n        previousSegment = currentSegment;\n        if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n      }\n    }\n\n    // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n    if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n  },\n  round: function (precision) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      segment.round(precision);\n    }\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      segment.scale(sx, sy, origin);\n    }\n    return this;\n  },\n  segmentAt: function (ratio, opt) {\n    var index = this.segmentIndexAt(ratio, opt);\n    if (!index) return null;\n    return this.getSegment(index);\n  },\n  // Accepts negative length.\n  segmentAtLength: function (length, opt) {\n    var index = this.segmentIndexAtLength(length, opt);\n    if (!index) return null;\n    return this.getSegment(index);\n  },\n  segmentIndexAt: function (ratio, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (ratio < 0) ratio = 0;\n    if (ratio > 1) ratio = 1;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var pathLength = this.length(localOpt);\n    var length = pathLength * ratio;\n    return this.segmentIndexAtLength(length, localOpt);\n  },\n  // Accepts negative length.\n  segmentIndexAtLength: function (length, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var fromStart = true;\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n      length = -length; // absolute value\n    }\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    // not using localOpt\n\n    var lastVisibleSegmentIndex = null;\n    var l = 0; // length so far\n    for (var i = 0; i < numSegments; i++) {\n      var index = fromStart ? i : numSegments - 1 - i;\n      var segment = segments[index];\n      var subdivisions = segmentSubdivisions[index];\n      var d = segment.length({\n        precision: precision,\n        subdivisions: subdivisions\n      });\n      if (segment.isVisible) {\n        if (length <= l + d) return index;\n        lastVisibleSegmentIndex = index;\n      }\n      l += d;\n    }\n\n    // if length requested is higher than the length of the path, return last visible segment index\n    // if no visible segment, return null\n    return lastVisibleSegmentIndex;\n  },\n  // Returns a string that can be used to reconstruct the path.\n  // Additional error checking compared to toString (must start with M segment).\n  serialize: function () {\n    if (!this.isValid()) throw new Error('Invalid path segments.');\n    return this.toString();\n  },\n  // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n  tangentAt: function (ratio, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (ratio < 0) ratio = 0;\n    if (ratio > 1) ratio = 1;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var pathLength = this.length(localOpt);\n    var length = pathLength * ratio;\n    return this.tangentAtLength(length, localOpt);\n  },\n  // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n  // Accepts negative length.\n  tangentAtLength: function (length, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var fromStart = true;\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n      length = -length; // absolute value\n    }\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    // not using localOpt\n\n    var lastValidSegment; // visible AND differentiable (with a tangent)\n    var l = 0; // length so far\n    for (var i = 0; i < numSegments; i++) {\n      var index = fromStart ? i : numSegments - 1 - i;\n      var segment = segments[index];\n      var subdivisions = segmentSubdivisions[index];\n      var d = segment.length({\n        precision: precision,\n        subdivisions: subdivisions\n      });\n      if (segment.isDifferentiable()) {\n        if (length <= l + d) {\n          return segment.tangentAtLength((fromStart ? 1 : -1) * (length - l), {\n            precision: precision,\n            subdivisions: subdivisions\n          });\n        }\n        lastValidSegment = segment;\n      }\n      l += d;\n    }\n\n    // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n    if (lastValidSegment) {\n      var t = fromStart ? 1 : 0;\n      return lastValidSegment.tangentAtT(t);\n    }\n\n    // if no valid segment, return null\n    return null;\n  },\n  // Private function.\n  tangentAtT: function (t) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) return segments[0].tangentAtT(0);\n    if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);\n    var tValue = t.value;\n    if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n    return segments[segmentIndex].tangentAtT(tValue);\n  },\n  toPoints: function (opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var points = [];\n    var partialPoints = [];\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      if (segment.isVisible) {\n        var currentSegmentSubdivisions = segmentSubdivisions[i];\n        if (currentSegmentSubdivisions.length > 0) {\n          var subdivisionPoints = currentSegmentSubdivisions.map(function (curve) {\n            return curve.start;\n          });\n          Array.prototype.push.apply(partialPoints, subdivisionPoints);\n        } else {\n          partialPoints.push(segment.start);\n        }\n      } else if (partialPoints.length > 0) {\n        partialPoints.push(segments[i - 1].end);\n        points.push(partialPoints);\n        partialPoints = [];\n      }\n    }\n    if (partialPoints.length > 0) {\n      partialPoints.push(this.end);\n      points.push(partialPoints);\n    }\n    return points;\n  },\n  toPolylines: function (opt) {\n    var polylines = [];\n    var points = this.toPoints(opt);\n    if (!points) return null;\n    for (var i = 0, n = points.length; i < n; i++) {\n      polylines.push(new Polyline(points[i]));\n    }\n    return polylines;\n  },\n  toString: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    var pathData = '';\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      pathData += segment.serialize() + ' ';\n    }\n    return pathData.trim();\n  },\n  translate: function (tx, ty) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      segment.translate(tx, ty);\n    }\n    return this;\n  },\n  // Helper method for updating subpath start of segments, starting with the one provided.\n  updateSubpathStartSegment: function (segment) {\n    var previousSegment = segment.previousSegment; // may be null\n    while (segment && !segment.isSubpathStart) {\n      // assign previous segment's subpath start segment to this segment\n      if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null\n      else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!\n\n      previousSegment = segment;\n      segment = segment.nextSegment; // move on to the segment after etc.\n    }\n  },\n  // If the path is not valid, insert M 0 0 at the beginning.\n  // Path with no segments is considered valid, so nothing is inserted.\n  validate: function () {\n    if (!this.isValid()) this.insertSegment(0, Path.createSegment('M', 0, 0));\n    return this;\n  }\n};\nObject.defineProperty(Path.prototype, 'start', {\n  // Getter for the first visible endpoint of the path.\n\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null;\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      if (segment.isVisible) return segment.start;\n    }\n\n    // if no visible segment, return last segment end point\n    return segments[numSegments - 1].end;\n  }\n});\nObject.defineProperty(Path.prototype, 'end', {\n  // Getter for the last visible endpoint of the path.\n\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null;\n    for (var i = numSegments - 1; i >= 0; i--) {\n      var segment = segments[i];\n      if (segment.isVisible) return segment.end;\n    }\n\n    // if no visible segment, return last segment end point\n    return segments[numSegments - 1].end;\n  }\n});\n\n// Local helper function.\n// Use an array of arguments to call a constructor (function called with `new`).\n// Adapted from https://stackoverflow.com/a/8843181/2263595\n// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\nfunction applyToNew(constructor, argsArray) {\n  // The `new` keyword can only be applied to functions that take a limited number of arguments.\n  // - We can fake that with .bind().\n  // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n  // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n  // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n  // We need to pass in a variable number of arguments to the bind() call.\n  // - We can use .apply().\n  // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n  // - `thisArg` can still be anything because `new` overwrites it.\n  // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n  // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\n  // The function expects `argsArray[0]` to be `thisArg`.\n  // - This means that whatever is sent as the first element will be ignored.\n  // - The constructor will only see arguments starting from argsArray[1].\n  // - So, a new dummy element is inserted at the start of the array.\n  argsArray.unshift(null);\n  return new (Function.prototype.bind.apply(constructor, argsArray))();\n}\n\n// Path segment interface:\nvar segmentPrototype = {\n  // virtual\n  bbox: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  clone: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  closestPoint: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  closestPointLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  closestPointNormalizedLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n  closestPointT: function (p) {\n    if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);\n    throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');\n  },\n  // virtual\n  closestPointTangent: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  divideAt: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  divideAtLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n  divideAtT: function (t) {\n    if (this.divideAt) return this.divideAt(t);\n    throw new Error('Neither divideAtT() nor divideAt() function is implemented.');\n  },\n  // virtual\n  equals: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  getSubdivisions: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  isDifferentiable: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  isSegment: true,\n  isSubpathStart: false,\n  // true for Moveto segments\n\n  isVisible: true,\n  // false for Moveto segments\n\n  // virtual\n  length: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n  lengthAtT: function (t) {\n    if (t <= 0) return 0;\n    var length = this.length();\n    if (t >= 1) return length;\n    return length * t;\n  },\n  nextSegment: null,\n  // needed for subpath start segment updating\n\n  // virtual\n  pointAt: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  pointAtLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n  pointAtT: function (t) {\n    if (this.pointAt) return this.pointAt(t);\n    throw new Error('Neither pointAtT() nor pointAt() function is implemented.');\n  },\n  previousSegment: null,\n  // needed to get segment start property\n\n  // virtual\n  round: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  subpathStartSegment: null,\n  // needed to get Closepath segment end property\n\n  // virtual\n  scale: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  serialize: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  tangentAt: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  tangentAtLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n  tangentAtT: function (t) {\n    if (this.tangentAt) return this.tangentAt(t);\n    throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');\n  },\n  // virtual\n  toString: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  translate: function () {\n    throw new Error('Declaration missing for virtual function.');\n  }\n};\n\n// usually directly assigned\n// getter for Closepath\nObject.defineProperty(segmentPrototype, 'end', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n// always a getter\n// always throws error for Moveto\nObject.defineProperty(segmentPrototype, 'start', {\n  // get a reference to the end point of previous segment\n\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.previousSegment) throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)');\n    return this.previousSegment.end;\n  }\n});\n\n// virtual\nObject.defineProperty(segmentPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    throw new Error('Bad segment declaration. No type specified.');\n  }\n});\n\n// Path segment implementations:\nvar Lineto = function () {\n  var args = [];\n  var n = arguments.length;\n  for (var i = 0; i < n; i++) {\n    args.push(arguments[i]);\n  }\n  if (!(this instanceof Lineto)) {\n    // switching context of `this` to Lineto when called without `new`\n    return applyToNew(Lineto, args);\n  }\n  if (n === 0) {\n    throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');\n  }\n  var outputArray;\n  if (args[0] instanceof Line) {\n    // lines provided\n    if (n === 1) {\n      this.end = args[0].end.clone();\n      return this;\n    } else {\n      throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');\n    }\n  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n    // coordinates provided\n    if (n === 2) {\n      this.end = new Point(+args[0], +args[1]);\n      return this;\n    } else if (n < 2) {\n      throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n    } else {\n      // this is a poly-line segment\n      var segmentCoords;\n      outputArray = [];\n      for (i = 0; i < n; i += 2) {\n        // coords come in groups of two\n\n        segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n        outputArray.push(applyToNew(Lineto, segmentCoords));\n      }\n      return outputArray;\n    }\n  } else {\n    // points provided (needs to be last to also cover plain objects with x and y)\n    if (n === 1) {\n      this.end = new Point(args[0]);\n      return this;\n    } else {\n      // this is a poly-line segment\n      var segmentPoint;\n      outputArray = [];\n      for (i = 0; i < n; i += 1) {\n        segmentPoint = args[i];\n        outputArray.push(new Lineto(segmentPoint));\n      }\n      return outputArray;\n    }\n  }\n};\nvar linetoPrototype = {\n  clone: function () {\n    return new Lineto(this.end);\n  },\n  divideAt: function (ratio) {\n    var line = new Line(this.start, this.end);\n    var divided = line.divideAt(ratio);\n    return [new Lineto(divided[0]), new Lineto(divided[1])];\n  },\n  divideAtLength: function (length) {\n    var line = new Line(this.start, this.end);\n    var divided = line.divideAtLength(length);\n    return [new Lineto(divided[0]), new Lineto(divided[1])];\n  },\n  getSubdivisions: function () {\n    return [];\n  },\n  isDifferentiable: function () {\n    if (!this.previousSegment) return false;\n    return !this.start.equals(this.end);\n  },\n  round: function (precision) {\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  serialize: function () {\n    var end = this.end;\n    return this.type + ' ' + end.x + ' ' + end.y;\n  },\n  toString: function () {\n    return this.type + ' ' + this.start + ' ' + this.end;\n  },\n  translate: function (tx, ty) {\n    this.end.translate(tx, ty);\n    return this;\n  }\n};\nObject.defineProperty(linetoPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  value: 'L'\n});\nLineto.prototype = extend(segmentPrototype, Line.prototype, linetoPrototype);\nvar Curveto = function () {\n  var args = [];\n  var n = arguments.length;\n  for (var i = 0; i < n; i++) {\n    args.push(arguments[i]);\n  }\n  if (!(this instanceof Curveto)) {\n    // switching context of `this` to Curveto when called without `new`\n    return applyToNew(Curveto, args);\n  }\n  if (n === 0) {\n    throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');\n  }\n  var outputArray;\n  if (args[0] instanceof Curve) {\n    // curves provided\n    if (n === 1) {\n      this.controlPoint1 = args[0].controlPoint1.clone();\n      this.controlPoint2 = args[0].controlPoint2.clone();\n      this.end = args[0].end.clone();\n      return this;\n    } else {\n      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');\n    }\n  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n    // coordinates provided\n    if (n === 6) {\n      this.controlPoint1 = new Point(+args[0], +args[1]);\n      this.controlPoint2 = new Point(+args[2], +args[3]);\n      this.end = new Point(+args[4], +args[5]);\n      return this;\n    } else if (n < 6) {\n      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');\n    } else {\n      // this is a poly-bezier segment\n      var segmentCoords;\n      outputArray = [];\n      for (i = 0; i < n; i += 6) {\n        // coords come in groups of six\n\n        segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n        outputArray.push(applyToNew(Curveto, segmentCoords));\n      }\n      return outputArray;\n    }\n  } else {\n    // points provided (needs to be last to also cover plain objects with x and y)\n    if (n === 3) {\n      this.controlPoint1 = new Point(args[0]);\n      this.controlPoint2 = new Point(args[1]);\n      this.end = new Point(args[2]);\n      return this;\n    } else if (n < 3) {\n      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');\n    } else {\n      // this is a poly-bezier segment\n      var segmentPoints;\n      outputArray = [];\n      for (i = 0; i < n; i += 3) {\n        // points come in groups of three\n\n        segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n        outputArray.push(applyToNew(Curveto, segmentPoints));\n      }\n      return outputArray;\n    }\n  }\n};\nvar curvetoPrototype = {\n  clone: function () {\n    return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n  },\n  divideAt: function (ratio, opt) {\n    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    var divided = curve.divideAt(ratio, opt);\n    return [new Curveto(divided[0]), new Curveto(divided[1])];\n  },\n  divideAtLength: function (length, opt) {\n    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    var divided = curve.divideAtLength(length, opt);\n    return [new Curveto(divided[0]), new Curveto(divided[1])];\n  },\n  divideAtT: function (t) {\n    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    var divided = curve.divideAtT(t);\n    return [new Curveto(divided[0]), new Curveto(divided[1])];\n  },\n  isDifferentiable: function () {\n    if (!this.previousSegment) return false;\n    var start = this.start;\n    var control1 = this.controlPoint1;\n    var control2 = this.controlPoint2;\n    var end = this.end;\n    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n  },\n  round: function (precision) {\n    this.controlPoint1.round(precision);\n    this.controlPoint2.round(precision);\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.controlPoint1.scale(sx, sy, origin);\n    this.controlPoint2.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  serialize: function () {\n    var c1 = this.controlPoint1;\n    var c2 = this.controlPoint2;\n    var end = this.end;\n    return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;\n  },\n  toString: function () {\n    return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n  },\n  translate: function (tx, ty) {\n    this.controlPoint1.translate(tx, ty);\n    this.controlPoint2.translate(tx, ty);\n    this.end.translate(tx, ty);\n    return this;\n  }\n};\nObject.defineProperty(curvetoPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  value: 'C'\n});\nCurveto.prototype = extend(segmentPrototype, Curve.prototype, curvetoPrototype);\nvar Moveto = function () {\n  var args = [];\n  var n = arguments.length;\n  for (var i = 0; i < n; i++) {\n    args.push(arguments[i]);\n  }\n  if (!(this instanceof Moveto)) {\n    // switching context of `this` to Moveto when called without `new`\n    return applyToNew(Moveto, args);\n  }\n  if (n === 0) {\n    throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');\n  }\n  var outputArray;\n  if (args[0] instanceof Line) {\n    // lines provided\n    if (n === 1) {\n      this.end = args[0].end.clone();\n      return this;\n    } else {\n      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');\n    }\n  } else if (args[0] instanceof Curve) {\n    // curves provided\n    if (n === 1) {\n      this.end = args[0].end.clone();\n      return this;\n    } else {\n      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');\n    }\n  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n    // coordinates provided\n    if (n === 2) {\n      this.end = new Point(+args[0], +args[1]);\n      return this;\n    } else if (n < 2) {\n      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n    } else {\n      // this is a moveto-with-subsequent-poly-line segment\n      var segmentCoords;\n      outputArray = [];\n      for (i = 0; i < n; i += 2) {\n        // coords come in groups of two\n\n        segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n        if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));else outputArray.push(applyToNew(Lineto, segmentCoords));\n      }\n      return outputArray;\n    }\n  } else {\n    // points provided (needs to be last to also cover plain objects with x and y)\n    if (n === 1) {\n      this.end = new Point(args[0]);\n      return this;\n    } else {\n      // this is a moveto-with-subsequent-poly-line segment\n      var segmentPoint;\n      outputArray = [];\n      for (i = 0; i < n; i += 1) {\n        // points come one by one\n\n        segmentPoint = args[i];\n        if (i === 0) outputArray.push(new Moveto(segmentPoint));else outputArray.push(new Lineto(segmentPoint));\n      }\n      return outputArray;\n    }\n  }\n};\nvar movetoPrototype = {\n  bbox: function () {\n    return null;\n  },\n  clone: function () {\n    return new Moveto(this.end);\n  },\n  closestPoint: function () {\n    return this.end.clone();\n  },\n  closestPointNormalizedLength: function () {\n    return 0;\n  },\n  closestPointLength: function () {\n    return 0;\n  },\n  closestPointT: function () {\n    return 1;\n  },\n  closestPointTangent: function () {\n    return null;\n  },\n  divideAt: function () {\n    return [this.clone(), this.clone()];\n  },\n  divideAtLength: function () {\n    return [this.clone(), this.clone()];\n  },\n  equals: function (m) {\n    return this.end.equals(m.end);\n  },\n  getSubdivisions: function () {\n    return [];\n  },\n  isDifferentiable: function () {\n    return false;\n  },\n  isSubpathStart: true,\n  isVisible: false,\n  length: function () {\n    return 0;\n  },\n  lengthAtT: function () {\n    return 0;\n  },\n  pointAt: function () {\n    return this.end.clone();\n  },\n  pointAtLength: function () {\n    return this.end.clone();\n  },\n  pointAtT: function () {\n    return this.end.clone();\n  },\n  round: function (precision) {\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  serialize: function () {\n    var end = this.end;\n    return this.type + ' ' + end.x + ' ' + end.y;\n  },\n  tangentAt: function () {\n    return null;\n  },\n  tangentAtLength: function () {\n    return null;\n  },\n  tangentAtT: function () {\n    return null;\n  },\n  toString: function () {\n    return this.type + ' ' + this.end;\n  },\n  translate: function (tx, ty) {\n    this.end.translate(tx, ty);\n    return this;\n  }\n};\nObject.defineProperty(movetoPrototype, 'start', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    throw new Error('Illegal access. Moveto segments should not need a start property.');\n  }\n});\nObject.defineProperty(movetoPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  value: 'M'\n});\nMoveto.prototype = extend(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n\nvar Closepath = function () {\n  var args = [];\n  var n = arguments.length;\n  for (var i = 0; i < n; i++) {\n    args.push(arguments[i]);\n  }\n  if (!(this instanceof Closepath)) {\n    // switching context of `this` to Closepath when called without `new`\n    return applyToNew(Closepath, args);\n  }\n  if (n > 0) {\n    throw new Error('Closepath constructor expects no arguments.');\n  }\n  return this;\n};\nvar closepathPrototype = {\n  clone: function () {\n    return new Closepath();\n  },\n  divideAt: function (ratio) {\n    var line = new Line(this.start, this.end);\n    var divided = line.divideAt(ratio);\n    return [\n    // if we didn't actually cut into the segment, first divided part can stay as Z\n    divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(), new Lineto(divided[1])];\n  },\n  divideAtLength: function (length) {\n    var line = new Line(this.start, this.end);\n    var divided = line.divideAtLength(length);\n    return [\n    // if we didn't actually cut into the segment, first divided part can stay as Z\n    divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(), new Lineto(divided[1])];\n  },\n  getSubdivisions: function () {\n    return [];\n  },\n  isDifferentiable: function () {\n    if (!this.previousSegment || !this.subpathStartSegment) return false;\n    return !this.start.equals(this.end);\n  },\n  round: function () {\n    return this;\n  },\n  scale: function () {\n    return this;\n  },\n  serialize: function () {\n    return this.type;\n  },\n  toString: function () {\n    return this.type + ' ' + this.start + ' ' + this.end;\n  },\n  translate: function () {\n    return this;\n  }\n};\nObject.defineProperty(closepathPrototype, 'end', {\n  // get a reference to the end point of subpath start segment\n\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.subpathStartSegment) throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)');\n    return this.subpathStartSegment.end;\n  }\n});\nObject.defineProperty(closepathPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  value: 'Z'\n});\nClosepath.prototype = extend(segmentPrototype, Line.prototype, closepathPrototype);\nvar segmentTypes = Path.segmentTypes = {\n  L: Lineto,\n  C: Curveto,\n  M: Moveto,\n  Z: Closepath,\n  z: Closepath\n};\nPath.regexSupportedData = new RegExp('^[\\\\s\\\\d' + Object.keys(segmentTypes).join('') + ',.]*$');\nPath.isDataSupported = function (data) {\n  if (typeof data !== 'string') return false;\n  return this.regexSupportedData.test(data);\n};","map":{"version":3,"names":["Polyline","Rect","Point","Line","Curve","types","extend","Path","arg","parse","segments","i","n","Array","isArray","length","reduce","acc","val","concat","isSegment","segment","appendSegment","previousObj","obj","Error","createSegment","start","end","equals","controlPoint1","controlPoint2","points","point","pathData","path","commandRe","commands","match","numCommands","command","argRe","args","apply","type","segmentConstructor","segmentTypes","arguments","push","applyToNew","prototype","numSegments","currentSegment","previousSegment","nextSegment","prepareSegment","currentArg","bbox","isVisible","segmentBBox","union","lastSegment","x","y","clone","closestPoint","p","opt","t","closestPointT","pointAtT","closestPointLength","precision","undefined","PRECISION","segmentSubdivisions","getSegmentSubdivisions","localOpt","lengthAtT","closestPointNormalizedLength","cpLength","minSquaredDistance","Infinity","subdivisions","segmentClosestPointT","segmentClosestPoint","squaredDistance","squaredLength","segmentIndex","value","closestPointTangent","isDifferentiable","tangentAtT","containsPoint","polylines","toPolylines","numPolylines","numIntersections","polyline","divideAt","ratio","pathLength","divideAtLength","fromStart","l","divided","dividedSegmentIndex","lastValidSegment","lastValidSegmentIndex","index","getSegment","d","divideAtT","pathCopy","replaceSegment","divisionStartIndex","divisionMidIndex","divisionEndIndex","removeSegment","movetoEnd","insertSegment","secondPathSegmentIndexConversion","originalSegment","subpathStartSegment","convertedSegment","firstPath","slice","secondPath","otherSegments","otherSegment","getSubdivisions","getSubpaths","validatedPath","validate","subpaths","isSubpathStart","splice","intersectionWithLine","line","intersection","polylineIntersection","intersect","isValid","tValue","precisison","pointAt","pointAtLength","lastVisibleSegment","updateSubpathStart","updateSubpathStartSegment","removedSegment","replacedSegment","round","scale","sx","sy","origin","segmentAt","segmentIndexAt","segmentAtLength","segmentIndexAtLength","lastVisibleSegmentIndex","serialize","toString","tangentAt","tangentAtLength","toPoints","partialPoints","currentSegmentSubdivisions","subdivisionPoints","map","curve","trim","translate","tx","ty","Object","defineProperty","configurable","enumerable","get","constructor","argsArray","unshift","Function","bind","segmentPrototype","writable","Lineto","outputArray","segmentCoords","segmentPoint","linetoPrototype","Curveto","segmentPoints","curvetoPrototype","control1","control2","c1","c2","Moveto","movetoPrototype","m","Closepath","closepathPrototype","L","C","M","Z","z","regexSupportedData","RegExp","keys","join","isDataSupported","data","test"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/g/path.mjs"],"sourcesContent":["// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).\nimport { Polyline } from './polyline.mjs';\nimport { Rect } from './rect.mjs';\nimport { Point } from './point.mjs';\nimport { Line } from './line.mjs';\nimport { Curve } from './curve.mjs';\nimport { types } from './types.mjs';\nimport { extend } from './extend.mjs';\nexport const Path = function(arg) {\n\n    if (!(this instanceof Path)) {\n        return new Path(arg);\n    }\n\n    if (typeof arg === 'string') { // create from a path data string\n        return new Path.parse(arg);\n    }\n\n    this.segments = [];\n\n    var i;\n    var n;\n\n    if (!arg) {\n        // don't do anything\n\n    } else if (Array.isArray(arg) && arg.length !== 0) { // if arg is a non-empty array\n        // flatten one level deep\n        // so we can chain arbitrary Path.createSegment results\n        arg = arg.reduce(function(acc, val) {\n            return acc.concat(val);\n        }, []);\n\n        n = arg.length;\n        if (arg[0].isSegment) { // create from an array of segments\n            for (i = 0; i < n; i++) {\n\n                var segment = arg[i];\n\n                this.appendSegment(segment);\n            }\n\n        } else { // create from an array of Curves and/or Lines\n            var previousObj = null;\n            for (i = 0; i < n; i++) {\n\n                var obj = arg[i];\n\n                if (!((obj instanceof Line) || (obj instanceof Curve))) {\n                    throw new Error('Cannot construct a path segment from the provided object.');\n                }\n\n                if (i === 0) this.appendSegment(Path.createSegment('M', obj.start));\n\n                // if objects do not link up, moveto segments are inserted to cover the gaps\n                if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path.createSegment('M', obj.start));\n\n                if (obj instanceof Line) {\n                    this.appendSegment(Path.createSegment('L', obj.end));\n\n                } else if (obj instanceof Curve) {\n                    this.appendSegment(Path.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));\n                }\n\n                previousObj = obj;\n            }\n        }\n\n    } else if (arg.isSegment) { // create from a single segment\n        this.appendSegment(arg);\n\n    } else if (arg instanceof Line) { // create from a single Line\n        this.appendSegment(Path.createSegment('M', arg.start));\n        this.appendSegment(Path.createSegment('L', arg.end));\n\n    } else if (arg instanceof Curve) { // create from a single Curve\n        this.appendSegment(Path.createSegment('M', arg.start));\n        this.appendSegment(Path.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));\n\n    } else if (arg instanceof Polyline) { // create from a Polyline\n        if (!(arg.points && (arg.points.length !== 0))) return; // if Polyline has no points, leave Path empty\n\n        n = arg.points.length;\n        for (i = 0; i < n; i++) {\n\n            var point = arg.points[i];\n\n            if (i === 0) this.appendSegment(Path.createSegment('M', point));\n            else this.appendSegment(Path.createSegment('L', point));\n        }\n\n    } else { // unknown object\n        throw new Error('Cannot construct a path from the provided object.');\n    }\n};\n\n// More permissive than V.normalizePathData and Path.prototype.serialize.\n// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n// Allows for command argument chaining.\n// Throws an error if wrong number of arguments is provided with a command.\n// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\nPath.parse = function(pathData) {\n\n    if (!pathData) return new Path();\n\n    var path = new Path();\n\n    var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    var commands = pathData.match(commandRe);\n\n    var numCommands = commands.length;\n    for (var i = 0; i < numCommands; i++) {\n\n        var command = commands[i];\n        var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n        var args = command.match(argRe);\n\n        var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n        path.appendSegment(segment);\n    }\n\n    return path;\n};\n\n// Create a segment or an array of segments.\n// Accepts unlimited points/coords arguments after `type`.\nPath.createSegment = function(type) {\n\n    if (!type) throw new Error('Type must be provided.');\n\n    var segmentConstructor = Path.segmentTypes[type];\n    if (!segmentConstructor) throw new Error(type + ' is not a recognized path segment type.');\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 1; i < n; i++) { // do not add first element (`type`) to args array\n        args.push(arguments[i]);\n    }\n\n    return applyToNew(segmentConstructor, args);\n};\n\nPath.prototype = {\n\n    type: types.Path,\n\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if argument is not a segment or an array of segments.\n    appendSegment: function(arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        var currentSegment;\n\n        var previousSegment = ((numSegments !== 0) ? segments[numSegments - 1] : null); // if we are appending to an empty path, previousSegment is null\n        var nextSegment = null;\n\n        if (!Array.isArray(arg)) { // arg is a segment\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.push(currentSegment);\n\n        } else { // arg is an array of segments\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.push(currentSegment);\n                previousSegment = currentSegment;\n            }\n        }\n    },\n\n    // Returns the bbox of the path.\n    // If path has no segments, returns null.\n    // If path has only invisible segments, returns bbox of the end point of last segment.\n    bbox: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var bbox;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var segmentBBox = segment.bbox();\n                bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n            }\n        }\n\n        if (bbox) return bbox;\n\n        // if the path has only invisible elements, return end point of last segment\n        var lastSegment = segments[numSegments - 1];\n        return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n    },\n\n    // Returns a new path that is a clone of this path.\n    clone: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        var path = new Path();\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i].clone();\n            path.appendSegment(segment);\n        }\n\n        return path;\n    },\n\n    closestPoint: function(p, opt) {\n\n        var t = this.closestPointT(p, opt);\n        if (!t) return null;\n\n        return this.pointAtT(t);\n    },\n\n    closestPointLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var t = this.closestPointT(p, localOpt);\n        if (!t) return 0;\n\n        return this.lengthAtT(t, localOpt);\n    },\n\n    closestPointNormalizedLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (cpLength === 0) return 0; // shortcut\n\n        var length = this.length(localOpt);\n        if (length === 0) return 0; // prevents division by zero\n\n        return cpLength / length;\n    },\n\n    // Private function.\n    closestPointT: function(p, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var closestPointT;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n\n            if (segment.isVisible) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = (new Line(segmentClosestPoint, p)).squaredLength();\n\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n\n        if (closestPointT) return closestPointT;\n\n        // if no visible segment, return end of last segment\n        return { segmentIndex: numSegments - 1, value: 1 };\n    },\n\n    closestPointTangent: function(p, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var closestPointTangent;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n\n            if (segment.isDifferentiable()) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = (new Line(segmentClosestPoint, p)).squaredLength();\n\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n\n        if (closestPointTangent) return closestPointTangent;\n\n        // if no valid segment, return null\n        return null;\n    },\n\n    // Returns `true` if the area surrounded by the path contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open paths (always imagines a final closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return false; // shortcut (this path has no polylines)\n\n        var numPolylines = polylines.length;\n\n        // how many component polylines does `p` lie within?\n        var numIntersections = 0;\n        for (var i = 0; i < numPolylines; i++) {\n            var polyline = polylines[i];\n            if (polyline.containsPoint(p)) {\n                // `p` lies within this polyline\n                numIntersections++;\n            }\n        }\n\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return ((numIntersections % 2) === 1);\n    },\n\n    // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.divideAtLength(length, localOpt);\n    },\n\n    // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n\n        var numSegments = this.segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var i;\n        var segment;\n\n        // identify the segment to divide:\n\n        var l = 0; // length so far\n        var divided;\n        var dividedSegmentIndex;\n        var lastValidSegment; // visible AND differentiable\n        var lastValidSegmentIndex;\n        var t;\n        for (i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            segment = this.getSegment(index);\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isDifferentiable()) { // segment is not just a point\n                lastValidSegment = segment;\n                lastValidSegmentIndex = index;\n\n                if (length <= (l + d)) {\n                    dividedSegmentIndex = index;\n                    divided = segment.divideAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                    break;\n                }\n            }\n\n            l += d;\n        }\n\n        if (!lastValidSegment) { // no valid segment found\n            return null;\n        }\n\n        // else: the path contains at least one valid segment\n\n        if (!divided) { // the desired length is greater than the length of the path\n            dividedSegmentIndex = lastValidSegmentIndex;\n            t = (fromStart ? 1 : 0);\n            divided = lastValidSegment.divideAtT(t);\n        }\n\n        // create a copy of this path and replace the identified segment with its two divided parts:\n\n        var pathCopy = this.clone();\n        pathCopy.replaceSegment(dividedSegmentIndex, divided);\n\n        var divisionStartIndex = dividedSegmentIndex;\n        var divisionMidIndex = dividedSegmentIndex + 1;\n        var divisionEndIndex = dividedSegmentIndex + 2;\n\n        // do not insert the part if it looks like a point\n        if (!divided[0].isDifferentiable()) {\n            pathCopy.removeSegment(divisionStartIndex);\n            divisionMidIndex -= 1;\n            divisionEndIndex -= 1;\n        }\n\n        // insert a Moveto segment to ensure secondPath will be valid:\n        var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n        divisionEndIndex += 1;\n\n        // do not insert the part if it looks like a point\n        if (!divided[1].isDifferentiable()) {\n            pathCopy.removeSegment(divisionEndIndex - 1);\n            divisionEndIndex -= 1;\n        }\n\n        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n        var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n        for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {\n\n            var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n            segment = pathCopy.getSegment(i);\n\n            if ((segment.type === 'Z') && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n                // pathCopy segment's subpathStartSegment is different from original segment's one\n                // convert this Closepath segment to a Lineto and replace it in pathCopy\n                var convertedSegment = Path.createSegment('L', originalSegment.end);\n                pathCopy.replaceSegment(i, convertedSegment);\n            }\n        }\n\n        // distribute pathCopy segments into two paths and return those:\n\n        var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n        var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n\n        return [firstPath, secondPath];\n    },\n\n    // Checks whether two paths are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n\n        if (!p) return false;\n\n        var segments = this.segments;\n        var otherSegments = p.segments;\n\n        var numSegments = segments.length;\n        if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var otherSegment = otherSegments[i];\n\n            // as soon as an inequality is found in segments, return false\n            if ((segment.type !== otherSegment.type) || (!segment.equals(otherSegment))) return false;\n        }\n\n        // if no inequality found in segments, return true\n        return true;\n    },\n\n    // Accepts negative indices.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    getSegment: function(index) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        return segments[index];\n    },\n\n    // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n    getSegmentSubdivisions: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.segmentSubdivisions\n        // not using localOpt\n\n        var segmentSubdivisions = [];\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segment.getSubdivisions({ precision: precision });\n            segmentSubdivisions.push(subdivisions);\n        }\n\n        return segmentSubdivisions;\n    },\n\n    // Returns an array of subpaths of this path.\n    // Invalid paths are validated first.\n    // Returns `[]` if path has no segments.\n    getSubpaths: function() {\n\n        const validatedPath = this.clone().validate();\n\n        const segments = validatedPath.segments;\n        const numSegments = segments.length;\n\n        const subpaths = [];\n        for (let i = 0; i < numSegments; i++) {\n\n            const segment = segments[i];\n            if (segment.isSubpathStart) {\n                // we encountered a subpath start segment\n                // create a new path for segment, and push it to list of subpaths\n                subpaths.push(new Path(segment));\n\n            } else {\n                // append current segment to the last subpath\n                subpaths[subpaths.length - 1].appendSegment(segment);\n            }\n        }\n\n        return subpaths;\n    },\n\n    // Insert `arg` at given `index`.\n    // `index = 0` means insert at the beginning.\n    // `index = segments.length` means insert at the end.\n    // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    insertSegment: function(index, arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        // note that these are incremented compared to getSegments()\n        // we can insert after last element (note that this changes the meaning of index -1)\n        if (index < 0) index = numSegments + index + 1; // convert negative indices to positive\n        if (index > numSegments || index < 0) throw new Error('Index out of range.');\n\n        var currentSegment;\n\n        var previousSegment = null;\n        var nextSegment = null;\n\n        if (numSegments !== 0) {\n            if (index >= 1) {\n                previousSegment = segments[index - 1];\n                nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n\n            } else { // if index === 0\n                // previousSegment is null\n                nextSegment = segments[0];\n            }\n        }\n\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 0, currentSegment);\n\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n            }\n        }\n    },\n\n    intersectionWithLine: function(line, opt) {\n\n        var intersection = null;\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return null;\n        for (var i = 0, n = polylines.length; i < n; i++) {\n            var polyline = polylines[i];\n            var polylineIntersection = line.intersect(polyline);\n            if (polylineIntersection) {\n                intersection || (intersection = []);\n                if (Array.isArray(polylineIntersection)) {\n                    Array.prototype.push.apply(intersection, polylineIntersection);\n                } else {\n                    intersection.push(polylineIntersection);\n                }\n            }\n        }\n\n        return intersection;\n    },\n\n    isDifferentiable: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            // as soon as a differentiable segment is found in segments, return true\n            if (segment.isDifferentiable()) return true;\n        }\n\n        // if no differentiable segment is found in segments, return false\n        return false;\n    },\n\n    // Checks whether current path segments are valid.\n    // Note that d is allowed to be empty - should disable rendering of the path.\n    isValid: function() {\n\n        var segments = this.segments;\n        var isValid = (segments.length === 0) || (segments[0].type === 'M'); // either empty or first segment is a Moveto\n        return isValid;\n    },\n\n    // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n    // If path has no segments, returns 0.\n    length: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var length = 0;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n            length += segment.length({ subdivisions: subdivisions });\n        }\n\n        return length;\n    },\n\n    // Private function.\n    lengthAtT: function(t, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return 0; // regardless of t.value\n\n        var tValue = t.value;\n        if (segmentIndex >= numSegments) {\n            segmentIndex = numSegments - 1;\n            tValue = 1;\n        } else if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var subdivisions;\n        var length = 0;\n        for (var i = 0; i < segmentIndex; i++) {\n\n            var segment = segments[i];\n            subdivisions = segmentSubdivisions[i];\n            length += segment.length({ precisison: precision, subdivisions: subdivisions });\n        }\n\n        segment = segments[segmentIndex];\n        subdivisions = segmentSubdivisions[segmentIndex];\n        length += segment.lengthAtT(tValue, { precisison: precision, subdivisions: subdivisions });\n\n        return length;\n    },\n\n    // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    pointAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.pointAtLength(length, localOpt);\n    },\n\n    // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    pointAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (length === 0) return this.start.clone();\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastVisibleSegment;\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isVisible) {\n                if (length <= (l + d)) {\n                    return segment.pointAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n\n                lastVisibleSegment = segment;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return last visible segment endpoint\n        if (lastVisibleSegment) return (fromStart ? lastVisibleSegment.end : lastVisibleSegment.start);\n\n        // if no visible segment, return last segment end point (no matter if fromStart or no)\n        var lastSegment = segments[numSegments - 1];\n        return lastSegment.end.clone();\n    },\n\n    // Private function.\n    pointAtT: function(t) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].pointAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);\n\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        return segments[segmentIndex].pointAtT(tValue);\n    },\n\n    // Default precision\n    PRECISION: 3,\n\n    // Helper method for adding segments.\n    prepareSegment: function(segment, previousSegment, nextSegment) {\n\n        // insert after previous segment and before previous segment's next segment\n        segment.previousSegment = previousSegment;\n        segment.nextSegment = nextSegment;\n        if (previousSegment) previousSegment.nextSegment = segment;\n        if (nextSegment) nextSegment.previousSegment = segment;\n\n        var updateSubpathStart = segment;\n        if (segment.isSubpathStart) {\n            segment.subpathStartSegment = segment; // assign self as subpath start segment\n            updateSubpathStart = nextSegment; // start updating from next segment\n        }\n\n        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n        if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);\n\n        return segment;\n    },\n\n    // Remove the segment at `index`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    removeSegment: function(index) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        var removedSegment = segments.splice(index, 1)[0];\n        var previousSegment = removedSegment.previousSegment;\n        var nextSegment = removedSegment.nextSegment;\n\n        // link the previous and next segments together (if present)\n        if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null\n        if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null\n\n        // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n        if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n\n    // Replace the segment at `index` with `arg`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    replaceSegment: function(index, arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        var currentSegment;\n\n        var replacedSegment = segments[index];\n        var previousSegment = replacedSegment.previousSegment;\n        var nextSegment = replacedSegment.nextSegment;\n\n        var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 1, currentSegment); // directly replace\n\n            if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            segments.splice(index, 1);\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n\n                if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n            }\n        }\n\n        // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n        if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n\n    round: function(precision) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.round(precision);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.scale(sx, sy, origin);\n        }\n\n        return this;\n    },\n\n    segmentAt: function(ratio, opt) {\n\n        var index = this.segmentIndexAt(ratio, opt);\n        if (!index) return null;\n\n        return this.getSegment(index);\n    },\n\n    // Accepts negative length.\n    segmentAtLength: function(length, opt) {\n\n        var index = this.segmentIndexAtLength(length, opt);\n        if (!index) return null;\n\n        return this.getSegment(index);\n    },\n\n    segmentIndexAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.segmentIndexAtLength(length, localOpt);\n    },\n\n    // Accepts negative length.\n    segmentIndexAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastVisibleSegmentIndex = null;\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isVisible) {\n                if (length <= (l + d)) return index;\n                lastVisibleSegmentIndex = index;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return last visible segment index\n        // if no visible segment, return null\n        return lastVisibleSegmentIndex;\n    },\n\n    // Returns a string that can be used to reconstruct the path.\n    // Additional error checking compared to toString (must start with M segment).\n    serialize: function() {\n\n        if (!this.isValid()) throw new Error('Invalid path segments.');\n\n        return this.toString();\n    },\n\n    // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    tangentAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.tangentAtLength(length, localOpt);\n    },\n\n    // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    tangentAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastValidSegment; // visible AND differentiable (with a tangent)\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isDifferentiable()) {\n                if (length <= (l + d)) {\n                    return segment.tangentAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n\n                lastValidSegment = segment;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n        if (lastValidSegment) {\n            var t = (fromStart ? 1 : 0);\n            return lastValidSegment.tangentAtT(t);\n        }\n\n        // if no valid segment, return null\n        return null;\n    },\n\n    // Private function.\n    tangentAtT: function(t) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].tangentAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);\n\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        return segments[segmentIndex].tangentAtT(tValue);\n    },\n\n    toPoints: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\n        var points = [];\n        var partialPoints = [];\n        for (var i = 0; i < numSegments; i++) {\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var currentSegmentSubdivisions = segmentSubdivisions[i];\n                if (currentSegmentSubdivisions.length > 0) {\n                    var subdivisionPoints = currentSegmentSubdivisions.map(function(curve) {\n                        return curve.start;\n                    });\n                    Array.prototype.push.apply(partialPoints, subdivisionPoints);\n                } else {\n                    partialPoints.push(segment.start);\n                }\n            } else if (partialPoints.length > 0) {\n                partialPoints.push(segments[i - 1].end);\n                points.push(partialPoints);\n                partialPoints = [];\n            }\n        }\n\n        if (partialPoints.length > 0) {\n            partialPoints.push(this.end);\n            points.push(partialPoints);\n        }\n        return points;\n    },\n\n    toPolylines: function(opt) {\n\n        var polylines = [];\n        var points = this.toPoints(opt);\n        if (!points) return null;\n        for (var i = 0, n = points.length; i < n; i++) {\n            polylines.push(new Polyline(points[i]));\n        }\n\n        return polylines;\n    },\n\n    toString: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        var pathData = '';\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            pathData += segment.serialize() + ' ';\n        }\n\n        return pathData.trim();\n    },\n\n    translate: function(tx, ty) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.translate(tx, ty);\n        }\n\n        return this;\n    },\n\n    // Helper method for updating subpath start of segments, starting with the one provided.\n    updateSubpathStartSegment: function(segment) {\n\n        var previousSegment = segment.previousSegment; // may be null\n        while (segment && !segment.isSubpathStart) {\n\n            // assign previous segment's subpath start segment to this segment\n            if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null\n            else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!\n\n            previousSegment = segment;\n            segment = segment.nextSegment; // move on to the segment after etc.\n        }\n    },\n\n    // If the path is not valid, insert M 0 0 at the beginning.\n    // Path with no segments is considered valid, so nothing is inserted.\n    validate: function() {\n\n        if (!this.isValid()) this.insertSegment(0, Path.createSegment('M', 0, 0));\n        return this;\n    }\n};\n\nObject.defineProperty(Path.prototype, 'start', {\n    // Getter for the first visible endpoint of the path.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            if (segment.isVisible) return segment.start;\n        }\n\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n\nObject.defineProperty(Path.prototype, 'end', {\n    // Getter for the last visible endpoint of the path.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n\n        for (var i = numSegments - 1; i >= 0; i--) {\n\n            var segment = segments[i];\n            if (segment.isVisible) return segment.end;\n        }\n\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n\n\n// Local helper function.\n// Use an array of arguments to call a constructor (function called with `new`).\n// Adapted from https://stackoverflow.com/a/8843181/2263595\n// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\nfunction applyToNew(constructor, argsArray) {\n    // The `new` keyword can only be applied to functions that take a limited number of arguments.\n    // - We can fake that with .bind().\n    // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n    // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n    // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n    // We need to pass in a variable number of arguments to the bind() call.\n    // - We can use .apply().\n    // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n    // - `thisArg` can still be anything because `new` overwrites it.\n    // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n    // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\n    // The function expects `argsArray[0]` to be `thisArg`.\n    // - This means that whatever is sent as the first element will be ignored.\n    // - The constructor will only see arguments starting from argsArray[1].\n    // - So, a new dummy element is inserted at the start of the array.\n    argsArray.unshift(null);\n\n    return new (Function.prototype.bind.apply(constructor, argsArray));\n}\n\n// Path segment interface:\nvar segmentPrototype = {\n\n    // virtual\n    bbox: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    clone: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPoint: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPointLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPointNormalizedLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n    closestPointT: function(p) {\n\n        if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);\n\n        throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');\n    },\n\n    // virtual\n    closestPointTangent: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    divideAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    divideAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n    divideAtT: function(t) {\n\n        if (this.divideAt) return this.divideAt(t);\n\n        throw new Error('Neither divideAtT() nor divideAt() function is implemented.');\n    },\n\n    // virtual\n    equals: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    getSubdivisions: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    isDifferentiable: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    isSegment: true,\n\n    isSubpathStart: false, // true for Moveto segments\n\n    isVisible: true, // false for Moveto segments\n\n    // virtual\n    length: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n    lengthAtT: function(t) {\n\n        if (t <= 0) return 0;\n\n        var length = this.length();\n\n        if (t >= 1) return length;\n\n        return length * t;\n    },\n\n    nextSegment: null, // needed for subpath start segment updating\n\n    // virtual\n    pointAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    pointAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n    pointAtT: function(t) {\n\n        if (this.pointAt) return this.pointAt(t);\n\n        throw new Error('Neither pointAtT() nor pointAt() function is implemented.');\n    },\n\n    previousSegment: null, // needed to get segment start property\n\n    // virtual\n    round: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    subpathStartSegment: null, // needed to get Closepath segment end property\n\n    // virtual\n    scale: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    serialize: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    tangentAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    tangentAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n    tangentAtT: function(t) {\n\n        if (this.tangentAt) return this.tangentAt(t);\n\n        throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');\n    },\n\n    // virtual\n    toString: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    translate: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    }\n};\n\n// usually directly assigned\n// getter for Closepath\nObject.defineProperty(segmentPrototype, 'end', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    writable: true\n});\n\n// always a getter\n// always throws error for Moveto\nObject.defineProperty(segmentPrototype, 'start', {\n    // get a reference to the end point of previous segment\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        if (!this.previousSegment) throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)');\n\n        return this.previousSegment.end;\n    }\n});\n\n// virtual\nObject.defineProperty(segmentPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        throw new Error('Bad segment declaration. No type specified.');\n    }\n});\n\n// Path segment implementations:\nvar Lineto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Lineto)) { // switching context of `this` to Lineto when called without `new`\n        return applyToNew(Lineto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Line) { // lines provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 2) {\n            this.end = new Point(+args[0], +args[1]);\n            return this;\n\n        } else if (n < 2) {\n            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a poly-line segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 1) {\n            this.end = new Point(args[0]);\n            return this;\n\n        } else { // this is a poly-line segment\n            var segmentPoint;\n            outputArray = [];\n            for (i = 0; i < n; i += 1) {\n\n                segmentPoint = args[i];\n                outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar linetoPrototype = {\n\n    clone: function() {\n\n        return new Lineto(this.end);\n    },\n\n    divideAt: function(ratio) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment) return false;\n\n        return !this.start.equals(this.end);\n    },\n\n    round: function(precision) {\n\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var end = this.end;\n        return this.type + ' ' + end.x + ' ' + end.y;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(linetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'L'\n});\n\nLineto.prototype = extend(segmentPrototype, Line.prototype, linetoPrototype);\n\nvar Curveto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Curveto)) { // switching context of `this` to Curveto when called without `new`\n        return applyToNew(Curveto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Curve) { // curves provided\n        if (n === 1) {\n            this.controlPoint1 = args[0].controlPoint1.clone();\n            this.controlPoint2 = args[0].controlPoint2.clone();\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 6) {\n            this.controlPoint1 = new Point(+args[0], +args[1]);\n            this.controlPoint2 = new Point(+args[2], +args[3]);\n            this.end = new Point(+args[4], +args[5]);\n            return this;\n\n        } else if (n < 6) {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a poly-bezier segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 6) { // coords come in groups of six\n\n                segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n                outputArray.push(applyToNew(Curveto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 3) {\n            this.controlPoint1 = new Point(args[0]);\n            this.controlPoint2 = new Point(args[1]);\n            this.end = new Point(args[2]);\n            return this;\n\n        } else if (n < 3) {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');\n\n        } else { // this is a poly-bezier segment\n            var segmentPoints;\n            outputArray = [];\n            for (i = 0; i < n; i += 3) { // points come in groups of three\n\n                segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n                outputArray.push(applyToNew(Curveto, segmentPoints));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar curvetoPrototype = {\n\n    clone: function() {\n\n        return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n    },\n\n    divideAt: function(ratio, opt) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAt(ratio, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length, opt) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtLength(length, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    divideAtT: function(t) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtT(t);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment) return false;\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n\n    round: function(precision) {\n\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var c1 = this.controlPoint1;\n        var c2 = this.controlPoint2;\n        var end = this.end;\n        return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(curvetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'C'\n});\n\nCurveto.prototype = extend(segmentPrototype, Curve.prototype, curvetoPrototype);\n\nvar Moveto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Moveto)) { // switching context of `this` to Moveto when called without `new`\n        return applyToNew(Moveto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Line) { // lines provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');\n        }\n\n    } else if (args[0] instanceof Curve) { // curves provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 2) {\n            this.end = new Point(+args[0], +args[1]);\n            return this;\n\n        } else if (n < 2) {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a moveto-with-subsequent-poly-line segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));\n                else outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 1) {\n            this.end = new Point(args[0]);\n            return this;\n\n        } else { // this is a moveto-with-subsequent-poly-line segment\n            var segmentPoint;\n            outputArray = [];\n            for (i = 0; i < n; i += 1) { // points come one by one\n\n                segmentPoint = args[i];\n                if (i === 0) outputArray.push(new Moveto(segmentPoint));\n                else outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar movetoPrototype = {\n\n    bbox: function() {\n\n        return null;\n    },\n\n    clone: function() {\n\n        return new Moveto(this.end);\n    },\n\n    closestPoint: function() {\n\n        return this.end.clone();\n    },\n\n    closestPointNormalizedLength: function() {\n\n        return 0;\n    },\n\n    closestPointLength: function() {\n\n        return 0;\n    },\n\n    closestPointT: function() {\n\n        return 1;\n    },\n\n    closestPointTangent: function() {\n\n        return null;\n    },\n\n    divideAt: function() {\n\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n\n    divideAtLength: function() {\n\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n\n    equals: function(m) {\n\n        return this.end.equals(m.end);\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        return false;\n    },\n\n    isSubpathStart: true,\n\n    isVisible: false,\n\n    length: function() {\n\n        return 0;\n    },\n\n    lengthAtT: function() {\n\n        return 0;\n    },\n\n    pointAt: function() {\n\n        return this.end.clone();\n    },\n\n    pointAtLength: function() {\n\n        return this.end.clone();\n    },\n\n    pointAtT: function() {\n\n        return this.end.clone();\n    },\n\n    round: function(precision) {\n\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var end = this.end;\n        return this.type + ' ' + end.x + ' ' + end.y;\n    },\n\n    tangentAt: function() {\n\n        return null;\n    },\n\n    tangentAtLength: function() {\n\n        return null;\n    },\n\n    tangentAtT: function() {\n\n        return null;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(movetoPrototype, 'start', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        throw new Error('Illegal access. Moveto segments should not need a start property.');\n    }\n});\n\nObject.defineProperty(movetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'M'\n});\n\nMoveto.prototype = extend(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n\nvar Closepath = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Closepath)) { // switching context of `this` to Closepath when called without `new`\n        return applyToNew(Closepath, args);\n    }\n\n    if (n > 0) {\n        throw new Error('Closepath constructor expects no arguments.');\n    }\n\n    return this;\n};\n\nvar closepathPrototype = {\n\n    clone: function() {\n\n        return new Closepath();\n    },\n\n    divideAt: function(ratio) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n            new Lineto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n            new Lineto(divided[1])\n        ];\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment || !this.subpathStartSegment) return false;\n\n        return !this.start.equals(this.end);\n    },\n\n    round: function() {\n\n        return this;\n    },\n\n    scale: function() {\n\n        return this;\n    },\n\n    serialize: function() {\n\n        return this.type;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.end;\n    },\n\n    translate: function() {\n\n        return this;\n    }\n};\n\nObject.defineProperty(closepathPrototype, 'end', {\n    // get a reference to the end point of subpath start segment\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        if (!this.subpathStartSegment) throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)');\n\n        return this.subpathStartSegment.end;\n    }\n});\n\nObject.defineProperty(closepathPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'Z'\n});\n\nClosepath.prototype = extend(segmentPrototype, Line.prototype, closepathPrototype);\n\nvar segmentTypes = Path.segmentTypes = {\n    L: Lineto,\n    C: Curveto,\n    M: Moveto,\n    Z: Closepath,\n    z: Closepath\n};\n\nPath.regexSupportedData = new RegExp('^[\\\\s\\\\d' + Object.keys(segmentTypes).join('') + ',.]*$');\n\nPath.isDataSupported = function(data) {\n\n    if (typeof data !== 'string') return false;\n    return this.regexSupportedData.test(data);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}