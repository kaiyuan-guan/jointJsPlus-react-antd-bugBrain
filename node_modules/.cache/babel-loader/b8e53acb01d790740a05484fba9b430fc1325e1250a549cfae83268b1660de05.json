{"ast":null,"code":"import * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\n// default size of jump if not specified in options\nvar JUMP_SIZE = 5;\n\n// available jump types\n// first one taken as default\nvar JUMP_TYPES = ['arc', 'gap', 'cubic'];\n\n// default radius\nvar RADIUS = 0;\n\n// takes care of math. error for case when jump is too close to end of line\nvar CLOSE_PROXIMITY_PADDING = 1;\n\n// list of connector types not to jump over.\nvar IGNORED_CONNECTORS = ['smooth'];\n\n// internal constants for round segment\nvar _13 = 1 / 3;\nvar _23 = 2 / 3;\nfunction sortPointsAscending(p1, p2) {\n  let {\n    x: x1,\n    y: y1\n  } = p1;\n  let {\n    x: x2,\n    y: y2\n  } = p2;\n  if (x1 > x2) {\n    let swap = x1;\n    x1 = x2;\n    x2 = swap;\n    swap = y1;\n    y1 = y2;\n    y2 = swap;\n  }\n  if (y1 > y2) {\n    let swap = x1;\n    x1 = x2;\n    x2 = swap;\n    swap = y1;\n    y1 = y2;\n    y2 = swap;\n  }\n  return [new g.Point(x1, y1), new g.Point(x2, y2)];\n}\nfunction overlapExists(line1, line2) {\n  const [{\n    x: x1,\n    y: y1\n  }, {\n    x: x2,\n    y: y2\n  }] = sortPointsAscending(line1.start, line1.end);\n  const [{\n    x: x3,\n    y: y3\n  }, {\n    x: x4,\n    y: y4\n  }] = sortPointsAscending(line2.start, line2.end);\n  const xMatch = x1 <= x4 && x3 <= x2;\n  const yMatch = y1 <= y4 && y3 <= y2;\n  return xMatch && yMatch;\n}\n\n/**\n * Transform start/end and route into series of lines\n * @param {g.point} sourcePoint start point\n * @param {g.point} targetPoint end point\n * @param {g.point[]} route optional list of route\n * @return {g.line[]} [description]\n */\nfunction createLines(sourcePoint, targetPoint, route) {\n  // make a flattened array of all points\n  var points = [].concat(sourcePoint, route, targetPoint);\n  return points.reduce(function (resultLines, point, idx) {\n    // if there is a next point, make a line with it\n    var nextPoint = points[idx + 1];\n    if (nextPoint != null) {\n      resultLines[idx] = g.line(point, nextPoint);\n    }\n    return resultLines;\n  }, []);\n}\nfunction setupUpdating(jumpOverLinkView) {\n  var paper = jumpOverLinkView.paper;\n  var updateList = paper._jumpOverUpdateList;\n\n  // first time setup for this paper\n  if (updateList == null) {\n    updateList = paper._jumpOverUpdateList = [];\n    var graph = paper.model;\n    graph.on('batch:stop', function () {\n      if (this.hasActiveBatch()) return;\n      updateJumpOver(paper);\n    });\n    graph.on('reset', function () {\n      updateList = paper._jumpOverUpdateList = [];\n    });\n  }\n\n  // add this link to a list so it can be updated when some other link is updated\n  if (updateList.indexOf(jumpOverLinkView) < 0) {\n    updateList.push(jumpOverLinkView);\n\n    // watch for change of connector type or removal of link itself\n    // to remove the link from a list of jump over connectors\n    jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function () {\n      updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n    });\n  }\n}\n\n/**\n * Handler for a batch:stop event to force\n * update of all registered links with jump over connector\n * @param {object} batchEvent optional object with info about batch\n */\nfunction updateJumpOver(paper) {\n  var updateList = paper._jumpOverUpdateList;\n  for (var i = 0; i < updateList.length; i++) {\n    const linkView = updateList[i];\n    const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n    linkView.requestUpdate(updateFlag);\n  }\n}\n\n/**\n * Utility function to collect all intersection points of a single\n * line against group of other lines.\n * @param {g.line} line where to find points\n * @param {g.line[]} crossCheckLines lines to cross\n * @return {g.point[]} list of intersection points\n */\nfunction findLineIntersections(line, crossCheckLines) {\n  return util.toArray(crossCheckLines).reduce(function (res, crossCheckLine) {\n    var intersection = line.intersection(crossCheckLine);\n    if (intersection) {\n      res.push(intersection);\n    }\n    return res;\n  }, []);\n}\n\n/**\n * Sorting function for list of points by their distance.\n * @param {g.point} p1 first point\n * @param {g.point} p2 second point\n * @return {number} squared distance between points\n */\nfunction sortPoints(p1, p2) {\n  return g.line(p1, p2).squaredLength();\n}\n\n/**\n * Split input line into multiple based on intersection points.\n * @param {g.line} line input line to split\n * @param {g.point[]} intersections points where to split the line\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @return {g.line[]} list of lines being split\n */\nfunction createJumps(line, intersections, jumpSize) {\n  return intersections.reduce(function (resultLines, point, idx) {\n    // skipping points that were merged with the previous line\n    // to make bigger arc over multiple lines that are close to each other\n    if (point.skip === true) {\n      return resultLines;\n    }\n\n    // always grab the last line from buffer and modify it\n    var lastLine = resultLines.pop() || line;\n\n    // calculate start and end of jump by moving by a given size of jump\n    var jumpStart = g.point(point).move(lastLine.start, -jumpSize);\n    var jumpEnd = g.point(point).move(lastLine.start, +jumpSize);\n\n    // now try to look at the next intersection point\n    var nextPoint = intersections[idx + 1];\n    if (nextPoint != null) {\n      var distance = jumpEnd.distance(nextPoint);\n      if (distance <= jumpSize) {\n        // next point is close enough, move the jump end by this\n        // difference and mark the next point to be skipped\n        jumpEnd = nextPoint.move(lastLine.start, distance);\n        nextPoint.skip = true;\n      }\n    } else {\n      // this block is inside of `else` as an optimization so the distance is\n      // not calculated when we know there are no other intersection points\n      var endDistance = jumpStart.distance(lastLine.end);\n      // if the end is too close to possible jump, draw remaining line instead of a jump\n      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n        resultLines.push(lastLine);\n        return resultLines;\n      }\n    }\n    var startDistance = jumpEnd.distance(lastLine.start);\n    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n      // if the start of line is too close to jump, draw that line instead of a jump\n      resultLines.push(lastLine);\n      return resultLines;\n    }\n\n    // finally create a jump line\n    var jumpLine = g.line(jumpStart, jumpEnd);\n    // it's just simple line but with a `isJump` property\n    jumpLine.isJump = true;\n    resultLines.push(g.line(lastLine.start, jumpStart), jumpLine, g.line(jumpEnd, lastLine.end));\n    return resultLines;\n  }, []);\n}\n\n/**\n * Assemble `D` attribute of a SVG path by iterating given lines.\n * @param {g.line[]} lines source lines to use\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @param {number} radius the radius\n * @return {string}\n */\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n  var path = new g.Path();\n  var segment;\n\n  // first move to the start of a first line\n  segment = g.Path.createSegment('M', lines[0].start);\n  path.appendSegment(segment);\n\n  // make a paths from lines\n  util.toArray(lines).forEach(function (line, index) {\n    if (line.isJump) {\n      var angle, diff;\n      var control1, control2;\n      if (jumpType === 'arc') {\n        // approximates semicircle with 2 curves\n        angle = -90;\n        // determine rotation of arc based on difference between points\n        diff = line.start.difference(line.end);\n        // make sure the arc always points up (or right)\n        var xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n        if (xAxisRotate) angle += 180;\n        var midpoint = line.midpoint();\n        var centerLine = new g.Line(midpoint, line.end).rotate(midpoint, angle);\n        var halfLine;\n\n        // first half\n        halfLine = new g.Line(line.start, midpoint);\n        control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n        control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n        segment = g.Path.createSegment('C', control1, control2, centerLine.end);\n        path.appendSegment(segment);\n\n        // second half\n        halfLine = new g.Line(midpoint, line.end);\n        control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n        control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n        segment = g.Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'gap') {\n        segment = g.Path.createSegment('M', line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'cubic') {\n        // approximates semicircle with 1 curve\n        angle = line.start.theta(line.end);\n        var xOffset = jumpSize * 0.6;\n        var yOffset = jumpSize * 1.35;\n\n        // determine rotation of arc based on difference between points\n        diff = line.start.difference(line.end);\n        // make sure the arc always points up (or right)\n        xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n        if (xAxisRotate) yOffset *= -1;\n        control1 = g.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n        control2 = g.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n        segment = g.Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      }\n    } else {\n      var nextLine = lines[index + 1];\n      if (radius == 0 || !nextLine || nextLine.isJump) {\n        segment = g.Path.createSegment('L', line.end);\n        path.appendSegment(segment);\n      } else {\n        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n      }\n    }\n  });\n  return path;\n}\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n  var prevDistance = curr.distance(prev) / 2;\n  var nextDistance = curr.distance(next) / 2;\n  var startMove = -Math.min(offset, prevDistance);\n  var endMove = -Math.min(offset, nextDistance);\n  var roundedStart = curr.clone().move(prev, startMove).round();\n  var roundedEnd = curr.clone().move(next, endMove).round();\n  var control1 = new g.Point(_13 * roundedStart.x + _23 * curr.x, _23 * curr.y + _13 * roundedStart.y);\n  var control2 = new g.Point(_13 * roundedEnd.x + _23 * curr.x, _23 * curr.y + _13 * roundedEnd.y);\n  var segment;\n  segment = g.Path.createSegment('L', roundedStart);\n  path.appendSegment(segment);\n  segment = g.Path.createSegment('C', control1, control2, roundedEnd);\n  path.appendSegment(segment);\n}\n\n/**\n * Actual connector function that will be run on every update.\n * @param {g.point} sourcePoint start point of this link\n * @param {g.point} targetPoint end point of this link\n * @param {g.point[]} route of this link\n * @param {object} opt options\n * @property {number} size optional size of a jump arc\n * @return {string} created `D` attribute of SVG path\n */\nexport const jumpover = function (sourcePoint, targetPoint, route, opt) {\n  // eslint-disable-line max-params\n\n  setupUpdating(this);\n  var raw = opt.raw;\n  var jumpSize = opt.size || JUMP_SIZE;\n  var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n  var radius = opt.radius || RADIUS;\n  var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n\n  // grab the first jump type as a default if specified one is invalid\n  if (JUMP_TYPES.indexOf(jumpType) === -1) {\n    jumpType = JUMP_TYPES[0];\n  }\n  var paper = this.paper;\n  var graph = paper.model;\n  var allLinks = graph.getLinks();\n\n  // there is just one link, draw it directly\n  if (allLinks.length === 1) {\n    return buildPath(createLines(sourcePoint, targetPoint, route), jumpSize, jumpType, radius);\n  }\n  var thisModel = this.model;\n  var thisIndex = allLinks.indexOf(thisModel);\n  var defaultConnector = paper.options.defaultConnector || {};\n\n  // not all links are meant to be jumped over.\n  var links = allLinks.filter(function (link, idx) {\n    var connector = link.get('connector') || defaultConnector;\n\n    // avoid jumping over links with connector type listed in `ignored connectors`.\n    if (util.toArray(ignoreConnectors).includes(connector.name)) {\n      return false;\n    }\n    // filter out links that are above this one and  have the same connector type\n    // otherwise there would double hoops for each intersection\n    if (idx > thisIndex) {\n      return connector.name !== 'jumpover';\n    }\n    return true;\n  });\n\n  // find views for all links\n  var linkViews = links.map(function (link) {\n    return paper.findViewByModel(link);\n  });\n\n  // create lines for this link\n  var thisLines = createLines(sourcePoint, targetPoint, route);\n\n  // create lines for all other links\n  var linkLines = linkViews.map(function (linkView) {\n    if (linkView == null) {\n      return [];\n    }\n    if (linkView === this) {\n      return thisLines;\n    }\n    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.route);\n  }, this);\n\n  // transform lines for this link by splitting with jump lines at\n  // points of intersection with other links\n  var jumpingLines = thisLines.reduce(function (resultLines, thisLine) {\n    // iterate all links and grab the intersections with this line\n    // these are then sorted by distance so the line can be split more easily\n    var intersections = links.reduce(function (res, link, i) {\n      // don't intersection with itself\n      if (link !== thisModel) {\n        const linkLinesToTest = linkLines[i].slice();\n        const overlapIndex = linkLinesToTest.findIndex(line => overlapExists(thisLine, line));\n\n        // Overlap occurs and the end point of one segment lies on thisLine\n        if (overlapIndex > -1 && thisLine.containsPoint(linkLinesToTest[overlapIndex].end)) {\n          // Remove the next segment because there will never be a jump\n          linkLinesToTest.splice(overlapIndex + 1, 1);\n        }\n        const lineIntersections = findLineIntersections(thisLine, linkLinesToTest);\n        res.push.apply(res, lineIntersections);\n      }\n      return res;\n    }, []).sort(function (a, b) {\n      return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n    });\n    if (intersections.length > 0) {\n      // split the line based on found intersection points\n      resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n    } else {\n      // without any intersection the line goes uninterrupted\n      resultLines.push(thisLine);\n    }\n    return resultLines;\n  }, []);\n  var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n  return raw ? path : path.serialize();\n};","map":{"version":3,"names":["util","g","JUMP_SIZE","JUMP_TYPES","RADIUS","CLOSE_PROXIMITY_PADDING","IGNORED_CONNECTORS","_13","_23","sortPointsAscending","p1","p2","x","x1","y","y1","x2","y2","swap","Point","overlapExists","line1","line2","start","end","x3","y3","x4","y4","xMatch","yMatch","createLines","sourcePoint","targetPoint","route","points","concat","reduce","resultLines","point","idx","nextPoint","line","setupUpdating","jumpOverLinkView","paper","updateList","_jumpOverUpdateList","graph","model","on","hasActiveBatch","updateJumpOver","indexOf","push","listenToOnce","splice","i","length","linkView","updateFlag","getFlag","constructor","Flags","CONNECTOR","requestUpdate","findLineIntersections","crossCheckLines","toArray","res","crossCheckLine","intersection","sortPoints","squaredLength","createJumps","intersections","jumpSize","skip","lastLine","pop","jumpStart","move","jumpEnd","distance","endDistance","startDistance","jumpLine","isJump","buildPath","lines","jumpType","radius","path","Path","segment","createSegment","appendSegment","forEach","index","angle","diff","control1","control2","difference","xAxisRotate","Number","midpoint","centerLine","Line","rotate","halfLine","pointAt","theta","xOffset","yOffset","nextLine","buildRoundedSegment","offset","curr","prev","next","prevDistance","nextDistance","startMove","Math","min","endMove","roundedStart","clone","round","roundedEnd","jumpover","opt","raw","size","jump","toLowerCase","ignoreConnectors","allLinks","getLinks","thisModel","thisIndex","defaultConnector","options","links","filter","link","connector","get","includes","name","linkViews","map","findViewByModel","thisLines","linkLines","jumpingLines","thisLine","linkLinesToTest","slice","overlapIndex","findIndex","containsPoint","lineIntersections","apply","sort","a","b","serialize"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/connectors/jumpover.mjs"],"sourcesContent":["import * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\n// default size of jump if not specified in options\nvar JUMP_SIZE = 5;\n\n// available jump types\n// first one taken as default\nvar JUMP_TYPES = ['arc', 'gap', 'cubic'];\n\n// default radius\nvar RADIUS = 0;\n\n// takes care of math. error for case when jump is too close to end of line\nvar CLOSE_PROXIMITY_PADDING = 1;\n\n// list of connector types not to jump over.\nvar IGNORED_CONNECTORS = ['smooth'];\n\n// internal constants for round segment\nvar _13 = 1 / 3;\nvar _23 = 2 / 3;\n\nfunction sortPointsAscending(p1, p2) {\n\n    let { x: x1, y: y1 } = p1;\n    let { x: x2, y: y2 } = p2;\n\n    if (x1 > x2) {\n\n        let swap = x1;\n        x1 = x2;\n        x2 = swap;\n\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n    }\n\n    if (y1 > y2) {\n        let swap = x1;\n        x1 = x2;\n        x2 = swap;\n\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n    }\n\n    return [new g.Point(x1, y1), new g.Point(x2, y2)];\n}\n\nfunction overlapExists(line1, line2) {\n\n    const [{ x: x1, y: y1 }, { x: x2, y: y2 }] = sortPointsAscending(line1.start, line1.end);\n    const [{ x: x3, y: y3 }, { x: x4, y: y4 }] = sortPointsAscending(line2.start, line2.end);\n\n    const xMatch = x1 <= x4 && x3 <= x2;\n    const yMatch = y1 <= y4 && y3 <= y2;\n\n    return xMatch && yMatch;\n}\n\n/**\n * Transform start/end and route into series of lines\n * @param {g.point} sourcePoint start point\n * @param {g.point} targetPoint end point\n * @param {g.point[]} route optional list of route\n * @return {g.line[]} [description]\n */\nfunction createLines(sourcePoint, targetPoint, route) {\n    // make a flattened array of all points\n    var points = [].concat(sourcePoint, route, targetPoint);\n    return points.reduce(function(resultLines, point, idx) {\n        // if there is a next point, make a line with it\n        var nextPoint = points[idx + 1];\n        if (nextPoint != null) {\n            resultLines[idx] = g.line(point, nextPoint);\n        }\n        return resultLines;\n    }, []);\n}\n\nfunction setupUpdating(jumpOverLinkView) {\n    var paper = jumpOverLinkView.paper;\n    var updateList = paper._jumpOverUpdateList;\n\n    // first time setup for this paper\n    if (updateList == null) {\n        updateList = paper._jumpOverUpdateList = [];\n        var graph = paper.model;\n        graph.on('batch:stop', function() {\n            if (this.hasActiveBatch()) return;\n            updateJumpOver(paper);\n        });\n        graph.on('reset', function() {\n            updateList = paper._jumpOverUpdateList = [];\n        });\n    }\n\n    // add this link to a list so it can be updated when some other link is updated\n    if (updateList.indexOf(jumpOverLinkView) < 0) {\n        updateList.push(jumpOverLinkView);\n\n        // watch for change of connector type or removal of link itself\n        // to remove the link from a list of jump over connectors\n        jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function() {\n            updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n        });\n    }\n}\n\n/**\n * Handler for a batch:stop event to force\n * update of all registered links with jump over connector\n * @param {object} batchEvent optional object with info about batch\n */\nfunction updateJumpOver(paper) {\n    var updateList = paper._jumpOverUpdateList;\n    for (var i = 0; i < updateList.length; i++) {\n        const linkView = updateList[i];\n        const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n        linkView.requestUpdate(updateFlag);\n    }\n}\n\n/**\n * Utility function to collect all intersection points of a single\n * line against group of other lines.\n * @param {g.line} line where to find points\n * @param {g.line[]} crossCheckLines lines to cross\n * @return {g.point[]} list of intersection points\n */\nfunction findLineIntersections(line, crossCheckLines) {\n    return util.toArray(crossCheckLines).reduce(function(res, crossCheckLine) {\n        var intersection = line.intersection(crossCheckLine);\n        if (intersection) {\n            res.push(intersection);\n        }\n        return res;\n    }, []);\n}\n\n/**\n * Sorting function for list of points by their distance.\n * @param {g.point} p1 first point\n * @param {g.point} p2 second point\n * @return {number} squared distance between points\n */\nfunction sortPoints(p1, p2) {\n    return g.line(p1, p2).squaredLength();\n}\n\n/**\n * Split input line into multiple based on intersection points.\n * @param {g.line} line input line to split\n * @param {g.point[]} intersections points where to split the line\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @return {g.line[]} list of lines being split\n */\nfunction createJumps(line, intersections, jumpSize) {\n    return intersections.reduce(function(resultLines, point, idx) {\n        // skipping points that were merged with the previous line\n        // to make bigger arc over multiple lines that are close to each other\n        if (point.skip === true) {\n            return resultLines;\n        }\n\n        // always grab the last line from buffer and modify it\n        var lastLine = resultLines.pop() || line;\n\n        // calculate start and end of jump by moving by a given size of jump\n        var jumpStart = g.point(point).move(lastLine.start, -(jumpSize));\n        var jumpEnd = g.point(point).move(lastLine.start, +(jumpSize));\n\n        // now try to look at the next intersection point\n        var nextPoint = intersections[idx + 1];\n        if (nextPoint != null) {\n            var distance = jumpEnd.distance(nextPoint);\n            if (distance <= jumpSize) {\n                // next point is close enough, move the jump end by this\n                // difference and mark the next point to be skipped\n                jumpEnd = nextPoint.move(lastLine.start, distance);\n                nextPoint.skip = true;\n            }\n        } else {\n            // this block is inside of `else` as an optimization so the distance is\n            // not calculated when we know there are no other intersection points\n            var endDistance = jumpStart.distance(lastLine.end);\n            // if the end is too close to possible jump, draw remaining line instead of a jump\n            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n                resultLines.push(lastLine);\n                return resultLines;\n            }\n        }\n\n        var startDistance = jumpEnd.distance(lastLine.start);\n        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n            // if the start of line is too close to jump, draw that line instead of a jump\n            resultLines.push(lastLine);\n            return resultLines;\n        }\n\n        // finally create a jump line\n        var jumpLine = g.line(jumpStart, jumpEnd);\n        // it's just simple line but with a `isJump` property\n        jumpLine.isJump = true;\n\n        resultLines.push(\n            g.line(lastLine.start, jumpStart),\n            jumpLine,\n            g.line(jumpEnd, lastLine.end)\n        );\n        return resultLines;\n    }, []);\n}\n\n/**\n * Assemble `D` attribute of a SVG path by iterating given lines.\n * @param {g.line[]} lines source lines to use\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @param {number} radius the radius\n * @return {string}\n */\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n\n    var path = new g.Path();\n    var segment;\n\n    // first move to the start of a first line\n    segment = g.Path.createSegment('M', lines[0].start);\n    path.appendSegment(segment);\n\n    // make a paths from lines\n    util.toArray(lines).forEach(function(line, index) {\n\n        if (line.isJump) {\n            var angle, diff;\n\n            var control1, control2;\n\n            if (jumpType === 'arc') { // approximates semicircle with 2 curves\n                angle = -90;\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                var xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) angle += 180;\n\n                var midpoint = line.midpoint();\n                var centerLine = new g.Line(midpoint, line.end).rotate(midpoint, angle);\n\n                var halfLine;\n\n                // first half\n                halfLine = new g.Line(line.start, midpoint);\n\n                control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n                control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n\n                segment = g.Path.createSegment('C', control1, control2, centerLine.end);\n                path.appendSegment(segment);\n\n                // second half\n                halfLine = new g.Line(midpoint, line.end);\n\n                control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n                control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n\n                segment = g.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'gap') {\n                segment = g.Path.createSegment('M', line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'cubic') { // approximates semicircle with 1 curve\n                angle = line.start.theta(line.end);\n\n                var xOffset = jumpSize * 0.6;\n                var yOffset = jumpSize * 1.35;\n\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) yOffset *= -1;\n\n                control1 = g.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n                control2 = g.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n\n                segment = g.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n            }\n\n        } else {\n            var nextLine = lines[index + 1];\n            if (radius == 0 || !nextLine || nextLine.isJump) {\n                segment = g.Path.createSegment('L', line.end);\n                path.appendSegment(segment);\n            } else {\n                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n            }\n        }\n    });\n\n    return path;\n}\n\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n    var prevDistance = curr.distance(prev) / 2;\n    var nextDistance = curr.distance(next) / 2;\n\n    var startMove = -Math.min(offset, prevDistance);\n    var endMove = -Math.min(offset, nextDistance);\n\n    var roundedStart = curr.clone().move(prev, startMove).round();\n    var roundedEnd = curr.clone().move(next, endMove).round();\n\n    var control1 = new g.Point((_13 * roundedStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedStart.y));\n    var control2 = new g.Point((_13 * roundedEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedEnd.y));\n\n    var segment;\n    segment = g.Path.createSegment('L', roundedStart);\n    path.appendSegment(segment);\n\n    segment = g.Path.createSegment('C', control1, control2, roundedEnd);\n    path.appendSegment(segment);\n}\n\n/**\n * Actual connector function that will be run on every update.\n * @param {g.point} sourcePoint start point of this link\n * @param {g.point} targetPoint end point of this link\n * @param {g.point[]} route of this link\n * @param {object} opt options\n * @property {number} size optional size of a jump arc\n * @return {string} created `D` attribute of SVG path\n */\nexport const jumpover = function(sourcePoint, targetPoint, route, opt) { // eslint-disable-line max-params\n\n    setupUpdating(this);\n\n    var raw = opt.raw;\n    var jumpSize = opt.size || JUMP_SIZE;\n    var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n    var radius = opt.radius || RADIUS;\n    var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n\n    // grab the first jump type as a default if specified one is invalid\n    if (JUMP_TYPES.indexOf(jumpType) === -1) {\n        jumpType = JUMP_TYPES[0];\n    }\n\n    var paper = this.paper;\n    var graph = paper.model;\n    var allLinks = graph.getLinks();\n\n    // there is just one link, draw it directly\n    if (allLinks.length === 1) {\n        return buildPath(\n            createLines(sourcePoint, targetPoint, route),\n            jumpSize, jumpType, radius\n        );\n    }\n\n    var thisModel = this.model;\n    var thisIndex = allLinks.indexOf(thisModel);\n    var defaultConnector = paper.options.defaultConnector || {};\n\n    // not all links are meant to be jumped over.\n    var links = allLinks.filter(function(link, idx) {\n\n        var connector = link.get('connector') || defaultConnector;\n\n        // avoid jumping over links with connector type listed in `ignored connectors`.\n        if (util.toArray(ignoreConnectors).includes(connector.name)) {\n            return false;\n        }\n        // filter out links that are above this one and  have the same connector type\n        // otherwise there would double hoops for each intersection\n        if (idx > thisIndex) {\n            return connector.name !== 'jumpover';\n        }\n        return true;\n    });\n\n    // find views for all links\n    var linkViews = links.map(function(link) {\n        return paper.findViewByModel(link);\n    });\n\n    // create lines for this link\n    var thisLines = createLines(\n        sourcePoint,\n        targetPoint,\n        route\n    );\n\n    // create lines for all other links\n    var linkLines = linkViews.map(function(linkView) {\n        if (linkView == null) {\n            return [];\n        }\n        if (linkView === this) {\n            return thisLines;\n        }\n        return createLines(\n            linkView.sourcePoint,\n            linkView.targetPoint,\n            linkView.route\n        );\n    }, this);\n\n    // transform lines for this link by splitting with jump lines at\n    // points of intersection with other links\n    var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {\n        // iterate all links and grab the intersections with this line\n        // these are then sorted by distance so the line can be split more easily\n        var intersections = links.reduce(function(res, link, i) {\n            // don't intersection with itself\n            if (link !== thisModel) {\n\n                const linkLinesToTest = linkLines[i].slice();\n                const overlapIndex = linkLinesToTest.findIndex((line) => overlapExists(thisLine, line));\n\n                // Overlap occurs and the end point of one segment lies on thisLine\n                if (overlapIndex > -1 && thisLine.containsPoint(linkLinesToTest[overlapIndex].end)) {\n                    // Remove the next segment because there will never be a jump\n                    linkLinesToTest.splice(overlapIndex + 1, 1);\n                }\n                const lineIntersections = findLineIntersections(thisLine, linkLinesToTest);\n                res.push.apply(res, lineIntersections);\n            }\n            return res;\n        }, []).sort(function(a, b) {\n            return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n        });\n\n        if (intersections.length > 0) {\n            // split the line based on found intersection points\n            resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n        } else {\n            // without any intersection the line goes uninterrupted\n            resultLines.push(thisLine);\n        }\n        return resultLines;\n    }, []);\n\n    var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n    return (raw) ? path : path.serialize();\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}