{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nexport function audit(durationSelector) {\n  return function auditOperatorFunction(source) {\n    return source.lift(new AuditOperator(durationSelector));\n  };\n}\nvar AuditOperator = /*@__PURE__*/function () {\n  function AuditOperator(durationSelector) {\n    this.durationSelector = durationSelector;\n  }\n  AuditOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n  };\n  return AuditOperator;\n}();\nvar AuditSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(AuditSubscriber, _super);\n  function AuditSubscriber(destination, durationSelector) {\n    var _this = _super.call(this, destination) || this;\n    _this.durationSelector = durationSelector;\n    _this.hasValue = false;\n    return _this;\n  }\n  AuditSubscriber.prototype._next = function (value) {\n    this.value = value;\n    this.hasValue = true;\n    if (!this.throttled) {\n      var duration = void 0;\n      try {\n        var durationSelector = this.durationSelector;\n        duration = durationSelector(value);\n      } catch (err) {\n        return this.destination.error(err);\n      }\n      var innerSubscription = subscribeToResult(this, duration);\n      if (!innerSubscription || innerSubscription.closed) {\n        this.clearThrottle();\n      } else {\n        this.add(this.throttled = innerSubscription);\n      }\n    }\n  };\n  AuditSubscriber.prototype.clearThrottle = function () {\n    var _a = this,\n      value = _a.value,\n      hasValue = _a.hasValue,\n      throttled = _a.throttled;\n    if (throttled) {\n      this.remove(throttled);\n      this.throttled = null;\n      throttled.unsubscribe();\n    }\n    if (hasValue) {\n      this.value = null;\n      this.hasValue = false;\n      this.destination.next(value);\n    }\n  };\n  AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n    this.clearThrottle();\n  };\n  AuditSubscriber.prototype.notifyComplete = function () {\n    this.clearThrottle();\n  };\n  return AuditSubscriber;\n}(OuterSubscriber);","map":{"version":3,"names":["tslib_1","OuterSubscriber","subscribeToResult","audit","durationSelector","auditOperatorFunction","source","lift","AuditOperator","prototype","call","subscriber","subscribe","AuditSubscriber","_super","__extends","destination","_this","_next","value","hasValue","throttled","duration","err","error","innerSubscription","closed","clearThrottle","add","_a","remove","unsubscribe","next","notifyNext","outerValue","innerValue","outerIndex","innerIndex","notifyComplete"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/rxjs@6.5.4/node_modules/rxjs/src/internal/operators/audit.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubscribableOrPromise, TeardownLogic } from '../types';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](audit.png)\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { audit } from 'rxjs/operators'\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(audit(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nexport function audit<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): MonoTypeOperatorFunction<T> {\n  return function auditOperatorFunction(source: Observable<T>) {\n    return source.lift(new AuditOperator(durationSelector));\n  };\n}\n\nclass AuditOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new AuditSubscriber<T, T>(subscriber, this.durationSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass AuditSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  private value: T;\n  private hasValue: boolean = false;\n  private throttled: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.value = value;\n    this.hasValue = true;\n    if (!this.throttled) {\n      let duration;\n      try {\n        const { durationSelector } = this;\n        duration = durationSelector(value);\n      } catch (err) {\n        return this.destination.error(err);\n      }\n      const innerSubscription = subscribeToResult(this, duration);\n      if (!innerSubscription || innerSubscription.closed) {\n        this.clearThrottle();\n      } else {\n        this.add(this.throttled = innerSubscription);\n      }\n    }\n  }\n\n  clearThrottle() {\n    const { value, hasValue, throttled } = this;\n    if (throttled) {\n      this.remove(throttled);\n      this.throttled = null;\n      throttled.unsubscribe();\n    }\n    if (hasValue) {\n      this.value = null;\n      this.hasValue = false;\n      this.destination.next(value);\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number): void {\n    this.clearThrottle();\n  }\n\n  notifyComplete(): void {\n    this.clearThrottle();\n  }\n}\n"],"mappings":";AAMA,OAAO,KAAEA,OAAA,MAAe,OAAQ;AAChC,SAASC,eAAA,QAAmB,oBAAM;AAgDlC,SAAMC,iBAAmB,mCAA0D;OACjF,SAAOC,KAASA,CAAAC,gBAAA;SACd,SAAOC,qBAAgBA,CAAAC,MAAc;IACrC,OAAAA,MAAA,CAAAC,IAAA,KAAAC,aAAA,CAAAJ,gBAAA;EACH;AAED;IACEI,aAAA,gBAAoB,YAA0D;WAA1DA,cAAAJ,gBAAA;IACnB,KAAAA,gBAAA,GAAAA,gBAAA;EAED;eACS,CAAAK,SAAO,CAAAC,IAAU,aAAIC,UAAsB,EAAAL,MAAU,EAAE;IAC/D,OAAAA,MAAA,CAAAM,SAAA,KAAAC,eAAA,CAAAF,UAAA,OAAAP,gBAAA;EACH;EAPA,OAOCI,aAAA;AAOD;IAAoCK,eAAA,0BAAqBC,MAAA;EAMvDd,OAAA,CAAAe,SAAA,CAAAF,eAAY,EAAAC,MACQ;WADpBD,eAEEA,CAAAG,WAAM,EAAAZ,gBAAY,EACnB;IAFmB,IAAAa,KAAA,GAAAH,MAAA,CAAAJ,IAAgB,KAAhB,EAAAM,WAAgB,CAA0C;IAJtEC,KAAA,CAAAb,gBAAyB,GAACA,gBAAA;;IAMjC,OAAAa,KAAA;EAES;iBACE,CAAAR,SAAS,CAAAS,KAAA,aAAAC,KAAA;IACnB,IAAI,CAACA,KAAA,GAAQA,KAAG;IAChB,IAAI,CAACC,QAAK,OAAS;QACjB,KAAI,CAAAC,SAAQ;MACZ,IAAIC,QAAA;UACM;QACR,IAAAlB,gBAAW,OAAgB,CAACA,gBAAO;QACpCkB,QAAA,GAAAlB,gBAAA,CAAAe,KAAA;MAAC,E,OACAI,GAAA,EAAO;QACR,YAAAP,WAAA,CAAAQ,KAAA,CAAAD,GAAA;MACD;MACA,IAAIE,iBAAC,GAAiBvB,iBAAI,KAAkB,EAAAoB,QAAQ;UAClD,CAAAG,iBAAkB,IAAGA,iBAAA,CAAAC,MAAA;QACtB,KAAAC,aAAA;aACC;QACD,KAAAC,GAAA,MAAAP,SAAA,GAAAI,iBAAA;MACF;IACF;EAED;iBACQ,CAAAhB,SAAE,CAAAkB,aAAO;IACf,IAAIE,EAAA,OAAS;MAAEV,KAAA,GAAAU,EAAA,CAAAV,KAAA;MAAAC,QAAA,GAAAS,EAAA,CAAAT,QAAA;MAAAC,SAAA,GAAAQ,EAAA,CAAAR,SAAA;QACbA,SAAK,EAAM;MACX,IAAI,CAACS,MAAA,CAAAT,SAAgB,CAAC;MACtB,KAAAA,SAAU,OAAW;MACtBA,SAAA,CAAAU,WAAA;IACD;QACEX,QAAK,EAAK;MACV,IAAI,CAACD,KAAA,GAAQ,IAAG;MAChB,IAAI,CAACC,QAAA,GAAW,KAAK;MACtB,KAAAJ,WAAA,CAAAgB,IAAA,CAAAb,KAAA;IACF;EAED;iBACO,CAAAV,SAAgB,CAAAwB,UAAA,aAAAC,UAAA,EAAAC,UAAA,EAAAC,UAAA,EAAAC,UAAA;IACtB,KAAAV,aAAA;EAED;iBACO,CAAAlB,SAAgB,CAAA6B,cAAA;IACtB,KAAAX,aAAA;EACH;EApDoC,OAAAd,eAoDnC"},"metadata":{},"sourceType":"module","externalDependencies":[]}