{"ast":null,"code":"import * as g from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport * as util from '../util/index.mjs';\nfunction offsetPoint(p1, p2, offset) {\n  if (util.isPlainObject(offset)) {\n    const {\n      x,\n      y\n    } = offset;\n    if (isFinite(y)) {\n      const line = new g.Line(p2, p1);\n      const {\n        start,\n        end\n      } = line.parallel(y);\n      p2 = start;\n      p1 = end;\n    }\n    offset = x;\n  }\n  if (!isFinite(offset)) return p1;\n  var length = p1.distance(p2);\n  if (offset === 0 && length > 0) return p1;\n  return p1.move(p2, -Math.min(offset, length - 1));\n}\nfunction stroke(magnet) {\n  var stroke = magnet.getAttribute('stroke-width');\n  if (stroke === null) return 0;\n  return parseFloat(stroke) || 0;\n}\nfunction alignLine(line, type, offset = 0) {\n  let coordinate, a, b, direction;\n  const {\n    start,\n    end\n  } = line;\n  switch (type) {\n    case 'left':\n      coordinate = 'x';\n      a = end;\n      b = start;\n      direction = -1;\n      break;\n    case 'right':\n      coordinate = 'x';\n      a = start;\n      b = end;\n      direction = 1;\n      break;\n    case 'top':\n      coordinate = 'y';\n      a = end;\n      b = start;\n      direction = -1;\n      break;\n    case 'bottom':\n      coordinate = 'y';\n      a = start;\n      b = end;\n      direction = 1;\n      break;\n    default:\n      return;\n  }\n  if (start[coordinate] < end[coordinate]) {\n    a[coordinate] = b[coordinate];\n  } else {\n    b[coordinate] = a[coordinate];\n  }\n  if (isFinite(offset)) {\n    a[coordinate] += direction * offset;\n    b[coordinate] += direction * offset;\n  }\n}\n\n// Connection Points\n\nfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n  let {\n    offset,\n    alignOffset,\n    align\n  } = opt;\n  if (align) alignLine(line, align, alignOffset);\n  return offsetPoint(line.end, line.start, offset);\n}\nfunction bboxIntersection(line, view, magnet, opt) {\n  var bbox = view.getNodeBBox(magnet);\n  if (opt.stroke) bbox.inflate(stroke(magnet) / 2);\n  var intersections = line.intersect(bbox);\n  var cp = intersections ? line.start.chooseClosest(intersections) : line.end;\n  return offsetPoint(cp, line.start, opt.offset);\n}\nfunction rectangleIntersection(line, view, magnet, opt) {\n  var angle = view.model.angle();\n  if (angle === 0) {\n    return bboxIntersection(line, view, magnet, opt);\n  }\n  var bboxWORotation = view.getNodeUnrotatedBBox(magnet);\n  if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);\n  var center = bboxWORotation.center();\n  var lineWORotation = line.clone().rotate(center, angle);\n  var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n  var cp = intersections ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle) : line.end;\n  return offsetPoint(cp, line.start, opt.offset);\n}\nfunction findShapeNode(magnet) {\n  if (!magnet) return null;\n  var node = magnet;\n  do {\n    var tagName = node.tagName;\n    if (typeof tagName !== 'string') return null;\n    tagName = tagName.toUpperCase();\n    if (tagName === 'G') {\n      node = node.firstElementChild;\n    } else if (tagName === 'TITLE') {\n      node = node.nextElementSibling;\n    } else break;\n  } while (node);\n  return node;\n}\nvar BNDR_SUBDIVISIONS = 'segmentSubdivisons';\nvar BNDR_SHAPE_BBOX = 'shapeBBox';\nfunction boundaryIntersection(line, view, magnet, opt) {\n  var node, intersection;\n  var selector = opt.selector;\n  var anchor = line.end;\n  if (typeof selector === 'string') {\n    node = view.findNode(selector);\n  } else if (selector === false) {\n    node = magnet;\n  } else if (Array.isArray(selector)) {\n    node = util.getByPath(magnet, selector);\n  } else {\n    node = findShapeNode(magnet);\n  }\n  if (!V.isSVGGraphicsElement(node)) {\n    if (node === magnet || !V.isSVGGraphicsElement(magnet)) return anchor;\n    node = magnet;\n  }\n  var localShape = view.getNodeShape(node);\n  var magnetMatrix = view.getNodeMatrix(node);\n  var translateMatrix = view.getRootTranslateMatrix();\n  var rotateMatrix = view.getRootRotateMatrix();\n  var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n  var localMatrix = targetMatrix.inverse();\n  var localLine = V.transformLine(line, localMatrix);\n  var localRef = localLine.start.clone();\n  var data = view.getNodeData(node);\n  if (opt.insideout === false) {\n    if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();\n    var localBBox = data[BNDR_SHAPE_BBOX];\n    if (localBBox.containsPoint(localRef)) return anchor;\n  }\n\n  // Caching segment subdivisions for paths\n  var pathOpt;\n  if (localShape instanceof g.Path) {\n    var precision = opt.precision || 2;\n    if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({\n      precision: precision\n    });\n    pathOpt = {\n      precision: precision,\n      segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n    };\n  }\n  if (opt.extrapolate === true) localLine.setLength(1e6);\n  intersection = localLine.intersect(localShape, pathOpt);\n  if (intersection) {\n    // More than one intersection\n    if (V.isArray(intersection)) intersection = localRef.chooseClosest(intersection);\n  } else if (opt.sticky === true) {\n    // No intersection, find the closest point instead\n    if (localShape instanceof g.Rect) {\n      intersection = localShape.pointNearestToPoint(localRef);\n    } else if (localShape instanceof g.Ellipse) {\n      intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n    } else {\n      intersection = localShape.closestPoint(localRef, pathOpt);\n    }\n  }\n  var cp = intersection ? V.transformPoint(intersection, targetMatrix) : anchor;\n  var cpOffset = opt.offset || 0;\n  if (opt.stroke) cpOffset += stroke(node) / 2;\n  return offsetPoint(cp, line.start, cpOffset);\n}\nexport const anchor = anchorConnectionPoint;\nexport const bbox = bboxIntersection;\nexport const rectangle = rectangleIntersection;\nexport const boundary = boundaryIntersection;","map":{"version":3,"names":["g","V","util","offsetPoint","p1","p2","offset","isPlainObject","x","y","isFinite","line","Line","start","end","parallel","length","distance","move","Math","min","stroke","magnet","getAttribute","parseFloat","alignLine","type","coordinate","a","b","direction","anchorConnectionPoint","_view","_magnet","opt","alignOffset","align","bboxIntersection","view","bbox","getNodeBBox","inflate","intersections","intersect","cp","chooseClosest","rectangleIntersection","angle","model","bboxWORotation","getNodeUnrotatedBBox","center","lineWORotation","clone","rotate","setLength","findShapeNode","node","tagName","toUpperCase","firstElementChild","nextElementSibling","BNDR_SUBDIVISIONS","BNDR_SHAPE_BBOX","boundaryIntersection","intersection","selector","anchor","findNode","Array","isArray","getByPath","isSVGGraphicsElement","localShape","getNodeShape","magnetMatrix","getNodeMatrix","translateMatrix","getRootTranslateMatrix","rotateMatrix","getRootRotateMatrix","targetMatrix","multiply","localMatrix","inverse","localLine","transformLine","localRef","data","getNodeData","insideout","localBBox","containsPoint","pathOpt","Path","precision","getSegmentSubdivisions","segmentSubdivisions","extrapolate","sticky","Rect","pointNearestToPoint","Ellipse","intersectionWithLineFromCenterToPoint","closestPoint","transformPoint","cpOffset","rectangle","boundary"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/connectionPoints/index.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport * as util from '../util/index.mjs';\n\nfunction offsetPoint(p1, p2, offset) {\n    if (util.isPlainObject(offset)) {\n        const { x, y } = offset;\n        if (isFinite(y)) {\n            const line =  new g.Line(p2, p1);\n            const { start, end } = line.parallel(y);\n            p2 = start;\n            p1 = end;\n        }\n        offset = x;\n    }\n    if (!isFinite(offset)) return p1;\n    var length = p1.distance(p2);\n    if (offset === 0 && length > 0) return p1;\n    return p1.move(p2, -Math.min(offset, length - 1));\n}\n\nfunction stroke(magnet) {\n\n    var stroke = magnet.getAttribute('stroke-width');\n    if (stroke === null) return 0;\n    return parseFloat(stroke) || 0;\n}\n\nfunction alignLine(line, type, offset = 0) {\n    let coordinate, a, b, direction;\n    const { start, end } = line;\n    switch (type) {\n        case 'left':\n            coordinate = 'x';\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case 'right':\n            coordinate = 'x';\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        case 'top':\n            coordinate = 'y';\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case 'bottom':\n            coordinate = 'y';\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        default:\n            return;\n    }\n    if (start[coordinate] < end[coordinate]) {\n        a[coordinate] = b[coordinate];\n    } else {\n        b[coordinate] = a[coordinate];\n    }\n    if (isFinite(offset)) {\n        a[coordinate] += direction * offset;\n        b[coordinate] += direction * offset;\n    }\n}\n\n// Connection Points\n\nfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n    let { offset, alignOffset, align } = opt;\n    if (align) alignLine(line, align, alignOffset);\n    return offsetPoint(line.end, line.start, offset);\n}\n\nfunction bboxIntersection(line, view, magnet, opt) {\n\n    var bbox = view.getNodeBBox(magnet);\n    if (opt.stroke) bbox.inflate(stroke(magnet) / 2);\n    var intersections = line.intersect(bbox);\n    var cp = (intersections)\n        ? line.start.chooseClosest(intersections)\n        : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction rectangleIntersection(line, view, magnet, opt) {\n\n    var angle = view.model.angle();\n    if (angle === 0) {\n        return bboxIntersection(line, view, magnet, opt);\n    }\n\n    var bboxWORotation = view.getNodeUnrotatedBBox(magnet);\n    if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);\n    var center = bboxWORotation.center();\n    var lineWORotation = line.clone().rotate(center, angle);\n    var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n    var cp = (intersections)\n        ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle)\n        : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction findShapeNode(magnet) {\n    if (!magnet) return null;\n    var node = magnet;\n    do {\n        var tagName = node.tagName;\n        if (typeof tagName !== 'string') return null;\n        tagName = tagName.toUpperCase();\n        if (tagName === 'G') {\n            node = node.firstElementChild;\n        } else if (tagName === 'TITLE') {\n            node = node.nextElementSibling;\n        } else break;\n    } while (node);\n    return node;\n}\n\nvar BNDR_SUBDIVISIONS = 'segmentSubdivisons';\nvar BNDR_SHAPE_BBOX = 'shapeBBox';\n\nfunction boundaryIntersection(line, view, magnet, opt) {\n\n    var node, intersection;\n    var selector = opt.selector;\n    var anchor = line.end;\n\n    if (typeof selector === 'string') {\n        node = view.findNode(selector);\n    } else if (selector === false) {\n        node = magnet;\n    } else if (Array.isArray(selector)) {\n        node = util.getByPath(magnet, selector);\n    } else {\n        node = findShapeNode(magnet);\n    }\n\n    if (!V.isSVGGraphicsElement(node)) {\n        if (node === magnet || !V.isSVGGraphicsElement(magnet)) return anchor;\n        node = magnet;\n    }\n\n    var localShape = view.getNodeShape(node);\n    var magnetMatrix = view.getNodeMatrix(node);\n    var translateMatrix = view.getRootTranslateMatrix();\n    var rotateMatrix = view.getRootRotateMatrix();\n    var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n    var localMatrix = targetMatrix.inverse();\n    var localLine = V.transformLine(line, localMatrix);\n    var localRef = localLine.start.clone();\n    var data = view.getNodeData(node);\n\n    if (opt.insideout === false) {\n        if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();\n        var localBBox = data[BNDR_SHAPE_BBOX];\n        if (localBBox.containsPoint(localRef)) return anchor;\n    }\n\n    // Caching segment subdivisions for paths\n    var pathOpt;\n    if (localShape instanceof g.Path) {\n        var precision = opt.precision || 2;\n        if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({ precision: precision });\n        pathOpt = {\n            precision: precision,\n            segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n        };\n    }\n\n    if (opt.extrapolate === true) localLine.setLength(1e6);\n\n    intersection = localLine.intersect(localShape, pathOpt);\n    if (intersection) {\n        // More than one intersection\n        if (V.isArray(intersection)) intersection = localRef.chooseClosest(intersection);\n    } else if (opt.sticky === true) {\n        // No intersection, find the closest point instead\n        if (localShape instanceof g.Rect) {\n            intersection = localShape.pointNearestToPoint(localRef);\n        } else if (localShape instanceof g.Ellipse) {\n            intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n        } else {\n            intersection = localShape.closestPoint(localRef, pathOpt);\n        }\n    }\n\n    var cp = (intersection) ? V.transformPoint(intersection, targetMatrix) : anchor;\n    var cpOffset = opt.offset || 0;\n    if (opt.stroke) cpOffset += stroke(node) / 2;\n\n    return offsetPoint(cp, line.start, cpOffset);\n}\n\nexport const anchor = anchorConnectionPoint;\nexport const bbox = bboxIntersection;\nexport const rectangle = rectangleIntersection;\nexport const boundary = boundaryIntersection;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}