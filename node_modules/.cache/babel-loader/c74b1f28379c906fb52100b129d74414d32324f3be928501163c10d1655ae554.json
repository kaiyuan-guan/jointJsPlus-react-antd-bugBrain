{"ast":null,"code":"// Local helper function.\n// Add properties from arguments on top of properties from `obj`.\n// This allows for rudimentary inheritance.\n// - The `obj` argument acts as parent.\n// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\nexport function extend(obj) {\n  // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n  // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n  // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n  // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n  // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n  // - This method provides a way to do exactly that.\n  // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n  // - Therefore, to continue with the example above:\n  //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n  //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n  //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n  //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n  // - Multiple inheritance is also possible, if multiple arguments are provided.\n  // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n  //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n  //   - The ancestors are applied in order of appearance.\n  //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n  //   - Any number of ancestors may be provided.\n  // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n  // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n  //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n  //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n  // - Therefore, both of the following are valid:\n  //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n  //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n\n  var i;\n  var n;\n  var args = [];\n  n = arguments.length;\n  for (i = 1; i < n; i++) {\n    // skip over obj\n    args.push(arguments[i]);\n  }\n  if (!obj) throw new Error('Missing a parent object.');\n  var child = Object.create(obj);\n  n = args.length;\n  for (i = 0; i < n; i++) {\n    var src = args[i];\n    var inheritedProperty;\n    var key;\n    for (key in src) {\n      if (src.hasOwnProperty(key)) {\n        delete child[key]; // delete property inherited from parent\n        inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n        Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n      }\n    }\n  }\n  return child;\n}","map":{"version":3,"names":["extend","obj","i","n","args","arguments","length","push","Error","child","Object","create","src","inheritedProperty","key","hasOwnProperty","getOwnPropertyDescriptor","defineProperty"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/g/extend.mjs"],"sourcesContent":["// Local helper function.\n// Add properties from arguments on top of properties from `obj`.\n// This allows for rudimentary inheritance.\n// - The `obj` argument acts as parent.\n// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\nexport function extend(obj) {\n    // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n    // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n    // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n    // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n    // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n    // - This method provides a way to do exactly that.\n    // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n    // - Therefore, to continue with the example above:\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n    //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n    //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n    //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n    // - Multiple inheritance is also possible, if multiple arguments are provided.\n    // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n    //   - The ancestors are applied in order of appearance.\n    //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n    //   - Any number of ancestors may be provided.\n    // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n    // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n    //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n    //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n    // - Therefore, both of the following are valid:\n    //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n    //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n\n    var i;\n    var n;\n\n    var args = [];\n    n = arguments.length;\n    for (i = 1; i < n; i++) { // skip over obj\n        args.push(arguments[i]);\n    }\n\n    if (!obj) throw new Error('Missing a parent object.');\n    var child = Object.create(obj);\n\n    n = args.length;\n    for (i = 0; i < n; i++) {\n\n        var src = args[i];\n\n        var inheritedProperty;\n        var key;\n        for (key in src) {\n\n            if (src.hasOwnProperty(key)) {\n                delete child[key]; // delete property inherited from parent\n                inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n                Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n            }\n        }\n    }\n\n    return child;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,MAAMA,CAACC,GAAG,EAAE;EACxB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,IAAIC,CAAC;EACL,IAAIC,CAAC;EAEL,IAAIC,IAAI,GAAG,EAAE;EACbD,CAAC,GAAGE,SAAS,CAACC,MAAM;EACpB,KAAKJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;IAAE;IACtBE,IAAI,CAACG,IAAI,CAACF,SAAS,CAACH,CAAC,CAAC,CAAC;EAC3B;EAEA,IAAI,CAACD,GAAG,EAAE,MAAM,IAAIO,KAAK,CAAC,0BAA0B,CAAC;EACrD,IAAIC,KAAK,GAAGC,MAAM,CAACC,MAAM,CAACV,GAAG,CAAC;EAE9BE,CAAC,GAAGC,IAAI,CAACE,MAAM;EACf,KAAKJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;IAEpB,IAAIU,GAAG,GAAGR,IAAI,CAACF,CAAC,CAAC;IAEjB,IAAIW,iBAAiB;IACrB,IAAIC,GAAG;IACP,KAAKA,GAAG,IAAIF,GAAG,EAAE;MAEb,IAAIA,GAAG,CAACG,cAAc,CAACD,GAAG,CAAC,EAAE;QACzB,OAAOL,KAAK,CAACK,GAAG,CAAC,CAAC,CAAC;QACnBD,iBAAiB,GAAGH,MAAM,CAACM,wBAAwB,CAACJ,GAAG,EAAEE,GAAG,CAAC,CAAC,CAAC;QAC/DJ,MAAM,CAACO,cAAc,CAACR,KAAK,EAAEK,GAAG,EAAED,iBAAiB,CAAC,CAAC,CAAC;MAC1D;IACJ;EACJ;EAEA,OAAOJ,KAAK;AAChB"},"metadata":{},"sourceType":"module","externalDependencies":[]}