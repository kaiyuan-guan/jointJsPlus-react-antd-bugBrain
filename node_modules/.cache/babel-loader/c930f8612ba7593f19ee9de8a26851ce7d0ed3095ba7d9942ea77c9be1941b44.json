{"ast":null,"code":"import { uniqueId, union, result, merge, forIn, isObject, isEqual, isString, cloneDeep, omit, uuid, isEmpty, assign, uniq, toArray, setByPath, unsetByPath, getByPath, timing, interpolate, nextFrame, without, cancelFrame, defaultsDeep, has, sortBy, defaults } from '../util/util.mjs';\nimport { Model } from '../mvc/Model.mjs';\nimport { cloneCells } from '../util/cloneCells.mjs';\nimport { attributes } from './attributes/index.mjs';\nimport * as g from '../g/index.mjs';\n\n// Cell base model.\n// --------------------------\n\nconst attributesMerger = function (a, b) {\n  if (Array.isArray(a)) {\n    return b;\n  }\n};\nexport const Cell = Model.extend({\n  // This is the same as mvc.Model with the only difference that is uses util.merge\n  // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.\n  constructor: function (attributes, options) {\n    var defaults;\n    var attrs = attributes || {};\n    if (typeof this.preinitialize === 'function') {\n      // Check to support an older version\n      this.preinitialize.apply(this, arguments);\n    }\n    this.cid = uniqueId('c');\n    this.attributes = {};\n    if (options && options.collection) this.collection = options.collection;\n    if (options && options.parse) attrs = this.parse(attrs, options) || {};\n    if (defaults = result(this, 'defaults')) {\n      //<custom code>\n      // Replaced the call to _.defaults with util.merge.\n      const customizer = options && options.mergeArrays === true ? false : attributesMerger;\n      attrs = merge({}, defaults, attrs, customizer);\n      //</custom code>\n    }\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n  },\n  translate: function (dx, dy, opt) {\n    throw new Error('Must define a translate() method.');\n  },\n  toJSON: function () {\n    const defaults = result(this.constructor.prototype, 'defaults');\n    const defaultAttrs = defaults.attrs || {};\n    const attrs = this.attributes.attrs;\n    const finalAttrs = {};\n\n    // Loop through all the attributes and\n    // omit the default attributes as they are implicitly reconstructible by the cell 'type'.\n    forIn(attrs, function (attr, selector) {\n      const defaultAttr = defaultAttrs[selector];\n      forIn(attr, function (value, name) {\n        // attr is mainly flat though it might have one more level (consider the `style` attribute).\n        // Check if the `value` is object and if yes, go one level deep.\n        if (isObject(value) && !Array.isArray(value)) {\n          forIn(value, function (value2, name2) {\n            if (!defaultAttr || !defaultAttr[name] || !isEqual(defaultAttr[name][name2], value2)) {\n              finalAttrs[selector] = finalAttrs[selector] || {};\n              (finalAttrs[selector][name] || (finalAttrs[selector][name] = {}))[name2] = value2;\n            }\n          });\n        } else if (!defaultAttr || !isEqual(defaultAttr[name], value)) {\n          // `value` is not an object, default attribute for such a selector does not exist\n          // or it is different than the attribute value set on the model.\n\n          finalAttrs[selector] = finalAttrs[selector] || {};\n          finalAttrs[selector][name] = value;\n        }\n      });\n    });\n    const attributes = cloneDeep(omit(this.attributes, 'attrs'));\n    attributes.attrs = finalAttrs;\n    return attributes;\n  },\n  initialize: function (options) {\n    const idAttribute = this.getIdAttribute();\n    if (!options || options[idAttribute] === undefined) {\n      this.set(idAttribute, this.generateId(), {\n        silent: true\n      });\n    }\n    this._transitionIds = {};\n    this._scheduledTransitionIds = {};\n\n    // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n    this.processPorts();\n    this.on('change:attrs', this.processPorts, this);\n  },\n  getIdAttribute: function () {\n    return this.idAttribute || 'id';\n  },\n  generateId: function () {\n    return uuid();\n  },\n  /**\n   * @deprecated\n   */\n  processPorts: function () {\n    // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n    // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n    // set to that port, we remove those links as well (to follow the same behaviour as\n    // with a removed element).\n\n    var previousPorts = this.ports;\n\n    // Collect ports from the `attrs` object.\n    var ports = {};\n    forIn(this.get('attrs'), function (attrs, selector) {\n      if (attrs && attrs.port) {\n        // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n        if (attrs.port.id !== undefined) {\n          ports[attrs.port.id] = attrs.port;\n        } else {\n          ports[attrs.port] = {\n            id: attrs.port\n          };\n        }\n      }\n    });\n\n    // Collect ports that have been removed (compared to the previous ports) - if any.\n    // Use hash table for quick lookup.\n    var removedPorts = {};\n    forIn(previousPorts, function (port, id) {\n      if (!ports[id]) removedPorts[id] = true;\n    });\n\n    // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n    if (this.graph && !isEmpty(removedPorts)) {\n      var inboundLinks = this.graph.getConnectedLinks(this, {\n        inbound: true\n      });\n      inboundLinks.forEach(function (link) {\n        if (removedPorts[link.get('target').port]) link.remove();\n      });\n      var outboundLinks = this.graph.getConnectedLinks(this, {\n        outbound: true\n      });\n      outboundLinks.forEach(function (link) {\n        if (removedPorts[link.get('source').port]) link.remove();\n      });\n    }\n\n    // Update the `ports` object.\n    this.ports = ports;\n  },\n  remove: function (opt = {}) {\n    // Store the graph in a variable because `this.graph` won't be accessible\n    // after `this.trigger('remove', ...)` down below.\n    const {\n      graph,\n      collection\n    } = this;\n    if (!graph) {\n      // The collection is a common mvc collection (not the graph collection).\n      if (collection) collection.remove(this, opt);\n      return this;\n    }\n    graph.startBatch('remove');\n\n    // First, unembed this cell from its parent cell if there is one.\n    const parentCell = this.getParentCell();\n    if (parentCell) {\n      parentCell.unembed(this, opt);\n    }\n\n    // Remove also all the cells, which were embedded into this cell\n    const embeddedCells = this.getEmbeddedCells();\n    for (let i = 0, n = embeddedCells.length; i < n; i++) {\n      const embed = embeddedCells[i];\n      if (embed) {\n        embed.remove(opt);\n      }\n    }\n    this.trigger('remove', this, graph.attributes.cells, opt);\n    graph.stopBatch('remove');\n    return this;\n  },\n  toFront: function (opt) {\n    var graph = this.graph;\n    if (graph) {\n      opt = defaults(opt || {}, {\n        foregroundEmbeds: true\n      });\n      let cells;\n      if (opt.deep) {\n        cells = this.getEmbeddedCells({\n          deep: true,\n          breadthFirst: opt.breadthFirst !== false,\n          sortSiblings: opt.foregroundEmbeds\n        });\n        cells.unshift(this);\n      } else {\n        cells = [this];\n      }\n      const sortedCells = opt.foregroundEmbeds ? cells : sortBy(cells, cell => cell.z());\n      const maxZ = graph.maxZIndex();\n      let z = maxZ - cells.length + 1;\n      const collection = graph.get('cells');\n      let shouldUpdate = collection.toArray().indexOf(sortedCells[0]) !== collection.length - cells.length;\n      if (!shouldUpdate) {\n        shouldUpdate = sortedCells.some(function (cell, index) {\n          return cell.z() !== z + index;\n        });\n      }\n      if (shouldUpdate) {\n        this.startBatch('to-front');\n        z = z + cells.length;\n        sortedCells.forEach(function (cell, index) {\n          cell.set('z', z + index, opt);\n        });\n        this.stopBatch('to-front');\n      }\n    }\n    return this;\n  },\n  toBack: function (opt) {\n    var graph = this.graph;\n    if (graph) {\n      opt = defaults(opt || {}, {\n        foregroundEmbeds: true\n      });\n      let cells;\n      if (opt.deep) {\n        cells = this.getEmbeddedCells({\n          deep: true,\n          breadthFirst: opt.breadthFirst !== false,\n          sortSiblings: opt.foregroundEmbeds\n        });\n        cells.unshift(this);\n      } else {\n        cells = [this];\n      }\n      const sortedCells = opt.foregroundEmbeds ? cells : sortBy(cells, cell => cell.z());\n      let z = graph.minZIndex();\n      var collection = graph.get('cells');\n      let shouldUpdate = collection.toArray().indexOf(sortedCells[0]) !== 0;\n      if (!shouldUpdate) {\n        shouldUpdate = sortedCells.some(function (cell, index) {\n          return cell.z() !== z + index;\n        });\n      }\n      if (shouldUpdate) {\n        this.startBatch('to-back');\n        z -= cells.length;\n        sortedCells.forEach(function (cell, index) {\n          cell.set('z', z + index, opt);\n        });\n        this.stopBatch('to-back');\n      }\n    }\n    return this;\n  },\n  parent: function (parent, opt) {\n    // getter\n    if (parent === undefined) return this.get('parent');\n    // setter\n    return this.set('parent', parent, opt);\n  },\n  embed: function (cell, opt) {\n    const cells = Array.isArray(cell) ? cell : [cell];\n    if (!this.canEmbed(cells)) {\n      throw new Error('Recursive embedding not allowed.');\n    }\n    if (cells.some(c => c.isEmbedded() && this.id !== c.parent())) {\n      throw new Error('Embedding of already embedded cells is not allowed.');\n    }\n    this._embedCells(cells, opt);\n    return this;\n  },\n  unembed: function (cell, opt) {\n    const cells = Array.isArray(cell) ? cell : [cell];\n    this._unembedCells(cells, opt);\n    return this;\n  },\n  canEmbed: function (cell) {\n    const cells = Array.isArray(cell) ? cell : [cell];\n    return cells.every(c => this !== c && !this.isEmbeddedIn(c));\n  },\n  _embedCells: function (cells, opt) {\n    const batchName = 'embed';\n    this.startBatch(batchName);\n    const embeds = assign([], this.get('embeds'));\n    cells.forEach(cell => {\n      // We keep all element ids after link ids.\n      embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);\n      cell.parent(this.id, opt);\n    });\n    this.set('embeds', uniq(embeds), opt);\n    this.stopBatch(batchName);\n  },\n  _unembedCells: function (cells, opt) {\n    const batchName = 'unembed';\n    this.startBatch(batchName);\n    cells.forEach(cell => cell.unset('parent', opt));\n    this.set('embeds', without(this.get('embeds'), ...cells.map(cell => cell.id)), opt);\n    this.stopBatch(batchName);\n  },\n  getParentCell: function () {\n    // unlike link.source/target, cell.parent stores id directly as a string\n    var parentId = this.parent();\n    var graph = this.graph;\n    return parentId && graph && graph.getCell(parentId) || null;\n  },\n  // Return an array of ancestor cells.\n  // The array is ordered from the parent of the cell\n  // to the most distant ancestor.\n  getAncestors: function () {\n    var ancestors = [];\n    if (!this.graph) {\n      return ancestors;\n    }\n    var parentCell = this.getParentCell();\n    while (parentCell) {\n      ancestors.push(parentCell);\n      parentCell = parentCell.getParentCell();\n    }\n    return ancestors;\n  },\n  getEmbeddedCells: function (opt) {\n    opt = opt || {};\n\n    // Cell models can only be retrieved when this element is part of a collection.\n    // There is no way this element knows about other cells otherwise.\n    // This also means that calling e.g. `translate()` on an element with embeds before\n    // adding it to a graph does not translate its embeds.\n    if (!this.graph) {\n      return [];\n    }\n    if (opt.deep) {\n      if (opt.breadthFirst) {\n        return this._getEmbeddedCellsBfs(opt.sortSiblings);\n      } else {\n        return this._getEmbeddedCellsDfs(opt.sortSiblings);\n      }\n    }\n    const embeddedIds = this.get('embeds');\n    if (isEmpty(embeddedIds)) {\n      return [];\n    }\n    let cells = embeddedIds.map(this.graph.getCell, this.graph);\n    if (opt.sortSiblings) {\n      cells = sortBy(cells, cell => cell.z());\n    }\n    return cells;\n  },\n  _getEmbeddedCellsBfs: function (sortSiblings) {\n    const cells = [];\n    const queue = [];\n    queue.push(this);\n    while (queue.length > 0) {\n      const current = queue.shift();\n      cells.push(current);\n      const embeddedCells = current.getEmbeddedCells({\n        sortSiblings: sortSiblings\n      });\n      queue.push(...embeddedCells);\n    }\n    cells.shift();\n    return cells;\n  },\n  _getEmbeddedCellsDfs: function (sortSiblings) {\n    const cells = [];\n    const stack = [];\n    stack.push(this);\n    while (stack.length > 0) {\n      const current = stack.pop();\n      cells.push(current);\n      const embeddedCells = current.getEmbeddedCells({\n        sortSiblings: sortSiblings\n      });\n\n      // When using the stack, cells that are embedded last are processed first.\n      // To maintain the original order, we need to push the cells in reverse order\n      for (let i = embeddedCells.length - 1; i >= 0; --i) {\n        stack.push(embeddedCells[i]);\n      }\n    }\n    cells.shift();\n    return cells;\n  },\n  isEmbeddedIn: function (cell, opt) {\n    var cellId = isString(cell) ? cell : cell.id;\n    var parentId = this.parent();\n    opt = assign({\n      deep: true\n    }, opt);\n\n    // See getEmbeddedCells().\n    if (this.graph && opt.deep) {\n      while (parentId) {\n        if (parentId === cellId) {\n          return true;\n        }\n        parentId = this.graph.getCell(parentId).parent();\n      }\n      return false;\n    } else {\n      // When this cell is not part of a collection check\n      // at least whether it's a direct child of given cell.\n      return parentId === cellId;\n    }\n  },\n  // Whether or not the cell is embedded in any other cell.\n  isEmbedded: function () {\n    return !!this.parent();\n  },\n  // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n  // Shallow cloning simply clones the cell and returns a new cell with different ID.\n  // Deep cloning clones the cell and all its embedded cells recursively.\n  clone: function (opt) {\n    opt = opt || {};\n    if (!opt.deep) {\n      // Shallow cloning.\n\n      var clone = Model.prototype.clone.apply(this, arguments);\n      // We don't want the clone to have the same ID as the original.\n      clone.set(this.getIdAttribute(), this.generateId());\n      // A shallow cloned element does not carry over the original embeds.\n      clone.unset('embeds');\n      // And can not be embedded in any cell\n      // as the clone is not part of the graph.\n      clone.unset('parent');\n      return clone;\n    } else {\n      // Deep cloning.\n\n      // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.\n      return toArray(cloneCells([this].concat(this.getEmbeddedCells({\n        deep: true\n      }))));\n    }\n  },\n  // A convenient way to set nested properties.\n  // This method merges the properties you'd like to set with the ones\n  // stored in the cell and makes sure change events are properly triggered.\n  // You can either set a nested property with one object\n  // or use a property path.\n  // The most simple use case is:\n  // `cell.prop('name/first', 'John')` or\n  // `cell.prop({ name: { first: 'John' } })`.\n  // Nested arrays are supported too:\n  // `cell.prop('series/0/data/0/degree', 50)` or\n  // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n  prop: function (props, value, opt) {\n    var delim = '/';\n    var _isString = isString(props);\n    if (_isString || Array.isArray(props)) {\n      // Get/set an attribute by a special path syntax that delimits\n      // nested objects by the colon character.\n\n      if (arguments.length > 1) {\n        var path;\n        var pathArray;\n        if (_isString) {\n          path = props;\n          pathArray = path.split('/');\n        } else {\n          path = props.join(delim);\n          pathArray = props.slice();\n        }\n        var property = pathArray[0];\n        var pathArrayLength = pathArray.length;\n        const options = opt || {};\n        options.propertyPath = path;\n        options.propertyValue = value;\n        options.propertyPathArray = pathArray;\n        if (!('rewrite' in options)) {\n          options.rewrite = false;\n        }\n        var update = {};\n        // Initialize the nested object. Sub-objects are either arrays or objects.\n        // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n        // Note that this imposes a limitation on object keys one can use with Inspector.\n        // Pure integer keys will cause issues and are therefore not allowed.\n        var initializer = update;\n        var prevProperty = property;\n        for (var i = 1; i < pathArrayLength; i++) {\n          var pathItem = pathArray[i];\n          var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n          initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n          prevProperty = pathItem;\n        }\n\n        // Fill update with the `value` on `path`.\n        update = setByPath(update, pathArray, value, '/');\n        var baseAttributes = merge({}, this.attributes);\n        // if rewrite mode enabled, we replace value referenced by path with\n        // the new one (we don't merge).\n        options.rewrite && unsetByPath(baseAttributes, path, '/');\n\n        // Merge update with the model attributes.\n        var attributes = merge(baseAttributes, update);\n        // Finally, set the property to the updated attributes.\n        return this.set(property, attributes[property], options);\n      } else {\n        return getByPath(this.attributes, props, delim);\n      }\n    }\n    const options = value || {};\n    // Note: '' is not the path to the root. It's a path with an empty string i.e. { '': {}}.\n    options.propertyPath = null;\n    options.propertyValue = props;\n    options.propertyPathArray = [];\n    if (!('rewrite' in options)) {\n      options.rewrite = false;\n    }\n\n    // Create a new object containing only the changed attributes.\n    const changedAttributes = {};\n    for (const key in props) {\n      // Merging the values of changed attributes with the current ones.\n      const {\n        changedValue\n      } = merge({}, {\n        changedValue: this.attributes[key]\n      }, {\n        changedValue: props[key]\n      });\n      changedAttributes[key] = changedValue;\n    }\n    return this.set(changedAttributes, options);\n  },\n  // A convenient way to unset nested properties\n  removeProp: function (path, opt) {\n    opt = opt || {};\n    var pathArray = Array.isArray(path) ? path : path.split('/');\n\n    // Once a property is removed from the `attrs` attribute\n    // the cellView will recognize a `dirty` flag and re-render itself\n    // in order to remove the attribute from SVG element.\n    var property = pathArray[0];\n    if (property === 'attrs') opt.dirty = true;\n    if (pathArray.length === 1) {\n      // A top level property\n      return this.unset(path, opt);\n    }\n\n    // A nested property\n    var nestedPath = pathArray.slice(1);\n    var propertyValue = this.get(property);\n    if (propertyValue === undefined || propertyValue === null) return this;\n    propertyValue = cloneDeep(propertyValue);\n    unsetByPath(propertyValue, nestedPath, '/');\n    return this.set(property, propertyValue, opt);\n  },\n  // A convenient way to set nested attributes.\n  attr: function (attrs, value, opt) {\n    var args = Array.from(arguments);\n    if (args.length === 0) {\n      return this.get('attrs');\n    }\n    if (Array.isArray(attrs)) {\n      args[0] = ['attrs'].concat(attrs);\n    } else if (isString(attrs)) {\n      // Get/set an attribute by a special path syntax that delimits\n      // nested objects by the colon character.\n      args[0] = 'attrs/' + attrs;\n    } else {\n      args[0] = {\n        'attrs': attrs\n      };\n    }\n    return this.prop.apply(this, args);\n  },\n  // A convenient way to unset nested attributes\n  removeAttr: function (path, opt) {\n    if (Array.isArray(path)) {\n      return this.removeProp(['attrs'].concat(path));\n    }\n    return this.removeProp('attrs/' + path, opt);\n  },\n  transition: function (path, value, opt, delim) {\n    delim = delim || '/';\n    var defaults = {\n      duration: 100,\n      delay: 10,\n      timingFunction: timing.linear,\n      valueFunction: interpolate.number\n    };\n    opt = assign(defaults, opt);\n    var firstFrameTime = 0;\n    var interpolatingFunction;\n    var setter = function (runtime) {\n      var id, progress, propertyValue;\n      firstFrameTime = firstFrameTime || runtime;\n      runtime -= firstFrameTime;\n      progress = runtime / opt.duration;\n      if (progress < 1) {\n        this._transitionIds[path] = id = nextFrame(setter);\n      } else {\n        progress = 1;\n        delete this._transitionIds[path];\n      }\n      propertyValue = interpolatingFunction(opt.timingFunction(progress));\n      opt.transitionId = id;\n      this.prop(path, propertyValue, opt);\n      if (!id) this.trigger('transition:end', this, path);\n    }.bind(this);\n    const {\n      _scheduledTransitionIds\n    } = this;\n    let initialId;\n    var initiator = callback => {\n      if (_scheduledTransitionIds[path]) {\n        _scheduledTransitionIds[path] = without(_scheduledTransitionIds[path], initialId);\n        if (_scheduledTransitionIds[path].length === 0) {\n          delete _scheduledTransitionIds[path];\n        }\n      }\n      this.stopPendingTransitions(path, delim);\n      interpolatingFunction = opt.valueFunction(getByPath(this.attributes, path, delim), value);\n      this._transitionIds[path] = nextFrame(callback);\n      this.trigger('transition:start', this, path);\n    };\n    initialId = setTimeout(initiator, opt.delay, setter);\n    _scheduledTransitionIds[path] || (_scheduledTransitionIds[path] = []);\n    _scheduledTransitionIds[path].push(initialId);\n    return initialId;\n  },\n  getTransitions: function () {\n    return union(Object.keys(this._transitionIds), Object.keys(this._scheduledTransitionIds));\n  },\n  stopScheduledTransitions: function (path, delim = '/') {\n    const {\n      _scheduledTransitionIds = {}\n    } = this;\n    let transitions = Object.keys(_scheduledTransitionIds);\n    if (path) {\n      const pathArray = path.split(delim);\n      transitions = transitions.filter(key => {\n        return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n      });\n    }\n    transitions.forEach(key => {\n      const transitionIds = _scheduledTransitionIds[key];\n      // stop the initiator\n      transitionIds.forEach(transitionId => clearTimeout(transitionId));\n      delete _scheduledTransitionIds[key];\n      // Note: we could trigger transition:cancel` event here\n    });\n    return this;\n  },\n  stopPendingTransitions(path, delim = '/') {\n    const {\n      _transitionIds = {}\n    } = this;\n    let transitions = Object.keys(_transitionIds);\n    if (path) {\n      const pathArray = path.split(delim);\n      transitions = transitions.filter(key => {\n        return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n      });\n    }\n    transitions.forEach(key => {\n      const transitionId = _transitionIds[key];\n      // stop the setter\n      cancelFrame(transitionId);\n      delete _transitionIds[key];\n      this.trigger('transition:end', this, key);\n    });\n  },\n  stopTransitions: function (path, delim = '/') {\n    this.stopScheduledTransitions(path, delim);\n    this.stopPendingTransitions(path, delim);\n    return this;\n  },\n  // A shorcut making it easy to create constructs like the following:\n  // `var el = (new joint.shapes.standard.Rectangle()).addTo(graph)`.\n  addTo: function (graph, opt) {\n    graph.addCell(this, opt);\n    return this;\n  },\n  // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n  // making it easy to create constructs like the following:\n  // `cell.findView(paper).highlight()`\n  findView: function (paper) {\n    return paper.findViewByModel(this);\n  },\n  isElement: function () {\n    return false;\n  },\n  isLink: function () {\n    return false;\n  },\n  startBatch: function (name, opt) {\n    if (this.graph) {\n      this.graph.startBatch(name, assign({}, opt, {\n        cell: this\n      }));\n    }\n    return this;\n  },\n  stopBatch: function (name, opt) {\n    if (this.graph) {\n      this.graph.stopBatch(name, assign({}, opt, {\n        cell: this\n      }));\n    }\n    return this;\n  },\n  getChangeFlag: function (attributes) {\n    var flag = 0;\n    if (!attributes) return flag;\n    for (var key in attributes) {\n      if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;\n      flag |= attributes[key];\n    }\n    return flag;\n  },\n  angle: function () {\n    // To be overridden.\n    return 0;\n  },\n  position: function () {\n    // To be overridden.\n    return new g.Point(0, 0);\n  },\n  z: function () {\n    return this.get('z') || 0;\n  },\n  getPointFromConnectedLink: function () {\n    // To be overridden\n    return new g.Point();\n  },\n  getBBox: function () {\n    // To be overridden\n    return new g.Rect(0, 0, 0, 0);\n  },\n  getPointRotatedAroundCenter(angle, x, y) {\n    const point = new g.Point(x, y);\n    if (angle) point.rotate(this.getBBox().center(), angle);\n    return point;\n  },\n  getAbsolutePointFromRelative(x, y) {\n    // Rotate the position to take the model angle into account\n    return this.getPointRotatedAroundCenter(-this.angle(),\n    // Transform the relative position to absolute\n    this.position().offset(x, y));\n  },\n  getRelativePointFromAbsolute(x, y) {\n    return this\n    // Rotate the coordinates to mitigate the element's rotation.\n    .getPointRotatedAroundCenter(this.angle(), x, y)\n    // Transform the absolute position into relative\n    .difference(this.position());\n  }\n}, {\n  getAttributeDefinition: function (attrName) {\n    var defNS = this.attributes;\n    var globalDefNS = attributes;\n    return defNS && defNS[attrName] || globalDefNS[attrName];\n  },\n  define: function (type, defaults, protoProps, staticProps) {\n    protoProps = assign({\n      defaults: defaultsDeep({\n        type: type\n      }, defaults, this.prototype.defaults)\n    }, protoProps);\n    var Cell = this.extend(protoProps, staticProps);\n    // es5 backward compatibility\n    /* eslint-disable no-undef */\n    if (typeof joint !== 'undefined' && has(joint, 'shapes')) {\n      setByPath(joint.shapes, type, Cell, '.');\n    }\n    /* eslint-enable no-undef */\n    return Cell;\n  }\n});","map":{"version":3,"names":["uniqueId","union","result","merge","forIn","isObject","isEqual","isString","cloneDeep","omit","uuid","isEmpty","assign","uniq","toArray","setByPath","unsetByPath","getByPath","timing","interpolate","nextFrame","without","cancelFrame","defaultsDeep","has","sortBy","defaults","Model","cloneCells","attributes","g","attributesMerger","a","b","Array","isArray","Cell","extend","constructor","options","attrs","preinitialize","apply","arguments","cid","collection","parse","customizer","mergeArrays","set","changed","initialize","translate","dx","dy","opt","Error","toJSON","prototype","defaultAttrs","finalAttrs","attr","selector","defaultAttr","value","name","value2","name2","idAttribute","getIdAttribute","undefined","generateId","silent","_transitionIds","_scheduledTransitionIds","processPorts","on","previousPorts","ports","get","port","id","removedPorts","graph","inboundLinks","getConnectedLinks","inbound","forEach","link","remove","outboundLinks","outbound","startBatch","parentCell","getParentCell","unembed","embeddedCells","getEmbeddedCells","i","n","length","embed","trigger","cells","stopBatch","toFront","foregroundEmbeds","deep","breadthFirst","sortSiblings","unshift","sortedCells","cell","z","maxZ","maxZIndex","shouldUpdate","indexOf","some","index","toBack","minZIndex","parent","canEmbed","c","isEmbedded","_embedCells","_unembedCells","every","isEmbeddedIn","batchName","embeds","isLink","unset","map","parentId","getCell","getAncestors","ancestors","push","_getEmbeddedCellsBfs","_getEmbeddedCellsDfs","embeddedIds","queue","current","shift","stack","pop","cellId","clone","concat","prop","props","delim","_isString","path","pathArray","split","join","slice","property","pathArrayLength","propertyPath","propertyValue","propertyPathArray","rewrite","update","initializer","prevProperty","pathItem","isArrayIndex","Number","isFinite","baseAttributes","changedAttributes","key","changedValue","removeProp","dirty","nestedPath","args","from","removeAttr","transition","duration","delay","timingFunction","linear","valueFunction","number","firstFrameTime","interpolatingFunction","setter","runtime","progress","transitionId","bind","initialId","initiator","callback","stopPendingTransitions","setTimeout","getTransitions","Object","keys","stopScheduledTransitions","transitions","filter","transitionIds","clearTimeout","stopTransitions","addTo","addCell","findView","paper","findViewByModel","isElement","getChangeFlag","flag","hasOwnProperty","hasChanged","angle","position","Point","getPointFromConnectedLink","getBBox","Rect","getPointRotatedAroundCenter","x","y","point","rotate","center","getAbsolutePointFromRelative","offset","getRelativePointFromAbsolute","difference","getAttributeDefinition","attrName","defNS","globalDefNS","define","type","protoProps","staticProps","joint","shapes"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/dia/Cell.mjs"],"sourcesContent":["import {\n    uniqueId,\n    union,\n    result,\n    merge,\n    forIn,\n    isObject,\n    isEqual,\n    isString,\n    cloneDeep,\n    omit,\n    uuid,\n    isEmpty,\n    assign,\n    uniq,\n    toArray,\n    setByPath,\n    unsetByPath,\n    getByPath,\n    timing,\n    interpolate,\n    nextFrame,\n    without,\n    cancelFrame,\n    defaultsDeep,\n    has,\n    sortBy,\n    defaults\n} from '../util/util.mjs';\nimport { Model } from '../mvc/Model.mjs';\nimport { cloneCells } from '../util/cloneCells.mjs';\nimport { attributes } from './attributes/index.mjs';\nimport * as g from '../g/index.mjs';\n\n\n// Cell base model.\n// --------------------------\n\nconst attributesMerger = function(a, b) {\n    if (Array.isArray(a)) {\n        return b;\n    }\n};\n\nexport const Cell = Model.extend({\n\n    // This is the same as mvc.Model with the only difference that is uses util.merge\n    // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.\n    constructor: function(attributes, options) {\n\n        var defaults;\n        var attrs = attributes || {};\n        if (typeof this.preinitialize === 'function') {\n            // Check to support an older version\n            this.preinitialize.apply(this, arguments);\n        }\n        this.cid = uniqueId('c');\n        this.attributes = {};\n        if (options && options.collection) this.collection = options.collection;\n        if (options && options.parse) attrs = this.parse(attrs, options) || {};\n        if ((defaults = result(this, 'defaults'))) {\n            //<custom code>\n            // Replaced the call to _.defaults with util.merge.\n            const customizer = (options && options.mergeArrays === true) ? false : attributesMerger;\n            attrs = merge({}, defaults, attrs, customizer);\n            //</custom code>\n        }\n        this.set(attrs, options);\n        this.changed = {};\n        this.initialize.apply(this, arguments);\n    },\n\n    translate: function(dx, dy, opt) {\n\n        throw new Error('Must define a translate() method.');\n    },\n\n    toJSON: function() {\n\n        const defaults = result(this.constructor.prototype, 'defaults');\n        const defaultAttrs = defaults.attrs || {};\n        const attrs = this.attributes.attrs;\n        const finalAttrs = {};\n\n        // Loop through all the attributes and\n        // omit the default attributes as they are implicitly reconstructible by the cell 'type'.\n        forIn(attrs, function(attr, selector) {\n\n            const defaultAttr = defaultAttrs[selector];\n\n            forIn(attr, function(value, name) {\n\n                // attr is mainly flat though it might have one more level (consider the `style` attribute).\n                // Check if the `value` is object and if yes, go one level deep.\n                if (isObject(value) && !Array.isArray(value)) {\n\n                    forIn(value, function(value2, name2) {\n\n                        if (!defaultAttr || !defaultAttr[name] || !isEqual(defaultAttr[name][name2], value2)) {\n\n                            finalAttrs[selector] = finalAttrs[selector] || {};\n                            (finalAttrs[selector][name] || (finalAttrs[selector][name] = {}))[name2] = value2;\n                        }\n                    });\n\n                } else if (!defaultAttr || !isEqual(defaultAttr[name], value)) {\n                    // `value` is not an object, default attribute for such a selector does not exist\n                    // or it is different than the attribute value set on the model.\n\n                    finalAttrs[selector] = finalAttrs[selector] || {};\n                    finalAttrs[selector][name] = value;\n                }\n            });\n        });\n\n        const attributes = cloneDeep(omit(this.attributes, 'attrs'));\n        attributes.attrs = finalAttrs;\n\n        return attributes;\n    },\n\n    initialize: function(options) {\n\n        const idAttribute = this.getIdAttribute();\n        if (!options || options[idAttribute] === undefined) {\n            this.set(idAttribute, this.generateId(), { silent: true });\n        }\n\n        this._transitionIds = {};\n        this._scheduledTransitionIds = {};\n\n        // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n        this.processPorts();\n        this.on('change:attrs', this.processPorts, this);\n    },\n\n    getIdAttribute: function() {\n        return this.idAttribute || 'id';\n    },\n\n    generateId: function() {\n        return uuid();\n    },\n\n    /**\n     * @deprecated\n     */\n    processPorts: function() {\n\n        // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n        // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n        // set to that port, we remove those links as well (to follow the same behaviour as\n        // with a removed element).\n\n        var previousPorts = this.ports;\n\n        // Collect ports from the `attrs` object.\n        var ports = {};\n        forIn(this.get('attrs'), function(attrs, selector) {\n\n            if (attrs && attrs.port) {\n\n                // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n                if (attrs.port.id !== undefined) {\n                    ports[attrs.port.id] = attrs.port;\n                } else {\n                    ports[attrs.port] = { id: attrs.port };\n                }\n            }\n        });\n\n        // Collect ports that have been removed (compared to the previous ports) - if any.\n        // Use hash table for quick lookup.\n        var removedPorts = {};\n        forIn(previousPorts, function(port, id) {\n\n            if (!ports[id]) removedPorts[id] = true;\n        });\n\n        // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n        if (this.graph && !isEmpty(removedPorts)) {\n\n            var inboundLinks = this.graph.getConnectedLinks(this, { inbound: true });\n            inboundLinks.forEach(function(link) {\n\n                if (removedPorts[link.get('target').port]) link.remove();\n            });\n\n            var outboundLinks = this.graph.getConnectedLinks(this, { outbound: true });\n            outboundLinks.forEach(function(link) {\n\n                if (removedPorts[link.get('source').port]) link.remove();\n            });\n        }\n\n        // Update the `ports` object.\n        this.ports = ports;\n    },\n\n    remove: function(opt = {}) {\n\n        // Store the graph in a variable because `this.graph` won't be accessible\n        // after `this.trigger('remove', ...)` down below.\n        const { graph, collection } = this;\n        if (!graph) {\n            // The collection is a common mvc collection (not the graph collection).\n            if (collection) collection.remove(this, opt);\n            return this;\n        }\n\n        graph.startBatch('remove');\n\n        // First, unembed this cell from its parent cell if there is one.\n        const parentCell = this.getParentCell();\n        if (parentCell) {\n            parentCell.unembed(this, opt);\n        }\n\n        // Remove also all the cells, which were embedded into this cell\n        const embeddedCells = this.getEmbeddedCells();\n        for (let i = 0, n = embeddedCells.length; i < n; i++) {\n            const embed = embeddedCells[i];\n            if (embed) {\n                embed.remove(opt);\n            }\n        }\n\n        this.trigger('remove', this, graph.attributes.cells, opt);\n\n        graph.stopBatch('remove');\n\n        return this;\n    },\n\n    toFront: function(opt) {\n        var graph = this.graph;\n        if (graph) {\n            opt = defaults(opt || {}, { foregroundEmbeds: true });\n\n            let cells;\n            if (opt.deep) {\n                cells = this.getEmbeddedCells({ deep: true, breadthFirst: opt.breadthFirst !== false, sortSiblings: opt.foregroundEmbeds });\n                cells.unshift(this);\n            } else {\n                cells = [this];\n            }\n\n            const sortedCells = opt.foregroundEmbeds ? cells : sortBy(cells, cell => cell.z());\n\n            const maxZ = graph.maxZIndex();\n            let z = maxZ - cells.length + 1;\n\n            const collection = graph.get('cells');\n\n            let shouldUpdate = (collection.toArray().indexOf(sortedCells[0]) !== (collection.length - cells.length));\n            if (!shouldUpdate) {\n                shouldUpdate = sortedCells.some(function(cell, index) {\n                    return cell.z() !== z + index;\n                });\n            }\n\n            if (shouldUpdate) {\n                this.startBatch('to-front');\n\n                z = z + cells.length;\n\n                sortedCells.forEach(function(cell, index) {\n                    cell.set('z', z + index, opt);\n                });\n\n                this.stopBatch('to-front');\n            }\n        }\n\n        return this;\n    },\n\n    toBack: function(opt) {\n        var graph = this.graph;\n        if (graph) {\n            opt = defaults(opt || {}, { foregroundEmbeds: true });\n\n            let cells;\n            if (opt.deep) {\n                cells = this.getEmbeddedCells({ deep: true, breadthFirst: opt.breadthFirst !== false, sortSiblings: opt.foregroundEmbeds });\n                cells.unshift(this);\n            } else {\n                cells = [this];\n            }\n\n            const sortedCells = opt.foregroundEmbeds ? cells : sortBy(cells, cell => cell.z());\n\n            let z = graph.minZIndex();\n\n            var collection = graph.get('cells');\n\n            let shouldUpdate = (collection.toArray().indexOf(sortedCells[0]) !== 0);\n            if (!shouldUpdate) {\n                shouldUpdate = sortedCells.some(function(cell, index) {\n                    return cell.z() !== z + index;\n                });\n            }\n\n            if (shouldUpdate) {\n                this.startBatch('to-back');\n\n                z -= cells.length;\n\n                sortedCells.forEach(function(cell, index) {\n                    cell.set('z', z + index, opt);\n                });\n\n                this.stopBatch('to-back');\n            }\n        }\n\n        return this;\n    },\n\n    parent: function(parent, opt) {\n\n        // getter\n        if (parent === undefined) return this.get('parent');\n        // setter\n        return this.set('parent', parent, opt);\n    },\n\n    embed: function(cell, opt) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        if (!this.canEmbed(cells)) {\n            throw new Error('Recursive embedding not allowed.');\n        }\n        if (cells.some(c => c.isEmbedded() && this.id !== c.parent())) {\n            throw new Error('Embedding of already embedded cells is not allowed.');\n        }\n        this._embedCells(cells, opt);\n        return this;\n    },\n\n    unembed: function(cell, opt) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        this._unembedCells(cells, opt);\n        return this;\n    },\n\n    canEmbed: function(cell) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        return cells.every(c => this !== c && !this.isEmbeddedIn(c));\n    },\n\n    _embedCells: function(cells, opt) {\n        const batchName = 'embed';\n        this.startBatch(batchName);\n        const embeds = assign([], this.get('embeds'));\n        cells.forEach(cell => {\n            // We keep all element ids after link ids.\n            embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);\n            cell.parent(this.id, opt);\n        });\n        this.set('embeds', uniq(embeds), opt);\n        this.stopBatch(batchName);\n    },\n\n    _unembedCells: function(cells, opt) {\n        const batchName = 'unembed';\n        this.startBatch(batchName);\n        cells.forEach(cell => cell.unset('parent', opt));\n        this.set('embeds', without(this.get('embeds'), ...cells.map(cell => cell.id)), opt);\n        this.stopBatch(batchName);\n    },\n\n    getParentCell: function() {\n\n        // unlike link.source/target, cell.parent stores id directly as a string\n        var parentId = this.parent();\n        var graph = this.graph;\n\n        return (parentId && graph && graph.getCell(parentId)) || null;\n    },\n\n    // Return an array of ancestor cells.\n    // The array is ordered from the parent of the cell\n    // to the most distant ancestor.\n    getAncestors: function() {\n\n        var ancestors = [];\n\n        if (!this.graph) {\n            return ancestors;\n        }\n\n        var parentCell = this.getParentCell();\n        while (parentCell) {\n            ancestors.push(parentCell);\n            parentCell = parentCell.getParentCell();\n        }\n\n        return ancestors;\n    },\n\n    getEmbeddedCells: function(opt) {\n\n        opt = opt || {};\n\n        // Cell models can only be retrieved when this element is part of a collection.\n        // There is no way this element knows about other cells otherwise.\n        // This also means that calling e.g. `translate()` on an element with embeds before\n        // adding it to a graph does not translate its embeds.\n        if (!this.graph) {\n            return [];\n        }\n\n        if (opt.deep) {\n            if (opt.breadthFirst) {\n                return this._getEmbeddedCellsBfs(opt.sortSiblings);\n            } else {\n                return this._getEmbeddedCellsDfs(opt.sortSiblings);\n            }\n        }\n\n        const embeddedIds = this.get('embeds');\n        if (isEmpty(embeddedIds)) {\n            return [];\n        }\n\n        let cells = embeddedIds.map(this.graph.getCell, this.graph);\n        if (opt.sortSiblings) {\n            cells = sortBy(cells, cell => cell.z());\n        }\n\n        return cells;\n    },\n\n    _getEmbeddedCellsBfs: function(sortSiblings) {\n        const cells = [];\n\n        const queue = [];\n        queue.push(this);\n\n        while (queue.length > 0) {\n            const current = queue.shift();\n            cells.push(current);\n\n            const embeddedCells = current.getEmbeddedCells({ sortSiblings: sortSiblings });\n\n            queue.push(...embeddedCells);\n        }\n        cells.shift();\n\n        return cells;\n    },\n\n    _getEmbeddedCellsDfs: function(sortSiblings) {\n        const cells = [];\n\n        const stack = [];\n        stack.push(this);\n\n        while (stack.length > 0) {\n            const current = stack.pop();\n            cells.push(current);\n\n            const embeddedCells = current.getEmbeddedCells({ sortSiblings: sortSiblings });\n\n            // When using the stack, cells that are embedded last are processed first.\n            // To maintain the original order, we need to push the cells in reverse order\n            for (let i = embeddedCells.length - 1; i >= 0; --i) {\n                stack.push(embeddedCells[i]);\n            }\n        }\n        cells.shift();\n\n        return cells;\n    },\n\n    isEmbeddedIn: function(cell, opt) {\n\n        var cellId = isString(cell) ? cell : cell.id;\n        var parentId = this.parent();\n\n        opt = assign({ deep: true }, opt);\n\n        // See getEmbeddedCells().\n        if (this.graph && opt.deep) {\n\n            while (parentId) {\n                if (parentId === cellId) {\n                    return true;\n                }\n                parentId = this.graph.getCell(parentId).parent();\n            }\n\n            return false;\n\n        } else {\n\n            // When this cell is not part of a collection check\n            // at least whether it's a direct child of given cell.\n            return parentId === cellId;\n        }\n    },\n\n    // Whether or not the cell is embedded in any other cell.\n    isEmbedded: function() {\n\n        return !!this.parent();\n    },\n\n    // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n    // Shallow cloning simply clones the cell and returns a new cell with different ID.\n    // Deep cloning clones the cell and all its embedded cells recursively.\n    clone: function(opt) {\n\n        opt = opt || {};\n\n        if (!opt.deep) {\n            // Shallow cloning.\n\n            var clone = Model.prototype.clone.apply(this, arguments);\n            // We don't want the clone to have the same ID as the original.\n            clone.set(this.getIdAttribute(), this.generateId());\n            // A shallow cloned element does not carry over the original embeds.\n            clone.unset('embeds');\n            // And can not be embedded in any cell\n            // as the clone is not part of the graph.\n            clone.unset('parent');\n\n            return clone;\n\n        } else {\n            // Deep cloning.\n\n            // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.\n            return toArray(cloneCells([this].concat(this.getEmbeddedCells({ deep: true }))));\n        }\n    },\n\n    // A convenient way to set nested properties.\n    // This method merges the properties you'd like to set with the ones\n    // stored in the cell and makes sure change events are properly triggered.\n    // You can either set a nested property with one object\n    // or use a property path.\n    // The most simple use case is:\n    // `cell.prop('name/first', 'John')` or\n    // `cell.prop({ name: { first: 'John' } })`.\n    // Nested arrays are supported too:\n    // `cell.prop('series/0/data/0/degree', 50)` or\n    // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n    prop: function(props, value, opt) {\n\n        var delim = '/';\n        var _isString = isString(props);\n\n        if (_isString || Array.isArray(props)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n\n            if (arguments.length > 1) {\n\n                var path;\n                var pathArray;\n\n                if (_isString) {\n                    path = props;\n                    pathArray = path.split('/');\n                } else {\n                    path = props.join(delim);\n                    pathArray = props.slice();\n                }\n\n                var property = pathArray[0];\n                var pathArrayLength = pathArray.length;\n\n                const options = opt || {};\n                options.propertyPath = path;\n                options.propertyValue = value;\n                options.propertyPathArray = pathArray;\n                if (!('rewrite' in options)) {\n                    options.rewrite = false;\n                }\n\n                var update = {};\n                // Initialize the nested object. Sub-objects are either arrays or objects.\n                // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n                // Note that this imposes a limitation on object keys one can use with Inspector.\n                // Pure integer keys will cause issues and are therefore not allowed.\n                var initializer = update;\n                var prevProperty = property;\n\n                for (var i = 1; i < pathArrayLength; i++) {\n                    var pathItem = pathArray[i];\n                    var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n                    initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n                    prevProperty = pathItem;\n                }\n\n                // Fill update with the `value` on `path`.\n                update = setByPath(update, pathArray, value, '/');\n\n                var baseAttributes = merge({}, this.attributes);\n                // if rewrite mode enabled, we replace value referenced by path with\n                // the new one (we don't merge).\n                options.rewrite && unsetByPath(baseAttributes, path, '/');\n\n                // Merge update with the model attributes.\n                var attributes = merge(baseAttributes, update);\n                // Finally, set the property to the updated attributes.\n                return this.set(property, attributes[property], options);\n\n            } else {\n\n                return getByPath(this.attributes, props, delim);\n            }\n        }\n\n        const options = value || {};\n        // Note: '' is not the path to the root. It's a path with an empty string i.e. { '': {}}.\n        options.propertyPath = null;\n        options.propertyValue = props;\n        options.propertyPathArray = [];\n        if (!('rewrite' in options)) {\n            options.rewrite = false;\n        }\n\n        // Create a new object containing only the changed attributes.\n        const changedAttributes = {};\n        for (const key in props) {\n            // Merging the values of changed attributes with the current ones.\n            const { changedValue } = merge({}, { changedValue: this.attributes[key] }, { changedValue: props[key] });\n            changedAttributes[key] = changedValue;\n        }\n\n        return this.set(changedAttributes, options);\n    },\n\n    // A convenient way to unset nested properties\n    removeProp: function(path, opt) {\n\n        opt = opt || {};\n\n        var pathArray = Array.isArray(path) ? path : path.split('/');\n\n        // Once a property is removed from the `attrs` attribute\n        // the cellView will recognize a `dirty` flag and re-render itself\n        // in order to remove the attribute from SVG element.\n        var property = pathArray[0];\n        if (property === 'attrs') opt.dirty = true;\n\n        if (pathArray.length === 1) {\n            // A top level property\n            return this.unset(path, opt);\n        }\n\n        // A nested property\n        var nestedPath = pathArray.slice(1);\n        var propertyValue = this.get(property);\n        if (propertyValue === undefined || propertyValue === null) return this;\n        propertyValue = cloneDeep(propertyValue);\n\n        unsetByPath(propertyValue, nestedPath, '/');\n\n        return this.set(property, propertyValue, opt);\n    },\n\n    // A convenient way to set nested attributes.\n    attr: function(attrs, value, opt) {\n\n        var args = Array.from(arguments);\n        if (args.length === 0) {\n            return this.get('attrs');\n        }\n\n        if (Array.isArray(attrs)) {\n            args[0] = ['attrs'].concat(attrs);\n        } else if (isString(attrs)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            args[0] = 'attrs/' + attrs;\n\n        } else {\n\n            args[0] = { 'attrs' : attrs };\n        }\n\n        return this.prop.apply(this, args);\n    },\n\n    // A convenient way to unset nested attributes\n    removeAttr: function(path, opt) {\n\n        if (Array.isArray(path)) {\n\n            return this.removeProp(['attrs'].concat(path));\n        }\n\n        return this.removeProp('attrs/' + path, opt);\n    },\n\n    transition: function(path, value, opt, delim) {\n\n        delim = delim || '/';\n\n        var defaults = {\n            duration: 100,\n            delay: 10,\n            timingFunction: timing.linear,\n            valueFunction: interpolate.number\n        };\n\n        opt = assign(defaults, opt);\n\n        var firstFrameTime = 0;\n        var interpolatingFunction;\n\n        var setter = function(runtime) {\n\n            var id, progress, propertyValue;\n\n            firstFrameTime = firstFrameTime || runtime;\n            runtime -= firstFrameTime;\n            progress = runtime / opt.duration;\n\n            if (progress < 1) {\n                this._transitionIds[path] = id = nextFrame(setter);\n            } else {\n                progress = 1;\n                delete this._transitionIds[path];\n            }\n\n            propertyValue = interpolatingFunction(opt.timingFunction(progress));\n\n            opt.transitionId = id;\n\n            this.prop(path, propertyValue, opt);\n\n            if (!id) this.trigger('transition:end', this, path);\n\n        }.bind(this);\n\n        const { _scheduledTransitionIds } = this;\n        let initialId;\n\n        var initiator = (callback) => {\n\n            if (_scheduledTransitionIds[path]) {\n                _scheduledTransitionIds[path] = without(_scheduledTransitionIds[path], initialId);\n                if (_scheduledTransitionIds[path].length === 0) {\n                    delete _scheduledTransitionIds[path];\n                }\n            }\n\n            this.stopPendingTransitions(path, delim);\n\n            interpolatingFunction = opt.valueFunction(getByPath(this.attributes, path, delim), value);\n\n            this._transitionIds[path] = nextFrame(callback);\n\n            this.trigger('transition:start', this, path);\n\n        };\n\n        initialId = setTimeout(initiator, opt.delay, setter);\n\n        _scheduledTransitionIds[path] || (_scheduledTransitionIds[path] = []);\n        _scheduledTransitionIds[path].push(initialId);\n\n        return initialId;\n    },\n\n    getTransitions: function() {\n        return union(\n            Object.keys(this._transitionIds),\n            Object.keys(this._scheduledTransitionIds)\n        );\n    },\n\n    stopScheduledTransitions: function(path, delim = '/') {\n        const { _scheduledTransitionIds = {}} = this;\n        let transitions = Object.keys(_scheduledTransitionIds);\n        if (path) {\n            const pathArray = path.split(delim);\n            transitions = transitions.filter((key) => {\n                return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n            });\n        }\n        transitions.forEach((key) => {\n            const transitionIds = _scheduledTransitionIds[key];\n            // stop the initiator\n            transitionIds.forEach(transitionId => clearTimeout(transitionId));\n            delete _scheduledTransitionIds[key];\n            // Note: we could trigger transition:cancel` event here\n        });\n        return this;\n    },\n\n    stopPendingTransitions(path, delim = '/') {\n        const { _transitionIds = {}} = this;\n        let transitions = Object.keys(_transitionIds);\n        if (path) {\n            const pathArray = path.split(delim);\n            transitions = transitions.filter((key) => {\n                return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n            });\n        }\n        transitions.forEach((key) => {\n            const transitionId = _transitionIds[key];\n            // stop the setter\n            cancelFrame(transitionId);\n            delete _transitionIds[key];\n            this.trigger('transition:end', this, key);\n        });\n    },\n\n    stopTransitions: function(path, delim = '/') {\n        this.stopScheduledTransitions(path, delim);\n        this.stopPendingTransitions(path, delim);\n        return this;\n    },\n\n    // A shorcut making it easy to create constructs like the following:\n    // `var el = (new joint.shapes.standard.Rectangle()).addTo(graph)`.\n    addTo: function(graph, opt) {\n\n        graph.addCell(this, opt);\n        return this;\n    },\n\n    // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n    // making it easy to create constructs like the following:\n    // `cell.findView(paper).highlight()`\n    findView: function(paper) {\n\n        return paper.findViewByModel(this);\n    },\n\n    isElement: function() {\n\n        return false;\n    },\n\n    isLink: function() {\n\n        return false;\n    },\n\n    startBatch: function(name, opt) {\n\n        if (this.graph) { this.graph.startBatch(name, assign({}, opt, { cell: this })); }\n        return this;\n    },\n\n    stopBatch: function(name, opt) {\n\n        if (this.graph) { this.graph.stopBatch(name, assign({}, opt, { cell: this })); }\n        return this;\n    },\n\n    getChangeFlag: function(attributes) {\n\n        var flag = 0;\n        if (!attributes) return flag;\n        for (var key in attributes) {\n            if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;\n            flag |= attributes[key];\n        }\n        return flag;\n    },\n\n    angle: function() {\n\n        // To be overridden.\n        return 0;\n    },\n\n    position: function() {\n\n        // To be overridden.\n        return new g.Point(0, 0);\n    },\n\n    z: function() {\n        return this.get('z') || 0;\n    },\n\n    getPointFromConnectedLink: function() {\n\n        // To be overridden\n        return new g.Point();\n    },\n\n    getBBox: function() {\n\n        // To be overridden\n        return new g.Rect(0, 0, 0, 0);\n    },\n\n    getPointRotatedAroundCenter(angle, x, y) {\n        const point = new g.Point(x, y);\n        if (angle) point.rotate(this.getBBox().center(), angle);\n        return point;\n    },\n\n    getAbsolutePointFromRelative(x, y) {\n        // Rotate the position to take the model angle into account\n        return this.getPointRotatedAroundCenter(\n            -this.angle(),\n            // Transform the relative position to absolute\n            this.position().offset(x, y)\n        );\n    },\n\n    getRelativePointFromAbsolute(x, y) {\n        return this\n            // Rotate the coordinates to mitigate the element's rotation.\n            .getPointRotatedAroundCenter(this.angle(), x, y)\n            // Transform the absolute position into relative\n            .difference(this.position());\n    }\n\n}, {\n\n    getAttributeDefinition: function(attrName) {\n\n        var defNS = this.attributes;\n        var globalDefNS = attributes;\n        return (defNS && defNS[attrName]) || globalDefNS[attrName];\n    },\n\n    define: function(type, defaults, protoProps, staticProps) {\n\n        protoProps = assign({\n            defaults: defaultsDeep({ type: type }, defaults, this.prototype.defaults)\n        }, protoProps);\n\n        var Cell = this.extend(protoProps, staticProps);\n        // es5 backward compatibility\n        /* eslint-disable no-undef */\n        if (typeof joint !== 'undefined' && has(joint, 'shapes')) {\n            setByPath(joint.shapes, type, Cell, '.');\n        }\n        /* eslint-enable no-undef */\n        return Cell;\n    }\n});\n\n"],"mappings":"AAAA,SACIA,QAAQ,EACRC,KAAK,EACLC,MAAM,EACNC,KAAK,EACLC,KAAK,EACLC,QAAQ,EACRC,OAAO,EACPC,QAAQ,EACRC,SAAS,EACTC,IAAI,EACJC,IAAI,EACJC,OAAO,EACPC,MAAM,EACNC,IAAI,EACJC,OAAO,EACPC,SAAS,EACTC,WAAW,EACXC,SAAS,EACTC,MAAM,EACNC,WAAW,EACXC,SAAS,EACTC,OAAO,EACPC,WAAW,EACXC,YAAY,EACZC,GAAG,EACHC,MAAM,EACNC,QAAQ,QACL,kBAAkB;AACzB,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,UAAU,QAAQ,wBAAwB;AACnD,SAASC,UAAU,QAAQ,wBAAwB;AACnD,OAAO,KAAKC,CAAC,MAAM,gBAAgB;;AAGnC;AACA;;AAEA,MAAMC,gBAAgB,GAAG,SAAAA,CAASC,CAAC,EAAEC,CAAC,EAAE;EACpC,IAAIC,KAAK,CAACC,OAAO,CAACH,CAAC,CAAC,EAAE;IAClB,OAAOC,CAAC;EACZ;AACJ,CAAC;AAED,OAAO,MAAMG,IAAI,GAAGT,KAAK,CAACU,MAAM,CAAC;EAE7B;EACA;EACAC,WAAW,EAAE,SAAAA,CAAST,UAAU,EAAEU,OAAO,EAAE;IAEvC,IAAIb,QAAQ;IACZ,IAAIc,KAAK,GAAGX,UAAU,IAAI,CAAC,CAAC;IAC5B,IAAI,OAAO,IAAI,CAACY,aAAa,KAAK,UAAU,EAAE;MAC1C;MACA,IAAI,CAACA,aAAa,CAACC,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IAC7C;IACA,IAAI,CAACC,GAAG,GAAG5C,QAAQ,CAAC,GAAG,CAAC;IACxB,IAAI,CAAC6B,UAAU,GAAG,CAAC,CAAC;IACpB,IAAIU,OAAO,IAAIA,OAAO,CAACM,UAAU,EAAE,IAAI,CAACA,UAAU,GAAGN,OAAO,CAACM,UAAU;IACvE,IAAIN,OAAO,IAAIA,OAAO,CAACO,KAAK,EAAEN,KAAK,GAAG,IAAI,CAACM,KAAK,CAACN,KAAK,EAAED,OAAO,CAAC,IAAI,CAAC,CAAC;IACtE,IAAKb,QAAQ,GAAGxB,MAAM,CAAC,IAAI,EAAE,UAAU,CAAC,EAAG;MACvC;MACA;MACA,MAAM6C,UAAU,GAAIR,OAAO,IAAIA,OAAO,CAACS,WAAW,KAAK,IAAI,GAAI,KAAK,GAAGjB,gBAAgB;MACvFS,KAAK,GAAGrC,KAAK,CAAC,CAAC,CAAC,EAAEuB,QAAQ,EAAEc,KAAK,EAAEO,UAAU,CAAC;MAC9C;IACJ;IACA,IAAI,CAACE,GAAG,CAACT,KAAK,EAAED,OAAO,CAAC;IACxB,IAAI,CAACW,OAAO,GAAG,CAAC,CAAC;IACjB,IAAI,CAACC,UAAU,CAACT,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;EAC1C,CAAC;EAEDS,SAAS,EAAE,SAAAA,CAASC,EAAE,EAAEC,EAAE,EAAEC,GAAG,EAAE;IAE7B,MAAM,IAAIC,KAAK,CAAC,mCAAmC,CAAC;EACxD,CAAC;EAEDC,MAAM,EAAE,SAAAA,CAAA,EAAW;IAEf,MAAM/B,QAAQ,GAAGxB,MAAM,CAAC,IAAI,CAACoC,WAAW,CAACoB,SAAS,EAAE,UAAU,CAAC;IAC/D,MAAMC,YAAY,GAAGjC,QAAQ,CAACc,KAAK,IAAI,CAAC,CAAC;IACzC,MAAMA,KAAK,GAAG,IAAI,CAACX,UAAU,CAACW,KAAK;IACnC,MAAMoB,UAAU,GAAG,CAAC,CAAC;;IAErB;IACA;IACAxD,KAAK,CAACoC,KAAK,EAAE,UAASqB,IAAI,EAAEC,QAAQ,EAAE;MAElC,MAAMC,WAAW,GAAGJ,YAAY,CAACG,QAAQ,CAAC;MAE1C1D,KAAK,CAACyD,IAAI,EAAE,UAASG,KAAK,EAAEC,IAAI,EAAE;QAE9B;QACA;QACA,IAAI5D,QAAQ,CAAC2D,KAAK,CAAC,IAAI,CAAC9B,KAAK,CAACC,OAAO,CAAC6B,KAAK,CAAC,EAAE;UAE1C5D,KAAK,CAAC4D,KAAK,EAAE,UAASE,MAAM,EAAEC,KAAK,EAAE;YAEjC,IAAI,CAACJ,WAAW,IAAI,CAACA,WAAW,CAACE,IAAI,CAAC,IAAI,CAAC3D,OAAO,CAACyD,WAAW,CAACE,IAAI,CAAC,CAACE,KAAK,CAAC,EAAED,MAAM,CAAC,EAAE;cAElFN,UAAU,CAACE,QAAQ,CAAC,GAAGF,UAAU,CAACE,QAAQ,CAAC,IAAI,CAAC,CAAC;cACjD,CAACF,UAAU,CAACE,QAAQ,CAAC,CAACG,IAAI,CAAC,KAAKL,UAAU,CAACE,QAAQ,CAAC,CAACG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAEE,KAAK,CAAC,GAAGD,MAAM;YACrF;UACJ,CAAC,CAAC;QAEN,CAAC,MAAM,IAAI,CAACH,WAAW,IAAI,CAACzD,OAAO,CAACyD,WAAW,CAACE,IAAI,CAAC,EAAED,KAAK,CAAC,EAAE;UAC3D;UACA;;UAEAJ,UAAU,CAACE,QAAQ,CAAC,GAAGF,UAAU,CAACE,QAAQ,CAAC,IAAI,CAAC,CAAC;UACjDF,UAAU,CAACE,QAAQ,CAAC,CAACG,IAAI,CAAC,GAAGD,KAAK;QACtC;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;IAEF,MAAMnC,UAAU,GAAGrB,SAAS,CAACC,IAAI,CAAC,IAAI,CAACoB,UAAU,EAAE,OAAO,CAAC,CAAC;IAC5DA,UAAU,CAACW,KAAK,GAAGoB,UAAU;IAE7B,OAAO/B,UAAU;EACrB,CAAC;EAEDsB,UAAU,EAAE,SAAAA,CAASZ,OAAO,EAAE;IAE1B,MAAM6B,WAAW,GAAG,IAAI,CAACC,cAAc,CAAC,CAAC;IACzC,IAAI,CAAC9B,OAAO,IAAIA,OAAO,CAAC6B,WAAW,CAAC,KAAKE,SAAS,EAAE;MAChD,IAAI,CAACrB,GAAG,CAACmB,WAAW,EAAE,IAAI,CAACG,UAAU,CAAC,CAAC,EAAE;QAAEC,MAAM,EAAE;MAAK,CAAC,CAAC;IAC9D;IAEA,IAAI,CAACC,cAAc,GAAG,CAAC,CAAC;IACxB,IAAI,CAACC,uBAAuB,GAAG,CAAC,CAAC;;IAEjC;IACA,IAAI,CAACC,YAAY,CAAC,CAAC;IACnB,IAAI,CAACC,EAAE,CAAC,cAAc,EAAE,IAAI,CAACD,YAAY,EAAE,IAAI,CAAC;EACpD,CAAC;EAEDN,cAAc,EAAE,SAAAA,CAAA,EAAW;IACvB,OAAO,IAAI,CAACD,WAAW,IAAI,IAAI;EACnC,CAAC;EAEDG,UAAU,EAAE,SAAAA,CAAA,EAAW;IACnB,OAAO7D,IAAI,CAAC,CAAC;EACjB,CAAC;EAED;AACJ;AACA;EACIiE,YAAY,EAAE,SAAAA,CAAA,EAAW;IAErB;IACA;IACA;IACA;;IAEA,IAAIE,aAAa,GAAG,IAAI,CAACC,KAAK;;IAE9B;IACA,IAAIA,KAAK,GAAG,CAAC,CAAC;IACd1E,KAAK,CAAC,IAAI,CAAC2E,GAAG,CAAC,OAAO,CAAC,EAAE,UAASvC,KAAK,EAAEsB,QAAQ,EAAE;MAE/C,IAAItB,KAAK,IAAIA,KAAK,CAACwC,IAAI,EAAE;QAErB;QACA,IAAIxC,KAAK,CAACwC,IAAI,CAACC,EAAE,KAAKX,SAAS,EAAE;UAC7BQ,KAAK,CAACtC,KAAK,CAACwC,IAAI,CAACC,EAAE,CAAC,GAAGzC,KAAK,CAACwC,IAAI;QACrC,CAAC,MAAM;UACHF,KAAK,CAACtC,KAAK,CAACwC,IAAI,CAAC,GAAG;YAAEC,EAAE,EAAEzC,KAAK,CAACwC;UAAK,CAAC;QAC1C;MACJ;IACJ,CAAC,CAAC;;IAEF;IACA;IACA,IAAIE,YAAY,GAAG,CAAC,CAAC;IACrB9E,KAAK,CAACyE,aAAa,EAAE,UAASG,IAAI,EAAEC,EAAE,EAAE;MAEpC,IAAI,CAACH,KAAK,CAACG,EAAE,CAAC,EAAEC,YAAY,CAACD,EAAE,CAAC,GAAG,IAAI;IAC3C,CAAC,CAAC;;IAEF;IACA,IAAI,IAAI,CAACE,KAAK,IAAI,CAACxE,OAAO,CAACuE,YAAY,CAAC,EAAE;MAEtC,IAAIE,YAAY,GAAG,IAAI,CAACD,KAAK,CAACE,iBAAiB,CAAC,IAAI,EAAE;QAAEC,OAAO,EAAE;MAAK,CAAC,CAAC;MACxEF,YAAY,CAACG,OAAO,CAAC,UAASC,IAAI,EAAE;QAEhC,IAAIN,YAAY,CAACM,IAAI,CAACT,GAAG,CAAC,QAAQ,CAAC,CAACC,IAAI,CAAC,EAAEQ,IAAI,CAACC,MAAM,CAAC,CAAC;MAC5D,CAAC,CAAC;MAEF,IAAIC,aAAa,GAAG,IAAI,CAACP,KAAK,CAACE,iBAAiB,CAAC,IAAI,EAAE;QAAEM,QAAQ,EAAE;MAAK,CAAC,CAAC;MAC1ED,aAAa,CAACH,OAAO,CAAC,UAASC,IAAI,EAAE;QAEjC,IAAIN,YAAY,CAACM,IAAI,CAACT,GAAG,CAAC,QAAQ,CAAC,CAACC,IAAI,CAAC,EAAEQ,IAAI,CAACC,MAAM,CAAC,CAAC;MAC5D,CAAC,CAAC;IACN;;IAEA;IACA,IAAI,CAACX,KAAK,GAAGA,KAAK;EACtB,CAAC;EAEDW,MAAM,EAAE,SAAAA,CAASlC,GAAG,GAAG,CAAC,CAAC,EAAE;IAEvB;IACA;IACA,MAAM;MAAE4B,KAAK;MAAEtC;IAAW,CAAC,GAAG,IAAI;IAClC,IAAI,CAACsC,KAAK,EAAE;MACR;MACA,IAAItC,UAAU,EAAEA,UAAU,CAAC4C,MAAM,CAAC,IAAI,EAAElC,GAAG,CAAC;MAC5C,OAAO,IAAI;IACf;IAEA4B,KAAK,CAACS,UAAU,CAAC,QAAQ,CAAC;;IAE1B;IACA,MAAMC,UAAU,GAAG,IAAI,CAACC,aAAa,CAAC,CAAC;IACvC,IAAID,UAAU,EAAE;MACZA,UAAU,CAACE,OAAO,CAAC,IAAI,EAAExC,GAAG,CAAC;IACjC;;IAEA;IACA,MAAMyC,aAAa,GAAG,IAAI,CAACC,gBAAgB,CAAC,CAAC;IAC7C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGH,aAAa,CAACI,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MAClD,MAAMG,KAAK,GAAGL,aAAa,CAACE,CAAC,CAAC;MAC9B,IAAIG,KAAK,EAAE;QACPA,KAAK,CAACZ,MAAM,CAAClC,GAAG,CAAC;MACrB;IACJ;IAEA,IAAI,CAAC+C,OAAO,CAAC,QAAQ,EAAE,IAAI,EAAEnB,KAAK,CAACtD,UAAU,CAAC0E,KAAK,EAAEhD,GAAG,CAAC;IAEzD4B,KAAK,CAACqB,SAAS,CAAC,QAAQ,CAAC;IAEzB,OAAO,IAAI;EACf,CAAC;EAEDC,OAAO,EAAE,SAAAA,CAASlD,GAAG,EAAE;IACnB,IAAI4B,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIA,KAAK,EAAE;MACP5B,GAAG,GAAG7B,QAAQ,CAAC6B,GAAG,IAAI,CAAC,CAAC,EAAE;QAAEmD,gBAAgB,EAAE;MAAK,CAAC,CAAC;MAErD,IAAIH,KAAK;MACT,IAAIhD,GAAG,CAACoD,IAAI,EAAE;QACVJ,KAAK,GAAG,IAAI,CAACN,gBAAgB,CAAC;UAAEU,IAAI,EAAE,IAAI;UAAEC,YAAY,EAAErD,GAAG,CAACqD,YAAY,KAAK,KAAK;UAAEC,YAAY,EAAEtD,GAAG,CAACmD;QAAiB,CAAC,CAAC;QAC3HH,KAAK,CAACO,OAAO,CAAC,IAAI,CAAC;MACvB,CAAC,MAAM;QACHP,KAAK,GAAG,CAAC,IAAI,CAAC;MAClB;MAEA,MAAMQ,WAAW,GAAGxD,GAAG,CAACmD,gBAAgB,GAAGH,KAAK,GAAG9E,MAAM,CAAC8E,KAAK,EAAES,IAAI,IAAIA,IAAI,CAACC,CAAC,CAAC,CAAC,CAAC;MAElF,MAAMC,IAAI,GAAG/B,KAAK,CAACgC,SAAS,CAAC,CAAC;MAC9B,IAAIF,CAAC,GAAGC,IAAI,GAAGX,KAAK,CAACH,MAAM,GAAG,CAAC;MAE/B,MAAMvD,UAAU,GAAGsC,KAAK,CAACJ,GAAG,CAAC,OAAO,CAAC;MAErC,IAAIqC,YAAY,GAAIvE,UAAU,CAAC/B,OAAO,CAAC,CAAC,CAACuG,OAAO,CAACN,WAAW,CAAC,CAAC,CAAC,CAAC,KAAMlE,UAAU,CAACuD,MAAM,GAAGG,KAAK,CAACH,MAAQ;MACxG,IAAI,CAACgB,YAAY,EAAE;QACfA,YAAY,GAAGL,WAAW,CAACO,IAAI,CAAC,UAASN,IAAI,EAAEO,KAAK,EAAE;UAClD,OAAOP,IAAI,CAACC,CAAC,CAAC,CAAC,KAAKA,CAAC,GAAGM,KAAK;QACjC,CAAC,CAAC;MACN;MAEA,IAAIH,YAAY,EAAE;QACd,IAAI,CAACxB,UAAU,CAAC,UAAU,CAAC;QAE3BqB,CAAC,GAAGA,CAAC,GAAGV,KAAK,CAACH,MAAM;QAEpBW,WAAW,CAACxB,OAAO,CAAC,UAASyB,IAAI,EAAEO,KAAK,EAAE;UACtCP,IAAI,CAAC/D,GAAG,CAAC,GAAG,EAAEgE,CAAC,GAAGM,KAAK,EAAEhE,GAAG,CAAC;QACjC,CAAC,CAAC;QAEF,IAAI,CAACiD,SAAS,CAAC,UAAU,CAAC;MAC9B;IACJ;IAEA,OAAO,IAAI;EACf,CAAC;EAEDgB,MAAM,EAAE,SAAAA,CAASjE,GAAG,EAAE;IAClB,IAAI4B,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIA,KAAK,EAAE;MACP5B,GAAG,GAAG7B,QAAQ,CAAC6B,GAAG,IAAI,CAAC,CAAC,EAAE;QAAEmD,gBAAgB,EAAE;MAAK,CAAC,CAAC;MAErD,IAAIH,KAAK;MACT,IAAIhD,GAAG,CAACoD,IAAI,EAAE;QACVJ,KAAK,GAAG,IAAI,CAACN,gBAAgB,CAAC;UAAEU,IAAI,EAAE,IAAI;UAAEC,YAAY,EAAErD,GAAG,CAACqD,YAAY,KAAK,KAAK;UAAEC,YAAY,EAAEtD,GAAG,CAACmD;QAAiB,CAAC,CAAC;QAC3HH,KAAK,CAACO,OAAO,CAAC,IAAI,CAAC;MACvB,CAAC,MAAM;QACHP,KAAK,GAAG,CAAC,IAAI,CAAC;MAClB;MAEA,MAAMQ,WAAW,GAAGxD,GAAG,CAACmD,gBAAgB,GAAGH,KAAK,GAAG9E,MAAM,CAAC8E,KAAK,EAAES,IAAI,IAAIA,IAAI,CAACC,CAAC,CAAC,CAAC,CAAC;MAElF,IAAIA,CAAC,GAAG9B,KAAK,CAACsC,SAAS,CAAC,CAAC;MAEzB,IAAI5E,UAAU,GAAGsC,KAAK,CAACJ,GAAG,CAAC,OAAO,CAAC;MAEnC,IAAIqC,YAAY,GAAIvE,UAAU,CAAC/B,OAAO,CAAC,CAAC,CAACuG,OAAO,CAACN,WAAW,CAAC,CAAC,CAAC,CAAC,KAAK,CAAE;MACvE,IAAI,CAACK,YAAY,EAAE;QACfA,YAAY,GAAGL,WAAW,CAACO,IAAI,CAAC,UAASN,IAAI,EAAEO,KAAK,EAAE;UAClD,OAAOP,IAAI,CAACC,CAAC,CAAC,CAAC,KAAKA,CAAC,GAAGM,KAAK;QACjC,CAAC,CAAC;MACN;MAEA,IAAIH,YAAY,EAAE;QACd,IAAI,CAACxB,UAAU,CAAC,SAAS,CAAC;QAE1BqB,CAAC,IAAIV,KAAK,CAACH,MAAM;QAEjBW,WAAW,CAACxB,OAAO,CAAC,UAASyB,IAAI,EAAEO,KAAK,EAAE;UACtCP,IAAI,CAAC/D,GAAG,CAAC,GAAG,EAAEgE,CAAC,GAAGM,KAAK,EAAEhE,GAAG,CAAC;QACjC,CAAC,CAAC;QAEF,IAAI,CAACiD,SAAS,CAAC,SAAS,CAAC;MAC7B;IACJ;IAEA,OAAO,IAAI;EACf,CAAC;EAEDkB,MAAM,EAAE,SAAAA,CAASA,MAAM,EAAEnE,GAAG,EAAE;IAE1B;IACA,IAAImE,MAAM,KAAKpD,SAAS,EAAE,OAAO,IAAI,CAACS,GAAG,CAAC,QAAQ,CAAC;IACnD;IACA,OAAO,IAAI,CAAC9B,GAAG,CAAC,QAAQ,EAAEyE,MAAM,EAAEnE,GAAG,CAAC;EAC1C,CAAC;EAED8C,KAAK,EAAE,SAAAA,CAASW,IAAI,EAAEzD,GAAG,EAAE;IACvB,MAAMgD,KAAK,GAAGrE,KAAK,CAACC,OAAO,CAAC6E,IAAI,CAAC,GAAGA,IAAI,GAAG,CAACA,IAAI,CAAC;IACjD,IAAI,CAAC,IAAI,CAACW,QAAQ,CAACpB,KAAK,CAAC,EAAE;MACvB,MAAM,IAAI/C,KAAK,CAAC,kCAAkC,CAAC;IACvD;IACA,IAAI+C,KAAK,CAACe,IAAI,CAACM,CAAC,IAAIA,CAAC,CAACC,UAAU,CAAC,CAAC,IAAI,IAAI,CAAC5C,EAAE,KAAK2C,CAAC,CAACF,MAAM,CAAC,CAAC,CAAC,EAAE;MAC3D,MAAM,IAAIlE,KAAK,CAAC,qDAAqD,CAAC;IAC1E;IACA,IAAI,CAACsE,WAAW,CAACvB,KAAK,EAAEhD,GAAG,CAAC;IAC5B,OAAO,IAAI;EACf,CAAC;EAEDwC,OAAO,EAAE,SAAAA,CAASiB,IAAI,EAAEzD,GAAG,EAAE;IACzB,MAAMgD,KAAK,GAAGrE,KAAK,CAACC,OAAO,CAAC6E,IAAI,CAAC,GAAGA,IAAI,GAAG,CAACA,IAAI,CAAC;IACjD,IAAI,CAACe,aAAa,CAACxB,KAAK,EAAEhD,GAAG,CAAC;IAC9B,OAAO,IAAI;EACf,CAAC;EAEDoE,QAAQ,EAAE,SAAAA,CAASX,IAAI,EAAE;IACrB,MAAMT,KAAK,GAAGrE,KAAK,CAACC,OAAO,CAAC6E,IAAI,CAAC,GAAGA,IAAI,GAAG,CAACA,IAAI,CAAC;IACjD,OAAOT,KAAK,CAACyB,KAAK,CAACJ,CAAC,IAAI,IAAI,KAAKA,CAAC,IAAI,CAAC,IAAI,CAACK,YAAY,CAACL,CAAC,CAAC,CAAC;EAChE,CAAC;EAEDE,WAAW,EAAE,SAAAA,CAASvB,KAAK,EAAEhD,GAAG,EAAE;IAC9B,MAAM2E,SAAS,GAAG,OAAO;IACzB,IAAI,CAACtC,UAAU,CAACsC,SAAS,CAAC;IAC1B,MAAMC,MAAM,GAAGvH,MAAM,CAAC,EAAE,EAAE,IAAI,CAACmE,GAAG,CAAC,QAAQ,CAAC,CAAC;IAC7CwB,KAAK,CAAChB,OAAO,CAACyB,IAAI,IAAI;MAClB;MACAmB,MAAM,CAACnB,IAAI,CAACoB,MAAM,CAAC,CAAC,GAAG,SAAS,GAAG,MAAM,CAAC,CAACpB,IAAI,CAAC/B,EAAE,CAAC;MACnD+B,IAAI,CAACU,MAAM,CAAC,IAAI,CAACzC,EAAE,EAAE1B,GAAG,CAAC;IAC7B,CAAC,CAAC;IACF,IAAI,CAACN,GAAG,CAAC,QAAQ,EAAEpC,IAAI,CAACsH,MAAM,CAAC,EAAE5E,GAAG,CAAC;IACrC,IAAI,CAACiD,SAAS,CAAC0B,SAAS,CAAC;EAC7B,CAAC;EAEDH,aAAa,EAAE,SAAAA,CAASxB,KAAK,EAAEhD,GAAG,EAAE;IAChC,MAAM2E,SAAS,GAAG,SAAS;IAC3B,IAAI,CAACtC,UAAU,CAACsC,SAAS,CAAC;IAC1B3B,KAAK,CAAChB,OAAO,CAACyB,IAAI,IAAIA,IAAI,CAACqB,KAAK,CAAC,QAAQ,EAAE9E,GAAG,CAAC,CAAC;IAChD,IAAI,CAACN,GAAG,CAAC,QAAQ,EAAE5B,OAAO,CAAC,IAAI,CAAC0D,GAAG,CAAC,QAAQ,CAAC,EAAE,GAAGwB,KAAK,CAAC+B,GAAG,CAACtB,IAAI,IAAIA,IAAI,CAAC/B,EAAE,CAAC,CAAC,EAAE1B,GAAG,CAAC;IACnF,IAAI,CAACiD,SAAS,CAAC0B,SAAS,CAAC;EAC7B,CAAC;EAEDpC,aAAa,EAAE,SAAAA,CAAA,EAAW;IAEtB;IACA,IAAIyC,QAAQ,GAAG,IAAI,CAACb,MAAM,CAAC,CAAC;IAC5B,IAAIvC,KAAK,GAAG,IAAI,CAACA,KAAK;IAEtB,OAAQoD,QAAQ,IAAIpD,KAAK,IAAIA,KAAK,CAACqD,OAAO,CAACD,QAAQ,CAAC,IAAK,IAAI;EACjE,CAAC;EAED;EACA;EACA;EACAE,YAAY,EAAE,SAAAA,CAAA,EAAW;IAErB,IAAIC,SAAS,GAAG,EAAE;IAElB,IAAI,CAAC,IAAI,CAACvD,KAAK,EAAE;MACb,OAAOuD,SAAS;IACpB;IAEA,IAAI7C,UAAU,GAAG,IAAI,CAACC,aAAa,CAAC,CAAC;IACrC,OAAOD,UAAU,EAAE;MACf6C,SAAS,CAACC,IAAI,CAAC9C,UAAU,CAAC;MAC1BA,UAAU,GAAGA,UAAU,CAACC,aAAa,CAAC,CAAC;IAC3C;IAEA,OAAO4C,SAAS;EACpB,CAAC;EAEDzC,gBAAgB,EAAE,SAAAA,CAAS1C,GAAG,EAAE;IAE5BA,GAAG,GAAGA,GAAG,IAAI,CAAC,CAAC;;IAEf;IACA;IACA;IACA;IACA,IAAI,CAAC,IAAI,CAAC4B,KAAK,EAAE;MACb,OAAO,EAAE;IACb;IAEA,IAAI5B,GAAG,CAACoD,IAAI,EAAE;MACV,IAAIpD,GAAG,CAACqD,YAAY,EAAE;QAClB,OAAO,IAAI,CAACgC,oBAAoB,CAACrF,GAAG,CAACsD,YAAY,CAAC;MACtD,CAAC,MAAM;QACH,OAAO,IAAI,CAACgC,oBAAoB,CAACtF,GAAG,CAACsD,YAAY,CAAC;MACtD;IACJ;IAEA,MAAMiC,WAAW,GAAG,IAAI,CAAC/D,GAAG,CAAC,QAAQ,CAAC;IACtC,IAAIpE,OAAO,CAACmI,WAAW,CAAC,EAAE;MACtB,OAAO,EAAE;IACb;IAEA,IAAIvC,KAAK,GAAGuC,WAAW,CAACR,GAAG,CAAC,IAAI,CAACnD,KAAK,CAACqD,OAAO,EAAE,IAAI,CAACrD,KAAK,CAAC;IAC3D,IAAI5B,GAAG,CAACsD,YAAY,EAAE;MAClBN,KAAK,GAAG9E,MAAM,CAAC8E,KAAK,EAAES,IAAI,IAAIA,IAAI,CAACC,CAAC,CAAC,CAAC,CAAC;IAC3C;IAEA,OAAOV,KAAK;EAChB,CAAC;EAEDqC,oBAAoB,EAAE,SAAAA,CAAS/B,YAAY,EAAE;IACzC,MAAMN,KAAK,GAAG,EAAE;IAEhB,MAAMwC,KAAK,GAAG,EAAE;IAChBA,KAAK,CAACJ,IAAI,CAAC,IAAI,CAAC;IAEhB,OAAOI,KAAK,CAAC3C,MAAM,GAAG,CAAC,EAAE;MACrB,MAAM4C,OAAO,GAAGD,KAAK,CAACE,KAAK,CAAC,CAAC;MAC7B1C,KAAK,CAACoC,IAAI,CAACK,OAAO,CAAC;MAEnB,MAAMhD,aAAa,GAAGgD,OAAO,CAAC/C,gBAAgB,CAAC;QAAEY,YAAY,EAAEA;MAAa,CAAC,CAAC;MAE9EkC,KAAK,CAACJ,IAAI,CAAC,GAAG3C,aAAa,CAAC;IAChC;IACAO,KAAK,CAAC0C,KAAK,CAAC,CAAC;IAEb,OAAO1C,KAAK;EAChB,CAAC;EAEDsC,oBAAoB,EAAE,SAAAA,CAAShC,YAAY,EAAE;IACzC,MAAMN,KAAK,GAAG,EAAE;IAEhB,MAAM2C,KAAK,GAAG,EAAE;IAChBA,KAAK,CAACP,IAAI,CAAC,IAAI,CAAC;IAEhB,OAAOO,KAAK,CAAC9C,MAAM,GAAG,CAAC,EAAE;MACrB,MAAM4C,OAAO,GAAGE,KAAK,CAACC,GAAG,CAAC,CAAC;MAC3B5C,KAAK,CAACoC,IAAI,CAACK,OAAO,CAAC;MAEnB,MAAMhD,aAAa,GAAGgD,OAAO,CAAC/C,gBAAgB,CAAC;QAAEY,YAAY,EAAEA;MAAa,CAAC,CAAC;;MAE9E;MACA;MACA,KAAK,IAAIX,CAAC,GAAGF,aAAa,CAACI,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;QAChDgD,KAAK,CAACP,IAAI,CAAC3C,aAAa,CAACE,CAAC,CAAC,CAAC;MAChC;IACJ;IACAK,KAAK,CAAC0C,KAAK,CAAC,CAAC;IAEb,OAAO1C,KAAK;EAChB,CAAC;EAED0B,YAAY,EAAE,SAAAA,CAASjB,IAAI,EAAEzD,GAAG,EAAE;IAE9B,IAAI6F,MAAM,GAAG7I,QAAQ,CAACyG,IAAI,CAAC,GAAGA,IAAI,GAAGA,IAAI,CAAC/B,EAAE;IAC5C,IAAIsD,QAAQ,GAAG,IAAI,CAACb,MAAM,CAAC,CAAC;IAE5BnE,GAAG,GAAG3C,MAAM,CAAC;MAAE+F,IAAI,EAAE;IAAK,CAAC,EAAEpD,GAAG,CAAC;;IAEjC;IACA,IAAI,IAAI,CAAC4B,KAAK,IAAI5B,GAAG,CAACoD,IAAI,EAAE;MAExB,OAAO4B,QAAQ,EAAE;QACb,IAAIA,QAAQ,KAAKa,MAAM,EAAE;UACrB,OAAO,IAAI;QACf;QACAb,QAAQ,GAAG,IAAI,CAACpD,KAAK,CAACqD,OAAO,CAACD,QAAQ,CAAC,CAACb,MAAM,CAAC,CAAC;MACpD;MAEA,OAAO,KAAK;IAEhB,CAAC,MAAM;MAEH;MACA;MACA,OAAOa,QAAQ,KAAKa,MAAM;IAC9B;EACJ,CAAC;EAED;EACAvB,UAAU,EAAE,SAAAA,CAAA,EAAW;IAEnB,OAAO,CAAC,CAAC,IAAI,CAACH,MAAM,CAAC,CAAC;EAC1B,CAAC;EAED;EACA;EACA;EACA2B,KAAK,EAAE,SAAAA,CAAS9F,GAAG,EAAE;IAEjBA,GAAG,GAAGA,GAAG,IAAI,CAAC,CAAC;IAEf,IAAI,CAACA,GAAG,CAACoD,IAAI,EAAE;MACX;;MAEA,IAAI0C,KAAK,GAAG1H,KAAK,CAAC+B,SAAS,CAAC2F,KAAK,CAAC3G,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;MACxD;MACA0G,KAAK,CAACpG,GAAG,CAAC,IAAI,CAACoB,cAAc,CAAC,CAAC,EAAE,IAAI,CAACE,UAAU,CAAC,CAAC,CAAC;MACnD;MACA8E,KAAK,CAAChB,KAAK,CAAC,QAAQ,CAAC;MACrB;MACA;MACAgB,KAAK,CAAChB,KAAK,CAAC,QAAQ,CAAC;MAErB,OAAOgB,KAAK;IAEhB,CAAC,MAAM;MACH;;MAEA;MACA,OAAOvI,OAAO,CAACc,UAAU,CAAC,CAAC,IAAI,CAAC,CAAC0H,MAAM,CAAC,IAAI,CAACrD,gBAAgB,CAAC;QAAEU,IAAI,EAAE;MAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IACpF;EACJ,CAAC;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA4C,IAAI,EAAE,SAAAA,CAASC,KAAK,EAAExF,KAAK,EAAET,GAAG,EAAE;IAE9B,IAAIkG,KAAK,GAAG,GAAG;IACf,IAAIC,SAAS,GAAGnJ,QAAQ,CAACiJ,KAAK,CAAC;IAE/B,IAAIE,SAAS,IAAIxH,KAAK,CAACC,OAAO,CAACqH,KAAK,CAAC,EAAE;MACnC;MACA;;MAEA,IAAI7G,SAAS,CAACyD,MAAM,GAAG,CAAC,EAAE;QAEtB,IAAIuD,IAAI;QACR,IAAIC,SAAS;QAEb,IAAIF,SAAS,EAAE;UACXC,IAAI,GAAGH,KAAK;UACZI,SAAS,GAAGD,IAAI,CAACE,KAAK,CAAC,GAAG,CAAC;QAC/B,CAAC,MAAM;UACHF,IAAI,GAAGH,KAAK,CAACM,IAAI,CAACL,KAAK,CAAC;UACxBG,SAAS,GAAGJ,KAAK,CAACO,KAAK,CAAC,CAAC;QAC7B;QAEA,IAAIC,QAAQ,GAAGJ,SAAS,CAAC,CAAC,CAAC;QAC3B,IAAIK,eAAe,GAAGL,SAAS,CAACxD,MAAM;QAEtC,MAAM7D,OAAO,GAAGgB,GAAG,IAAI,CAAC,CAAC;QACzBhB,OAAO,CAAC2H,YAAY,GAAGP,IAAI;QAC3BpH,OAAO,CAAC4H,aAAa,GAAGnG,KAAK;QAC7BzB,OAAO,CAAC6H,iBAAiB,GAAGR,SAAS;QACrC,IAAI,EAAE,SAAS,IAAIrH,OAAO,CAAC,EAAE;UACzBA,OAAO,CAAC8H,OAAO,GAAG,KAAK;QAC3B;QAEA,IAAIC,MAAM,GAAG,CAAC,CAAC;QACf;QACA;QACA;QACA;QACA,IAAIC,WAAW,GAAGD,MAAM;QACxB,IAAIE,YAAY,GAAGR,QAAQ;QAE3B,KAAK,IAAI9D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+D,eAAe,EAAE/D,CAAC,EAAE,EAAE;UACtC,IAAIuE,QAAQ,GAAGb,SAAS,CAAC1D,CAAC,CAAC;UAC3B,IAAIwE,YAAY,GAAGC,MAAM,CAACC,QAAQ,CAAClB,SAAS,GAAGiB,MAAM,CAACF,QAAQ,CAAC,GAAGA,QAAQ,CAAC;UAC3EF,WAAW,GAAGA,WAAW,CAACC,YAAY,CAAC,GAAGE,YAAY,GAAG,EAAE,GAAG,CAAC,CAAC;UAChEF,YAAY,GAAGC,QAAQ;QAC3B;;QAEA;QACAH,MAAM,GAAGvJ,SAAS,CAACuJ,MAAM,EAAEV,SAAS,EAAE5F,KAAK,EAAE,GAAG,CAAC;QAEjD,IAAI6G,cAAc,GAAG1K,KAAK,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC0B,UAAU,CAAC;QAC/C;QACA;QACAU,OAAO,CAAC8H,OAAO,IAAIrJ,WAAW,CAAC6J,cAAc,EAAElB,IAAI,EAAE,GAAG,CAAC;;QAEzD;QACA,IAAI9H,UAAU,GAAG1B,KAAK,CAAC0K,cAAc,EAAEP,MAAM,CAAC;QAC9C;QACA,OAAO,IAAI,CAACrH,GAAG,CAAC+G,QAAQ,EAAEnI,UAAU,CAACmI,QAAQ,CAAC,EAAEzH,OAAO,CAAC;MAE5D,CAAC,MAAM;QAEH,OAAOtB,SAAS,CAAC,IAAI,CAACY,UAAU,EAAE2H,KAAK,EAAEC,KAAK,CAAC;MACnD;IACJ;IAEA,MAAMlH,OAAO,GAAGyB,KAAK,IAAI,CAAC,CAAC;IAC3B;IACAzB,OAAO,CAAC2H,YAAY,GAAG,IAAI;IAC3B3H,OAAO,CAAC4H,aAAa,GAAGX,KAAK;IAC7BjH,OAAO,CAAC6H,iBAAiB,GAAG,EAAE;IAC9B,IAAI,EAAE,SAAS,IAAI7H,OAAO,CAAC,EAAE;MACzBA,OAAO,CAAC8H,OAAO,GAAG,KAAK;IAC3B;;IAEA;IACA,MAAMS,iBAAiB,GAAG,CAAC,CAAC;IAC5B,KAAK,MAAMC,GAAG,IAAIvB,KAAK,EAAE;MACrB;MACA,MAAM;QAAEwB;MAAa,CAAC,GAAG7K,KAAK,CAAC,CAAC,CAAC,EAAE;QAAE6K,YAAY,EAAE,IAAI,CAACnJ,UAAU,CAACkJ,GAAG;MAAE,CAAC,EAAE;QAAEC,YAAY,EAAExB,KAAK,CAACuB,GAAG;MAAE,CAAC,CAAC;MACxGD,iBAAiB,CAACC,GAAG,CAAC,GAAGC,YAAY;IACzC;IAEA,OAAO,IAAI,CAAC/H,GAAG,CAAC6H,iBAAiB,EAAEvI,OAAO,CAAC;EAC/C,CAAC;EAED;EACA0I,UAAU,EAAE,SAAAA,CAAStB,IAAI,EAAEpG,GAAG,EAAE;IAE5BA,GAAG,GAAGA,GAAG,IAAI,CAAC,CAAC;IAEf,IAAIqG,SAAS,GAAG1H,KAAK,CAACC,OAAO,CAACwH,IAAI,CAAC,GAAGA,IAAI,GAAGA,IAAI,CAACE,KAAK,CAAC,GAAG,CAAC;;IAE5D;IACA;IACA;IACA,IAAIG,QAAQ,GAAGJ,SAAS,CAAC,CAAC,CAAC;IAC3B,IAAII,QAAQ,KAAK,OAAO,EAAEzG,GAAG,CAAC2H,KAAK,GAAG,IAAI;IAE1C,IAAItB,SAAS,CAACxD,MAAM,KAAK,CAAC,EAAE;MACxB;MACA,OAAO,IAAI,CAACiC,KAAK,CAACsB,IAAI,EAAEpG,GAAG,CAAC;IAChC;;IAEA;IACA,IAAI4H,UAAU,GAAGvB,SAAS,CAACG,KAAK,CAAC,CAAC,CAAC;IACnC,IAAII,aAAa,GAAG,IAAI,CAACpF,GAAG,CAACiF,QAAQ,CAAC;IACtC,IAAIG,aAAa,KAAK7F,SAAS,IAAI6F,aAAa,KAAK,IAAI,EAAE,OAAO,IAAI;IACtEA,aAAa,GAAG3J,SAAS,CAAC2J,aAAa,CAAC;IAExCnJ,WAAW,CAACmJ,aAAa,EAAEgB,UAAU,EAAE,GAAG,CAAC;IAE3C,OAAO,IAAI,CAAClI,GAAG,CAAC+G,QAAQ,EAAEG,aAAa,EAAE5G,GAAG,CAAC;EACjD,CAAC;EAED;EACAM,IAAI,EAAE,SAAAA,CAASrB,KAAK,EAAEwB,KAAK,EAAET,GAAG,EAAE;IAE9B,IAAI6H,IAAI,GAAGlJ,KAAK,CAACmJ,IAAI,CAAC1I,SAAS,CAAC;IAChC,IAAIyI,IAAI,CAAChF,MAAM,KAAK,CAAC,EAAE;MACnB,OAAO,IAAI,CAACrB,GAAG,CAAC,OAAO,CAAC;IAC5B;IAEA,IAAI7C,KAAK,CAACC,OAAO,CAACK,KAAK,CAAC,EAAE;MACtB4I,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC9B,MAAM,CAAC9G,KAAK,CAAC;IACrC,CAAC,MAAM,IAAIjC,QAAQ,CAACiC,KAAK,CAAC,EAAE;MACxB;MACA;MACA4I,IAAI,CAAC,CAAC,CAAC,GAAG,QAAQ,GAAG5I,KAAK;IAE9B,CAAC,MAAM;MAEH4I,IAAI,CAAC,CAAC,CAAC,GAAG;QAAE,OAAO,EAAG5I;MAAM,CAAC;IACjC;IAEA,OAAO,IAAI,CAAC+G,IAAI,CAAC7G,KAAK,CAAC,IAAI,EAAE0I,IAAI,CAAC;EACtC,CAAC;EAED;EACAE,UAAU,EAAE,SAAAA,CAAS3B,IAAI,EAAEpG,GAAG,EAAE;IAE5B,IAAIrB,KAAK,CAACC,OAAO,CAACwH,IAAI,CAAC,EAAE;MAErB,OAAO,IAAI,CAACsB,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC3B,MAAM,CAACK,IAAI,CAAC,CAAC;IAClD;IAEA,OAAO,IAAI,CAACsB,UAAU,CAAC,QAAQ,GAAGtB,IAAI,EAAEpG,GAAG,CAAC;EAChD,CAAC;EAEDgI,UAAU,EAAE,SAAAA,CAAS5B,IAAI,EAAE3F,KAAK,EAAET,GAAG,EAAEkG,KAAK,EAAE;IAE1CA,KAAK,GAAGA,KAAK,IAAI,GAAG;IAEpB,IAAI/H,QAAQ,GAAG;MACX8J,QAAQ,EAAE,GAAG;MACbC,KAAK,EAAE,EAAE;MACTC,cAAc,EAAExK,MAAM,CAACyK,MAAM;MAC7BC,aAAa,EAAEzK,WAAW,CAAC0K;IAC/B,CAAC;IAEDtI,GAAG,GAAG3C,MAAM,CAACc,QAAQ,EAAE6B,GAAG,CAAC;IAE3B,IAAIuI,cAAc,GAAG,CAAC;IACtB,IAAIC,qBAAqB;IAEzB,IAAIC,MAAM,GAAG,UAASC,OAAO,EAAE;MAE3B,IAAIhH,EAAE,EAAEiH,QAAQ,EAAE/B,aAAa;MAE/B2B,cAAc,GAAGA,cAAc,IAAIG,OAAO;MAC1CA,OAAO,IAAIH,cAAc;MACzBI,QAAQ,GAAGD,OAAO,GAAG1I,GAAG,CAACiI,QAAQ;MAEjC,IAAIU,QAAQ,GAAG,CAAC,EAAE;QACd,IAAI,CAACzH,cAAc,CAACkF,IAAI,CAAC,GAAG1E,EAAE,GAAG7D,SAAS,CAAC4K,MAAM,CAAC;MACtD,CAAC,MAAM;QACHE,QAAQ,GAAG,CAAC;QACZ,OAAO,IAAI,CAACzH,cAAc,CAACkF,IAAI,CAAC;MACpC;MAEAQ,aAAa,GAAG4B,qBAAqB,CAACxI,GAAG,CAACmI,cAAc,CAACQ,QAAQ,CAAC,CAAC;MAEnE3I,GAAG,CAAC4I,YAAY,GAAGlH,EAAE;MAErB,IAAI,CAACsE,IAAI,CAACI,IAAI,EAAEQ,aAAa,EAAE5G,GAAG,CAAC;MAEnC,IAAI,CAAC0B,EAAE,EAAE,IAAI,CAACqB,OAAO,CAAC,gBAAgB,EAAE,IAAI,EAAEqD,IAAI,CAAC;IAEvD,CAAC,CAACyC,IAAI,CAAC,IAAI,CAAC;IAEZ,MAAM;MAAE1H;IAAwB,CAAC,GAAG,IAAI;IACxC,IAAI2H,SAAS;IAEb,IAAIC,SAAS,GAAIC,QAAQ,IAAK;MAE1B,IAAI7H,uBAAuB,CAACiF,IAAI,CAAC,EAAE;QAC/BjF,uBAAuB,CAACiF,IAAI,CAAC,GAAGtI,OAAO,CAACqD,uBAAuB,CAACiF,IAAI,CAAC,EAAE0C,SAAS,CAAC;QACjF,IAAI3H,uBAAuB,CAACiF,IAAI,CAAC,CAACvD,MAAM,KAAK,CAAC,EAAE;UAC5C,OAAO1B,uBAAuB,CAACiF,IAAI,CAAC;QACxC;MACJ;MAEA,IAAI,CAAC6C,sBAAsB,CAAC7C,IAAI,EAAEF,KAAK,CAAC;MAExCsC,qBAAqB,GAAGxI,GAAG,CAACqI,aAAa,CAAC3K,SAAS,CAAC,IAAI,CAACY,UAAU,EAAE8H,IAAI,EAAEF,KAAK,CAAC,EAAEzF,KAAK,CAAC;MAEzF,IAAI,CAACS,cAAc,CAACkF,IAAI,CAAC,GAAGvI,SAAS,CAACmL,QAAQ,CAAC;MAE/C,IAAI,CAACjG,OAAO,CAAC,kBAAkB,EAAE,IAAI,EAAEqD,IAAI,CAAC;IAEhD,CAAC;IAED0C,SAAS,GAAGI,UAAU,CAACH,SAAS,EAAE/I,GAAG,CAACkI,KAAK,EAAEO,MAAM,CAAC;IAEpDtH,uBAAuB,CAACiF,IAAI,CAAC,KAAKjF,uBAAuB,CAACiF,IAAI,CAAC,GAAG,EAAE,CAAC;IACrEjF,uBAAuB,CAACiF,IAAI,CAAC,CAAChB,IAAI,CAAC0D,SAAS,CAAC;IAE7C,OAAOA,SAAS;EACpB,CAAC;EAEDK,cAAc,EAAE,SAAAA,CAAA,EAAW;IACvB,OAAOzM,KAAK,CACR0M,MAAM,CAACC,IAAI,CAAC,IAAI,CAACnI,cAAc,CAAC,EAChCkI,MAAM,CAACC,IAAI,CAAC,IAAI,CAAClI,uBAAuB,CAC5C,CAAC;EACL,CAAC;EAEDmI,wBAAwB,EAAE,SAAAA,CAASlD,IAAI,EAAEF,KAAK,GAAG,GAAG,EAAE;IAClD,MAAM;MAAE/E,uBAAuB,GAAG,CAAC;IAAC,CAAC,GAAG,IAAI;IAC5C,IAAIoI,WAAW,GAAGH,MAAM,CAACC,IAAI,CAAClI,uBAAuB,CAAC;IACtD,IAAIiF,IAAI,EAAE;MACN,MAAMC,SAAS,GAAGD,IAAI,CAACE,KAAK,CAACJ,KAAK,CAAC;MACnCqD,WAAW,GAAGA,WAAW,CAACC,MAAM,CAAEhC,GAAG,IAAK;QACtC,OAAOzK,OAAO,CAACsJ,SAAS,EAAEmB,GAAG,CAAClB,KAAK,CAACJ,KAAK,CAAC,CAACM,KAAK,CAAC,CAAC,EAAEH,SAAS,CAACxD,MAAM,CAAC,CAAC;MAC1E,CAAC,CAAC;IACN;IACA0G,WAAW,CAACvH,OAAO,CAAEwF,GAAG,IAAK;MACzB,MAAMiC,aAAa,GAAGtI,uBAAuB,CAACqG,GAAG,CAAC;MAClD;MACAiC,aAAa,CAACzH,OAAO,CAAC4G,YAAY,IAAIc,YAAY,CAACd,YAAY,CAAC,CAAC;MACjE,OAAOzH,uBAAuB,CAACqG,GAAG,CAAC;MACnC;IACJ,CAAC,CAAC;IACF,OAAO,IAAI;EACf,CAAC;EAEDyB,sBAAsBA,CAAC7C,IAAI,EAAEF,KAAK,GAAG,GAAG,EAAE;IACtC,MAAM;MAAEhF,cAAc,GAAG,CAAC;IAAC,CAAC,GAAG,IAAI;IACnC,IAAIqI,WAAW,GAAGH,MAAM,CAACC,IAAI,CAACnI,cAAc,CAAC;IAC7C,IAAIkF,IAAI,EAAE;MACN,MAAMC,SAAS,GAAGD,IAAI,CAACE,KAAK,CAACJ,KAAK,CAAC;MACnCqD,WAAW,GAAGA,WAAW,CAACC,MAAM,CAAEhC,GAAG,IAAK;QACtC,OAAOzK,OAAO,CAACsJ,SAAS,EAAEmB,GAAG,CAAClB,KAAK,CAACJ,KAAK,CAAC,CAACM,KAAK,CAAC,CAAC,EAAEH,SAAS,CAACxD,MAAM,CAAC,CAAC;MAC1E,CAAC,CAAC;IACN;IACA0G,WAAW,CAACvH,OAAO,CAAEwF,GAAG,IAAK;MACzB,MAAMoB,YAAY,GAAG1H,cAAc,CAACsG,GAAG,CAAC;MACxC;MACAzJ,WAAW,CAAC6K,YAAY,CAAC;MACzB,OAAO1H,cAAc,CAACsG,GAAG,CAAC;MAC1B,IAAI,CAACzE,OAAO,CAAC,gBAAgB,EAAE,IAAI,EAAEyE,GAAG,CAAC;IAC7C,CAAC,CAAC;EACN,CAAC;EAEDmC,eAAe,EAAE,SAAAA,CAASvD,IAAI,EAAEF,KAAK,GAAG,GAAG,EAAE;IACzC,IAAI,CAACoD,wBAAwB,CAAClD,IAAI,EAAEF,KAAK,CAAC;IAC1C,IAAI,CAAC+C,sBAAsB,CAAC7C,IAAI,EAAEF,KAAK,CAAC;IACxC,OAAO,IAAI;EACf,CAAC;EAED;EACA;EACA0D,KAAK,EAAE,SAAAA,CAAShI,KAAK,EAAE5B,GAAG,EAAE;IAExB4B,KAAK,CAACiI,OAAO,CAAC,IAAI,EAAE7J,GAAG,CAAC;IACxB,OAAO,IAAI;EACf,CAAC;EAED;EACA;EACA;EACA8J,QAAQ,EAAE,SAAAA,CAASC,KAAK,EAAE;IAEtB,OAAOA,KAAK,CAACC,eAAe,CAAC,IAAI,CAAC;EACtC,CAAC;EAEDC,SAAS,EAAE,SAAAA,CAAA,EAAW;IAElB,OAAO,KAAK;EAChB,CAAC;EAEDpF,MAAM,EAAE,SAAAA,CAAA,EAAW;IAEf,OAAO,KAAK;EAChB,CAAC;EAEDxC,UAAU,EAAE,SAAAA,CAAS3B,IAAI,EAAEV,GAAG,EAAE;IAE5B,IAAI,IAAI,CAAC4B,KAAK,EAAE;MAAE,IAAI,CAACA,KAAK,CAACS,UAAU,CAAC3B,IAAI,EAAErD,MAAM,CAAC,CAAC,CAAC,EAAE2C,GAAG,EAAE;QAAEyD,IAAI,EAAE;MAAK,CAAC,CAAC,CAAC;IAAE;IAChF,OAAO,IAAI;EACf,CAAC;EAEDR,SAAS,EAAE,SAAAA,CAASvC,IAAI,EAAEV,GAAG,EAAE;IAE3B,IAAI,IAAI,CAAC4B,KAAK,EAAE;MAAE,IAAI,CAACA,KAAK,CAACqB,SAAS,CAACvC,IAAI,EAAErD,MAAM,CAAC,CAAC,CAAC,EAAE2C,GAAG,EAAE;QAAEyD,IAAI,EAAE;MAAK,CAAC,CAAC,CAAC;IAAE;IAC/E,OAAO,IAAI;EACf,CAAC;EAEDyG,aAAa,EAAE,SAAAA,CAAS5L,UAAU,EAAE;IAEhC,IAAI6L,IAAI,GAAG,CAAC;IACZ,IAAI,CAAC7L,UAAU,EAAE,OAAO6L,IAAI;IAC5B,KAAK,IAAI3C,GAAG,IAAIlJ,UAAU,EAAE;MACxB,IAAI,CAACA,UAAU,CAAC8L,cAAc,CAAC5C,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC6C,UAAU,CAAC7C,GAAG,CAAC,EAAE;MAC9D2C,IAAI,IAAI7L,UAAU,CAACkJ,GAAG,CAAC;IAC3B;IACA,OAAO2C,IAAI;EACf,CAAC;EAEDG,KAAK,EAAE,SAAAA,CAAA,EAAW;IAEd;IACA,OAAO,CAAC;EACZ,CAAC;EAEDC,QAAQ,EAAE,SAAAA,CAAA,EAAW;IAEjB;IACA,OAAO,IAAIhM,CAAC,CAACiM,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;EAC5B,CAAC;EAED9G,CAAC,EAAE,SAAAA,CAAA,EAAW;IACV,OAAO,IAAI,CAAClC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC;EAC7B,CAAC;EAEDiJ,yBAAyB,EAAE,SAAAA,CAAA,EAAW;IAElC;IACA,OAAO,IAAIlM,CAAC,CAACiM,KAAK,CAAC,CAAC;EACxB,CAAC;EAEDE,OAAO,EAAE,SAAAA,CAAA,EAAW;IAEhB;IACA,OAAO,IAAInM,CAAC,CAACoM,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACjC,CAAC;EAEDC,2BAA2BA,CAACN,KAAK,EAAEO,CAAC,EAAEC,CAAC,EAAE;IACrC,MAAMC,KAAK,GAAG,IAAIxM,CAAC,CAACiM,KAAK,CAACK,CAAC,EAAEC,CAAC,CAAC;IAC/B,IAAIR,KAAK,EAAES,KAAK,CAACC,MAAM,CAAC,IAAI,CAACN,OAAO,CAAC,CAAC,CAACO,MAAM,CAAC,CAAC,EAAEX,KAAK,CAAC;IACvD,OAAOS,KAAK;EAChB,CAAC;EAEDG,4BAA4BA,CAACL,CAAC,EAAEC,CAAC,EAAE;IAC/B;IACA,OAAO,IAAI,CAACF,2BAA2B,CACnC,CAAC,IAAI,CAACN,KAAK,CAAC,CAAC;IACb;IACA,IAAI,CAACC,QAAQ,CAAC,CAAC,CAACY,MAAM,CAACN,CAAC,EAAEC,CAAC,CAC/B,CAAC;EACL,CAAC;EAEDM,4BAA4BA,CAACP,CAAC,EAAEC,CAAC,EAAE;IAC/B,OAAO;IACH;IAAA,CACCF,2BAA2B,CAAC,IAAI,CAACN,KAAK,CAAC,CAAC,EAAEO,CAAC,EAAEC,CAAC;IAC/C;IAAA,CACCO,UAAU,CAAC,IAAI,CAACd,QAAQ,CAAC,CAAC,CAAC;EACpC;AAEJ,CAAC,EAAE;EAECe,sBAAsB,EAAE,SAAAA,CAASC,QAAQ,EAAE;IAEvC,IAAIC,KAAK,GAAG,IAAI,CAAClN,UAAU;IAC3B,IAAImN,WAAW,GAAGnN,UAAU;IAC5B,OAAQkN,KAAK,IAAIA,KAAK,CAACD,QAAQ,CAAC,IAAKE,WAAW,CAACF,QAAQ,CAAC;EAC9D,CAAC;EAEDG,MAAM,EAAE,SAAAA,CAASC,IAAI,EAAExN,QAAQ,EAAEyN,UAAU,EAAEC,WAAW,EAAE;IAEtDD,UAAU,GAAGvO,MAAM,CAAC;MAChBc,QAAQ,EAAEH,YAAY,CAAC;QAAE2N,IAAI,EAAEA;MAAK,CAAC,EAAExN,QAAQ,EAAE,IAAI,CAACgC,SAAS,CAAChC,QAAQ;IAC5E,CAAC,EAAEyN,UAAU,CAAC;IAEd,IAAI/M,IAAI,GAAG,IAAI,CAACC,MAAM,CAAC8M,UAAU,EAAEC,WAAW,CAAC;IAC/C;IACA;IACA,IAAI,OAAOC,KAAK,KAAK,WAAW,IAAI7N,GAAG,CAAC6N,KAAK,EAAE,QAAQ,CAAC,EAAE;MACtDtO,SAAS,CAACsO,KAAK,CAACC,MAAM,EAAEJ,IAAI,EAAE9M,IAAI,EAAE,GAAG,CAAC;IAC5C;IACA;IACA,OAAOA,IAAI;EACf;AACJ,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}