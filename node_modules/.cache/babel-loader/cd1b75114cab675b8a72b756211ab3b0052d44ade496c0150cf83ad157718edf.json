{"ast":null,"code":"import * as g from '../g/index.mjs';\nconst Directions = {\n  AUTO: 'auto',\n  LEFT: 'left',\n  RIGHT: 'right',\n  TOP: 'top',\n  BOTTOM: 'bottom',\n  ANCHOR_SIDE: 'anchor-side',\n  MAGNET_SIDE: 'magnet-side'\n};\nconst DEFINED_DIRECTIONS = [Directions.LEFT, Directions.RIGHT, Directions.TOP, Directions.BOTTOM];\nconst OPPOSITE_DIRECTIONS = {\n  [Directions.LEFT]: Directions.RIGHT,\n  [Directions.RIGHT]: Directions.LEFT,\n  [Directions.TOP]: Directions.BOTTOM,\n  [Directions.BOTTOM]: Directions.TOP\n};\nconst VERTICAL_DIRECTIONS = [Directions.TOP, Directions.BOTTOM];\nconst ANGLE_DIRECTION_MAP = {\n  0: Directions.RIGHT,\n  180: Directions.LEFT,\n  270: Directions.TOP,\n  90: Directions.BOTTOM\n};\nfunction getSegmentAngle(line) {\n  // TODO: the angle() method is general and therefore unnecessarily heavy for orthogonal links\n  return line.angle();\n}\nfunction simplifyPoints(points) {\n  // TODO: use own more efficient implementation (filter points that do not change direction).\n  // To simplify segments that are almost aligned (start and end points differ by e.g. 0.5px), use a threshold of 1.\n  return new g.Polyline(points).simplify({\n    threshold: 1\n  }).points;\n}\nfunction resolveSides(source, target) {\n  const {\n    point: sourcePoint,\n    x0: sx0,\n    y0: sy0,\n    view: sourceView,\n    bbox: sourceBBox,\n    direction: sourceDirection\n  } = source;\n  const {\n    point: targetPoint,\n    x0: tx0,\n    y0: ty0,\n    view: targetView,\n    bbox: targetBBox,\n    direction: targetDirection\n  } = target;\n  let sourceSide;\n  if (!sourceView) {\n    const sourceLinkAnchorBBox = new g.Rect(sx0, sy0, 0, 0);\n    sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);\n  } else if (sourceView.model.isLink()) {\n    sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);\n  } else if (sourceDirection === Directions.ANCHOR_SIDE) {\n    sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);\n  } else if (sourceDirection === Directions.MAGNET_SIDE) {\n    sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);\n  } else {\n    sourceSide = sourceDirection;\n  }\n  let targetSide;\n  if (!targetView) {\n    const targetLinkAnchorBBox = new g.Rect(tx0, ty0, 0, 0);\n    targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);\n  } else if (targetView.model.isLink()) {\n    targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);\n  } else if (targetDirection === Directions.ANCHOR_SIDE) {\n    targetSide = targetBBox.sideNearestToPoint(targetPoint);\n  } else if (targetDirection === Directions.MAGNET_SIDE) {\n    targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);\n  } else {\n    targetSide = targetDirection;\n  }\n  return [sourceSide, targetSide];\n}\nfunction resolveForTopSourceSide(source, target, nextInLine) {\n  const {\n    x0: sx0,\n    y0: sy0,\n    width,\n    height,\n    point: anchor,\n    margin\n  } = source;\n  const sx1 = sx0 + width;\n  const sy1 = sy0 + height;\n  const smx0 = sx0 - margin;\n  const smx1 = sx1 + margin;\n  const smy0 = sy0 - margin;\n  const {\n    x: ax\n  } = anchor;\n  const {\n    x0: tx,\n    y0: ty\n  } = target;\n  if (tx === ax && ty < sy0) return Directions.BOTTOM;\n  if (tx < ax && ty < smy0) return Directions.RIGHT;\n  if (tx > ax && ty < smy0) return Directions.LEFT;\n  if (tx < smx0 && ty >= sy0) return Directions.TOP;\n  if (tx > smx1 && ty >= sy0) return Directions.TOP;\n  if (tx >= smx0 && tx <= ax && ty > sy1) {\n    if (nextInLine.point.x < tx) {\n      return Directions.RIGHT;\n    }\n    return Directions.LEFT;\n  }\n  if (tx <= smx1 && tx >= ax && ty > sy1) {\n    if (nextInLine.point.x < tx) {\n      return Directions.RIGHT;\n    }\n    return Directions.LEFT;\n  }\n  return Directions.TOP;\n}\nfunction resolveForBottomSourceSide(source, target, nextInLine) {\n  const {\n    x0: sx0,\n    y0: sy0,\n    width,\n    height,\n    point: anchor,\n    margin\n  } = source;\n  const sx1 = sx0 + width;\n  const sy1 = sy0 + height;\n  const smx0 = sx0 - margin;\n  const smx1 = sx1 + margin;\n  const smy1 = sy1 + margin;\n  const {\n    x: ax\n  } = anchor;\n  const {\n    x0: tx,\n    y0: ty\n  } = target;\n  if (tx === ax && ty > sy1) return Directions.TOP;\n  if (tx < ax && ty > smy1) return Directions.RIGHT;\n  if (tx > ax && ty > smy1) return Directions.LEFT;\n  if (tx < smx0 && ty <= sy1) return Directions.BOTTOM;\n  if (tx > smx1 && ty <= sy1) return Directions.BOTTOM;\n  if (tx >= smx0 && tx <= ax && ty < sy0) {\n    if (nextInLine.point.x < tx) {\n      return Directions.RIGHT;\n    }\n    return Directions.LEFT;\n  }\n  if (tx <= smx1 && tx >= ax && ty < sy0) {\n    if (nextInLine.point.x < tx) {\n      return Directions.RIGHT;\n    }\n    return Directions.LEFT;\n  }\n  return Directions.BOTTOM;\n}\nfunction resolveForLeftSourceSide(source, target, nextInLine) {\n  const {\n    y0: sy0,\n    x0: sx0,\n    width,\n    height,\n    point: anchor,\n    margin\n  } = source;\n  const sx1 = sx0 + width;\n  const sy1 = sy0 + height;\n  const smx0 = sx0 - margin;\n  const smy0 = sy0 - margin;\n  const smy1 = sy1 + margin;\n  const {\n    x: ax,\n    y: ay\n  } = anchor;\n  const {\n    x0: tx,\n    y0: ty\n  } = target;\n  if (tx < ax && ty === ay) return Directions.RIGHT;\n  if (tx <= smx0 && ty < ay) return Directions.BOTTOM;\n  if (tx <= smx0 && ty > ay) return Directions.TOP;\n  if (tx >= sx0 && ty <= smy0) return Directions.LEFT;\n  if (tx >= sx0 && ty >= smy1) return Directions.LEFT;\n  if (tx > sx1 && ty >= smy0 && ty <= ay) {\n    if (nextInLine.point.y < ty) {\n      return Directions.BOTTOM;\n    }\n    return Directions.TOP;\n  }\n  if (tx > sx1 && ty <= smy1 && ty >= ay) {\n    if (nextInLine.point.y < ty) {\n      return Directions.BOTTOM;\n    }\n    return Directions.TOP;\n  }\n  return Directions.LEFT;\n}\nfunction resolveForRightSourceSide(source, target, nextInLine) {\n  const {\n    y0: sy0,\n    x0: sx0,\n    width,\n    height,\n    point: anchor,\n    margin\n  } = source;\n  const sx1 = sx0 + width;\n  const sy1 = sy0 + height;\n  const smx1 = sx1 + margin;\n  const smy0 = sy0 - margin;\n  const smy1 = sy1 + margin;\n  const {\n    x: ax,\n    y: ay\n  } = anchor;\n  const {\n    x0: tx,\n    y0: ty\n  } = target;\n  if (tx > ax && ty === ay) return Directions.LEFT;\n  if (tx >= smx1 && ty < ay) return Directions.BOTTOM;\n  if (tx >= smx1 && ty > ay) return Directions.TOP;\n  if (tx <= sx1 && ty <= smy0) return Directions.RIGHT;\n  if (tx <= sx1 && ty >= smy1) return Directions.RIGHT;\n  if (tx < sx0 && ty >= smy0 && ty <= ay) {\n    if (nextInLine.point.y < ty) {\n      return Directions.BOTTOM;\n    }\n    return Directions.TOP;\n  }\n  if (tx < sx0 && ty <= smy1 && ty >= ay) {\n    if (nextInLine.point.y < ty) {\n      return Directions.BOTTOM;\n    }\n    return Directions.TOP;\n  }\n  return Directions.RIGHT;\n}\nfunction resolveInitialDirection(source, target, nextInLine) {\n  const [sourceSide] = resolveSides(source, target);\n  switch (sourceSide) {\n    case Directions.TOP:\n      return resolveForTopSourceSide(source, target, nextInLine);\n    case Directions.RIGHT:\n      return resolveForRightSourceSide(source, target, nextInLine);\n    case Directions.BOTTOM:\n      return resolveForBottomSourceSide(source, target, nextInLine);\n    case Directions.LEFT:\n      return resolveForLeftSourceSide(source, target, nextInLine);\n  }\n}\nfunction getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {\n  const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));\n  const roundedAngle = Math.round(getSegmentAngle(tangent) / 90) * 90;\n  if (roundedAngle % 180 === 0 && linkOrigin.y === connectionPoint.y) {\n    return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n  } else if (linkOrigin.x === connectionPoint.x) {\n    return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n  }\n  switch (roundedAngle) {\n    case 0:\n    case 180:\n    case 360:\n      return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n    case 90:\n    case 270:\n      return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n  }\n}\nfunction pointDataFromAnchor(view, point, bbox, direction, isPort, fallBackAnchor, margin) {\n  if (direction === Directions.AUTO) {\n    direction = isPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n  }\n  const isElement = view && view.model.isElement();\n  const {\n    x: x0,\n    y: y0,\n    width = 0,\n    height = 0\n  } = isElement ? g.Rect.fromRectUnion(bbox, view.model.getBBox()) : fallBackAnchor;\n  return {\n    point,\n    x0,\n    y0,\n    view,\n    bbox,\n    width,\n    height,\n    direction,\n    margin: isElement ? margin : 0\n  };\n}\nfunction pointDataFromVertex({\n  x,\n  y\n}) {\n  const point = new g.Point(x, y);\n  return {\n    point,\n    x0: point.x,\n    y0: point.y,\n    view: null,\n    bbox: new g.Rect(x, y, 0, 0),\n    width: 0,\n    height: 0,\n    direction: null,\n    margin: 0\n  };\n}\nfunction getOutsidePoint(side, pointData, margin) {\n  const outsidePoint = pointData.point.clone();\n  const {\n    x0,\n    y0,\n    width,\n    height\n  } = pointData;\n  switch (side) {\n    case 'left':\n      outsidePoint.x = x0 - margin;\n      break;\n    case 'right':\n      outsidePoint.x = x0 + width + margin;\n      break;\n    case 'top':\n      outsidePoint.y = y0 - margin;\n      break;\n    case 'bottom':\n      outsidePoint.y = y0 + height + margin;\n      break;\n  }\n  return outsidePoint;\n}\nfunction routeBetweenPoints(source, target) {\n  const {\n    point: sourcePoint,\n    x0: sx0,\n    y0: sy0,\n    view: sourceView,\n    width: sourceWidth,\n    height: sourceHeight,\n    margin: sourceMargin\n  } = source;\n  const {\n    point: targetPoint,\n    x0: tx0,\n    y0: ty0,\n    width: targetWidth,\n    height: targetHeight,\n    margin: targetMargin\n  } = target;\n  const tx1 = tx0 + targetWidth;\n  const ty1 = ty0 + targetHeight;\n  const sx1 = sx0 + sourceWidth;\n  const sy1 = sy0 + sourceHeight;\n  const isSourceEl = sourceView && sourceView.model.isElement();\n\n  // Key coordinates including the margin\n  const smx0 = sx0 - sourceMargin;\n  const smx1 = sx1 + sourceMargin;\n  const smy0 = sy0 - sourceMargin;\n  const smy1 = sy1 + sourceMargin;\n  const tmx0 = tx0 - targetMargin;\n  const tmx1 = tx1 + targetMargin;\n  const tmy0 = ty0 - targetMargin;\n  const tmy1 = ty1 + targetMargin;\n  const [sourceSide, targetSide] = resolveSides(source, target);\n  const sourceOutsidePoint = getOutsidePoint(sourceSide, {\n    point: sourcePoint,\n    x0: sx0,\n    y0: sy0,\n    width: sourceWidth,\n    height: sourceHeight\n  }, sourceMargin);\n  const targetOutsidePoint = getOutsidePoint(targetSide, {\n    point: targetPoint,\n    x0: tx0,\n    y0: ty0,\n    width: targetWidth,\n    height: targetHeight\n  }, targetMargin);\n  const {\n    x: sox,\n    y: soy\n  } = sourceOutsidePoint;\n  const {\n    x: tox,\n    y: toy\n  } = targetOutsidePoint;\n  const tcx = (tx0 + tx1) / 2;\n  const tcy = (ty0 + ty1) / 2;\n  const scx = (sx0 + sx1) / 2;\n  const scy = (sy0 + sy1) / 2;\n  const middleOfVerticalSides = (scx < tcx ? sx1 + tx0 : tx1 + sx0) / 2;\n  const middleOfHorizontalSides = (scy < tcy ? sy1 + ty0 : ty1 + sy0) / 2;\n  if (sourceSide === 'left' && targetSide === 'right') {\n    if (smx0 <= tmx1) {\n      let y = middleOfHorizontalSides;\n      if (sx1 <= tx0) {\n        if (ty1 >= smy0 && toy < soy) {\n          y = Math.min(tmy0, smy0);\n        } else if (ty0 <= smy1 && toy >= soy) {\n          y = Math.max(tmy1, smy1);\n        }\n      }\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y\n      }, {\n        x: tox,\n        y\n      }, {\n        x: tox,\n        y: toy\n      }];\n    }\n    const x = (sox + tox) / 2;\n    return [{\n      x,\n      y: soy\n    }, {\n      x,\n      y: toy\n    }];\n  } else if (sourceSide === 'right' && targetSide === 'left') {\n    if (smx1 >= tmx0) {\n      let y = middleOfHorizontalSides;\n      if (sox > tx1) {\n        if (ty1 >= smy0 && toy < soy) {\n          y = Math.min(tmy0, smy0);\n        } else if (ty0 <= smy1 && toy >= soy) {\n          y = Math.max(tmy1, smy1);\n        }\n      }\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y\n      }, {\n        x: tox,\n        y\n      }, {\n        x: tox,\n        y: toy\n      }];\n    }\n    const x = (sox + tox) / 2;\n    return [{\n      x,\n      y: soy\n    }, {\n      x,\n      y: toy\n    }];\n  } else if (sourceSide === 'top' && targetSide === 'bottom') {\n    if (soy < toy) {\n      let x = middleOfVerticalSides;\n      let y = soy;\n      if (soy < ty0) {\n        if (tx1 >= smx0 && tox < sox) {\n          x = Math.min(tmx0, smx0);\n        } else if (tx0 <= smx1 && tox >= sox) {\n          x = Math.max(tmx1, smx1);\n        }\n      }\n      return [{\n        x: sox,\n        y\n      }, {\n        x,\n        y\n      }, {\n        x,\n        y: toy\n      }, {\n        x: tox,\n        y: toy\n      }];\n    }\n    const y = (soy + toy) / 2;\n    return [{\n      x: sox,\n      y\n    }, {\n      x: tox,\n      y\n    }];\n  } else if (sourceSide === 'bottom' && targetSide === 'top') {\n    if (soy - sourceMargin > toy) {\n      let x = middleOfVerticalSides;\n      let y = soy;\n      if (soy > ty1) {\n        if (tx1 >= smx0 && tox < sox) {\n          x = Math.min(tmx0, smx0);\n        } else if (tx0 <= smx1 && tox >= sox) {\n          x = Math.max(tmx1, smx1);\n        }\n      }\n      return [{\n        x: sox,\n        y\n      }, {\n        x,\n        y\n      }, {\n        x,\n        y: toy\n      }, {\n        x: tox,\n        y: toy\n      }];\n    }\n    const y = (soy + toy) / 2;\n    return [{\n      x: sox,\n      y\n    }, {\n      x: tox,\n      y\n    }];\n  } else if (sourceSide === 'top' && targetSide === 'top') {\n    let x;\n    let y1 = Math.min((sy1 + ty0) / 2, toy);\n    let y2 = Math.min((sy0 + ty1) / 2, soy);\n    if (toy < soy) {\n      if (sox >= tmx1 || sox <= tmx0) {\n        return [{\n          x: sox,\n          y: Math.min(soy, toy)\n        }, {\n          x: tox,\n          y: Math.min(soy, toy)\n        }];\n      } else if (tox > sox) {\n        x = Math.min(sox, tmx0);\n      } else {\n        x = Math.max(sox, tmx1);\n      }\n    } else {\n      if (tox >= smx1 || tox <= smx0) {\n        return [{\n          x: sox,\n          y: Math.min(soy, toy)\n        }, {\n          x: tox,\n          y: Math.min(soy, toy)\n        }];\n      } else if (tox >= sox) {\n        x = Math.max(tox, smx1);\n      } else {\n        x = Math.min(tox, smx0);\n      }\n    }\n    return [{\n      x: sox,\n      y: y2\n    }, {\n      x,\n      y: y2\n    }, {\n      x,\n      y: y1\n    }, {\n      x: tox,\n      y: y1\n    }];\n  } else if (sourceSide === 'bottom' && targetSide === 'bottom') {\n    let x;\n    let y1 = Math.max((sy0 + ty1) / 2, toy);\n    let y2 = Math.max((sy1 + ty0) / 2, soy);\n    if (toy > soy) {\n      if (sox >= tmx1 || sox <= tmx0) {\n        return [{\n          x: sox,\n          y: Math.max(soy, toy)\n        }, {\n          x: tox,\n          y: Math.max(soy, toy)\n        }];\n      } else if (tox > sox) {\n        x = Math.min(sox, tmx0);\n      } else {\n        x = Math.max(sox, tmx1);\n      }\n    } else {\n      if (tox >= smx1 || tox <= smx0) {\n        return [{\n          x: sox,\n          y: Math.max(soy, toy)\n        }, {\n          x: tox,\n          y: Math.max(soy, toy)\n        }];\n      } else if (tox >= sox) {\n        x = Math.max(tox, smx1);\n      } else {\n        x = Math.min(tox, smx0);\n      }\n    }\n    return [{\n      x: sox,\n      y: y2\n    }, {\n      x,\n      y: y2\n    }, {\n      x,\n      y: y1\n    }, {\n      x: tox,\n      y: y1\n    }];\n  } else if (sourceSide === 'left' && targetSide === 'left') {\n    let y;\n    let x1 = Math.min((sx1 + tx0) / 2, tox);\n    let x2 = Math.min((sx0 + tx1) / 2, sox);\n    if (tox > sox) {\n      if (toy <= soy) {\n        y = Math.min(smy0, toy);\n      } else {\n        y = Math.max(smy1, toy);\n      }\n    } else {\n      if (toy >= soy) {\n        y = Math.min(tmy0, soy);\n      } else {\n        y = Math.max(tmy1, soy);\n      }\n    }\n    return [{\n      x: x2,\n      y: soy\n    }, {\n      x: x2,\n      y\n    }, {\n      x: x1,\n      y\n    }, {\n      x: x1,\n      y: toy\n    }];\n  } else if (sourceSide === 'right' && targetSide === 'right') {\n    let y;\n    let x1 = Math.max((sx0 + tx1) / 2, tox);\n    let x2 = Math.max((sx1 + tx0) / 2, sox);\n    if (tox < sox) {\n      if (toy <= soy) {\n        y = Math.min(smy0, toy);\n      } else {\n        y = Math.max(smy1, toy);\n      }\n    } else {\n      if (toy >= soy) {\n        y = Math.min(tmy0, soy);\n      } else {\n        y = Math.max(tmy1, soy);\n      }\n    }\n    return [{\n      x: x2,\n      y: soy\n    }, {\n      x: x2,\n      y\n    }, {\n      x: x1,\n      y\n    }, {\n      x: x1,\n      y: toy\n    }];\n  } else if (sourceSide === 'top' && targetSide === 'right') {\n    if (soy > toy) {\n      if (sox < tox) {\n        let y = middleOfHorizontalSides;\n        if ((y > tcy || !isSourceEl) && y < tmy1 && sox < tx0) {\n          y = tmy0;\n        }\n        return [{\n          x: sox,\n          y\n        }, {\n          x: tox,\n          y\n        }, {\n          x: tox,\n          y: toy\n        }];\n      }\n      return [{\n        x: sox,\n        y: toy\n      }];\n    }\n    const x = Math.max(middleOfVerticalSides, tmx1);\n    if (tox < sox && toy > sy0 && toy < sy1) {\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: x,\n        y: soy\n      }, {\n        x: x,\n        y: toy\n      }];\n    }\n    if (x > smx0 && toy > sy0 || tx0 > sx1) {\n      const y = Math.min(sy0 - sourceMargin, ty0 - targetMargin);\n      const x = Math.max(sx1 + sourceMargin, tx1 + targetMargin);\n      return [{\n        x: sox,\n        y\n      }, {\n        x,\n        y\n      }, {\n        x,\n        y: toy\n      }];\n    }\n    return [{\n      x: sox,\n      y: soy\n    }, {\n      x: Math.max(x, tox),\n      y: soy\n    }, {\n      x: Math.max(x, tox),\n      y: toy\n    }];\n  } else if (sourceSide === 'top' && targetSide === 'left') {\n    if (soy > toy) {\n      if (sox > tox) {\n        let y = middleOfHorizontalSides;\n        if ((y > tcy || !isSourceEl) && y < tmy1 && sox > tx1) {\n          y = tmy0;\n        }\n        return [{\n          x: sox,\n          y\n        }, {\n          x: tox,\n          y\n        }, {\n          x: tox,\n          y: toy\n        }];\n      }\n      return [{\n        x: sox,\n        y: toy\n      }];\n    }\n    const x = Math.min(tmx0, middleOfVerticalSides);\n    if (sox < tox && sy1 >= toy) {\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x,\n        y: soy\n      }, {\n        x,\n        y: toy\n      }];\n    }\n    if (x < smx1 && soy < ty1) {\n      const y = Math.min(smy0, tmy0);\n      const x = Math.min(smx0, tmx0);\n      return [{\n        x: sox,\n        y\n      }, {\n        x,\n        y\n      }, {\n        x,\n        y: toy\n      }];\n    }\n    return [{\n      x: sox,\n      y: soy\n    }, {\n      x,\n      y: soy\n    }, {\n      x,\n      y: toy\n    }];\n  } else if (sourceSide === 'bottom' && targetSide === 'right') {\n    if (soy < toy) {\n      if (sox < tox) {\n        let y = middleOfHorizontalSides;\n        if ((y < tcy || !isSourceEl) && y > tmy0 && sox < tx0) {\n          y = tmy1;\n        }\n        return [{\n          x: sox,\n          y\n        }, {\n          x: tox,\n          y\n        }, {\n          x: tox,\n          y: toy\n        }];\n      }\n      return [{\n        x: sox,\n        y: toy\n      }];\n    } else {\n      if (sx0 < tox) {\n        const y = Math.max(smy1, tmy1);\n        const x = Math.max(smx1, tmx1);\n        return [{\n          x: sox,\n          y\n        }, {\n          x,\n          y\n        }, {\n          x,\n          y: toy\n        }];\n      }\n    }\n    const x = middleOfVerticalSides;\n    return [{\n      x: sox,\n      y: soy\n    }, {\n      x,\n      y: soy\n    }, {\n      x,\n      y: toy\n    }];\n  } else if (sourceSide === 'bottom' && targetSide === 'left') {\n    if (soy < toy) {\n      if (sox > tox) {\n        let y = middleOfHorizontalSides;\n        if ((y < tcy || !isSourceEl) && y > tmy0 && sox > tx1) {\n          y = tmy1;\n        }\n        return [{\n          x: sox,\n          y\n        }, {\n          x: tox,\n          y\n        }, {\n          x: tox,\n          y: toy\n        }];\n      }\n      return [{\n        x: sox,\n        y: toy\n      }];\n    } else {\n      if (sx1 > tox) {\n        const y = Math.max(smy1, tmy1);\n        const x = Math.min(smx0, tmx0);\n        return [{\n          x: sox,\n          y\n        }, {\n          x,\n          y\n        }, {\n          x,\n          y: toy\n        }];\n      }\n    }\n    const x = middleOfVerticalSides;\n    return [{\n      x: sox,\n      y: soy\n    }, {\n      x,\n      y: soy\n    }, {\n      x,\n      y: toy\n    }];\n  } else if (sourceSide === 'left' && targetSide === 'bottom') {\n    if (sox >= tox && soy >= tmy1) {\n      return [{\n        x: tox,\n        y: soy\n      }];\n    }\n    if (sox >= tx1 && soy < toy) {\n      const x = middleOfVerticalSides;\n      return [{\n        x,\n        y: soy\n      }, {\n        x,\n        y: toy\n      }, {\n        x: tox,\n        y: toy\n      }];\n    }\n    if (tox < sx1 && ty1 <= sy0) {\n      const y = middleOfHorizontalSides;\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y\n      }, {\n        x: tox,\n        y\n      }];\n    }\n    const x = Math.min(tmx0, sox);\n    const y = Math.max(smy1, tmy1);\n    return [{\n      x,\n      y: soy\n    }, {\n      x,\n      y\n    }, {\n      x: tox,\n      y\n    }];\n  } else if (sourceSide === 'left' && targetSide === 'top') {\n    if (sox > tox && soy < tmy0) {\n      return [{\n        x: tox,\n        y: soy\n      }];\n    }\n    if (sox >= tx1) {\n      if (soy > toy) {\n        const x = middleOfVerticalSides;\n        return [{\n          x,\n          y: soy\n        }, {\n          x,\n          y: toy\n        }, {\n          x: tox,\n          y: toy\n        }];\n      }\n    }\n    if (tox <= sx1 && toy > soy) {\n      const y = middleOfHorizontalSides;\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y\n      }, {\n        x: tox,\n        y\n      }];\n    }\n    const x = toy < soy ? Math.min(smx0, tmx0) : smx0;\n    const y = Math.min(smy0, tmy0);\n    return [{\n      x,\n      y: soy\n    }, {\n      x,\n      y\n    }, {\n      x: tox,\n      y\n    }];\n  } else if (sourceSide === 'right' && targetSide === 'top') {\n    if (sox <= tox && soy < tmy0) {\n      return [{\n        x: tox,\n        y: soy\n      }];\n    }\n    if (sx1 < tx0 && soy > toy) {\n      let x = middleOfVerticalSides;\n      return [{\n        x,\n        y: soy\n      }, {\n        x,\n        y: toy\n      }, {\n        x: tox,\n        y: toy\n      }];\n    }\n    if (tox < sox && ty0 > sy1) {\n      const y = middleOfHorizontalSides;\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y\n      }, {\n        x: tox,\n        y\n      }];\n    }\n    const x = Math.max(smx1, tmx1);\n    const y = Math.min(smy0, tmy0);\n    return [{\n      x,\n      y: soy\n    }, {\n      x,\n      y\n    }, {\n      x: tox,\n      y\n    }];\n  } else if (sourceSide === 'right' && targetSide === 'bottom') {\n    if (sox <= tox && soy >= tmy1) {\n      return [{\n        x: tox,\n        y: soy\n      }];\n    }\n    if (sox <= tmx0 && soy < toy) {\n      const x = middleOfVerticalSides;\n      return [{\n        x,\n        y: soy\n      }, {\n        x,\n        y: toy\n      }, {\n        x: tox,\n        y: toy\n      }];\n    }\n    if (tox > sx0 && ty1 < sy0) {\n      const y = middleOfHorizontalSides;\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y\n      }, {\n        x: tox,\n        y\n      }];\n    }\n    const x = Math.max(tmx1, sox);\n    const y = Math.max(smy1, tmy1);\n    return [{\n      x,\n      y: soy\n    }, {\n      x,\n      y\n    }, {\n      x: tox,\n      y\n    }];\n  }\n}\nfunction rightAngleRouter(vertices, opt, linkView) {\n  const {\n    sourceDirection = Directions.AUTO,\n    targetDirection = Directions.AUTO\n  } = opt;\n  const margin = opt.margin || 20;\n  const useVertices = opt.useVertices || false;\n  const isSourcePort = !!linkView.model.source().port;\n  const sourcePoint = pointDataFromAnchor(linkView.sourceView, linkView.sourceAnchor, linkView.sourceBBox, sourceDirection, isSourcePort, linkView.sourceAnchor, margin);\n  const isTargetPort = !!linkView.model.target().port;\n  const targetPoint = pointDataFromAnchor(linkView.targetView, linkView.targetAnchor, linkView.targetBBox, targetDirection, isTargetPort, linkView.targetAnchor, margin);\n  let resultVertices = [];\n  if (!useVertices || vertices.length === 0) {\n    return simplifyPoints(routeBetweenPoints(sourcePoint, targetPoint));\n  }\n  const verticesData = vertices.map(v => pointDataFromVertex(v));\n  const [firstVertex] = verticesData;\n  if (sourcePoint.view && sourcePoint.view.model.isElement() && sourcePoint.view.model.getBBox().inflate(margin).containsPoint(firstVertex.point)) {\n    const [fromDirection] = resolveSides(sourcePoint, firstVertex);\n    const toDirection = fromDirection;\n    const dummySource = pointDataFromVertex(sourcePoint.point);\n    // Points do not usually have margin. Here we create a point with a margin.\n    dummySource.margin = margin;\n    dummySource.direction = fromDirection;\n    firstVertex.direction = toDirection;\n    resultVertices.push(...routeBetweenPoints(dummySource, firstVertex), firstVertex.point);\n  } else {\n    // The first point responsible for the initial direction of the route\n    const next = verticesData[1] || targetPoint;\n    const direction = resolveInitialDirection(sourcePoint, firstVertex, next);\n    firstVertex.direction = direction;\n    resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex), firstVertex.point);\n  }\n  for (let i = 0; i < verticesData.length - 1; i++) {\n    const from = verticesData[i];\n    const to = verticesData[i + 1];\n    const segment = new g.Line(from.point, to.point);\n    const segmentAngle = getSegmentAngle(segment);\n    if (segmentAngle % 90 === 0) {\n      // Since the segment is horizontal or vertical, we can skip the routing and just connect them with a straight line\n      const toDirection = ANGLE_DIRECTION_MAP[segmentAngle];\n      const accessDirection = OPPOSITE_DIRECTIONS[toDirection];\n      if (toDirection !== from.direction) {\n        resultVertices.push(from.point, to.point);\n        to.direction = accessDirection;\n      } else {\n        const angle = g.normalizeAngle(segmentAngle - 90);\n        let dx = 0;\n        let dy = 0;\n        if (angle === 90) {\n          dy = -margin;\n        } else if (angle === 180) {\n          dx = -margin;\n        } else if (angle === 270) {\n          dy = margin;\n        } else if (angle === 0) {\n          dx = margin;\n        }\n        const p1 = {\n          x: from.point.x + dx,\n          y: from.point.y + dy\n        };\n        const p2 = {\n          x: to.point.x + dx,\n          y: to.point.y + dy\n        };\n        const segment2 = new g.Line(to.point, p2);\n        to.direction = ANGLE_DIRECTION_MAP[getSegmentAngle(segment2)];\n\n        // Constructing a loop\n        resultVertices.push(from.point, p1, p2, to.point);\n      }\n      continue;\n    }\n    const [fromDirection, toDirection] = resolveDirection(from, to);\n    from.direction = fromDirection;\n    to.direction = toDirection;\n    resultVertices.push(...routeBetweenPoints(from, to), to.point);\n  }\n  const lastVertex = verticesData[verticesData.length - 1];\n  if (targetPoint.view && targetPoint.view.model.isElement()) {\n    if (targetPoint.view.model.getBBox().inflate(margin).containsPoint(lastVertex.point)) {\n      const [fromDirection] = resolveDirection(lastVertex, targetPoint);\n      const dummyTarget = pointDataFromVertex(targetPoint.point);\n      const [, toDirection] = resolveSides(lastVertex, targetPoint);\n      // we are creating a point that has a margin\n      dummyTarget.margin = margin;\n      dummyTarget.direction = toDirection;\n      lastVertex.direction = fromDirection;\n      resultVertices.push(...routeBetweenPoints(lastVertex, dummyTarget));\n    } else {\n      // the last point of `simplified` array is the last defined vertex\n      // grab the penultimate point and construct a line segment from it to the last vertex\n      // this will ensure that the last segment continues in a straight line\n\n      const simplified = simplifyPoints(resultVertices);\n      const segment = new g.Line(simplified[simplified.length - 2], lastVertex.point);\n      const definedDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(segment))];\n      lastVertex.direction = definedDirection;\n      let lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n      const [p1, p2] = simplifyPoints([...lastSegmentRoute, targetPoint.point]);\n      const lastSegment = new g.Line(p1, p2);\n      const roundedLastSegmentAngle = Math.round(getSegmentAngle(lastSegment));\n      const lastSegmentDirection = ANGLE_DIRECTION_MAP[roundedLastSegmentAngle];\n      if (lastSegmentDirection !== definedDirection && definedDirection === OPPOSITE_DIRECTIONS[lastSegmentDirection]) {\n        lastVertex.margin = margin;\n        lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n      }\n      resultVertices.push(...lastSegmentRoute);\n    }\n  } else {\n    // since the target is only a point we can apply the same logic as if we connected two verticesData\n    const [vertexDirection] = resolveDirection(lastVertex, targetPoint);\n    lastVertex.direction = vertexDirection;\n    resultVertices.push(...routeBetweenPoints(lastVertex, targetPoint));\n  }\n  return simplifyPoints(resultVertices);\n}\nfunction resolveDirection(from, to) {\n  const accessDirection = from.direction;\n  const isDirectionVertical = VERTICAL_DIRECTIONS.includes(accessDirection);\n  let sourceDirection = from.direction;\n  let targetDirection = to.direction;\n  if (isDirectionVertical) {\n    const isToAbove = from.point.y > to.point.y;\n    const dx = to.point.x - from.point.x;\n    if (accessDirection === Directions.BOTTOM) {\n      // If isToAbove === false and we need figure out if to go left or right\n      sourceDirection = isToAbove ? OPPOSITE_DIRECTIONS[accessDirection] : dx >= 0 ? Directions.RIGHT : Directions.LEFT;\n      if (dx > 0) {\n        targetDirection = isToAbove ? Directions.LEFT : Directions.TOP;\n      } else if (dx < 0) {\n        targetDirection = isToAbove ? Directions.RIGHT : Directions.TOP;\n      }\n    } else {\n      // If isToAbove === true and we need figure out if to go left or right\n      sourceDirection = isToAbove ? dx >= 0 ? Directions.RIGHT : Directions.LEFT : OPPOSITE_DIRECTIONS[accessDirection];\n      if (dx > 0) {\n        targetDirection = isToAbove ? Directions.BOTTOM : Directions.LEFT;\n      } else if (dx < 0) {\n        targetDirection = isToAbove ? Directions.BOTTOM : Directions.RIGHT;\n      }\n    }\n  } else {\n    const isToLeft = from.point.x > to.point.x;\n    const dy = to.point.y - from.point.y;\n    if (accessDirection === Directions.RIGHT) {\n      sourceDirection = isToLeft ? OPPOSITE_DIRECTIONS[accessDirection] : dy >= 0 ? Directions.BOTTOM : Directions.TOP;\n      if (dy > 0) {\n        targetDirection = isToLeft ? Directions.TOP : Directions.LEFT;\n      } else if (dy < 0) {\n        targetDirection = isToLeft ? Directions.BOTTOM : Directions.LEFT;\n      }\n    } else {\n      sourceDirection = isToLeft ? dy >= 0 ? Directions.BOTTOM : Directions.TOP : OPPOSITE_DIRECTIONS[accessDirection];\n      if (dy > 0) {\n        targetDirection = isToLeft ? Directions.RIGHT : Directions.TOP;\n      } else if (dy < 0) {\n        targetDirection = isToLeft ? Directions.RIGHT : Directions.BOTTOM;\n      }\n    }\n  }\n  return [sourceDirection, targetDirection];\n}\nrightAngleRouter.Directions = Directions;\nexport const rightAngle = rightAngleRouter;","map":{"version":3,"names":["g","Directions","AUTO","LEFT","RIGHT","TOP","BOTTOM","ANCHOR_SIDE","MAGNET_SIDE","DEFINED_DIRECTIONS","OPPOSITE_DIRECTIONS","VERTICAL_DIRECTIONS","ANGLE_DIRECTION_MAP","getSegmentAngle","line","angle","simplifyPoints","points","Polyline","simplify","threshold","resolveSides","source","target","point","sourcePoint","x0","sx0","y0","sy0","view","sourceView","bbox","sourceBBox","direction","sourceDirection","targetPoint","tx0","ty0","targetView","targetBBox","targetDirection","sourceSide","sourceLinkAnchorBBox","Rect","includes","sideNearestToPoint","model","isLink","getDirectionForLinkConnection","getBBox","targetSide","targetLinkAnchorBBox","resolveForTopSourceSide","nextInLine","width","height","anchor","margin","sx1","sy1","smx0","smx1","smy0","x","ax","tx","ty","resolveForBottomSourceSide","smy1","resolveForLeftSourceSide","y","ay","resolveForRightSourceSide","resolveInitialDirection","linkOrigin","connectionPoint","linkView","tangent","getTangentAtLength","getClosestPointLength","roundedAngle","Math","round","pointDataFromAnchor","isPort","fallBackAnchor","isElement","fromRectUnion","pointDataFromVertex","Point","getOutsidePoint","side","pointData","outsidePoint","clone","routeBetweenPoints","sourceWidth","sourceHeight","sourceMargin","targetWidth","targetHeight","targetMargin","tx1","ty1","isSourceEl","tmx0","tmx1","tmy0","tmy1","sourceOutsidePoint","targetOutsidePoint","sox","soy","tox","toy","tcx","tcy","scx","scy","middleOfVerticalSides","middleOfHorizontalSides","min","max","y1","y2","x1","x2","rightAngleRouter","vertices","opt","useVertices","isSourcePort","port","sourceAnchor","isTargetPort","targetAnchor","resultVertices","length","verticesData","map","v","firstVertex","inflate","containsPoint","fromDirection","toDirection","dummySource","push","next","i","from","to","segment","Line","segmentAngle","accessDirection","normalizeAngle","dx","dy","p1","p2","segment2","resolveDirection","lastVertex","dummyTarget","simplified","definedDirection","lastSegmentRoute","lastSegment","roundedLastSegmentAngle","lastSegmentDirection","vertexDirection","isDirectionVertical","isToAbove","isToLeft","rightAngle"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/routers/rightAngle.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\n\nconst Directions = {\n    AUTO: 'auto',\n    LEFT: 'left',\n    RIGHT: 'right',\n    TOP: 'top',\n    BOTTOM: 'bottom',\n    ANCHOR_SIDE: 'anchor-side',\n    MAGNET_SIDE: 'magnet-side'\n};\n\nconst DEFINED_DIRECTIONS = [Directions.LEFT, Directions.RIGHT, Directions.TOP, Directions.BOTTOM];\n\nconst OPPOSITE_DIRECTIONS = {\n    [Directions.LEFT]: Directions.RIGHT,\n    [Directions.RIGHT]: Directions.LEFT,\n    [Directions.TOP]: Directions.BOTTOM,\n    [Directions.BOTTOM]: Directions.TOP\n};\n\nconst VERTICAL_DIRECTIONS = [Directions.TOP, Directions.BOTTOM];\n\nconst ANGLE_DIRECTION_MAP = {\n    0: Directions.RIGHT,\n    180: Directions.LEFT,\n    270: Directions.TOP,\n    90: Directions.BOTTOM\n};\n\nfunction getSegmentAngle(line) {\n    // TODO: the angle() method is general and therefore unnecessarily heavy for orthogonal links\n    return line.angle();\n}\n\nfunction simplifyPoints(points) {\n    // TODO: use own more efficient implementation (filter points that do not change direction).\n    // To simplify segments that are almost aligned (start and end points differ by e.g. 0.5px), use a threshold of 1.\n    return new g.Polyline(points).simplify({ threshold: 1 }).points;\n}\n\nfunction resolveSides(source, target) {\n    const { point: sourcePoint, x0: sx0, y0: sy0, view: sourceView, bbox: sourceBBox, direction: sourceDirection } = source;\n    const { point: targetPoint, x0: tx0, y0: ty0, view: targetView, bbox: targetBBox, direction: targetDirection } = target;\n\n    let sourceSide;\n\n    if (!sourceView) {\n        const sourceLinkAnchorBBox = new g.Rect(sx0, sy0, 0, 0);\n        sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);\n    } else if (sourceView.model.isLink()) {\n        sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);\n    } else if (sourceDirection === Directions.ANCHOR_SIDE) {\n        sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);\n    } else if (sourceDirection === Directions.MAGNET_SIDE) {\n        sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);\n    } else {\n        sourceSide = sourceDirection;\n    }\n\n    let targetSide;\n\n    if (!targetView) {\n        const targetLinkAnchorBBox = new g.Rect(tx0, ty0, 0, 0);\n        targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);\n    } else if (targetView.model.isLink()) {\n        targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);\n    } else if (targetDirection === Directions.ANCHOR_SIDE) {\n        targetSide = targetBBox.sideNearestToPoint(targetPoint);\n    } else if (targetDirection === Directions.MAGNET_SIDE) {\n        targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);\n    } else {\n        targetSide = targetDirection;\n    }\n\n    return [sourceSide, targetSide];\n}\n\nfunction resolveForTopSourceSide(source, target, nextInLine) {\n    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smx1 = sx1 + margin;\n    const smy0 = sy0 - margin;\n\n    const { x: ax } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx === ax && ty < sy0) return Directions.BOTTOM;\n    if (tx < ax && ty < smy0) return Directions.RIGHT;\n    if (tx > ax && ty < smy0) return Directions.LEFT;\n    if (tx < smx0 && ty >= sy0) return Directions.TOP;\n    if (tx > smx1 && ty >= sy0) return Directions.TOP;\n    if (tx >= smx0 && tx <= ax && ty > sy1) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n\n        return Directions.LEFT;\n    }\n    if (tx <= smx1 && tx >= ax && ty > sy1) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n\n        return Directions.LEFT;\n    }\n\n    return Directions.TOP;\n}\n\nfunction resolveForBottomSourceSide(source, target, nextInLine) {\n    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smx1 = sx1 + margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx === ax && ty > sy1) return Directions.TOP;\n    if (tx < ax && ty > smy1) return Directions.RIGHT;\n    if (tx > ax && ty > smy1) return Directions.LEFT;\n    if (tx < smx0 && ty <= sy1) return Directions.BOTTOM;\n    if (tx > smx1 && ty <= sy1) return Directions.BOTTOM;\n    if (tx >= smx0 && tx <= ax && ty < sy0) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n\n        return Directions.LEFT;\n    }\n    if (tx <= smx1 && tx >= ax && ty < sy0) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n\n        return Directions.LEFT;\n    }\n\n    return Directions.BOTTOM;\n}\n\nfunction resolveForLeftSourceSide(source, target, nextInLine) {\n    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smy0 = sy0 - margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax, y: ay } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx < ax && ty === ay) return Directions.RIGHT;\n    if (tx <= smx0 && ty < ay) return Directions.BOTTOM;\n    if (tx <= smx0 && ty > ay) return Directions.TOP;\n    if (tx >= sx0 && ty <= smy0) return Directions.LEFT;\n    if (tx >= sx0 && ty >= smy1) return Directions.LEFT;\n    if (tx > sx1 && ty >= smy0 && ty <= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n    if (tx > sx1 && ty <= smy1 && ty >= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n\n    return Directions.LEFT;\n}\n\nfunction resolveForRightSourceSide(source, target, nextInLine) {\n    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx1 = sx1 + margin;\n    const smy0 = sy0 - margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax, y: ay } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx > ax && ty === ay) return Directions.LEFT;\n    if (tx >= smx1 && ty < ay) return Directions.BOTTOM;\n    if (tx >= smx1 && ty > ay) return Directions.TOP;\n    if (tx <= sx1 && ty <= smy0) return Directions.RIGHT;\n    if (tx <= sx1 && ty >= smy1) return Directions.RIGHT;\n    if (tx < sx0 && ty >= smy0 && ty <= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n    if (tx < sx0 && ty <= smy1 && ty >= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n\n    return Directions.RIGHT;\n}\n\nfunction resolveInitialDirection(source, target, nextInLine) {\n    const [sourceSide] = resolveSides(source, target);\n\n    switch (sourceSide) {\n        case Directions.TOP:\n            return resolveForTopSourceSide(source, target, nextInLine);\n        case Directions.RIGHT:\n            return resolveForRightSourceSide(source, target, nextInLine);\n        case Directions.BOTTOM:\n            return resolveForBottomSourceSide(source, target, nextInLine);\n        case Directions.LEFT:\n            return resolveForLeftSourceSide(source, target, nextInLine);\n    }\n}\n\nfunction getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {\n    const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));\n    const roundedAngle = Math.round(getSegmentAngle(tangent) / 90) * 90;\n\n    if (roundedAngle % 180 === 0 && linkOrigin.y === connectionPoint.y) {\n        return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n    } else if (linkOrigin.x === connectionPoint.x) {\n        return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n    }\n\n    switch (roundedAngle) {\n        case 0:\n        case 180:\n        case 360:\n            return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n        case 90:\n        case 270:\n            return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n    }\n}\n\nfunction pointDataFromAnchor(view, point, bbox, direction, isPort, fallBackAnchor, margin) {\n    if (direction === Directions.AUTO) {\n        direction = isPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n    }\n\n    const isElement = view && view.model.isElement();\n\n    const {\n        x: x0,\n        y: y0,\n        width = 0,\n        height = 0\n    } = isElement ? g.Rect.fromRectUnion(bbox, view.model.getBBox()) : fallBackAnchor;\n\n    return {\n        point,\n        x0,\n        y0,\n        view,\n        bbox,\n        width,\n        height,\n        direction,\n        margin: isElement ? margin : 0\n    };\n}\n\nfunction pointDataFromVertex({ x, y }) {\n    const point = new g.Point(x, y);\n\n    return {\n        point,\n        x0: point.x,\n        y0: point.y,\n        view: null,\n        bbox: new g.Rect(x, y, 0, 0),\n        width: 0,\n        height: 0,\n        direction: null,\n        margin: 0\n    };\n}\n\nfunction getOutsidePoint(side, pointData, margin) {\n    const outsidePoint = pointData.point.clone();\n\n    const { x0, y0, width, height } = pointData;\n\n    switch (side) {\n        case 'left':\n            outsidePoint.x = x0 - margin;\n            break;\n        case 'right':\n            outsidePoint.x = x0 + width + margin;\n            break;\n        case 'top':\n            outsidePoint.y = y0 - margin;\n            break;\n        case 'bottom':\n            outsidePoint.y = y0 + height + margin;\n            break;\n    }\n\n    return outsidePoint;\n}\n\nfunction routeBetweenPoints(source, target) {\n    const { point: sourcePoint, x0: sx0, y0: sy0, view: sourceView, width: sourceWidth, height: sourceHeight, margin: sourceMargin } = source;\n    const { point: targetPoint, x0: tx0, y0: ty0, width: targetWidth, height: targetHeight, margin: targetMargin } = target;\n\n    const tx1 = tx0 + targetWidth;\n    const ty1 = ty0 + targetHeight;\n    const sx1 = sx0 + sourceWidth;\n    const sy1 = sy0 + sourceHeight;\n\n    const isSourceEl = sourceView && sourceView.model.isElement();\n\n    // Key coordinates including the margin\n    const smx0 = sx0 - sourceMargin;\n    const smx1 = sx1 + sourceMargin;\n    const smy0 = sy0 - sourceMargin;\n    const smy1 = sy1 + sourceMargin;\n\n    const tmx0 = tx0 - targetMargin;\n    const tmx1 = tx1 + targetMargin;\n    const tmy0 = ty0 - targetMargin;\n    const tmy1 = ty1 + targetMargin;\n\n    const [sourceSide, targetSide] = resolveSides(source, target);\n\n    const sourceOutsidePoint = getOutsidePoint(sourceSide, { point: sourcePoint, x0: sx0, y0: sy0, width: sourceWidth, height: sourceHeight }, sourceMargin);\n    const targetOutsidePoint = getOutsidePoint(targetSide, { point: targetPoint, x0: tx0, y0: ty0, width: targetWidth, height: targetHeight }, targetMargin);\n\n    const { x: sox, y: soy } = sourceOutsidePoint;\n    const { x: tox, y: toy } = targetOutsidePoint;\n    const tcx = (tx0 + tx1) / 2;\n    const tcy = (ty0 + ty1) / 2;\n    const scx = (sx0 + sx1) / 2;\n    const scy = (sy0 + sy1) / 2;\n    const middleOfVerticalSides = (scx < tcx ? (sx1 + tx0) : (tx1 + sx0)) / 2;\n    const middleOfHorizontalSides = (scy < tcy ? (sy1 + ty0) : (ty1 + sy0)) / 2;\n\n    if (sourceSide === 'left' && targetSide === 'right') {\n        if (smx0 <= tmx1) {\n            let y = middleOfHorizontalSides;\n            if (sx1 <= tx0) {\n                if (ty1 >= smy0 && toy < soy) {\n                    y = Math.min(tmy0, smy0);\n                } else if (ty0 <= smy1 && toy >= soy) {\n                    y = Math.max(tmy1, smy1);\n                }\n            }\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y },\n                { x: tox, y: toy }\n            ];\n        }\n\n        const x = (sox + tox) / 2;\n        return [\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'left') {\n        if (smx1 >= tmx0) {\n            let y = middleOfHorizontalSides;\n            if (sox > tx1) {\n                if (ty1 >= smy0 && toy < soy) {\n                    y = Math.min(tmy0, smy0);\n                } else if (ty0 <= smy1 && toy >= soy) {\n                    y = Math.max(tmy1, smy1);\n                }\n            }\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y },\n                { x: tox, y: toy }\n            ];\n        }\n\n        const x = (sox + tox) / 2;\n        return [\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'bottom') {\n        if (soy < toy) {\n            let x = middleOfVerticalSides;\n            let y = soy;\n\n            if (soy < ty0) {\n                if (tx1 >= smx0 && tox < sox) {\n                    x = Math.min(tmx0, smx0);\n                } else if (tx0 <= smx1 && tox >= sox) {\n                    x = Math.max(tmx1, smx1);\n                }\n            }\n\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n        const y = (soy + toy) / 2;\n        return [\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'top') {\n        if (soy - sourceMargin > toy) {\n            let x = middleOfVerticalSides;\n            let y = soy;\n\n            if (soy > ty1) {\n                if (tx1 >= smx0 && tox < sox) {\n                    x = Math.min(tmx0, smx0);\n                } else if (tx0 <= smx1 && tox >= sox) {\n                    x = Math.max(tmx1, smx1);\n                }\n            }\n\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n        const y = (soy + toy) / 2;\n        return [\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'top') {\n        let x;\n        let y1 = Math.min((sy1 + ty0) / 2, toy);\n        let y2 = Math.min((sy0 + ty1) / 2, soy);\n\n        if (toy < soy) {\n            if (sox >= tmx1 || sox <= tmx0) {\n                return [\n                    { x: sox, y: Math.min(soy, toy) },\n                    { x: tox, y: Math.min(soy, toy) }\n                ];\n            } else if (tox > sox) {\n                x = Math.min(sox, tmx0);\n            } else {\n                x = Math.max(sox, tmx1);\n            }\n        } else {\n            if (tox >= smx1 || tox <= smx0) {\n                return [\n                    { x: sox, y: Math.min(soy, toy) },\n                    { x: tox, y: Math.min(soy, toy) }\n                ];\n            } else if (tox >= sox) {\n                x = Math.max(tox, smx1);\n            } else {\n                x = Math.min(tox, smx0);\n            }\n        }\n\n        return [\n            { x: sox, y: y2 },\n            { x, y: y2 },\n            { x, y: y1 },\n            { x: tox, y: y1 }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'bottom') {\n        let x;\n        let y1 = Math.max((sy0 + ty1) / 2, toy);\n        let y2 = Math.max((sy1 + ty0) / 2, soy);\n\n        if (toy > soy) {\n            if (sox >= tmx1 || sox <= tmx0) {\n                return [\n                    { x: sox, y: Math.max(soy, toy) },\n                    { x: tox, y: Math.max(soy, toy) }\n                ];\n            } else if (tox > sox) {\n                x = Math.min(sox, tmx0);\n            } else {\n                x = Math.max(sox, tmx1);\n            }\n        } else {\n            if (tox >= smx1 || tox <= smx0) {\n                return [\n                    { x: sox, y: Math.max(soy, toy) },\n                    { x: tox, y: Math.max(soy, toy) }\n                ];\n            } else if (tox >= sox) {\n                x = Math.max(tox, smx1);\n            } else {\n                x = Math.min(tox, smx0);\n            }\n        }\n\n        return [\n            { x: sox, y: y2 },\n            { x, y: y2 },\n            { x, y: y1 },\n            { x: tox, y: y1 }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'left') {\n        let y;\n        let x1 = Math.min((sx1 + tx0) / 2, tox);\n        let x2 = Math.min((sx0 + tx1) / 2, sox);\n\n        if (tox > sox) {\n            if (toy <= soy) {\n                y = Math.min(smy0, toy);\n            } else {\n                y = Math.max(smy1, toy);\n            }\n        } else {\n            if (toy >= soy) {\n                y = Math.min(tmy0, soy);\n            } else {\n                y = Math.max(tmy1, soy);\n            }\n        }\n\n        return [\n            { x: x2, y: soy },\n            { x: x2, y },\n            { x: x1, y },\n            { x: x1, y: toy }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'right') {\n        let y;\n        let x1 = Math.max((sx0 + tx1) / 2, tox);\n        let x2 = Math.max((sx1 + tx0) / 2, sox);\n\n        if (tox < sox) {\n            if (toy <= soy) {\n                y = Math.min(smy0, toy);\n            } else {\n                y = Math.max(smy1, toy);\n            }\n        } else {\n            if (toy >= soy) {\n                y = Math.min(tmy0, soy);\n            } else {\n                y = Math.max(tmy1, soy);\n            }\n        }\n\n        return [\n            { x: x2, y: soy },\n            { x: x2, y },\n            { x: x1, y },\n            { x: x1, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'right') {\n        if (soy > toy) {\n            if (sox < tox) {\n                let y = middleOfHorizontalSides;\n\n                if ((y > tcy || !isSourceEl) && y < tmy1 && sox < tx0) {\n                    y = tmy0;\n                }\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.max(middleOfVerticalSides, tmx1);\n\n        if (tox < sox && toy > sy0 && toy < sy1) {\n            return [\n                { x: sox, y: soy },\n                { x: x, y: soy },\n                { x: x, y: toy }\n            ];\n        }\n\n        if ((x > smx0 && toy > sy0) || tx0 > sx1) {\n            const y = Math.min(sy0 - sourceMargin, ty0 - targetMargin);\n            const x = Math.max(sx1 + sourceMargin, tx1 + targetMargin);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: Math.max(x, tox), y: soy },\n            { x: Math.max(x, tox), y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'left') {\n        if (soy > toy) {\n            if (sox > tox) {\n                let y = middleOfHorizontalSides;\n\n                if ((y > tcy || !isSourceEl) && y < tmy1 && sox > tx1) {\n                    y = tmy0;\n                }\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.min(tmx0, middleOfVerticalSides);\n\n        if (sox < tox && sy1 >= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }];\n        }\n\n        if (x < smx1 && soy < ty1) {\n            const y = Math.min(smy0, tmy0);\n            const x = Math.min(smx0, tmx0);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'right') {\n        if (soy < toy) {\n            if (sox < tox) {\n                let y = middleOfHorizontalSides;\n\n                if ((y < tcy || !isSourceEl) && y > tmy0 && sox < tx0) {\n                    y = tmy1;\n                }\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n            return [{ x: sox, y: toy }];\n        } else {\n            if (sx0 < tox) {\n                const y = Math.max(smy1, tmy1);\n                const x = Math.max(smx1, tmx1);\n                return [\n                    { x: sox, y },\n                    { x, y },\n                    { x, y: toy }\n                ];\n            }\n        }\n\n        const x = middleOfVerticalSides;\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'left') {\n        if (soy < toy) {\n            if (sox > tox) {\n                let y = middleOfHorizontalSides;\n\n                if ((y < tcy || !isSourceEl) && y > tmy0 && sox > tx1) {\n                    y = tmy1;\n                }\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n            return [{ x: sox, y: toy }];\n        } else {\n            if (sx1 > tox) {\n                const y = Math.max(smy1, tmy1);\n                const x = Math.min(smx0, tmx0);\n                return [\n                    { x: sox, y },\n                    { x, y },\n                    { x, y: toy }\n                ];\n            }\n        }\n\n        const x = middleOfVerticalSides;\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    }\n    else if (sourceSide === 'left' && targetSide === 'bottom') {\n        if (sox >= tox && soy >= tmy1) {\n            return [{ x: tox, y: soy }];\n        }\n\n        if (sox >= tx1 && soy < toy) {\n            const x = middleOfVerticalSides;\n\n            return [\n                { x, y: soy },\n                { x, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (tox < sx1 && ty1 <= sy0) {\n            const y = middleOfHorizontalSides;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }\n            ];\n        }\n\n        const x = Math.min(tmx0, sox);\n        const y = Math.max(smy1, tmy1);\n\n        return [\n            { x, y: soy },\n            { x, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'top') {\n        if (sox > tox && soy < tmy0) {\n            return [{ x: tox, y: soy }];\n        }\n\n        if (sox >= tx1) {\n            if (soy > toy) {\n                const x = middleOfVerticalSides;\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n        }\n\n        if (tox <= sx1 && toy > soy) {\n            const y = middleOfHorizontalSides;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y },\n            ];\n        }\n\n        const x = toy < soy ? Math.min(smx0, tmx0) : smx0;\n        const y = Math.min(smy0, tmy0);\n\n        return [\n            { x, y: soy },\n            { x, y },\n            { x: tox, y }\n        ];\n\n    } else if (sourceSide === 'right' && targetSide === 'top') {\n        if (sox <= tox && soy < tmy0) {\n            return [{ x: tox, y: soy }];\n        }\n\n        if (sx1 < tx0 && soy > toy) {\n            let x = middleOfVerticalSides;\n\n            return [\n                { x, y: soy },\n                { x, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (tox < sox && ty0 > sy1) {\n            const y = middleOfHorizontalSides;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }\n            ];\n        }\n\n        const x = Math.max(smx1, tmx1);\n        const y = Math.min(smy0, tmy0);\n\n        return [\n            { x, y: soy },\n            { x, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'bottom') {\n        if (sox <= tox && soy >= tmy1) {\n            return [{ x: tox, y: soy }];\n        }\n\n        if (sox <= tmx0 && soy < toy) {\n            const x = middleOfVerticalSides;\n\n            return [\n                { x, y: soy },\n                { x, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (tox > sx0 && ty1 < sy0) {\n            const y = middleOfHorizontalSides;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }\n            ];\n        }\n\n        const x = Math.max(tmx1, sox);\n        const y = Math.max(smy1, tmy1);\n\n        return [\n            { x, y: soy },\n            { x, y },\n            { x: tox, y }\n        ];\n    }\n}\n\nfunction rightAngleRouter(vertices, opt, linkView) {\n    const { sourceDirection = Directions.AUTO, targetDirection = Directions.AUTO } = opt;\n    const margin = opt.margin || 20;\n    const useVertices = opt.useVertices || false;\n\n    const isSourcePort = !!linkView.model.source().port;\n    const sourcePoint = pointDataFromAnchor(linkView.sourceView, linkView.sourceAnchor, linkView.sourceBBox, sourceDirection, isSourcePort, linkView.sourceAnchor, margin);\n\n    const isTargetPort = !!linkView.model.target().port;\n    const targetPoint = pointDataFromAnchor(linkView.targetView, linkView.targetAnchor, linkView.targetBBox, targetDirection, isTargetPort, linkView.targetAnchor, margin);\n\n    let resultVertices = [];\n\n    if (!useVertices || vertices.length === 0) {\n        return simplifyPoints(routeBetweenPoints(sourcePoint, targetPoint));\n    }\n\n    const verticesData = vertices.map((v) => pointDataFromVertex(v));\n    const [firstVertex] = verticesData;\n\n    if (sourcePoint.view && sourcePoint.view.model.isElement() && sourcePoint.view.model.getBBox().inflate(margin).containsPoint(firstVertex.point)) {\n        const [fromDirection] = resolveSides(sourcePoint, firstVertex);\n        const toDirection = fromDirection;\n        const dummySource = pointDataFromVertex(sourcePoint.point);\n        // Points do not usually have margin. Here we create a point with a margin.\n        dummySource.margin = margin;\n        dummySource.direction = fromDirection;\n        firstVertex.direction = toDirection;\n\n        resultVertices.push(...routeBetweenPoints(dummySource, firstVertex), firstVertex.point);\n    } else {\n        // The first point responsible for the initial direction of the route\n        const next = verticesData[1] || targetPoint;\n        const direction = resolveInitialDirection(sourcePoint, firstVertex, next);\n        firstVertex.direction = direction;\n\n        resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex), firstVertex.point);\n    }\n\n    for (let i = 0; i < verticesData.length - 1; i++) {\n        const from = verticesData[i];\n        const to = verticesData[i + 1];\n\n        const segment = new g.Line(from.point, to.point);\n        const segmentAngle = getSegmentAngle(segment);\n        if (segmentAngle % 90 === 0) {\n            // Since the segment is horizontal or vertical, we can skip the routing and just connect them with a straight line\n            const toDirection = ANGLE_DIRECTION_MAP[segmentAngle];\n            const accessDirection = OPPOSITE_DIRECTIONS[toDirection];\n\n            if (toDirection !== from.direction) {\n                resultVertices.push(from.point, to.point);\n                to.direction = accessDirection;\n            } else {\n                const angle = g.normalizeAngle(segmentAngle - 90);\n\n                let dx = 0;\n                let dy = 0;\n\n                if (angle === 90) {\n                    dy = -margin;\n                } else if (angle === 180) {\n                    dx = -margin;\n                } else if (angle === 270) {\n                    dy = margin;\n                } else if (angle === 0) {\n                    dx = margin;\n                }\n\n                const p1 = { x: from.point.x + dx, y: from.point.y + dy };\n                const p2 = { x: to.point.x + dx, y: to.point.y + dy };\n\n                const segment2 = new g.Line(to.point, p2);\n                to.direction = ANGLE_DIRECTION_MAP[getSegmentAngle(segment2)];\n\n                // Constructing a loop\n                resultVertices.push(from.point, p1, p2, to.point);\n            }\n\n            continue;\n        }\n\n        const [fromDirection, toDirection] = resolveDirection(from, to);\n\n        from.direction = fromDirection;\n        to.direction = toDirection;\n\n        resultVertices.push(...routeBetweenPoints(from, to), to.point);\n    }\n\n    const lastVertex = verticesData[verticesData.length - 1];\n\n    if (targetPoint.view && targetPoint.view.model.isElement()) {\n        if (targetPoint.view.model.getBBox().inflate(margin).containsPoint(lastVertex.point)) {\n            const [fromDirection] = resolveDirection(lastVertex, targetPoint);\n            const dummyTarget = pointDataFromVertex(targetPoint.point);\n            const [, toDirection] = resolveSides(lastVertex, targetPoint);\n            // we are creating a point that has a margin\n            dummyTarget.margin = margin;\n            dummyTarget.direction = toDirection;\n            lastVertex.direction = fromDirection;\n\n            resultVertices.push(...routeBetweenPoints(lastVertex, dummyTarget));\n        } else {\n            // the last point of `simplified` array is the last defined vertex\n            // grab the penultimate point and construct a line segment from it to the last vertex\n            // this will ensure that the last segment continues in a straight line\n\n            const simplified = simplifyPoints(resultVertices);\n            const segment = new g.Line(simplified[simplified.length - 2], lastVertex.point);\n            const definedDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(segment))];\n            lastVertex.direction = definedDirection;\n\n            let lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            const [p1, p2] = simplifyPoints([...lastSegmentRoute, targetPoint.point]);\n\n            const lastSegment = new g.Line(p1, p2);\n            const roundedLastSegmentAngle = Math.round(getSegmentAngle(lastSegment));\n            const lastSegmentDirection = ANGLE_DIRECTION_MAP[roundedLastSegmentAngle];\n\n            if (lastSegmentDirection !== definedDirection && definedDirection === OPPOSITE_DIRECTIONS[lastSegmentDirection]) {\n                lastVertex.margin = margin;\n                lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            }\n\n            resultVertices.push(...lastSegmentRoute);\n        }\n    } else {\n        // since the target is only a point we can apply the same logic as if we connected two verticesData\n        const [vertexDirection] = resolveDirection(lastVertex, targetPoint);\n        lastVertex.direction = vertexDirection;\n\n        resultVertices.push(...routeBetweenPoints(lastVertex, targetPoint));\n    }\n\n    return simplifyPoints(resultVertices);\n}\n\nfunction resolveDirection(from, to) {\n    const accessDirection = from.direction;\n    const isDirectionVertical = VERTICAL_DIRECTIONS.includes(accessDirection);\n\n    let sourceDirection = from.direction;\n    let targetDirection = to.direction;\n\n    if (isDirectionVertical) {\n        const isToAbove = from.point.y > to.point.y;\n        const dx = to.point.x - from.point.x;\n\n        if (accessDirection === Directions.BOTTOM) {\n            // If isToAbove === false and we need figure out if to go left or right\n            sourceDirection = isToAbove ? OPPOSITE_DIRECTIONS[accessDirection] : dx >= 0 ? Directions.RIGHT : Directions.LEFT;\n\n            if (dx > 0) {\n                targetDirection = isToAbove ? Directions.LEFT : Directions.TOP;\n            } else if (dx < 0) {\n                targetDirection = isToAbove ? Directions.RIGHT : Directions.TOP;\n            }\n        } else {\n            // If isToAbove === true and we need figure out if to go left or right\n            sourceDirection = isToAbove ? dx >= 0 ? Directions.RIGHT : Directions.LEFT : OPPOSITE_DIRECTIONS[accessDirection];\n\n            if (dx > 0) {\n                targetDirection = isToAbove ? Directions.BOTTOM : Directions.LEFT;\n            } else if (dx < 0) {\n                targetDirection = isToAbove ? Directions.BOTTOM : Directions.RIGHT;\n            }\n        }\n    } else {\n        const isToLeft = from.point.x > to.point.x;\n        const dy = to.point.y - from.point.y;\n\n        if (accessDirection === Directions.RIGHT) {\n            sourceDirection = isToLeft ? OPPOSITE_DIRECTIONS[accessDirection] : dy >= 0 ? Directions.BOTTOM : Directions.TOP;\n\n            if (dy > 0) {\n                targetDirection = isToLeft ? Directions.TOP : Directions.LEFT;\n            } else if (dy < 0) {\n                targetDirection = isToLeft ? Directions.BOTTOM : Directions.LEFT;\n            }\n        } else {\n            sourceDirection = isToLeft ? dy >= 0 ? Directions.BOTTOM : Directions.TOP : OPPOSITE_DIRECTIONS[accessDirection];\n\n            if (dy > 0) {\n                targetDirection = isToLeft ? Directions.RIGHT : Directions.TOP;\n            } else if (dy < 0) {\n                targetDirection = isToLeft ? Directions.RIGHT : Directions.BOTTOM;\n            }\n        }\n    }\n\n    return [sourceDirection, targetDirection];\n}\n\nrightAngleRouter.Directions = Directions;\n\nexport const rightAngle = rightAngleRouter;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}