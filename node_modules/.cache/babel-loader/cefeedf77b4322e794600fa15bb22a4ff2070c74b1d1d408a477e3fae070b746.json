{"ast":null,"code":"import { assign } from '../util/index.mjs';\nimport V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\nexport const stroke = HighlighterView.extend({\n  tagName: 'path',\n  className: 'highlight-stroke',\n  attributes: {\n    'pointer-events': 'none',\n    'fill': 'none'\n  },\n  options: {\n    padding: 3,\n    rx: 0,\n    ry: 0,\n    useFirstSubpath: false,\n    attrs: {\n      'stroke-width': 3,\n      'stroke': '#FEB663'\n    }\n  },\n  getPathData(cellView, node) {\n    const {\n      options\n    } = this;\n    const {\n      useFirstSubpath\n    } = options;\n    let d;\n    try {\n      const vNode = V(node);\n      d = vNode.convertToPathData().trim();\n      if (vNode.tagName() === 'PATH' && useFirstSubpath) {\n        const secondSubpathIndex = d.search(/.M/i) + 1;\n        if (secondSubpathIndex > 0) {\n          d = d.substr(0, secondSubpathIndex);\n        }\n      }\n    } catch (error) {\n      // Failed to get path data from magnet element.\n      // Draw a rectangle around the node instead.\n      const nodeBBox = cellView.getNodeBoundingRect(node);\n      d = V.rectToPath(assign({}, options, nodeBBox.toJSON()));\n    }\n    return d;\n  },\n  highlightConnection(cellView) {\n    this.vel.attr('d', cellView.getSerializedConnection());\n  },\n  highlightNode(cellView, node) {\n    const {\n      vel,\n      options\n    } = this;\n    const {\n      padding,\n      layer\n    } = options;\n    let highlightMatrix = this.getNodeMatrix(cellView, node);\n    // Add padding to the highlight element.\n    if (padding) {\n      if (!layer && node === cellView.el) {\n        // If the highlighter is appended to the cellView\n        // and we measure the size of the cellView wrapping group\n        // it's necessary to remove the highlighter first\n        vel.remove();\n      }\n      let nodeBBox = cellView.getNodeBoundingRect(node);\n      const cx = nodeBBox.x + nodeBBox.width / 2;\n      const cy = nodeBBox.y + nodeBBox.height / 2;\n      nodeBBox = V.transformRect(nodeBBox, highlightMatrix);\n      const width = Math.max(nodeBBox.width, 1);\n      const height = Math.max(nodeBBox.height, 1);\n      const sx = (width + padding) / width;\n      const sy = (height + padding) / height;\n      const paddingMatrix = V.createSVGMatrix({\n        a: sx,\n        b: 0,\n        c: 0,\n        d: sy,\n        e: cx - sx * cx,\n        f: cy - sy * cy\n      });\n      highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n    }\n    vel.attr({\n      'd': this.getPathData(cellView, node),\n      'transform': V.matrixToTransformString(highlightMatrix)\n    });\n  },\n  highlight(cellView, node) {\n    const {\n      vel,\n      options\n    } = this;\n    vel.attr(options.attrs);\n    if (options.nonScalingStroke) {\n      vel.attr('vector-effect', 'non-scaling-stroke');\n    }\n    if (cellView.isNodeConnection(node)) {\n      this.highlightConnection(cellView);\n    } else {\n      this.highlightNode(cellView, node);\n    }\n  }\n});","map":{"version":3,"names":["assign","V","HighlighterView","stroke","extend","tagName","className","attributes","options","padding","rx","ry","useFirstSubpath","attrs","getPathData","cellView","node","d","vNode","convertToPathData","trim","secondSubpathIndex","search","substr","error","nodeBBox","getNodeBoundingRect","rectToPath","toJSON","highlightConnection","vel","attr","getSerializedConnection","highlightNode","layer","highlightMatrix","getNodeMatrix","el","remove","cx","x","width","cy","y","height","transformRect","Math","max","sx","sy","paddingMatrix","createSVGMatrix","a","b","c","e","f","multiply","matrixToTransformString","highlight","nonScalingStroke","isNodeConnection"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/highlighters/stroke.mjs"],"sourcesContent":["import { assign } from '../util/index.mjs';\nimport V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\n\nexport const stroke = HighlighterView.extend({\n\n    tagName: 'path',\n    className: 'highlight-stroke',\n    attributes: {\n        'pointer-events': 'none',\n        'fill': 'none'\n    },\n\n    options: {\n        padding: 3,\n        rx: 0,\n        ry: 0,\n        useFirstSubpath: false,\n        attrs: {\n            'stroke-width': 3,\n            'stroke': '#FEB663'\n        }\n    },\n\n    getPathData(cellView, node) {\n        const { options } = this;\n        const { useFirstSubpath } = options;\n        let d;\n        try {\n            const vNode = V(node);\n            d = vNode.convertToPathData().trim();\n            if (vNode.tagName() === 'PATH' && useFirstSubpath) {\n                const secondSubpathIndex = d.search(/.M/i) + 1;\n                if (secondSubpathIndex > 0) {\n                    d = d.substr(0, secondSubpathIndex);\n                }\n            }\n        } catch (error) {\n            // Failed to get path data from magnet element.\n            // Draw a rectangle around the node instead.\n            const nodeBBox = cellView.getNodeBoundingRect(node);\n            d = V.rectToPath(assign({}, options, nodeBBox.toJSON()));\n        }\n        return d;\n    },\n\n    highlightConnection(cellView) {\n        this.vel.attr('d', cellView.getSerializedConnection());\n    },\n\n    highlightNode(cellView, node) {\n        const { vel, options } = this;\n        const { padding, layer } = options;\n        let highlightMatrix = this.getNodeMatrix(cellView, node);\n        // Add padding to the highlight element.\n        if (padding) {\n            if (!layer && node === cellView.el) {\n                // If the highlighter is appended to the cellView\n                // and we measure the size of the cellView wrapping group\n                // it's necessary to remove the highlighter first\n                vel.remove();\n            }\n            let nodeBBox = cellView.getNodeBoundingRect(node);\n            const cx = nodeBBox.x + (nodeBBox.width / 2);\n            const cy = nodeBBox.y + (nodeBBox.height / 2);\n            nodeBBox = V.transformRect(nodeBBox, highlightMatrix);\n            const width = Math.max(nodeBBox.width, 1);\n            const height = Math.max(nodeBBox.height, 1);\n            const sx = (width + padding) / width;\n            const sy = (height + padding) / height;\n            const paddingMatrix = V.createSVGMatrix({\n                a: sx,\n                b: 0,\n                c: 0,\n                d: sy,\n                e: cx - sx * cx,\n                f: cy - sy * cy\n            });\n            highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n        }\n        vel.attr({\n            'd': this.getPathData(cellView, node),\n            'transform': V.matrixToTransformString(highlightMatrix)\n        });\n    },\n\n    highlight(cellView, node) {\n        const { vel, options } = this;\n        vel.attr(options.attrs);\n        if (options.nonScalingStroke) {\n            vel.attr('vector-effect', 'non-scaling-stroke');\n        }\n        if (cellView.isNodeConnection(node)) {\n            this.highlightConnection(cellView);\n        } else {\n            this.highlightNode(cellView, node);\n        }\n    }\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}