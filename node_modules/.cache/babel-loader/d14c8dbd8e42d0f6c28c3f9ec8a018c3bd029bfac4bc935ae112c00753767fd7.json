{"ast":null,"code":"import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\nimport { orthogonal } from './orthogonal.mjs';\nvar config = {\n  // size of the step to find a route (the grid of the manhattan pathfinder)\n  step: 10,\n  // the number of route finding loops that cause the router to abort\n  // returns fallback route instead\n  maximumLoops: 2000,\n  // the number of decimal places to round floating point coordinates\n  precision: 1,\n  // maximum change of direction\n  maxAllowedDirectionChange: 90,\n  // should the router use perpendicular linkView option?\n  // does not connect anchor of element but rather a point close-by that is orthogonal\n  // this looks much better\n  perpendicular: true,\n  // should the source and/or target not be considered as obstacles?\n  excludeEnds: [],\n  // 'source', 'target'\n\n  // should certain types of elements not be considered as obstacles?\n  excludeTypes: [],\n  // possible starting directions from an element\n  startDirections: ['top', 'right', 'bottom', 'left'],\n  // possible ending directions to an element\n  endDirections: ['top', 'right', 'bottom', 'left'],\n  // specify the directions used above and what they mean\n  directionMap: {\n    top: {\n      x: 0,\n      y: -1\n    },\n    right: {\n      x: 1,\n      y: 0\n    },\n    bottom: {\n      x: 0,\n      y: 1\n    },\n    left: {\n      x: -1,\n      y: 0\n    }\n  },\n  // cost of an orthogonal step\n  cost: function () {\n    return this.step;\n  },\n  // an array of directions to find next points on the route\n  // different from start/end directions\n  directions: function () {\n    var step = this.step;\n    var cost = this.cost();\n    return [{\n      offsetX: step,\n      offsetY: 0,\n      cost: cost\n    }, {\n      offsetX: -step,\n      offsetY: 0,\n      cost: cost\n    }, {\n      offsetX: 0,\n      offsetY: step,\n      cost: cost\n    }, {\n      offsetX: 0,\n      offsetY: -step,\n      cost: cost\n    }];\n  },\n  // a penalty received for direction change\n  penalties: function () {\n    return {\n      0: 0,\n      45: this.step / 2,\n      90: this.step / 2\n    };\n  },\n  // padding applied on the element bounding boxes\n  paddingBox: function () {\n    var step = this.step;\n    return {\n      x: -step,\n      y: -step,\n      width: 2 * step,\n      height: 2 * step\n    };\n  },\n  // A function that determines whether a given point is an obstacle or not.\n  // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.\n  // (point: dia.Point) => boolean;\n  isPointObstacle: null,\n  // a router to use when the manhattan router fails\n  // (one of the partial routes returns null)\n  fallbackRouter: function (vertices, opt, linkView) {\n    if (!util.isFunction(orthogonal)) {\n      throw new Error('Manhattan requires the orthogonal router as default fallback.');\n    }\n    return orthogonal(vertices, util.assign({}, config, opt), linkView);\n  },\n  /* Deprecated */\n  // a simple route used in situations when main routing method fails\n  // (exceed max number of loop iterations, inaccessible)\n  fallbackRoute: function (from, to, opt) {\n    return null; // null result will trigger the fallbackRouter\n\n    // left for reference:\n    /*// Find an orthogonal route ignoring obstacles.\n     var point = ((opt.previousDirAngle || 0) % 180 === 0)\n            ? new g.Point(from.x, to.y)\n            : new g.Point(to.x, from.y);\n     return [point];*/\n  },\n  // if a function is provided, it's used to route the link while dragging an end\n  // i.e. function(from, to, opt) { return []; }\n  draggingRoute: null\n};\n\n// HELPER CLASSES //\n\n// Map of obstacles\n// Helper structure to identify whether a point lies inside an obstacle.\nfunction ObstacleMap(opt) {\n  this.map = {};\n  this.options = opt;\n  // tells how to divide the paper when creating the elements map\n  this.mapGridSize = 100;\n}\nObstacleMap.prototype.build = function (graph, link) {\n  var opt = this.options;\n\n  // source or target element could be excluded from set of obstacles\n  var excludedEnds = util.toArray(opt.excludeEnds).reduce(function (res, item) {\n    var end = link.get(item);\n    if (end) {\n      var cell = graph.getCell(end.id);\n      if (cell) {\n        res.push(cell);\n      }\n    }\n    return res;\n  }, []);\n\n  // Exclude any embedded elements from the source and the target element.\n  var excludedAncestors = [];\n  var source = graph.getCell(link.get('source').id);\n  if (source) {\n    excludedAncestors = util.union(excludedAncestors, source.getAncestors().map(function (cell) {\n      return cell.id;\n    }));\n  }\n  var target = graph.getCell(link.get('target').id);\n  if (target) {\n    excludedAncestors = util.union(excludedAncestors, target.getAncestors().map(function (cell) {\n      return cell.id;\n    }));\n  }\n\n  // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n  // in any obstacle?) (a simplified grid search).\n  // The paper is divided into smaller cells, where each holds information about which\n  // elements belong to it. When we query whether a point lies inside an obstacle we\n  // don't need to go through all obstacles, we check only those in a particular cell.\n  var mapGridSize = this.mapGridSize;\n  graph.getElements().reduce(function (map, element) {\n    var isExcludedType = util.toArray(opt.excludeTypes).includes(element.get('type'));\n    var isExcludedEnd = excludedEnds.find(function (excluded) {\n      return excluded.id === element.id;\n    });\n    var isExcludedAncestor = excludedAncestors.includes(element.id);\n    var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n    if (!isExcluded) {\n      var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n      var origin = bbox.origin().snapToGrid(mapGridSize);\n      var corner = bbox.corner().snapToGrid(mapGridSize);\n      for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n        for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n          var gridKey = x + '@' + y;\n          map[gridKey] = map[gridKey] || [];\n          map[gridKey].push(bbox);\n        }\n      }\n    }\n    return map;\n  }, this.map);\n  return this;\n};\nObstacleMap.prototype.isPointAccessible = function (point) {\n  var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n  return util.toArray(this.map[mapKey]).every(function (obstacle) {\n    return !obstacle.containsPoint(point);\n  });\n};\n\n// Sorted Set\n// Set of items sorted by given value.\nfunction SortedSet() {\n  this.items = [];\n  this.hash = {};\n  this.values = {};\n  this.OPEN = 1;\n  this.CLOSE = 2;\n}\nSortedSet.prototype.add = function (item, value) {\n  if (this.hash[item]) {\n    // item removal\n    this.items.splice(this.items.indexOf(item), 1);\n  } else {\n    this.hash[item] = this.OPEN;\n  }\n  this.values[item] = value;\n  var index = util.sortedIndex(this.items, item, function (i) {\n    return this.values[i];\n  }.bind(this));\n  this.items.splice(index, 0, item);\n};\nSortedSet.prototype.remove = function (item) {\n  this.hash[item] = this.CLOSE;\n};\nSortedSet.prototype.isOpen = function (item) {\n  return this.hash[item] === this.OPEN;\n};\nSortedSet.prototype.isClose = function (item) {\n  return this.hash[item] === this.CLOSE;\n};\nSortedSet.prototype.isEmpty = function () {\n  return this.items.length === 0;\n};\nSortedSet.prototype.pop = function () {\n  var item = this.items.shift();\n  this.remove(item);\n  return item;\n};\n\n// HELPERS //\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n  // expand by padding box\n  if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);\n  return linkView.sourceBBox.clone();\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n  // expand by padding box\n  if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);\n  return linkView.targetBBox.clone();\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n  if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n  // fallback: center of bbox\n  var sourceBBox = getSourceBBox(linkView, opt);\n  return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n  if (linkView.targetAnchor) return linkView.targetAnchor;\n\n  // fallback: center of bbox\n  var targetBBox = getTargetBBox(linkView, opt);\n  return targetBBox.center(); // default\n}\n\n// returns a direction index from start point to end point\n// corrects for grid deformation between start and end\nfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n  var quadrant = 360 / numDirections;\n  var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n  var normalizedAngle = g.normalizeAngle(angleTheta + quadrant / 2);\n  return quadrant * Math.floor(normalizedAngle / quadrant);\n}\n\n// helper function for getDirectionAngle()\n// corrects for grid deformation\n// (if a point is one grid steps away from another in both dimensions,\n// it is considered to be 45 degrees away, even if the real angle is different)\n// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\nfunction fixAngleEnd(start, end, grid, opt) {\n  var step = opt.step;\n  var diffX = end.x - start.x;\n  var diffY = end.y - start.y;\n  var gridStepsX = diffX / grid.x;\n  var gridStepsY = diffY / grid.y;\n  var distanceX = gridStepsX * step;\n  var distanceY = gridStepsY * step;\n  return new g.Point(start.x + distanceX, start.y + distanceY);\n}\n\n// return the change in direction between two direction angles\nfunction getDirectionChange(angle1, angle2) {\n  var directionChange = Math.abs(angle1 - angle2);\n  return directionChange > 180 ? 360 - directionChange : directionChange;\n}\n\n// fix direction offsets according to current grid\nfunction getGridOffsets(directions, grid, opt) {\n  var step = opt.step;\n  util.toArray(opt.directions).forEach(function (direction) {\n    direction.gridOffsetX = direction.offsetX / step * grid.x;\n    direction.gridOffsetY = direction.offsetY / step * grid.y;\n  });\n}\n\n// get grid size in x and y dimensions, adapted to source and target positions\nfunction getGrid(step, source, target) {\n  return {\n    source: source.clone(),\n    x: getGridDimension(target.x - source.x, step),\n    y: getGridDimension(target.y - source.y, step)\n  };\n}\n\n// helper function for getGrid()\nfunction getGridDimension(diff, step) {\n  // return step if diff = 0\n  if (!diff) return step;\n  var absDiff = Math.abs(diff);\n  var numSteps = Math.round(absDiff / step);\n\n  // return absDiff if less than one step apart\n  if (!numSteps) return absDiff;\n\n  // otherwise, return corrected step\n  var roundedDiff = numSteps * step;\n  var remainder = absDiff - roundedDiff;\n  var stepCorrection = remainder / numSteps;\n  return step + stepCorrection;\n}\n\n// return a clone of point snapped to grid\nfunction snapToGrid(point, grid) {\n  var source = grid.source;\n  var snappedX = g.snapToGrid(point.x - source.x, grid.x) + source.x;\n  var snappedY = g.snapToGrid(point.y - source.y, grid.y) + source.y;\n  return new g.Point(snappedX, snappedY);\n}\n\n// round the point to opt.precision\nfunction round(point, precision) {\n  return point.round(precision);\n}\n\n// snap to grid and then round the point\nfunction align(point, grid, precision) {\n  return round(snapToGrid(point.clone(), grid), precision);\n}\n\n// return a string representing the point\n// string is rounded in both dimensions\nfunction getKey(point) {\n  return point.clone().toString();\n}\n\n// return a normalized vector from given point\n// used to determine the direction of a difference of two points\nfunction normalizePoint(point) {\n  return new g.Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);\n}\n\n// PATHFINDING //\n\n// reconstructs a route by concatenating points with their parents\nfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n  var route = [];\n  var prevDiff = normalizePoint(to.difference(tailPoint));\n\n  // tailPoint is assumed to be aligned already\n  var currentKey = getKey(tailPoint);\n  var parent = parents[currentKey];\n  var point;\n  while (parent) {\n    // point is assumed to be aligned already\n    point = points[currentKey];\n    var diff = normalizePoint(point.difference(parent));\n    if (!diff.equals(prevDiff)) {\n      route.unshift(point);\n      prevDiff = diff;\n    }\n\n    // parent is assumed to be aligned already\n    currentKey = getKey(parent);\n    parent = parents[currentKey];\n  }\n\n  // leadPoint is assumed to be aligned already\n  var leadPoint = points[currentKey];\n  var fromDiff = normalizePoint(leadPoint.difference(from));\n  if (!fromDiff.equals(prevDiff)) {\n    route.unshift(leadPoint);\n  }\n  return route;\n}\n\n// heuristic method to determine the distance between two points\nfunction estimateCost(from, endPoints) {\n  var min = Infinity;\n  for (var i = 0, len = endPoints.length; i < len; i++) {\n    var cost = from.manhattanDistance(endPoints[i]);\n    if (cost < min) min = cost;\n  }\n  return min;\n}\n\n// find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\nfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n  var precision = opt.precision;\n  var directionMap = opt.directionMap;\n  var anchorCenterVector = anchor.difference(bbox.center());\n  var keys = util.isObject(directionMap) ? Object.keys(directionMap) : [];\n  var dirList = util.toArray(directionList);\n  var rectPoints = keys.reduce(function (res, key) {\n    if (dirList.includes(key)) {\n      var direction = directionMap[key];\n\n      // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n      // even if anchor lies outside of bbox\n      var endpoint = new g.Point(anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height));\n      var intersectionLine = new g.Line(anchor, endpoint);\n\n      // get the farther intersection, in case there are two\n      // (that happens if anchor lies next to bbox)\n      var intersections = intersectionLine.intersect(bbox) || [];\n      var numIntersections = intersections.length;\n      var farthestIntersectionDistance;\n      var farthestIntersection = null;\n      for (var i = 0; i < numIntersections; i++) {\n        var currentIntersection = intersections[i];\n        var distance = anchor.squaredDistance(currentIntersection);\n        if (farthestIntersectionDistance === undefined || distance > farthestIntersectionDistance) {\n          farthestIntersectionDistance = distance;\n          farthestIntersection = currentIntersection;\n        }\n      }\n\n      // if an intersection was found in this direction, it is our rectPoint\n      if (farthestIntersection) {\n        var point = align(farthestIntersection, grid, precision);\n\n        // if the rectPoint lies inside the bbox, offset it by one more step\n        if (bbox.containsPoint(point)) {\n          point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n        }\n\n        // then add the point to the result array\n        // aligned\n        res.push(point);\n      }\n    }\n    return res;\n  }, []);\n\n  // if anchor lies outside of bbox, add it to the array of points\n  if (!bbox.containsPoint(anchor)) {\n    // aligned\n    rectPoints.push(align(anchor, grid, precision));\n  }\n  return rectPoints;\n}\n\n// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n// rectangles get rect points assigned by getRectPoints()\nfunction findRoute(from, to, isPointObstacle, opt) {\n  var precision = opt.precision;\n\n  // Get grid for this route.\n\n  var sourceAnchor, targetAnchor;\n  if (from instanceof g.Rect) {\n    // `from` is sourceBBox\n    sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);\n  } else {\n    sourceAnchor = round(from.clone(), precision);\n  }\n  if (to instanceof g.Rect) {\n    // `to` is targetBBox\n    targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);\n  } else {\n    targetAnchor = round(to.clone(), precision);\n  }\n  var grid = getGrid(opt.step, sourceAnchor, targetAnchor);\n\n  // Get pathfinding points.\n\n  var start, end; // aligned with grid by definition\n  var startPoints, endPoints; // assumed to be aligned with grid already\n\n  // set of points we start pathfinding from\n  if (from instanceof g.Rect) {\n    // `from` is sourceBBox\n    start = sourceAnchor;\n    startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n  } else {\n    start = sourceAnchor;\n    startPoints = [start];\n  }\n\n  // set of points we want the pathfinding to finish at\n  if (to instanceof g.Rect) {\n    // `to` is targetBBox\n    end = targetAnchor;\n    endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n  } else {\n    end = targetAnchor;\n    endPoints = [end];\n  }\n\n  // take into account only accessible rect points (those not under obstacles)\n  startPoints = startPoints.filter(p => !isPointObstacle(p));\n  endPoints = endPoints.filter(p => !isPointObstacle(p));\n\n  // Check that there is an accessible route point on both sides.\n  // Otherwise, use fallbackRoute().\n  if (startPoints.length > 0 && endPoints.length > 0) {\n    // The set of tentative points to be evaluated, initially containing the start points.\n    // Rounded to nearest integer for simplicity.\n    var openSet = new SortedSet();\n    // Keeps reference to actual points for given elements of the open set.\n    var points = {};\n    // Keeps reference to a point that is immediate predecessor of given element.\n    var parents = {};\n    // Cost from start to a point along best known path.\n    var costs = {};\n    for (var i = 0, n = startPoints.length; i < n; i++) {\n      // startPoint is assumed to be aligned already\n      var startPoint = startPoints[i];\n      var key = getKey(startPoint);\n      openSet.add(key, estimateCost(startPoint, endPoints));\n      points[key] = startPoint;\n      costs[key] = 0;\n    }\n    var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n    var isPathBeginning = previousRouteDirectionAngle === undefined;\n\n    // directions\n    var direction, directionChange;\n    var directions = opt.directions;\n    getGridOffsets(directions, grid, opt);\n    var numDirections = directions.length;\n    var endPointsKeys = util.toArray(endPoints).reduce(function (res, endPoint) {\n      // endPoint is assumed to be aligned already\n\n      var key = getKey(endPoint);\n      res.push(key);\n      return res;\n    }, []);\n\n    // main route finding loop\n    var loopsRemaining = opt.maximumLoops;\n    while (!openSet.isEmpty() && loopsRemaining > 0) {\n      // remove current from the open list\n      var currentKey = openSet.pop();\n      var currentPoint = points[currentKey];\n      var currentParent = parents[currentKey];\n      var currentCost = costs[currentKey];\n      var isRouteBeginning = currentParent === undefined; // undefined for route starts\n      var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n\n      var previousDirectionAngle;\n      if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route\n      else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path\n      else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point\n      else previousDirectionAngle = null; // beginning of path, source anchor or `from` point\n\n      // check if we reached any endpoint\n      var samePoints = startPoints.length === endPoints.length;\n      if (samePoints) {\n        for (var j = 0; j < startPoints.length; j++) {\n          if (!startPoints[j].equals(endPoints[j])) {\n            samePoints = false;\n            break;\n          }\n        }\n      }\n      var skipEndCheck = isRouteBeginning && samePoints;\n      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n        opt.previousDirectionAngle = previousDirectionAngle;\n        return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n      }\n\n      // go over all possible directions and find neighbors\n      for (i = 0; i < numDirections; i++) {\n        direction = directions[i];\n        var directionAngle = direction.angle;\n        directionChange = getDirectionChange(previousDirectionAngle, directionAngle);\n\n        // if the direction changed rapidly, don't use this point\n        // any direction is allowed for starting points\n        if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;\n        var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n        var neighborKey = getKey(neighborPoint);\n\n        // Closed points from the openSet were already evaluated.\n        if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;\n\n        // We can only enter end points at an acceptable angle.\n        if (endPointsKeys.indexOf(neighborKey) >= 0) {\n          // neighbor is an end point\n\n          var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n\n          if (!isNeighborEnd) {\n            var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n            var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n            if (endDirectionChange > opt.maxAllowedDirectionChange) continue;\n          }\n        }\n\n        // The current direction is ok.\n\n        var neighborCost = direction.cost;\n        var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n        var costFromStart = currentCost + neighborCost + neighborPenalty;\n        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n          // neighbor point has not been processed yet\n          // or the cost of the path from start is lower than previously calculated\n\n          points[neighborKey] = neighborPoint;\n          parents[neighborKey] = currentPoint;\n          costs[neighborKey] = costFromStart;\n          openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n        }\n      }\n      loopsRemaining--;\n    }\n  }\n\n  // no route found (`to` point either wasn't accessible or finding route took\n  // way too much calculation)\n  return opt.fallbackRoute.call(this, start, end, opt);\n}\n\n// resolve some of the options\nfunction resolveOptions(opt) {\n  opt.directions = util.result(opt, 'directions');\n  opt.penalties = util.result(opt, 'penalties');\n  opt.paddingBox = util.result(opt, 'paddingBox');\n  opt.padding = util.result(opt, 'padding');\n  if (opt.padding) {\n    // if both provided, opt.padding wins over opt.paddingBox\n    var sides = util.normalizeSides(opt.padding);\n    opt.paddingBox = {\n      x: -sides.left,\n      y: -sides.top,\n      width: sides.left + sides.right,\n      height: sides.top + sides.bottom\n    };\n  }\n  util.toArray(opt.directions).forEach(function (direction) {\n    var point1 = new g.Point(0, 0);\n    var point2 = new g.Point(direction.offsetX, direction.offsetY);\n    direction.angle = g.normalizeAngle(point1.theta(point2));\n  });\n}\n\n// initialization of the route finding\nfunction router(vertices, opt, linkView) {\n  resolveOptions(opt);\n\n  // enable/disable linkView perpendicular option\n  linkView.options.perpendicular = !!opt.perpendicular;\n  var sourceBBox = getSourceBBox(linkView, opt);\n  var targetBBox = getTargetBBox(linkView, opt);\n  var sourceAnchor = getSourceAnchor(linkView, opt);\n  //var targetAnchor = getTargetAnchor(linkView, opt);\n\n  // pathfinding\n  let isPointObstacle;\n  if (typeof opt.isPointObstacle === 'function') {\n    isPointObstacle = opt.isPointObstacle;\n  } else {\n    const map = new ObstacleMap(opt);\n    map.build(linkView.paper.model, linkView.model);\n    isPointObstacle = point => !map.isPointAccessible(point);\n  }\n  var oldVertices = util.toArray(vertices).map(g.Point);\n  var newVertices = [];\n  var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n\n  // find a route by concatenating all partial routes (routes need to pass through vertices)\n  // source -> vertex[1] -> ... -> vertex[n] -> target\n  var to, from;\n  for (var i = 0, len = oldVertices.length; i <= len; i++) {\n    var partialRoute = null;\n    from = to || sourceBBox;\n    to = oldVertices[i];\n    if (!to) {\n      // this is the last iteration\n      // we ran through all vertices in oldVertices\n      // 'to' is not a vertex.\n\n      to = targetBBox;\n\n      // If the target is a point (i.e. it's not an element), we\n      // should use dragging route instead of main routing method if it has been provided.\n      var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;\n      if (isEndingAtPoint && util.isFunction(opt.draggingRoute)) {\n        // Make sure we are passing points only (not rects).\n        var dragFrom = from === sourceBBox ? sourceAnchor : from;\n        var dragTo = to.origin();\n        partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n      }\n    }\n\n    // if partial route has not been calculated yet use the main routing method to find one\n    partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);\n    if (partialRoute === null) {\n      // the partial route cannot be found\n      return opt.fallbackRouter(vertices, opt, linkView);\n    }\n    var leadPoint = partialRoute[0];\n\n    // remove the first point if the previous partial route had the same point as last\n    if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();\n\n    // save tailPoint for next iteration\n    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n    Array.prototype.push.apply(newVertices, partialRoute);\n  }\n  return newVertices;\n}\n\n// public function\nexport const manhattan = function (vertices, opt, linkView) {\n  return router(vertices, util.assign({}, config, opt), linkView);\n};","map":{"version":3,"names":["g","util","orthogonal","config","step","maximumLoops","precision","maxAllowedDirectionChange","perpendicular","excludeEnds","excludeTypes","startDirections","endDirections","directionMap","top","x","y","right","bottom","left","cost","directions","offsetX","offsetY","penalties","paddingBox","width","height","isPointObstacle","fallbackRouter","vertices","opt","linkView","isFunction","Error","assign","fallbackRoute","from","to","draggingRoute","ObstacleMap","map","options","mapGridSize","prototype","build","graph","link","excludedEnds","toArray","reduce","res","item","end","get","cell","getCell","id","push","excludedAncestors","source","union","getAncestors","target","getElements","element","isExcludedType","includes","isExcludedEnd","find","excluded","isExcludedAncestor","isExcluded","bbox","getBBox","moveAndExpand","origin","snapToGrid","corner","gridKey","isPointAccessible","point","mapKey","clone","toString","every","obstacle","containsPoint","SortedSet","items","hash","values","OPEN","CLOSE","add","value","splice","indexOf","index","sortedIndex","i","bind","remove","isOpen","isClose","isEmpty","length","pop","shift","getSourceBBox","sourceBBox","getTargetBBox","targetBBox","getSourceAnchor","sourceAnchor","center","getTargetAnchor","targetAnchor","getDirectionAngle","start","numDirections","grid","quadrant","angleTheta","theta","fixAngleEnd","normalizedAngle","normalizeAngle","Math","floor","diffX","diffY","gridStepsX","gridStepsY","distanceX","distanceY","Point","getDirectionChange","angle1","angle2","directionChange","abs","getGridOffsets","forEach","direction","gridOffsetX","gridOffsetY","getGrid","getGridDimension","diff","absDiff","numSteps","round","roundedDiff","remainder","stepCorrection","snappedX","snappedY","align","getKey","normalizePoint","reconstructRoute","parents","points","tailPoint","route","prevDiff","difference","currentKey","parent","equals","unshift","leadPoint","fromDiff","estimateCost","endPoints","min","Infinity","len","manhattanDistance","getRectPoints","anchor","directionList","anchorCenterVector","keys","isObject","Object","dirList","rectPoints","key","endpoint","intersectionLine","Line","intersections","intersect","numIntersections","farthestIntersectionDistance","farthestIntersection","currentIntersection","distance","squaredDistance","undefined","offset","findRoute","Rect","startPoints","filter","p","openSet","costs","n","startPoint","previousRouteDirectionAngle","previousDirectionAngle","isPathBeginning","endPointsKeys","endPoint","loopsRemaining","currentPoint","currentParent","currentCost","isRouteBeginning","isStart","samePoints","j","skipEndCheck","directionAngle","angle","neighborPoint","neighborKey","isNeighborEnd","endDirectionAngle","endDirectionChange","neighborCost","neighborPenalty","costFromStart","call","resolveOptions","result","padding","sides","normalizeSides","point1","point2","router","paper","model","oldVertices","newVertices","partialRoute","isEndingAtPoint","dragFrom","dragTo","Array","apply","manhattan"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/routers/manhattan.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\nimport { orthogonal } from './orthogonal.mjs';\n\nvar config = {\n\n    // size of the step to find a route (the grid of the manhattan pathfinder)\n    step: 10,\n\n    // the number of route finding loops that cause the router to abort\n    // returns fallback route instead\n    maximumLoops: 2000,\n\n    // the number of decimal places to round floating point coordinates\n    precision: 1,\n\n    // maximum change of direction\n    maxAllowedDirectionChange: 90,\n\n    // should the router use perpendicular linkView option?\n    // does not connect anchor of element but rather a point close-by that is orthogonal\n    // this looks much better\n    perpendicular: true,\n\n    // should the source and/or target not be considered as obstacles?\n    excludeEnds: [], // 'source', 'target'\n\n    // should certain types of elements not be considered as obstacles?\n    excludeTypes: [],\n\n    // possible starting directions from an element\n    startDirections: ['top', 'right', 'bottom', 'left'],\n\n    // possible ending directions to an element\n    endDirections: ['top', 'right', 'bottom', 'left'],\n\n    // specify the directions used above and what they mean\n    directionMap: {\n        top: { x: 0, y: -1 },\n        right: { x: 1, y: 0 },\n        bottom: { x: 0, y: 1 },\n        left: { x: -1, y: 0 }\n    },\n\n    // cost of an orthogonal step\n    cost: function() {\n\n        return this.step;\n    },\n\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n\n        var step = this.step;\n        var cost = this.cost();\n\n        return [\n            { offsetX: step, offsetY: 0, cost: cost },\n            { offsetX: -step, offsetY: 0, cost: cost },\n            { offsetX: 0, offsetY: step, cost: cost },\n            { offsetX: 0, offsetY: -step, cost: cost }\n        ];\n    },\n\n    // a penalty received for direction change\n    penalties: function() {\n\n        return {\n            0: 0,\n            45: this.step / 2,\n            90: this.step / 2\n        };\n    },\n\n    // padding applied on the element bounding boxes\n    paddingBox: function() {\n\n        var step = this.step;\n\n        return {\n            x: -step,\n            y: -step,\n            width: 2 * step,\n            height: 2 * step\n        };\n    },\n\n    // A function that determines whether a given point is an obstacle or not.\n    // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.\n    // (point: dia.Point) => boolean;\n    isPointObstacle: null,\n\n    // a router to use when the manhattan router fails\n    // (one of the partial routes returns null)\n    fallbackRouter: function(vertices, opt, linkView) {\n\n        if (!util.isFunction(orthogonal)) {\n            throw new Error('Manhattan requires the orthogonal router as default fallback.');\n        }\n\n        return orthogonal(vertices, util.assign({}, config, opt), linkView);\n    },\n\n    /* Deprecated */\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n\n        return null; // null result will trigger the fallbackRouter\n\n        // left for reference:\n        /*// Find an orthogonal route ignoring obstacles.\n\n        var point = ((opt.previousDirAngle || 0) % 180 === 0)\n                ? new g.Point(from.x, to.y)\n                : new g.Point(to.x, from.y);\n\n        return [point];*/\n    },\n\n    // if a function is provided, it's used to route the link while dragging an end\n    // i.e. function(from, to, opt) { return []; }\n    draggingRoute: null\n};\n\n// HELPER CLASSES //\n\n// Map of obstacles\n// Helper structure to identify whether a point lies inside an obstacle.\nfunction ObstacleMap(opt) {\n\n    this.map = {};\n    this.options = opt;\n    // tells how to divide the paper when creating the elements map\n    this.mapGridSize = 100;\n}\n\nObstacleMap.prototype.build = function(graph, link) {\n\n    var opt = this.options;\n\n    // source or target element could be excluded from set of obstacles\n    var excludedEnds = util.toArray(opt.excludeEnds).reduce(function(res, item) {\n\n        var end = link.get(item);\n        if (end) {\n            var cell = graph.getCell(end.id);\n            if (cell) {\n                res.push(cell);\n            }\n        }\n\n        return res;\n    }, []);\n\n    // Exclude any embedded elements from the source and the target element.\n    var excludedAncestors = [];\n\n    var source = graph.getCell(link.get('source').id);\n    if (source) {\n        excludedAncestors = util.union(excludedAncestors, source.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n\n    var target = graph.getCell(link.get('target').id);\n    if (target) {\n        excludedAncestors = util.union(excludedAncestors, target.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n\n    // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n    // in any obstacle?) (a simplified grid search).\n    // The paper is divided into smaller cells, where each holds information about which\n    // elements belong to it. When we query whether a point lies inside an obstacle we\n    // don't need to go through all obstacles, we check only those in a particular cell.\n    var mapGridSize = this.mapGridSize;\n\n    graph.getElements().reduce(function(map, element) {\n\n        var isExcludedType = util.toArray(opt.excludeTypes).includes(element.get('type'));\n        var isExcludedEnd = excludedEnds.find(function(excluded) {\n            return excluded.id === element.id;\n        });\n        var isExcludedAncestor = excludedAncestors.includes(element.id);\n\n        var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n        if (!isExcluded) {\n            var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n\n            var origin = bbox.origin().snapToGrid(mapGridSize);\n            var corner = bbox.corner().snapToGrid(mapGridSize);\n\n            for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n                for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n                    var gridKey = x + '@' + y;\n                    map[gridKey] = map[gridKey] || [];\n                    map[gridKey].push(bbox);\n                }\n            }\n        }\n\n        return map;\n    }, this.map);\n\n    return this;\n};\n\nObstacleMap.prototype.isPointAccessible = function(point) {\n\n    var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n\n    return util.toArray(this.map[mapKey]).every(function(obstacle) {\n        return !obstacle.containsPoint(point);\n    });\n};\n\n// Sorted Set\n// Set of items sorted by given value.\nfunction SortedSet() {\n    this.items = [];\n    this.hash = {};\n    this.values = {};\n    this.OPEN = 1;\n    this.CLOSE = 2;\n}\n\nSortedSet.prototype.add = function(item, value) {\n\n    if (this.hash[item]) {\n        // item removal\n        this.items.splice(this.items.indexOf(item), 1);\n    } else {\n        this.hash[item] = this.OPEN;\n    }\n\n    this.values[item] = value;\n\n    var index = util.sortedIndex(this.items, item, function(i) {\n        return this.values[i];\n    }.bind(this));\n\n    this.items.splice(index, 0, item);\n};\n\nSortedSet.prototype.remove = function(item) {\n\n    this.hash[item] = this.CLOSE;\n};\n\nSortedSet.prototype.isOpen = function(item) {\n\n    return this.hash[item] === this.OPEN;\n};\n\nSortedSet.prototype.isClose = function(item) {\n\n    return this.hash[item] === this.CLOSE;\n};\n\nSortedSet.prototype.isEmpty = function() {\n\n    return this.items.length === 0;\n};\n\nSortedSet.prototype.pop = function() {\n\n    var item = this.items.shift();\n    this.remove(item);\n    return item;\n};\n\n// HELPERS //\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);\n\n    return linkView.sourceBBox.clone();\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);\n\n    return linkView.targetBBox.clone();\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n\n// returns a direction index from start point to end point\n// corrects for grid deformation between start and end\nfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n\n    var quadrant = 360 / numDirections;\n    var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n    var normalizedAngle = g.normalizeAngle(angleTheta + (quadrant / 2));\n    return quadrant * Math.floor(normalizedAngle / quadrant);\n}\n\n// helper function for getDirectionAngle()\n// corrects for grid deformation\n// (if a point is one grid steps away from another in both dimensions,\n// it is considered to be 45 degrees away, even if the real angle is different)\n// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\nfunction fixAngleEnd(start, end, grid, opt) {\n\n    var step = opt.step;\n\n    var diffX = end.x - start.x;\n    var diffY = end.y - start.y;\n\n    var gridStepsX = diffX / grid.x;\n    var gridStepsY = diffY / grid.y;\n\n    var distanceX = gridStepsX * step;\n    var distanceY = gridStepsY * step;\n\n    return new g.Point(start.x + distanceX, start.y + distanceY);\n}\n\n// return the change in direction between two direction angles\nfunction getDirectionChange(angle1, angle2) {\n\n    var directionChange = Math.abs(angle1 - angle2);\n    return (directionChange > 180) ? (360 - directionChange) : directionChange;\n}\n\n// fix direction offsets according to current grid\nfunction getGridOffsets(directions, grid, opt) {\n\n    var step = opt.step;\n\n    util.toArray(opt.directions).forEach(function(direction) {\n\n        direction.gridOffsetX = (direction.offsetX / step) * grid.x;\n        direction.gridOffsetY = (direction.offsetY / step) * grid.y;\n    });\n}\n\n// get grid size in x and y dimensions, adapted to source and target positions\nfunction getGrid(step, source, target) {\n\n    return {\n        source: source.clone(),\n        x: getGridDimension(target.x - source.x, step),\n        y: getGridDimension(target.y - source.y, step)\n    };\n}\n\n// helper function for getGrid()\nfunction getGridDimension(diff, step) {\n\n    // return step if diff = 0\n    if (!diff) return step;\n\n    var absDiff = Math.abs(diff);\n    var numSteps = Math.round(absDiff / step);\n\n    // return absDiff if less than one step apart\n    if (!numSteps) return absDiff;\n\n    // otherwise, return corrected step\n    var roundedDiff = numSteps * step;\n    var remainder = absDiff - roundedDiff;\n    var stepCorrection = remainder / numSteps;\n\n    return step + stepCorrection;\n}\n\n// return a clone of point snapped to grid\nfunction snapToGrid(point, grid) {\n\n    var source = grid.source;\n\n    var snappedX = g.snapToGrid(point.x - source.x, grid.x) + source.x;\n    var snappedY = g.snapToGrid(point.y - source.y, grid.y) + source.y;\n\n    return new g.Point(snappedX, snappedY);\n}\n\n// round the point to opt.precision\nfunction round(point, precision) {\n\n    return point.round(precision);\n}\n\n// snap to grid and then round the point\nfunction align(point, grid, precision) {\n\n    return round(snapToGrid(point.clone(), grid), precision);\n}\n\n// return a string representing the point\n// string is rounded in both dimensions\nfunction getKey(point) {\n\n    return point.clone().toString();\n}\n\n// return a normalized vector from given point\n// used to determine the direction of a difference of two points\nfunction normalizePoint(point) {\n\n    return new g.Point(\n        point.x === 0 ? 0 : Math.abs(point.x) / point.x,\n        point.y === 0 ? 0 : Math.abs(point.y) / point.y\n    );\n}\n\n// PATHFINDING //\n\n// reconstructs a route by concatenating points with their parents\nfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n\n    var route = [];\n\n    var prevDiff = normalizePoint(to.difference(tailPoint));\n\n    // tailPoint is assumed to be aligned already\n    var currentKey = getKey(tailPoint);\n    var parent = parents[currentKey];\n\n    var point;\n    while (parent) {\n\n        // point is assumed to be aligned already\n        point = points[currentKey];\n\n        var diff = normalizePoint(point.difference(parent));\n        if (!diff.equals(prevDiff)) {\n            route.unshift(point);\n            prevDiff = diff;\n        }\n\n        // parent is assumed to be aligned already\n        currentKey = getKey(parent);\n        parent = parents[currentKey];\n    }\n\n    // leadPoint is assumed to be aligned already\n    var leadPoint = points[currentKey];\n\n    var fromDiff = normalizePoint(leadPoint.difference(from));\n    if (!fromDiff.equals(prevDiff)) {\n        route.unshift(leadPoint);\n    }\n\n    return route;\n}\n\n// heuristic method to determine the distance between two points\nfunction estimateCost(from, endPoints) {\n\n    var min = Infinity;\n\n    for (var i = 0, len = endPoints.length; i < len; i++) {\n        var cost = from.manhattanDistance(endPoints[i]);\n        if (cost < min) min = cost;\n    }\n\n    return min;\n}\n\n// find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\nfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n\n    var precision = opt.precision;\n    var directionMap = opt.directionMap;\n\n    var anchorCenterVector = anchor.difference(bbox.center());\n\n    var keys = util.isObject(directionMap) ? Object.keys(directionMap) : [];\n    var dirList = util.toArray(directionList);\n    var rectPoints = keys.reduce(function(res, key) {\n\n        if (dirList.includes(key)) {\n            var direction = directionMap[key];\n\n            // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n            // even if anchor lies outside of bbox\n            var endpoint = new g.Point(\n                anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width),\n                anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height)\n            );\n            var intersectionLine = new g.Line(anchor, endpoint);\n\n            // get the farther intersection, in case there are two\n            // (that happens if anchor lies next to bbox)\n            var intersections = intersectionLine.intersect(bbox) || [];\n            var numIntersections = intersections.length;\n            var farthestIntersectionDistance;\n            var farthestIntersection = null;\n            for (var i = 0; i < numIntersections; i++) {\n                var currentIntersection = intersections[i];\n                var distance = anchor.squaredDistance(currentIntersection);\n                if ((farthestIntersectionDistance === undefined) || (distance > farthestIntersectionDistance)) {\n                    farthestIntersectionDistance = distance;\n                    farthestIntersection = currentIntersection;\n                }\n            }\n\n            // if an intersection was found in this direction, it is our rectPoint\n            if (farthestIntersection) {\n                var point = align(farthestIntersection, grid, precision);\n\n                // if the rectPoint lies inside the bbox, offset it by one more step\n                if (bbox.containsPoint(point)) {\n                    point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n                }\n\n                // then add the point to the result array\n                // aligned\n                res.push(point);\n            }\n        }\n\n        return res;\n    }, []);\n\n    // if anchor lies outside of bbox, add it to the array of points\n    if (!bbox.containsPoint(anchor)) {\n        // aligned\n        rectPoints.push(align(anchor, grid, precision));\n    }\n\n    return rectPoints;\n}\n\n// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n// rectangles get rect points assigned by getRectPoints()\nfunction findRoute(from, to, isPointObstacle, opt) {\n\n    var precision = opt.precision;\n\n    // Get grid for this route.\n\n    var sourceAnchor, targetAnchor;\n\n    if (from instanceof g.Rect) { // `from` is sourceBBox\n        sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);\n    } else {\n        sourceAnchor = round(from.clone(), precision);\n    }\n\n    if (to instanceof g.Rect) { // `to` is targetBBox\n        targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);\n    } else {\n        targetAnchor = round(to.clone(), precision);\n    }\n\n    var grid = getGrid(opt.step, sourceAnchor, targetAnchor);\n\n    // Get pathfinding points.\n\n    var start, end; // aligned with grid by definition\n    var startPoints, endPoints; // assumed to be aligned with grid already\n\n    // set of points we start pathfinding from\n    if (from instanceof g.Rect) { // `from` is sourceBBox\n        start = sourceAnchor;\n        startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n\n    } else {\n        start = sourceAnchor;\n        startPoints = [start];\n    }\n\n    // set of points we want the pathfinding to finish at\n    if (to instanceof g.Rect) { // `to` is targetBBox\n        end = targetAnchor;\n        endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n\n    } else {\n        end = targetAnchor;\n        endPoints = [end];\n    }\n\n    // take into account only accessible rect points (those not under obstacles)\n    startPoints = startPoints.filter(p => !isPointObstacle(p));\n    endPoints = endPoints.filter(p => !isPointObstacle(p));\n\n    // Check that there is an accessible route point on both sides.\n    // Otherwise, use fallbackRoute().\n    if (startPoints.length > 0 && endPoints.length > 0) {\n\n        // The set of tentative points to be evaluated, initially containing the start points.\n        // Rounded to nearest integer for simplicity.\n        var openSet = new SortedSet();\n        // Keeps reference to actual points for given elements of the open set.\n        var points = {};\n        // Keeps reference to a point that is immediate predecessor of given element.\n        var parents = {};\n        // Cost from start to a point along best known path.\n        var costs = {};\n\n        for (var i = 0, n = startPoints.length; i < n; i++) {\n            // startPoint is assumed to be aligned already\n            var startPoint = startPoints[i];\n\n            var key = getKey(startPoint);\n\n            openSet.add(key, estimateCost(startPoint, endPoints));\n            points[key] = startPoint;\n            costs[key] = 0;\n        }\n\n        var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n        var isPathBeginning = (previousRouteDirectionAngle === undefined);\n\n        // directions\n        var direction, directionChange;\n        var directions = opt.directions;\n        getGridOffsets(directions, grid, opt);\n\n        var numDirections = directions.length;\n\n        var endPointsKeys = util.toArray(endPoints).reduce(function(res, endPoint) {\n            // endPoint is assumed to be aligned already\n\n            var key = getKey(endPoint);\n            res.push(key);\n            return res;\n        }, []);\n\n        // main route finding loop\n        var loopsRemaining = opt.maximumLoops;\n        while (!openSet.isEmpty() && loopsRemaining > 0) {\n\n            // remove current from the open list\n            var currentKey = openSet.pop();\n            var currentPoint = points[currentKey];\n            var currentParent = parents[currentKey];\n            var currentCost = costs[currentKey];\n\n            var isRouteBeginning = (currentParent === undefined); // undefined for route starts\n            var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n\n            var previousDirectionAngle;\n            if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route\n            else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path\n            else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point\n            else previousDirectionAngle = null; // beginning of path, source anchor or `from` point\n\n            // check if we reached any endpoint\n            var samePoints = startPoints.length === endPoints.length;\n            if (samePoints) {\n                for (var j = 0; j < startPoints.length; j++) {\n                    if (!startPoints[j].equals(endPoints[j])) {\n                        samePoints = false;\n                        break;\n                    }\n                }\n            }\n            var skipEndCheck = (isRouteBeginning && samePoints);\n            if (!skipEndCheck && (endPointsKeys.indexOf(currentKey) >= 0)) {\n                opt.previousDirectionAngle = previousDirectionAngle;\n                return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n            }\n\n            // go over all possible directions and find neighbors\n            for (i = 0; i < numDirections; i++) {\n                direction = directions[i];\n\n                var directionAngle = direction.angle;\n                directionChange = getDirectionChange(previousDirectionAngle, directionAngle);\n\n                // if the direction changed rapidly, don't use this point\n                // any direction is allowed for starting points\n                if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;\n\n                var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n                var neighborKey = getKey(neighborPoint);\n\n                // Closed points from the openSet were already evaluated.\n                if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;\n\n                // We can only enter end points at an acceptable angle.\n                if (endPointsKeys.indexOf(neighborKey) >= 0) { // neighbor is an end point\n\n                    var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n\n                    if (!isNeighborEnd) {\n                        var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n                        var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n\n                        if (endDirectionChange > opt.maxAllowedDirectionChange) continue;\n                    }\n                }\n\n                // The current direction is ok.\n\n                var neighborCost = direction.cost;\n                var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n                var costFromStart = currentCost + neighborCost + neighborPenalty;\n\n                if (!openSet.isOpen(neighborKey) || (costFromStart < costs[neighborKey])) {\n                    // neighbor point has not been processed yet\n                    // or the cost of the path from start is lower than previously calculated\n\n                    points[neighborKey] = neighborPoint;\n                    parents[neighborKey] = currentPoint;\n                    costs[neighborKey] = costFromStart;\n                    openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n                }\n            }\n\n            loopsRemaining--;\n        }\n    }\n\n    // no route found (`to` point either wasn't accessible or finding route took\n    // way too much calculation)\n    return opt.fallbackRoute.call(this, start, end, opt);\n}\n\n// resolve some of the options\nfunction resolveOptions(opt) {\n\n    opt.directions = util.result(opt, 'directions');\n    opt.penalties = util.result(opt, 'penalties');\n    opt.paddingBox = util.result(opt, 'paddingBox');\n    opt.padding = util.result(opt, 'padding');\n\n    if (opt.padding) {\n        // if both provided, opt.padding wins over opt.paddingBox\n        var sides = util.normalizeSides(opt.padding);\n        opt.paddingBox = {\n            x: -sides.left,\n            y: -sides.top,\n            width: sides.left + sides.right,\n            height: sides.top + sides.bottom\n        };\n    }\n\n    util.toArray(opt.directions).forEach(function(direction) {\n\n        var point1 = new g.Point(0, 0);\n        var point2 = new g.Point(direction.offsetX, direction.offsetY);\n\n        direction.angle = g.normalizeAngle(point1.theta(point2));\n    });\n}\n\n// initialization of the route finding\nfunction router(vertices, opt, linkView) {\n\n    resolveOptions(opt);\n\n    // enable/disable linkView perpendicular option\n    linkView.options.perpendicular = !!opt.perpendicular;\n\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    //var targetAnchor = getTargetAnchor(linkView, opt);\n\n    // pathfinding\n    let isPointObstacle;\n    if (typeof opt.isPointObstacle === 'function') {\n        isPointObstacle = opt.isPointObstacle;\n    } else {\n        const map = new ObstacleMap(opt);\n        map.build(linkView.paper.model, linkView.model);\n        isPointObstacle = (point) => !map.isPointAccessible(point);\n    }\n\n    var oldVertices = util.toArray(vertices).map(g.Point);\n    var newVertices = [];\n    var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n\n    // find a route by concatenating all partial routes (routes need to pass through vertices)\n    // source -> vertex[1] -> ... -> vertex[n] -> target\n    var to, from;\n\n    for (var i = 0, len = oldVertices.length; i <= len; i++) {\n\n        var partialRoute = null;\n\n        from = to || sourceBBox;\n        to = oldVertices[i];\n\n        if (!to) {\n            // this is the last iteration\n            // we ran through all vertices in oldVertices\n            // 'to' is not a vertex.\n\n            to = targetBBox;\n\n            // If the target is a point (i.e. it's not an element), we\n            // should use dragging route instead of main routing method if it has been provided.\n            var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;\n\n            if (isEndingAtPoint && util.isFunction(opt.draggingRoute)) {\n                // Make sure we are passing points only (not rects).\n                var dragFrom = (from === sourceBBox) ? sourceAnchor : from;\n                var dragTo = to.origin();\n\n                partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n            }\n        }\n\n        // if partial route has not been calculated yet use the main routing method to find one\n        partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);\n\n        if (partialRoute === null) { // the partial route cannot be found\n            return opt.fallbackRouter(vertices, opt, linkView);\n        }\n\n        var leadPoint = partialRoute[0];\n\n        // remove the first point if the previous partial route had the same point as last\n        if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();\n\n        // save tailPoint for next iteration\n        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n\n        Array.prototype.push.apply(newVertices, partialRoute);\n    }\n\n    return newVertices;\n}\n\n// public function\nexport const manhattan = function(vertices, opt, linkView) {\n    return router(vertices, util.assign({}, config, opt), linkView);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}