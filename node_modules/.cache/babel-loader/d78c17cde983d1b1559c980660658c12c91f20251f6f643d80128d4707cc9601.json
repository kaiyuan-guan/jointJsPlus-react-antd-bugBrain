{"ast":null,"code":"import { Cell } from './Cell.mjs';\nimport { Point, toRad, normalizeAngle, Rect } from '../g/index.mjs';\nimport { isNumber, isObject, interpolate, assign, invoke, normalizeSides } from '../util/index.mjs';\nimport { elementPortPrototype } from './ports.mjs';\n\n// Element base model.\n// -----------------------------\n\nexport const Element = Cell.extend({\n  defaults: {\n    position: {\n      x: 0,\n      y: 0\n    },\n    size: {\n      width: 1,\n      height: 1\n    },\n    angle: 0\n  },\n  initialize: function () {\n    this._initializePorts();\n    Cell.prototype.initialize.apply(this, arguments);\n  },\n  /**\n   * @abstract\n   */\n  _initializePorts: function () {\n    // implemented in ports.js\n  },\n  _refreshPorts: function () {\n    // implemented in ports.js\n  },\n  isElement: function () {\n    return true;\n  },\n  position: function (x, y, opt) {\n    const isSetter = isNumber(y);\n    opt = (isSetter ? opt : x) || {};\n    const {\n      parentRelative,\n      deep,\n      restrictedArea\n    } = opt;\n\n    // option `parentRelative` for setting the position relative to the element's parent.\n    let parentPosition;\n    if (parentRelative) {\n      // Getting the parent's position requires the collection.\n      // Cell.parent() holds cell id only.\n      if (!this.graph) throw new Error('Element must be part of a graph.');\n      const parent = this.getParentCell();\n      if (parent && !parent.isLink()) {\n        parentPosition = parent.get('position');\n      }\n    }\n    if (isSetter) {\n      if (parentPosition) {\n        x += parentPosition.x;\n        y += parentPosition.y;\n      }\n      if (deep || restrictedArea) {\n        const {\n          x: x0,\n          y: y0\n        } = this.get('position');\n        this.translate(x - x0, y - y0, opt);\n      } else {\n        this.set('position', {\n          x,\n          y\n        }, opt);\n      }\n      return this;\n    } else {\n      // Getter returns a geometry point.\n\n      const elementPosition = Point(this.get('position'));\n      return parentRelative ? elementPosition.difference(parentPosition) : elementPosition;\n    }\n  },\n  translate: function (tx, ty, opt) {\n    tx = tx || 0;\n    ty = ty || 0;\n    if (tx === 0 && ty === 0) {\n      // Like nothing has happened.\n      return this;\n    }\n    opt = opt || {};\n    // Pass the initiator of the translation.\n    opt.translateBy = opt.translateBy || this.id;\n    var position = this.get('position') || {\n      x: 0,\n      y: 0\n    };\n    var ra = opt.restrictedArea;\n    if (ra && opt.translateBy === this.id) {\n      if (typeof ra === 'function') {\n        var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n        tx = newPosition.x - position.x;\n        ty = newPosition.y - position.y;\n      } else {\n        // We are restricting the translation for the element itself only. We get\n        // the bounding box of the element including all its embeds.\n        // All embeds have to be translated the exact same way as the element.\n        var bbox = this.getBBox({\n          deep: true\n        });\n        //- - - - - - - - - - - - -> ra.x + ra.width\n        // - - - -> position.x      |\n        // -> bbox.x\n        //                ▓▓▓▓▓▓▓   |\n        //         ░░░░░░░▓▓▓▓▓▓▓\n        //         ░░░░░░░░░        |\n        //   ▓▓▓▓▓▓▓▓░░░░░░░\n        //   ▓▓▓▓▓▓▓▓               |\n        //   <-dx->                     | restricted area right border\n        //         <-width->        |   ░ translated element\n        //   <- - bbox.width - ->       ▓ embedded element\n        var dx = position.x - bbox.x;\n        var dy = position.y - bbox.y;\n        // Find the maximal/minimal coordinates that the element can be translated\n        // while complies the restrictions.\n        var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n        var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n        // recalculate the translation taking the restrictions into account.\n        tx = x - position.x;\n        ty = y - position.y;\n      }\n    }\n    var translatedPosition = {\n      x: position.x + tx,\n      y: position.y + ty\n    };\n\n    // To find out by how much an element was translated in event 'change:position' handlers.\n    opt.tx = tx;\n    opt.ty = ty;\n    if (opt.transition) {\n      if (!isObject(opt.transition)) opt.transition = {};\n      this.transition('position', translatedPosition, assign({}, opt.transition, {\n        valueFunction: interpolate.object\n      }));\n\n      // Recursively call `translate()` on all the embeds cells.\n      invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n    } else {\n      this.startBatch('translate', opt);\n      this.set('position', translatedPosition, opt);\n      invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n      this.stopBatch('translate', opt);\n    }\n    return this;\n  },\n  size: function (width, height, opt) {\n    var currentSize = this.get('size');\n    // Getter\n    // () signature\n    if (width === undefined) {\n      return {\n        width: currentSize.width,\n        height: currentSize.height\n      };\n    }\n    // Setter\n    // (size, opt) signature\n    if (isObject(width)) {\n      opt = height;\n      height = isNumber(width.height) ? width.height : currentSize.height;\n      width = isNumber(width.width) ? width.width : currentSize.width;\n    }\n    return this.resize(width, height, opt);\n  },\n  resize: function (width, height, opt) {\n    opt = opt || {};\n    this.startBatch('resize', opt);\n    if (opt.direction) {\n      var currentSize = this.get('size');\n      switch (opt.direction) {\n        case 'left':\n        case 'right':\n          // Don't change height when resizing horizontally.\n          height = currentSize.height;\n          break;\n        case 'top':\n        case 'bottom':\n          // Don't change width when resizing vertically.\n          width = currentSize.width;\n          break;\n      }\n\n      // Get the angle and clamp its value between 0 and 360 degrees.\n      var angle = normalizeAngle(this.get('angle') || 0);\n\n      // This is a rectangle in size of the un-rotated element.\n      var bbox = this.getBBox();\n      var origin;\n      if (angle) {\n        var quadrant = {\n          'top-right': 0,\n          'right': 0,\n          'top-left': 1,\n          'top': 1,\n          'bottom-left': 2,\n          'left': 2,\n          'bottom-right': 3,\n          'bottom': 3\n        }[opt.direction];\n        if (opt.absolute) {\n          // We are taking the element's rotation into account\n          quadrant += Math.floor((angle + 45) / 90);\n          quadrant %= 4;\n        }\n\n        // Pick the corner point on the element, which meant to stay on its place before and\n        // after the rotation.\n        var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]]();\n\n        // Find  an image of the previous indent point. This is the position, where is the\n        // point actually located on the screen.\n        var imageFixedPoint = Point(fixedPoint).rotate(bbox.center(), -angle);\n\n        // Every point on the element rotates around a circle with the centre of rotation\n        // in the middle of the element while the whole element is being rotated. That means\n        // that the distance from a point in the corner of the element (supposed its always rect) to\n        // the center of the element doesn't change during the rotation and therefore it equals\n        // to a distance on un-rotated element.\n        // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n        var radius = Math.sqrt(width * width + height * height) / 2;\n\n        // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n        // and ending at the center of the element. We call this angle `alpha`.\n\n        // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n        // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n        //\n        // 3 | 2\n        // --c-- Quadrant positions around the element's center `c`\n        // 0 | 1\n        //\n        var alpha = quadrant * Math.PI / 2;\n\n        // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n        // going through the center of the element) and line crossing the indent of the fixed point and the center\n        // of the element. This is the angle we need but on the un-rotated element.\n        alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);\n\n        // Lastly we have to deduct the original angle the element was rotated by and that's it.\n        alpha -= toRad(angle);\n\n        // With this angle and distance we can easily calculate the centre of the un-rotated element.\n        // Note that fromPolar constructor accepts an angle in radians.\n        var center = Point.fromPolar(radius, alpha, imageFixedPoint);\n\n        // The top left corner on the un-rotated element has to be half a width on the left\n        // and half a height to the top from the center. This will be the origin of rectangle\n        // we were looking for.\n        origin = Point(center).offset(width / -2, height / -2);\n      } else {\n        // calculation for the origin Point when there is no rotation of the element\n        origin = bbox.topLeft();\n        switch (opt.direction) {\n          case 'top':\n          case 'top-right':\n            origin.offset(0, bbox.height - height);\n            break;\n          case 'left':\n          case 'bottom-left':\n            origin.offset(bbox.width - width, 0);\n            break;\n          case 'top-left':\n            origin.offset(bbox.width - width, bbox.height - height);\n            break;\n        }\n      }\n\n      // Resize the element (before re-positioning it).\n      this.set('size', {\n        width: width,\n        height: height\n      }, opt);\n\n      // Finally, re-position the element.\n      this.position(origin.x, origin.y, opt);\n    } else {\n      // Resize the element.\n      this.set('size', {\n        width: width,\n        height: height\n      }, opt);\n    }\n    this.stopBatch('resize', opt);\n    return this;\n  },\n  scale: function (sx, sy, origin, opt) {\n    var scaledBBox = this.getBBox().scale(sx, sy, origin);\n    this.startBatch('scale', opt);\n    this.position(scaledBBox.x, scaledBBox.y, opt);\n    this.resize(scaledBBox.width, scaledBBox.height, opt);\n    this.stopBatch('scale');\n    return this;\n  },\n  fitEmbeds: function (opt) {\n    return this.fitToChildren(opt);\n  },\n  fitToChildren: function (opt = {}) {\n    // Getting the children's size and position requires the collection.\n    // Cell.get('embeds') holds an array of cell ids only.\n    const {\n      graph\n    } = this;\n    if (!graph) throw new Error('Element must be part of a graph.');\n    const childElements = this.getEmbeddedCells().filter(cell => cell.isElement());\n    if (childElements.length === 0) return this;\n    this.startBatch('fit-embeds', opt);\n    if (opt.deep) {\n      // `opt.deep = true` means \"fit to all descendants\".\n      // As the first action of the fitting algorithm, recursively apply `fitToChildren()` on all descendants.\n      // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant, then go up (= this element).\n      invoke(childElements, 'fitToChildren', opt);\n    }\n\n    // Set new size and position of this element, based on:\n    // - union of bboxes of all children\n    // - inflated by given `opt.padding`\n    this._fitToElements(Object.assign({\n      elements: childElements\n    }, opt));\n    this.stopBatch('fit-embeds');\n    return this;\n  },\n  fitParent: function (opt = {}) {\n    const {\n      graph\n    } = this;\n    if (!graph) throw new Error('Element must be part of a graph.');\n\n    // When `opt.deep = true`, we want `opt.terminator` to be the last ancestor processed.\n    // If the current element is `opt.terminator`, it means that this element has already been processed as parent so we can exit now.\n    if (opt.deep && opt.terminator && (opt.terminator === this || opt.terminator === this.id)) return this;\n    const parentElement = this.getParentCell();\n    if (!parentElement || !parentElement.isElement()) return this;\n\n    // Get all children of parent element (i.e. this element + any sibling elements).\n    const siblingElements = parentElement.getEmbeddedCells().filter(cell => cell.isElement());\n    if (siblingElements.length === 0) return this;\n    this.startBatch('fit-parent', opt);\n\n    // Set new size and position of parent element, based on:\n    // - union of bboxes of all children of parent element (i.e. this element + any sibling elements)\n    // - inflated by given `opt.padding`\n    parentElement._fitToElements(Object.assign({\n      elements: siblingElements\n    }, opt));\n    if (opt.deep) {\n      // `opt.deep = true` means \"fit all ancestors to their respective children\".\n      // As the last action of the fitting algorithm, recursively apply `fitParent()` on all ancestors.\n      // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant (= this element), then go up.\n      parentElement.fitParent(opt);\n    }\n    this.stopBatch('fit-parent');\n    return this;\n  },\n  // Assumption: This element is part of a graph.\n  _fitToElements: function (opt = {}) {\n    const elementsBBox = this.graph.getCellsBBox(opt.elements);\n    // If no `opt.elements` were provided, do nothing.\n    if (!elementsBBox) return;\n    const {\n      expandOnly,\n      shrinkOnly\n    } = opt;\n    // This combination is meaningless, do nothing.\n    if (expandOnly && shrinkOnly) return;\n\n    // Calculate new size and position of this element based on:\n    // - union of bboxes of `opt.elements`\n    // - inflated by `opt.padding` (if not provided, all four properties = 0)\n    let {\n      x,\n      y,\n      width,\n      height\n    } = elementsBBox;\n    const {\n      left,\n      right,\n      top,\n      bottom\n    } = normalizeSides(opt.padding);\n    x -= left;\n    y -= top;\n    width += left + right;\n    height += bottom + top;\n    let resultBBox = new Rect(x, y, width, height);\n    if (expandOnly) {\n      // Non-shrinking is enforced by taking union of this element's current bbox with bbox calculated from `opt.elements`.\n      resultBBox = this.getBBox().union(resultBBox);\n    } else if (shrinkOnly) {\n      // Non-expansion is enforced by taking intersection of this element's current bbox with bbox calculated from `opt.elements`.\n      const intersectionBBox = this.getBBox().intersect(resultBBox);\n      // If all children are outside this element's current bbox, then `intersectionBBox` is `null` - does not make sense, do nothing.\n      if (!intersectionBBox) return;\n      resultBBox = intersectionBBox;\n    }\n\n    // Set the new size and position of this element.\n    this.set({\n      position: {\n        x: resultBBox.x,\n        y: resultBBox.y\n      },\n      size: {\n        width: resultBBox.width,\n        height: resultBBox.height\n      }\n    }, opt);\n  },\n  // Rotate element by `angle` degrees, optionally around `origin` point.\n  // If `origin` is not provided, it is considered to be the center of the element.\n  // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n  // the difference from the previous angle.\n  rotate: function (angle, absolute, origin, opt) {\n    if (origin) {\n      var center = this.getBBox().center();\n      var size = this.get('size');\n      var position = this.get('position');\n      center.rotate(origin, this.get('angle') - angle);\n      var dx = center.x - size.width / 2 - position.x;\n      var dy = center.y - size.height / 2 - position.y;\n      this.startBatch('rotate', {\n        angle: angle,\n        absolute: absolute,\n        origin: origin\n      });\n      this.position(position.x + dx, position.y + dy, opt);\n      this.rotate(angle, absolute, null, opt);\n      this.stopBatch('rotate');\n    } else {\n      this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);\n    }\n    return this;\n  },\n  angle: function () {\n    return normalizeAngle(this.get('angle') || 0);\n  },\n  getBBox: function (opt = {}) {\n    const {\n      graph,\n      attributes\n    } = this;\n    const {\n      deep,\n      rotate\n    } = opt;\n    if (deep && graph) {\n      // Get all the embedded elements using breadth first algorithm.\n      const elements = this.getEmbeddedCells({\n        deep: true,\n        breadthFirst: true\n      });\n      // Add the model itself.\n      elements.push(this);\n      // Note: the default of getCellsBBox() is rotate=true and can't be\n      // changed without a breaking change\n      return graph.getCellsBBox(elements, opt);\n    }\n    const {\n      angle = 0,\n      position: {\n        x,\n        y\n      },\n      size: {\n        width,\n        height\n      }\n    } = attributes;\n    const bbox = new Rect(x, y, width, height);\n    if (rotate) {\n      bbox.rotateAroundCenter(angle);\n    }\n    return bbox;\n  },\n  getPointFromConnectedLink: function (link, endType) {\n    // Center of the model\n    var bbox = this.getBBox();\n    var center = bbox.center();\n    // Center of a port\n    var endDef = link.get(endType);\n    if (!endDef) return center;\n    var portId = endDef.port;\n    if (!portId || !this.hasPort(portId)) return center;\n    var portGroup = this.portProp(portId, ['group']);\n    var portsPositions = this.getPortsPositions(portGroup);\n    var portCenter = new Point(portsPositions[portId]).offset(bbox.origin());\n    var angle = this.angle();\n    if (angle) portCenter.rotate(center, -angle);\n    return portCenter;\n  }\n});\nassign(Element.prototype, elementPortPrototype);","map":{"version":3,"names":["Cell","Point","toRad","normalizeAngle","Rect","isNumber","isObject","interpolate","assign","invoke","normalizeSides","elementPortPrototype","Element","extend","defaults","position","x","y","size","width","height","angle","initialize","_initializePorts","prototype","apply","arguments","_refreshPorts","isElement","opt","isSetter","parentRelative","deep","restrictedArea","parentPosition","graph","Error","parent","getParentCell","isLink","get","x0","y0","translate","set","elementPosition","difference","tx","ty","translateBy","id","ra","newPosition","call","bbox","getBBox","dx","dy","Math","max","min","translatedPosition","transition","valueFunction","object","getEmbeddedCells","startBatch","stopBatch","currentSize","undefined","resize","direction","origin","quadrant","absolute","floor","fixedPoint","imageFixedPoint","rotate","center","radius","sqrt","alpha","PI","atan","fromPolar","offset","topLeft","scale","sx","sy","scaledBBox","fitEmbeds","fitToChildren","childElements","filter","cell","length","_fitToElements","Object","elements","fitParent","terminator","parentElement","siblingElements","elementsBBox","getCellsBBox","expandOnly","shrinkOnly","left","right","top","bottom","padding","resultBBox","union","intersectionBBox","intersect","attributes","breadthFirst","push","rotateAroundCenter","getPointFromConnectedLink","link","endType","endDef","portId","port","hasPort","portGroup","portProp","portsPositions","getPortsPositions","portCenter"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/dia/Element.mjs"],"sourcesContent":["import { Cell } from './Cell.mjs';\nimport { Point, toRad, normalizeAngle, Rect } from '../g/index.mjs';\nimport { isNumber, isObject, interpolate, assign, invoke, normalizeSides } from '../util/index.mjs';\nimport { elementPortPrototype } from './ports.mjs';\n\n// Element base model.\n// -----------------------------\n\nexport const Element = Cell.extend({\n\n    defaults: {\n        position: { x: 0, y: 0 },\n        size: { width: 1, height: 1 },\n        angle: 0\n    },\n\n    initialize: function() {\n\n        this._initializePorts();\n        Cell.prototype.initialize.apply(this, arguments);\n    },\n\n    /**\n     * @abstract\n     */\n    _initializePorts: function() {\n        // implemented in ports.js\n    },\n\n    _refreshPorts: function() {\n        // implemented in ports.js\n    },\n\n    isElement: function() {\n\n        return true;\n    },\n\n    position: function(x, y, opt) {\n\n        const isSetter = isNumber(y);\n        opt = (isSetter ? opt : x) || {};\n        const { parentRelative, deep, restrictedArea } = opt;\n\n\n        // option `parentRelative` for setting the position relative to the element's parent.\n        let parentPosition;\n        if (parentRelative) {\n\n            // Getting the parent's position requires the collection.\n            // Cell.parent() holds cell id only.\n            if (!this.graph) throw new Error('Element must be part of a graph.');\n\n            const parent = this.getParentCell();\n            if (parent && !parent.isLink()) {\n                parentPosition = parent.get('position');\n            }\n        }\n\n        if (isSetter) {\n\n            if (parentPosition) {\n                x += parentPosition.x;\n                y += parentPosition.y;\n            }\n\n            if (deep || restrictedArea) {\n                const { x: x0, y: y0 } = this.get('position');\n                this.translate(x - x0, y - y0, opt);\n            } else {\n                this.set('position', { x, y }, opt);\n            }\n\n            return this;\n\n        } else { // Getter returns a geometry point.\n\n            const elementPosition = Point(this.get('position'));\n            return parentRelative\n                ? elementPosition.difference(parentPosition)\n                : elementPosition;\n        }\n    },\n\n    translate: function(tx, ty, opt) {\n\n        tx = tx || 0;\n        ty = ty || 0;\n\n        if (tx === 0 && ty === 0) {\n            // Like nothing has happened.\n            return this;\n        }\n\n        opt = opt || {};\n        // Pass the initiator of the translation.\n        opt.translateBy = opt.translateBy || this.id;\n\n        var position = this.get('position') || { x: 0, y: 0 };\n        var ra = opt.restrictedArea;\n        if (ra && opt.translateBy === this.id) {\n\n            if (typeof ra === 'function') {\n\n                var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n\n                tx = newPosition.x - position.x;\n                ty = newPosition.y - position.y;\n\n            } else  {\n                // We are restricting the translation for the element itself only. We get\n                // the bounding box of the element including all its embeds.\n                // All embeds have to be translated the exact same way as the element.\n                var bbox = this.getBBox({ deep: true });\n                //- - - - - - - - - - - - -> ra.x + ra.width\n                // - - - -> position.x      |\n                // -> bbox.x\n                //                ▓▓▓▓▓▓▓   |\n                //         ░░░░░░░▓▓▓▓▓▓▓\n                //         ░░░░░░░░░        |\n                //   ▓▓▓▓▓▓▓▓░░░░░░░\n                //   ▓▓▓▓▓▓▓▓               |\n                //   <-dx->                     | restricted area right border\n                //         <-width->        |   ░ translated element\n                //   <- - bbox.width - ->       ▓ embedded element\n                var dx = position.x - bbox.x;\n                var dy = position.y - bbox.y;\n                // Find the maximal/minimal coordinates that the element can be translated\n                // while complies the restrictions.\n                var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n                var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n                // recalculate the translation taking the restrictions into account.\n                tx = x - position.x;\n                ty = y - position.y;\n            }\n        }\n\n        var translatedPosition = {\n            x: position.x + tx,\n            y: position.y + ty\n        };\n\n        // To find out by how much an element was translated in event 'change:position' handlers.\n        opt.tx = tx;\n        opt.ty = ty;\n\n        if (opt.transition) {\n\n            if (!isObject(opt.transition)) opt.transition = {};\n\n            this.transition('position', translatedPosition, assign({}, opt.transition, {\n                valueFunction: interpolate.object\n            }));\n\n            // Recursively call `translate()` on all the embeds cells.\n            invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n\n        } else {\n\n            this.startBatch('translate', opt);\n            this.set('position', translatedPosition, opt);\n            invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n            this.stopBatch('translate', opt);\n        }\n\n        return this;\n    },\n\n    size: function(width, height, opt) {\n\n        var currentSize = this.get('size');\n        // Getter\n        // () signature\n        if (width === undefined) {\n            return {\n                width: currentSize.width,\n                height: currentSize.height\n            };\n        }\n        // Setter\n        // (size, opt) signature\n        if (isObject(width)) {\n            opt = height;\n            height = isNumber(width.height) ? width.height : currentSize.height;\n            width = isNumber(width.width) ? width.width : currentSize.width;\n        }\n\n        return this.resize(width, height, opt);\n    },\n\n    resize: function(width, height, opt) {\n\n        opt = opt || {};\n\n        this.startBatch('resize', opt);\n\n        if (opt.direction) {\n\n            var currentSize = this.get('size');\n\n            switch (opt.direction) {\n\n                case 'left':\n                case 'right':\n                    // Don't change height when resizing horizontally.\n                    height = currentSize.height;\n                    break;\n\n                case 'top':\n                case 'bottom':\n                    // Don't change width when resizing vertically.\n                    width = currentSize.width;\n                    break;\n            }\n\n            // Get the angle and clamp its value between 0 and 360 degrees.\n            var angle = normalizeAngle(this.get('angle') || 0);\n\n            // This is a rectangle in size of the un-rotated element.\n            var bbox = this.getBBox();\n\n            var origin;\n\n            if (angle) {\n\n                var quadrant = {\n                    'top-right': 0,\n                    'right': 0,\n                    'top-left': 1,\n                    'top': 1,\n                    'bottom-left': 2,\n                    'left': 2,\n                    'bottom-right': 3,\n                    'bottom': 3\n                }[opt.direction];\n\n                if (opt.absolute) {\n\n                    // We are taking the element's rotation into account\n                    quadrant += Math.floor((angle + 45) / 90);\n                    quadrant %= 4;\n                }\n\n                // Pick the corner point on the element, which meant to stay on its place before and\n                // after the rotation.\n                var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]]();\n\n                // Find  an image of the previous indent point. This is the position, where is the\n                // point actually located on the screen.\n                var imageFixedPoint = Point(fixedPoint).rotate(bbox.center(), -angle);\n\n                // Every point on the element rotates around a circle with the centre of rotation\n                // in the middle of the element while the whole element is being rotated. That means\n                // that the distance from a point in the corner of the element (supposed its always rect) to\n                // the center of the element doesn't change during the rotation and therefore it equals\n                // to a distance on un-rotated element.\n                // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n                var radius = Math.sqrt((width * width) + (height * height)) / 2;\n\n                // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n                // and ending at the center of the element. We call this angle `alpha`.\n\n                // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n                // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n                //\n                // 3 | 2\n                // --c-- Quadrant positions around the element's center `c`\n                // 0 | 1\n                //\n                var alpha = quadrant * Math.PI / 2;\n\n                // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n                // going through the center of the element) and line crossing the indent of the fixed point and the center\n                // of the element. This is the angle we need but on the un-rotated element.\n                alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);\n\n                // Lastly we have to deduct the original angle the element was rotated by and that's it.\n                alpha -= toRad(angle);\n\n                // With this angle and distance we can easily calculate the centre of the un-rotated element.\n                // Note that fromPolar constructor accepts an angle in radians.\n                var center = Point.fromPolar(radius, alpha, imageFixedPoint);\n\n                // The top left corner on the un-rotated element has to be half a width on the left\n                // and half a height to the top from the center. This will be the origin of rectangle\n                // we were looking for.\n                origin = Point(center).offset(width / -2, height / -2);\n\n            } else {\n                // calculation for the origin Point when there is no rotation of the element\n                origin = bbox.topLeft();\n\n                switch (opt.direction) {\n                    case 'top':\n                    case 'top-right':\n                        origin.offset(0, bbox.height - height);\n                        break;\n                    case 'left':\n                    case 'bottom-left':\n                        origin.offset(bbox.width -width, 0);\n                        break;\n                    case 'top-left':\n                        origin.offset(bbox.width - width, bbox.height - height);\n                        break;\n                }\n            }\n\n            // Resize the element (before re-positioning it).\n            this.set('size', { width: width, height: height }, opt);\n\n            // Finally, re-position the element.\n            this.position(origin.x, origin.y, opt);\n\n        } else {\n\n            // Resize the element.\n            this.set('size', { width: width, height: height }, opt);\n        }\n\n        this.stopBatch('resize', opt);\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin, opt) {\n\n        var scaledBBox = this.getBBox().scale(sx, sy, origin);\n        this.startBatch('scale', opt);\n        this.position(scaledBBox.x, scaledBBox.y, opt);\n        this.resize(scaledBBox.width, scaledBBox.height, opt);\n        this.stopBatch('scale');\n        return this;\n    },\n\n    fitEmbeds: function(opt) {\n\n        return this.fitToChildren(opt);\n    },\n\n    fitToChildren: function(opt = {}) {\n\n        // Getting the children's size and position requires the collection.\n        // Cell.get('embeds') holds an array of cell ids only.\n        const { graph } = this;\n        if (!graph) throw new Error('Element must be part of a graph.');\n\n        const childElements = this.getEmbeddedCells().filter(cell => cell.isElement());\n        if (childElements.length === 0) return this;\n\n        this.startBatch('fit-embeds', opt);\n\n        if (opt.deep) {\n            // `opt.deep = true` means \"fit to all descendants\".\n            // As the first action of the fitting algorithm, recursively apply `fitToChildren()` on all descendants.\n            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant, then go up (= this element).\n            invoke(childElements, 'fitToChildren', opt);\n        }\n\n        // Set new size and position of this element, based on:\n        // - union of bboxes of all children\n        // - inflated by given `opt.padding`\n        this._fitToElements(Object.assign({ elements: childElements }, opt));\n\n        this.stopBatch('fit-embeds');\n\n        return this;\n    },\n\n    fitParent: function(opt = {}) {\n\n        const { graph } = this;\n        if (!graph) throw new Error('Element must be part of a graph.');\n\n        // When `opt.deep = true`, we want `opt.terminator` to be the last ancestor processed.\n        // If the current element is `opt.terminator`, it means that this element has already been processed as parent so we can exit now.\n        if (opt.deep && opt.terminator && ((opt.terminator === this) || (opt.terminator === this.id))) return this;\n\n        const parentElement = this.getParentCell();\n        if (!parentElement || !parentElement.isElement()) return this;\n\n        // Get all children of parent element (i.e. this element + any sibling elements).\n        const siblingElements = parentElement.getEmbeddedCells().filter(cell => cell.isElement());\n        if (siblingElements.length === 0) return this;\n\n        this.startBatch('fit-parent', opt);\n\n        // Set new size and position of parent element, based on:\n        // - union of bboxes of all children of parent element (i.e. this element + any sibling elements)\n        // - inflated by given `opt.padding`\n        parentElement._fitToElements(Object.assign({ elements: siblingElements }, opt));\n\n        if (opt.deep) {\n            // `opt.deep = true` means \"fit all ancestors to their respective children\".\n            // As the last action of the fitting algorithm, recursively apply `fitParent()` on all ancestors.\n            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant (= this element), then go up.\n            parentElement.fitParent(opt);\n        }\n\n        this.stopBatch('fit-parent');\n\n        return this;\n    },\n\n    // Assumption: This element is part of a graph.\n    _fitToElements: function(opt = {}) {\n\n        const elementsBBox = this.graph.getCellsBBox(opt.elements);\n        // If no `opt.elements` were provided, do nothing.\n        if (!elementsBBox) return;\n\n        const { expandOnly, shrinkOnly } = opt;\n        // This combination is meaningless, do nothing.\n        if (expandOnly && shrinkOnly) return;\n\n        // Calculate new size and position of this element based on:\n        // - union of bboxes of `opt.elements`\n        // - inflated by `opt.padding` (if not provided, all four properties = 0)\n        let { x, y, width, height } = elementsBBox;\n        const { left, right, top, bottom } = normalizeSides(opt.padding);\n        x -= left;\n        y -= top;\n        width += left + right;\n        height += bottom + top;\n        let resultBBox = new Rect(x, y, width, height);\n\n        if (expandOnly) {\n            // Non-shrinking is enforced by taking union of this element's current bbox with bbox calculated from `opt.elements`.\n            resultBBox = this.getBBox().union(resultBBox);\n\n        } else if (shrinkOnly) {\n            // Non-expansion is enforced by taking intersection of this element's current bbox with bbox calculated from `opt.elements`.\n            const intersectionBBox = this.getBBox().intersect(resultBBox);\n            // If all children are outside this element's current bbox, then `intersectionBBox` is `null` - does not make sense, do nothing.\n            if (!intersectionBBox) return;\n\n            resultBBox =  intersectionBBox;\n        }\n\n        // Set the new size and position of this element.\n        this.set({\n            position: { x: resultBBox.x, y: resultBBox.y },\n            size: { width: resultBBox.width, height: resultBBox.height }\n        }, opt);\n    },\n\n    // Rotate element by `angle` degrees, optionally around `origin` point.\n    // If `origin` is not provided, it is considered to be the center of the element.\n    // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n    // the difference from the previous angle.\n    rotate: function(angle, absolute, origin, opt) {\n\n        if (origin) {\n\n            var center = this.getBBox().center();\n            var size = this.get('size');\n            var position = this.get('position');\n            center.rotate(origin, this.get('angle') - angle);\n            var dx = center.x - size.width / 2 - position.x;\n            var dy = center.y - size.height / 2 - position.y;\n            this.startBatch('rotate', { angle: angle, absolute: absolute, origin: origin });\n            this.position(position.x + dx, position.y + dy, opt);\n            this.rotate(angle, absolute, null, opt);\n            this.stopBatch('rotate');\n\n        } else {\n\n            this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);\n        }\n\n        return this;\n    },\n\n    angle: function() {\n        return normalizeAngle(this.get('angle') || 0);\n    },\n\n    getBBox: function(opt = {}) {\n\n        const { graph, attributes } = this;\n        const { deep, rotate } = opt;\n\n        if (deep && graph) {\n            // Get all the embedded elements using breadth first algorithm.\n            const elements = this.getEmbeddedCells({ deep: true, breadthFirst: true });\n            // Add the model itself.\n            elements.push(this);\n            // Note: the default of getCellsBBox() is rotate=true and can't be\n            // changed without a breaking change\n            return graph.getCellsBBox(elements, opt);\n        }\n\n        const { angle = 0, position: { x, y }, size: { width, height }} = attributes;\n        const bbox = new Rect(x, y, width, height);\n        if (rotate) {\n            bbox.rotateAroundCenter(angle);\n        }\n        return bbox;\n    },\n\n    getPointFromConnectedLink: function(link, endType) {\n        // Center of the model\n        var bbox = this.getBBox();\n        var center = bbox.center();\n        // Center of a port\n        var endDef = link.get(endType);\n        if (!endDef) return center;\n        var portId = endDef.port;\n        if (!portId || !this.hasPort(portId)) return center;\n        var portGroup = this.portProp(portId, ['group']);\n        var portsPositions = this.getPortsPositions(portGroup);\n        var portCenter = new Point(portsPositions[portId]).offset(bbox.origin());\n        var angle = this.angle();\n        if (angle) portCenter.rotate(center, -angle);\n        return portCenter;\n    }\n});\n\nassign(Element.prototype, elementPortPrototype);\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}