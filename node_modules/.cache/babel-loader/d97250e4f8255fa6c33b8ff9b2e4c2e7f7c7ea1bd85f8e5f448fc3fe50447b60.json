{"ast":null,"code":"import * as util from '../util/index.mjs';\nimport { toRad } from '../g/index.mjs';\nimport { resolveRef } from '../linkAnchors/index.mjs';\nfunction bboxWrapper(method) {\n  return function (view, magnet, ref, opt) {\n    var rotate = !!opt.rotate;\n    var bbox = rotate ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);\n    var anchor = bbox[method]();\n    var dx = opt.dx;\n    if (dx) {\n      var dxPercentage = util.isPercentage(dx);\n      dx = parseFloat(dx);\n      if (isFinite(dx)) {\n        if (dxPercentage) {\n          dx /= 100;\n          dx *= bbox.width;\n        }\n        anchor.x += dx;\n      }\n    }\n    var dy = opt.dy;\n    if (dy) {\n      var dyPercentage = util.isPercentage(dy);\n      dy = parseFloat(dy);\n      if (isFinite(dy)) {\n        if (dyPercentage) {\n          dy /= 100;\n          dy *= bbox.height;\n        }\n        anchor.y += dy;\n      }\n    }\n    return rotate ? anchor.rotate(view.model.getBBox().center(), -view.model.angle()) : anchor;\n  };\n}\nfunction _perpendicular(view, magnet, refPoint, opt) {\n  var angle = view.model.angle();\n  var bbox = view.getNodeBBox(magnet);\n  var anchor = bbox.center();\n  var topLeft = bbox.origin();\n  var bottomRight = bbox.corner();\n  var padding = opt.padding;\n  if (!isFinite(padding)) padding = 0;\n  if (topLeft.y + padding <= refPoint.y && refPoint.y <= bottomRight.y - padding) {\n    var dy = refPoint.y - anchor.y;\n    anchor.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan(toRad(angle));\n    anchor.y += dy;\n  } else if (topLeft.x + padding <= refPoint.x && refPoint.x <= bottomRight.x - padding) {\n    var dx = refPoint.x - anchor.x;\n    anchor.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan(toRad(angle));\n    anchor.x += dx;\n  }\n  return anchor;\n}\nfunction _midSide(view, magnet, refPoint, opt) {\n  var rotate = !!opt.rotate;\n  var bbox, angle, center;\n  if (rotate) {\n    bbox = view.getNodeUnrotatedBBox(magnet);\n    center = view.model.getBBox().center();\n    angle = view.model.angle();\n  } else {\n    bbox = view.getNodeBBox(magnet);\n  }\n  var padding = opt.padding;\n  if (isFinite(padding)) bbox.inflate(padding);\n  if (rotate) refPoint.rotate(center, angle);\n  var side = bbox.sideNearestToPoint(refPoint);\n  var anchor;\n  switch (side) {\n    case 'left':\n      anchor = bbox.leftMiddle();\n      break;\n    case 'right':\n      anchor = bbox.rightMiddle();\n      break;\n    case 'top':\n      anchor = bbox.topMiddle();\n      break;\n    case 'bottom':\n      anchor = bbox.bottomMiddle();\n      break;\n  }\n  return rotate ? anchor.rotate(center, -angle) : anchor;\n}\n\n// Can find anchor from model, when there is no selector or the link end\n// is connected to a port\nfunction _modelCenter(view, _magnet, _refPoint, opt, endType) {\n  return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);\n}\n\n//joint.anchors\nexport const center = bboxWrapper('center');\nexport const top = bboxWrapper('topMiddle');\nexport const bottom = bboxWrapper('bottomMiddle');\nexport const left = bboxWrapper('leftMiddle');\nexport const right = bboxWrapper('rightMiddle');\nexport const topLeft = bboxWrapper('origin');\nexport const topRight = bboxWrapper('topRight');\nexport const bottomLeft = bboxWrapper('bottomLeft');\nexport const bottomRight = bboxWrapper('corner');\nexport const perpendicular = resolveRef(_perpendicular);\nexport const midSide = resolveRef(_midSide);\nexport const modelCenter = _modelCenter;","map":{"version":3,"names":["util","toRad","resolveRef","bboxWrapper","method","view","magnet","ref","opt","rotate","bbox","getNodeUnrotatedBBox","getNodeBBox","anchor","dx","dxPercentage","isPercentage","parseFloat","isFinite","width","x","dy","dyPercentage","height","y","model","getBBox","center","angle","_perpendicular","refPoint","topLeft","origin","bottomRight","corner","padding","Math","tan","_midSide","inflate","side","sideNearestToPoint","leftMiddle","rightMiddle","topMiddle","bottomMiddle","_modelCenter","_magnet","_refPoint","endType","getPointFromConnectedLink","offset","top","bottom","left","right","topRight","bottomLeft","perpendicular","midSide","modelCenter"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/anchors/index.mjs"],"sourcesContent":["import * as util from '../util/index.mjs';\nimport { toRad } from '../g/index.mjs';\nimport { resolveRef } from '../linkAnchors/index.mjs';\n\nfunction bboxWrapper(method) {\n\n    return function(view, magnet, ref, opt) {\n\n        var rotate = !!opt.rotate;\n        var bbox = (rotate) ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);\n        var anchor = bbox[method]();\n\n        var dx = opt.dx;\n        if (dx) {\n            var dxPercentage = util.isPercentage(dx);\n            dx = parseFloat(dx);\n            if (isFinite(dx)) {\n                if (dxPercentage) {\n                    dx /= 100;\n                    dx *= bbox.width;\n                }\n                anchor.x += dx;\n            }\n        }\n\n        var dy = opt.dy;\n        if (dy) {\n            var dyPercentage = util.isPercentage(dy);\n            dy = parseFloat(dy);\n            if (isFinite(dy)) {\n                if (dyPercentage) {\n                    dy /= 100;\n                    dy *= bbox.height;\n                }\n                anchor.y += dy;\n            }\n        }\n\n        return (rotate) ? anchor.rotate(view.model.getBBox().center(), -view.model.angle()) : anchor;\n    };\n}\n\nfunction _perpendicular(view, magnet, refPoint, opt) {\n\n    var angle = view.model.angle();\n    var bbox = view.getNodeBBox(magnet);\n    var anchor = bbox.center();\n    var topLeft = bbox.origin();\n    var bottomRight = bbox.corner();\n\n    var padding = opt.padding;\n    if (!isFinite(padding)) padding = 0;\n\n    if ((topLeft.y + padding) <= refPoint.y && refPoint.y <= (bottomRight.y - padding)) {\n        var dy = (refPoint.y - anchor.y);\n        anchor.x += (angle === 0 || angle === 180) ? 0 : dy * 1 / Math.tan(toRad(angle));\n        anchor.y += dy;\n    } else if ((topLeft.x + padding) <= refPoint.x && refPoint.x <= (bottomRight.x - padding)) {\n        var dx = (refPoint.x - anchor.x);\n        anchor.y += (angle === 90 || angle === 270) ? 0 : dx * Math.tan(toRad(angle));\n        anchor.x += dx;\n    }\n\n    return anchor;\n}\n\nfunction _midSide(view, magnet, refPoint, opt) {\n\n    var rotate = !!opt.rotate;\n    var bbox, angle, center;\n    if (rotate) {\n        bbox = view.getNodeUnrotatedBBox(magnet);\n        center = view.model.getBBox().center();\n        angle = view.model.angle();\n    } else {\n        bbox = view.getNodeBBox(magnet);\n    }\n\n    var padding = opt.padding;\n    if (isFinite(padding)) bbox.inflate(padding);\n\n    if (rotate) refPoint.rotate(center, angle);\n\n    var side = bbox.sideNearestToPoint(refPoint);\n    var anchor;\n    switch (side) {\n        case 'left':\n            anchor = bbox.leftMiddle();\n            break;\n        case 'right':\n            anchor = bbox.rightMiddle();\n            break;\n        case 'top':\n            anchor = bbox.topMiddle();\n            break;\n        case 'bottom':\n            anchor = bbox.bottomMiddle();\n            break;\n    }\n\n    return (rotate) ? anchor.rotate(center, -angle) : anchor;\n}\n\n// Can find anchor from model, when there is no selector or the link end\n// is connected to a port\nfunction _modelCenter(view, _magnet, _refPoint, opt, endType) {\n    return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);\n}\n\n//joint.anchors\nexport const center = bboxWrapper('center');\nexport const top = bboxWrapper('topMiddle');\nexport const bottom = bboxWrapper('bottomMiddle');\nexport const left = bboxWrapper('leftMiddle');\nexport const right = bboxWrapper('rightMiddle');\nexport const topLeft = bboxWrapper('origin');\nexport const topRight = bboxWrapper('topRight');\nexport const bottomLeft = bboxWrapper('bottomLeft');\nexport const bottomRight = bboxWrapper('corner');\nexport const perpendicular = resolveRef(_perpendicular);\nexport const midSide = resolveRef(_midSide);\nexport const modelCenter = _modelCenter;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}