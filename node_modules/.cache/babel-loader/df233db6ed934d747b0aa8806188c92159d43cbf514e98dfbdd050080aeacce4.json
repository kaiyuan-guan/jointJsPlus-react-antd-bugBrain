{"ast":null,"code":"/*!\n * jQuery JavaScript Library v4.0.0-pre+c98597ea.dirty\n * https://jquery.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2023-11-24T14:04Z\n */\n\nimport { uniq, isEmpty } from '../../util/utilHelpers.mjs';\nimport { dataPriv, dataUser } from './vars.mjs';\nimport { Event } from './Event.mjs';\nconst document = typeof window !== 'undefined' ? window.document : null;\nconst documentElement = document && document.documentElement;\nconst rTypeNamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n// Only count HTML whitespace\n// Other whitespace should count in values\n// https://infra.spec.whatwg.org/#ascii-whitespace\nconst rNotHtmlWhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\n// Define a local copy of $\nconst $ = function (selector) {\n  // The $ object is actually just the init constructor 'enhanced'\n  // Need init if $ is called (just allow error to be thrown if not included)\n  return new $.Dom(selector);\n};\n$.fn = $.prototype = {\n  constructor: $,\n  // The default length of a $ object is 0\n  length: 0\n};\n\n// A global GUID counter for objects\n$.guid = 1;\n\n// User data storage\n$.data = dataUser;\n$.merge = function (first, second) {\n  let len = +second.length;\n  let i = first.length;\n  for (let j = 0; j < len; j++) {\n    first[i++] = second[j];\n  }\n  first.length = i;\n  return first;\n};\n$.parseHTML = function (string) {\n  // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.\n  const context = document.implementation.createHTMLDocument();\n  // Set the base href for the created document so any parsed elements with URLs\n  // are based on the document's URL\n  const base = context.createElement('base');\n  base.href = document.location.href;\n  context.head.appendChild(base);\n  context.body.innerHTML = string;\n  // remove scripts\n  const scripts = context.getElementsByTagName('script');\n  for (let i = 0; i < scripts.length; i++) {\n    scripts[i].remove();\n  }\n  return Array.from(context.body.childNodes);\n};\nif (typeof Symbol === 'function') {\n  $.fn[Symbol.iterator] = Array.prototype[Symbol.iterator];\n}\n$.fn.toArray = function () {\n  return Array.from(this);\n};\n\n// Take an array of elements and push it onto the stack\n// (returning the new matched element set)\n$.fn.pushStack = function (elements) {\n  // Build a new $ matched element set\n  const ret = $.merge(this.constructor(), elements);\n  // Add the old object onto the stack (as a reference)\n  ret.prevObject = this;\n  // Return the newly-formed element set\n  return ret;\n};\n$.fn.find = function (selector) {\n  const [el] = this;\n  const ret = this.pushStack([]);\n  if (!el) return ret;\n  // Early return if context is not an element, document or document fragment\n  const {\n    nodeType\n  } = el;\n  if (nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n    return ret;\n  }\n  if (typeof selector !== 'string') {\n    if (el !== selector && el.contains(selector)) {\n      $.merge(ret, [selector]);\n    }\n  } else {\n    $.merge(ret, el.querySelectorAll(selector));\n  }\n  return ret;\n};\n$.fn.add = function (selector, context) {\n  const newElements = $(selector, context).toArray();\n  const prevElements = this.toArray();\n  const ret = this.pushStack([]);\n  $.merge(ret, uniq(prevElements.concat(newElements)));\n  return ret;\n};\n$.fn.addBack = function () {\n  return this.add(this.prevObject);\n};\n$.fn.filter = function (selector) {\n  const matches = [];\n  for (let i = 0; i < this.length; i++) {\n    const node = this[i];\n    if (!node.matches(selector)) continue;\n    matches.push(node);\n  }\n  return this.pushStack(matches);\n};\n\n// A simple way to check for HTML strings\n// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n// Strict HTML recognition (trac-11290: must start with <)\n// Shortcut simple #id case for speed\nconst rQuickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/;\nfunction isObviousHtml(input) {\n  return input[0] === '<' && input[input.length - 1] === '>' && input.length >= 3;\n}\nconst Dom = function (selector) {\n  if (!selector) {\n    // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n    return this;\n  }\n  if (typeof selector === 'function') {\n    // HANDLE: $(function)\n    // Shortcut for document ready\n    throw new Error('function not supported');\n  }\n  if (arguments.length > 1) {\n    throw new Error('selector with context not supported');\n  }\n  if (selector.nodeType) {\n    // HANDLE: $(DOMElement)\n    this[0] = selector;\n    this.length = 1;\n    return this;\n  }\n  let match;\n  if (isObviousHtml(selector + '')) {\n    // Handle obvious HTML strings\n    // Assume that strings that start and end with <> are HTML and skip\n    // the regex check. This also handles browser-supported HTML wrappers\n    // like TrustedHTML.\n    match = [null, selector, null];\n  } else if (typeof selector === 'string') {\n    // Handle HTML strings or selectors\n    match = rQuickExpr.exec(selector);\n  } else {\n    // Array-like\n    return $.merge(this, selector);\n  }\n  if (!match || !match[1]) {\n    // HANDLE: $(expr)\n    return $root.find(selector);\n  }\n  // Match html or make sure no context is specified for #id\n  // Note: match[1] may be a string or a TrustedHTML wrapper\n  if (match[1]) {\n    // HANDLE: $(html) -> $(array)\n    $.merge(this, $.parseHTML(match[1]));\n    return this;\n  }\n  // HANDLE: $(#id)\n  const el = document.getElementById(match[2]);\n  if (el) {\n    // Inject the element directly into the $ object\n    this[0] = el;\n    this.length = 1;\n  }\n  return this;\n};\n$.Dom = Dom;\n\n// Give the init function the $ prototype for later instantiation\nDom.prototype = $.fn;\n\n// Events\n\n$.Event = Event;\n$.event = {\n  special: Object.create(null)\n};\n$.event.has = function (elem, eventType) {\n  const events = dataPriv.get(elem, 'events');\n  if (!events) return false;\n  if (!eventType) return true;\n  return Array.isArray(events[eventType]) && events[eventType].length > 0;\n};\n$.event.on = function (elem, types, selector, data, fn, one) {\n  // Types can be a map of types/handlers\n  if (typeof types === 'object') {\n    // ( types-Object, selector, data )\n    if (typeof selector !== 'string') {\n      // ( types-Object, data )\n      data = data || selector;\n      selector = undefined;\n    }\n    for (let type in types) {\n      $.event.on(elem, type, selector, data, types[type], one);\n    }\n    return elem;\n  }\n  if (data == null && fn == null) {\n    // ( types, fn )\n    fn = selector;\n    data = selector = undefined;\n  } else if (fn == null) {\n    if (typeof selector === 'string') {\n      // ( types, selector, fn )\n      fn = data;\n      data = undefined;\n    } else {\n      // ( types, data, fn )\n      fn = data;\n      data = selector;\n      selector = undefined;\n    }\n  }\n  if (!fn) {\n    return elem;\n  }\n  if (one === 1) {\n    const origFn = fn;\n    fn = function (event) {\n      // Can use an empty set, since event contains the info\n      $().off(event);\n      return origFn.apply(this, arguments);\n    };\n\n    // Use same guid so caller can remove using origFn\n    fn.guid = origFn.guid || (origFn.guid = $.guid++);\n  }\n  for (let i = 0; i < elem.length; i++) {\n    $.event.add(elem[i], types, fn, data, selector);\n  }\n};\n$.event.add = function (elem, types, handler, data, selector) {\n  // Only attach events to objects for which we can store data\n  if (typeof elem != 'object') {\n    return;\n  }\n  const elemData = dataPriv.create(elem);\n\n  // Caller can pass in an object of custom data in lieu of the handler\n  let handleObjIn;\n  if (handler.handler) {\n    handleObjIn = handler;\n    handler = handleObjIn.handler;\n    selector = handleObjIn.selector;\n  }\n\n  // Ensure that invalid selectors throw exceptions at attach time\n  // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n  if (selector) {\n    documentElement.matches(selector);\n  }\n\n  // Make sure that the handler has a unique ID, used to find/remove it later\n  if (!handler.guid) {\n    handler.guid = $.guid++;\n  }\n\n  // Init the element's event structure and main handler, if this is the first\n  let events;\n  if (!(events = elemData.events)) {\n    events = elemData.events = Object.create(null);\n  }\n  let eventHandle;\n  if (!(eventHandle = elemData.handle)) {\n    eventHandle = elemData.handle = function (e) {\n      // Discard the second event of a $.event.trigger() and\n      // when an event is called after a page has unloaded\n      return typeof $ !== 'undefined' ? $.event.dispatch.apply(elem, arguments) : undefined;\n    };\n  }\n\n  // Handle multiple events separated by a space\n  const typesArr = (types || '').match(rNotHtmlWhite) || [''];\n  let i = typesArr.length;\n  while (i--) {\n    const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);\n    // There *must* be a type, no attaching namespace-only handlers\n    if (!origType) {\n      continue;\n    }\n    const namespaces = ns.split('.').sort();\n    // If event changes its type, use the special event handlers for the changed type\n    let special = $.event.special[origType];\n    // If selector defined, determine special event api type, otherwise given type\n    const type = special && (selector ? special.delegateType : special.bindType) || origType;\n    // Update special based on newly reset type\n    special = $.event.special[type];\n    // handleObj is passed to all event handlers\n    const handleObj = Object.assign({\n      type: type,\n      origType: origType,\n      data: data,\n      handler: handler,\n      guid: handler.guid,\n      selector: selector,\n      namespace: namespaces.join('.')\n    }, handleObjIn);\n    let handlers;\n    // Init the event handler queue if we're the first\n    if (!(handlers = events[type])) {\n      handlers = events[type] = [];\n      handlers.delegateCount = 0;\n\n      // Only use addEventListener if the special events handler returns false\n      if (!special || !special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n        if (elem.addEventListener) {\n          elem.addEventListener(type, eventHandle);\n        }\n      }\n    }\n    if (special && special.add) {\n      special.add.call(elem, handleObj);\n      if (!handleObj.handler.guid) {\n        handleObj.handler.guid = handler.guid;\n      }\n    }\n\n    // Add to the element's handler list, delegates in front\n    if (selector) {\n      handlers.splice(handlers.delegateCount++, 0, handleObj);\n    } else {\n      handlers.push(handleObj);\n    }\n  }\n};\n\n// Detach an event or set of events from an element\n$.event.remove = function (elem, types, handler, selector, mappedTypes) {\n  const elemData = dataPriv.get(elem);\n  if (!elemData || !elemData.events) return;\n  const events = elemData.events;\n\n  // Once for each type.namespace in types; type may be omitted\n  const typesArr = (types || '').match(rNotHtmlWhite) || [''];\n  let i = typesArr.length;\n  while (i--) {\n    const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);\n    // Unbind all events (on this namespace, if provided) for the element\n    if (!origType) {\n      for (const type in events) {\n        $.event.remove(elem, type + typesArr[i], handler, selector, true);\n      }\n      continue;\n    }\n    const special = $.event.special[origType];\n    const type = special && (selector ? special.delegateType : special.bindType) || origType;\n    const handlers = events[type];\n    if (!handlers || handlers.length === 0) continue;\n    const namespaces = ns.split('.').sort();\n    const rNamespace = ns ? new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)') : null;\n\n    // Remove matching events\n    const origCount = handlers.length;\n    let j = origCount;\n    while (j--) {\n      const handleObj = handlers[j];\n      if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!rNamespace || rNamespace.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {\n        handlers.splice(j, 1);\n        if (handleObj.selector) {\n          handlers.delegateCount--;\n        }\n        if (special && special.remove) {\n          special.remove.call(elem, handleObj);\n        }\n      }\n    }\n\n    // Remove generic event handler if we removed something and no more handlers exist\n    // (avoids potential for endless recursion during removal of special event handlers)\n    if (origCount && handlers.length === 0) {\n      if (!special || !special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n        // This \"if\" is needed for plain objects\n        if (elem.removeEventListener) {\n          elem.removeEventListener(type, elemData.handle);\n        }\n      }\n      delete events[type];\n    }\n  }\n\n  // Remove data if it's no longer used\n  if (isEmpty(events)) {\n    dataPriv.remove(elem, 'handle');\n    dataPriv.remove(elem, 'events');\n  }\n};\n$.event.dispatch = function (nativeEvent) {\n  const elem = this;\n  // Make a writable $.Event from the native event object\n  const event = $.event.fix(nativeEvent);\n  event.delegateTarget = elem;\n  // Use the fix-ed $.Event rather than the (read-only) native event\n  const args = Array.from(arguments);\n  args[0] = event;\n  const eventsData = dataPriv.get(elem, 'events');\n  const handlers = eventsData && eventsData[event.type] || [];\n  const special = $.event.special[event.type];\n\n  // Call the preDispatch hook for the mapped type, and let it bail if desired\n  if (special && special.preDispatch) {\n    if (special.preDispatch.call(elem, event) === false) return;\n  }\n\n  // Determine handlers\n  const handlerQueue = $.event.handlers.call(elem, event, handlers);\n\n  // Run delegates first; they may want to stop propagation beneath us\n  let i = 0;\n  let matched;\n  while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n    event.currentTarget = matched.elem;\n    let j = 0;\n    let handleObj;\n    while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n      event.handleObj = handleObj;\n      event.data = handleObj.data;\n      const origSpecial = $.event.special[handleObj.origType];\n      let handler;\n      if (origSpecial && origSpecial.handle) {\n        handler = origSpecial.handle;\n      } else {\n        handler = handleObj.handler;\n      }\n      const ret = handler.apply(matched.elem, args);\n      if (ret !== undefined) {\n        if ((event.result = ret) === false) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      }\n    }\n  }\n\n  // Call the postDispatch hook for the mapped type\n  if (special && special.postDispatch) {\n    special.postDispatch.call(elem, event);\n  }\n  return event.result;\n};\n$.event.handlers = function (event, handlers) {\n  const delegateCount = handlers.delegateCount;\n  const handlerQueue = [];\n\n  // Find delegate handlers\n  if (delegateCount &&\n  // Support: Firefox <=42 - 66+\n  // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n  // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n  // Support: IE 11+\n  // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n  !(event.type === 'click' && event.button >= 1)) {\n    for (let cur = event.target; cur !== this; cur = cur.parentNode || this) {\n      // Don't check non-elements (trac-13208)\n      // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n      if (cur.nodeType === 1 && !(event.type === 'click' && cur.disabled === true)) {\n        const matchedHandlers = [];\n        const matchedSelectors = {};\n        for (let i = 0; i < delegateCount; i++) {\n          const handleObj = handlers[i];\n          // Don't conflict with Object.prototype properties (trac-13203)\n          const sel = handleObj.selector + ' ';\n          if (matchedSelectors[sel] === undefined) {\n            matchedSelectors[sel] = cur.matches(sel);\n          }\n          if (matchedSelectors[sel]) {\n            matchedHandlers.push(handleObj);\n          }\n        }\n        if (matchedHandlers.length) {\n          handlerQueue.push({\n            elem: cur,\n            handlers: matchedHandlers\n          });\n        }\n      }\n    }\n  }\n\n  // Add the remaining (directly-bound) handlers\n  if (delegateCount < handlers.length) {\n    handlerQueue.push({\n      elem: this,\n      handlers: handlers.slice(delegateCount)\n    });\n  }\n  return handlerQueue;\n};\n$.event.fix = function (originalEvent) {\n  return originalEvent.envelope ? originalEvent : new Event(originalEvent);\n};\n\n// A central reference to the root $(document)\nconst $root = $(document);\nexport { $ as default };","map":{"version":3,"names":["uniq","isEmpty","dataPriv","dataUser","Event","document","window","documentElement","rTypeNamespace","rNotHtmlWhite","$","selector","Dom","fn","prototype","constructor","length","guid","data","merge","first","second","len","i","j","parseHTML","string","context","implementation","createHTMLDocument","base","createElement","href","location","head","appendChild","body","innerHTML","scripts","getElementsByTagName","remove","Array","from","childNodes","Symbol","iterator","toArray","pushStack","elements","ret","prevObject","find","el","nodeType","contains","querySelectorAll","add","newElements","prevElements","concat","addBack","filter","matches","node","push","rQuickExpr","isObviousHtml","input","Error","arguments","match","exec","$root","getElementById","event","special","Object","create","has","elem","eventType","events","get","isArray","on","types","one","undefined","type","origFn","off","apply","handler","elemData","handleObjIn","eventHandle","handle","e","dispatch","typesArr","origType","ns","namespaces","split","sort","delegateType","bindType","handleObj","assign","namespace","join","handlers","delegateCount","setup","call","addEventListener","splice","mappedTypes","rNamespace","RegExp","origCount","test","teardown","removeEventListener","nativeEvent","fix","delegateTarget","args","eventsData","preDispatch","handlerQueue","matched","isPropagationStopped","currentTarget","isImmediatePropagationStopped","origSpecial","result","preventDefault","stopPropagation","postDispatch","button","cur","target","parentNode","disabled","matchedHandlers","matchedSelectors","sel","slice","originalEvent","envelope","default"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/mvc/Dom/Dom.mjs"],"sourcesContent":["\n/*!\n * jQuery JavaScript Library v4.0.0-pre+c98597ea.dirty\n * https://jquery.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2023-11-24T14:04Z\n */\n\nimport { uniq, isEmpty } from '../../util/utilHelpers.mjs';\nimport { dataPriv, dataUser } from './vars.mjs';\nimport { Event } from './Event.mjs';\n\nconst document = (typeof window !== 'undefined') ? window.document : null;\nconst documentElement = document && document.documentElement;\n\nconst rTypeNamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n// Only count HTML whitespace\n// Other whitespace should count in values\n// https://infra.spec.whatwg.org/#ascii-whitespace\nconst rNotHtmlWhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\n// Define a local copy of $\nconst $ = function(selector) {\n    // The $ object is actually just the init constructor 'enhanced'\n    // Need init if $ is called (just allow error to be thrown if not included)\n    return new $.Dom(selector);\n};\n\n$.fn = $.prototype = {\n    constructor: $,\n    // The default length of a $ object is 0\n    length: 0,\n};\n\n// A global GUID counter for objects\n$.guid = 1;\n\n// User data storage\n$.data = dataUser;\n\n$.merge = function(first, second) {\n    let len = +second.length;\n    let i = first.length;\n    for (let j = 0; j < len; j++) {\n        first[i++] = second[j];\n    }\n    first.length = i;\n    return first;\n};\n\n$.parseHTML = function(string) {\n    // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.\n    const context = document.implementation.createHTMLDocument();\n    // Set the base href for the created document so any parsed elements with URLs\n    // are based on the document's URL\n    const base = context.createElement('base');\n    base.href = document.location.href;\n    context.head.appendChild(base);\n\n    context.body.innerHTML = string;\n    // remove scripts\n    const scripts = context.getElementsByTagName('script');\n    for (let i = 0; i < scripts.length; i++) {\n        scripts[i].remove();\n    }\n    return Array.from(context.body.childNodes);\n};\n\nif (typeof Symbol === 'function') {\n    $.fn[Symbol.iterator] = Array.prototype[Symbol.iterator];\n}\n\n$.fn.toArray = function() {\n    return Array.from(this);\n};\n\n// Take an array of elements and push it onto the stack\n// (returning the new matched element set)\n$.fn.pushStack = function(elements) {\n    // Build a new $ matched element set\n    const ret = $.merge(this.constructor(), elements);\n    // Add the old object onto the stack (as a reference)\n    ret.prevObject = this;\n    // Return the newly-formed element set\n    return ret;\n};\n\n$.fn.find = function(selector) {\n    const [el] = this;\n    const ret = this.pushStack([]);\n    if (!el) return ret;\n    // Early return if context is not an element, document or document fragment\n    const { nodeType } = el;\n    if (nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n        return ret;\n    }\n    if (typeof selector !== 'string') {\n        if (el !== selector && el.contains(selector)) {\n            $.merge(ret, [selector]);\n        }\n    } else {\n        $.merge(ret, el.querySelectorAll(selector));\n    }\n    return ret;\n};\n\n$.fn.add = function(selector, context) {\n    const newElements = $(selector, context).toArray();\n    const prevElements = this.toArray();\n    const ret = this.pushStack([]);\n    $.merge(ret, uniq(prevElements.concat(newElements)));\n    return ret;\n};\n\n$.fn.addBack = function() {\n    return this.add(this.prevObject);\n};\n\n$.fn.filter = function(selector) {\n    const matches = [];\n    for (let i = 0; i < this.length; i++) {\n        const node = this[i];\n        if (!node.matches(selector)) continue;\n        matches.push(node);\n    }\n    return this.pushStack(matches);\n};\n\n// A simple way to check for HTML strings\n// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n// Strict HTML recognition (trac-11290: must start with <)\n// Shortcut simple #id case for speed\nconst rQuickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/;\n\nfunction isObviousHtml(input) {\n    return (\n        input[0] === '<' && input[input.length - 1] === '>' && input.length >= 3\n    );\n}\n\nconst Dom = function(selector) {\n    if (!selector) {\n        // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n        return this;\n    }\n    if (typeof selector === 'function') {\n        // HANDLE: $(function)\n        // Shortcut for document ready\n        throw new Error('function not supported');\n    }\n    if (arguments.length > 1) {\n        throw new Error('selector with context not supported');\n    }\n    if (selector.nodeType) {\n        // HANDLE: $(DOMElement)\n        this[0] = selector;\n        this.length = 1;\n        return this;\n    }\n    let match;\n    if (isObviousHtml(selector + '')) {\n        // Handle obvious HTML strings\n        // Assume that strings that start and end with <> are HTML and skip\n        // the regex check. This also handles browser-supported HTML wrappers\n        // like TrustedHTML.\n        match = [null, selector, null];\n    } else if (typeof selector === 'string') {\n        // Handle HTML strings or selectors\n        match = rQuickExpr.exec(selector);\n    } else {\n        // Array-like\n        return $.merge(this, selector);\n    }\n    if (!match || !match[1]) {\n        // HANDLE: $(expr)\n        return $root.find(selector);\n    }\n    // Match html or make sure no context is specified for #id\n    // Note: match[1] may be a string or a TrustedHTML wrapper\n    if (match[1]) {\n        // HANDLE: $(html) -> $(array)\n        $.merge(this, $.parseHTML(match[1]));\n        return this;\n    }\n    // HANDLE: $(#id)\n    const el = document.getElementById(match[2]);\n    if (el) {\n        // Inject the element directly into the $ object\n        this[0] = el;\n        this.length = 1;\n    }\n    return this;\n};\n\n$.Dom = Dom;\n\n// Give the init function the $ prototype for later instantiation\nDom.prototype = $.fn;\n\n// Events\n\n$.Event = Event;\n\n$.event = {\n    special: Object.create(null),\n};\n\n$.event.has = function(elem, eventType) {\n    const events = dataPriv.get(elem, 'events');\n    if (!events) return false;\n    if (!eventType) return true;\n    return Array.isArray(events[eventType]) && events[eventType].length > 0;\n};\n\n$.event.on = function(elem, types, selector, data, fn, one) {\n\n    // Types can be a map of types/handlers\n    if (typeof types === 'object') {\n        // ( types-Object, selector, data )\n        if (typeof selector !== 'string') {\n            // ( types-Object, data )\n            data = data || selector;\n            selector = undefined;\n        }\n        for (let type in types) {\n            $.event.on(elem, type, selector, data, types[type], one);\n        }\n        return elem;\n    }\n\n    if (data == null && fn == null) {\n        // ( types, fn )\n        fn = selector;\n        data = selector = undefined;\n    } else if (fn == null) {\n        if (typeof selector === 'string') {\n            // ( types, selector, fn )\n            fn = data;\n            data = undefined;\n        } else {\n            // ( types, data, fn )\n            fn = data;\n            data = selector;\n            selector = undefined;\n        }\n    }\n    if (!fn) {\n        return elem;\n    }\n    if (one === 1) {\n        const origFn = fn;\n        fn = function(event) {\n            // Can use an empty set, since event contains the info\n            $().off(event);\n            return origFn.apply(this, arguments);\n        };\n\n        // Use same guid so caller can remove using origFn\n        fn.guid = origFn.guid || (origFn.guid = $.guid++);\n    }\n    for (let i = 0; i < elem.length; i++) {\n        $.event.add(elem[i], types, fn, data, selector);\n    }\n};\n\n$.event.add = function(elem, types, handler, data, selector) {\n    // Only attach events to objects for which we can store data\n    if (typeof elem != 'object') {\n        return;\n    }\n\n    const elemData = dataPriv.create(elem);\n\n    // Caller can pass in an object of custom data in lieu of the handler\n    let handleObjIn;\n    if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n    }\n\n    // Ensure that invalid selectors throw exceptions at attach time\n    // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n    if (selector) {\n        documentElement.matches(selector);\n    }\n\n    // Make sure that the handler has a unique ID, used to find/remove it later\n    if (!handler.guid) {\n        handler.guid = $.guid++;\n    }\n\n    // Init the element's event structure and main handler, if this is the first\n    let events;\n    if (!(events = elemData.events)) {\n        events = elemData.events = Object.create(null);\n    }\n    let eventHandle;\n    if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function(e) {\n            // Discard the second event of a $.event.trigger() and\n            // when an event is called after a page has unloaded\n            return (typeof $ !== 'undefined')\n                ? $.event.dispatch.apply(elem, arguments)\n                : undefined;\n        };\n    }\n\n    // Handle multiple events separated by a space\n    const typesArr = (types || '').match(rNotHtmlWhite) || [''];\n    let i = typesArr.length;\n    while (i--) {\n        const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);\n        // There *must* be a type, no attaching namespace-only handlers\n        if (!origType) {\n            continue;\n        }\n\n        const namespaces = ns.split('.').sort();\n        // If event changes its type, use the special event handlers for the changed type\n        let special = $.event.special[origType];\n        // If selector defined, determine special event api type, otherwise given type\n        const type = (special && (selector ? special.delegateType : special.bindType)) || origType;\n        // Update special based on newly reset type\n        special = $.event.special[type];\n        // handleObj is passed to all event handlers\n        const handleObj = Object.assign(\n            {\n                type: type,\n                origType: origType,\n                data: data,\n                handler: handler,\n                guid: handler.guid,\n                selector: selector,\n                namespace: namespaces.join('.'),\n            },\n            handleObjIn\n        );\n\n        let handlers;\n        // Init the event handler queue if we're the first\n        if (!(handlers = events[type])) {\n            handlers = events[type] = [];\n            handlers.delegateCount = 0;\n\n            // Only use addEventListener if the special events handler returns false\n            if (\n                !special || !special.setup ||\n                    special.setup.call(elem, data, namespaces, eventHandle) === false\n            ) {\n                if (elem.addEventListener) {\n                    elem.addEventListener(type, eventHandle);\n                }\n            }\n        }\n\n        if (special && special.add) {\n            special.add.call(elem, handleObj);\n            if (!handleObj.handler.guid) {\n                handleObj.handler.guid = handler.guid;\n            }\n        }\n\n        // Add to the element's handler list, delegates in front\n        if (selector) {\n            handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n            handlers.push(handleObj);\n        }\n    }\n};\n\n// Detach an event or set of events from an element\n$.event.remove = function(elem, types, handler, selector, mappedTypes) {\n\n    const elemData = dataPriv.get(elem);\n    if (!elemData || !elemData.events) return;\n    const events = elemData.events;\n\n    // Once for each type.namespace in types; type may be omitted\n    const typesArr = (types || '').match(rNotHtmlWhite) || [''];\n    let i = typesArr.length;\n    while (i--) {\n        const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);\n        // Unbind all events (on this namespace, if provided) for the element\n        if (!origType) {\n            for (const type in events) {\n                $.event.remove(\n                    elem,\n                    type + typesArr[i],\n                    handler,\n                    selector,\n                    true\n                );\n            }\n            continue;\n        }\n\n        const special = $.event.special[origType];\n        const type = (special && (selector ? special.delegateType : special.bindType)) || origType;\n        const handlers = events[type];\n        if (!handlers || handlers.length === 0) continue;\n\n        const namespaces = ns.split('.').sort();\n        const rNamespace = ns\n            ? new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)')\n            : null;\n\n        // Remove matching events\n        const origCount = handlers.length;\n        let j = origCount;\n        while (j--) {\n            const handleObj = handlers[j];\n\n            if (\n                (mappedTypes || origType === handleObj.origType) &&\n                    (!handler || handler.guid === handleObj.guid) &&\n                    (!rNamespace || rNamespace.test(handleObj.namespace)) &&\n                    (!selector ||\n                        selector === handleObj.selector ||\n                        (selector === '**' && handleObj.selector))\n            ) {\n                handlers.splice(j, 1);\n                if (handleObj.selector) {\n                    handlers.delegateCount--;\n                }\n                if (special && special.remove) {\n                    special.remove.call(elem, handleObj);\n                }\n            }\n        }\n\n        // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n        if (origCount && handlers.length === 0) {\n            if (\n                !special || !special.teardown ||\n                    special.teardown.call(elem, namespaces, elemData.handle) === false\n            ) {\n                // This \"if\" is needed for plain objects\n                if (elem.removeEventListener) {\n                    elem.removeEventListener(type, elemData.handle);\n                }\n            }\n            delete events[type];\n        }\n    }\n\n    // Remove data if it's no longer used\n    if (isEmpty(events)) {\n        dataPriv.remove(elem, 'handle');\n        dataPriv.remove(elem, 'events');\n    }\n};\n\n$.event.dispatch = function(nativeEvent) {\n\n    const elem = this;\n    // Make a writable $.Event from the native event object\n    const event = $.event.fix(nativeEvent);\n    event.delegateTarget = elem;\n    // Use the fix-ed $.Event rather than the (read-only) native event\n    const args = Array.from(arguments);\n    args[0] = event;\n\n    const eventsData = dataPriv.get(elem, 'events');\n    const handlers = (eventsData && eventsData[event.type]) || [];\n    const special = $.event.special[event.type];\n\n    // Call the preDispatch hook for the mapped type, and let it bail if desired\n    if (special && special.preDispatch) {\n        if (special.preDispatch.call(elem, event) === false) return;\n    }\n\n    // Determine handlers\n    const handlerQueue = $.event.handlers.call(elem, event, handlers);\n\n    // Run delegates first; they may want to stop propagation beneath us\n    let i = 0;\n    let matched;\n    while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n        let j = 0;\n        let handleObj;\n        while (\n            (handleObj = matched.handlers[j++]) &&\n                !event.isImmediatePropagationStopped()\n        ) {\n\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n\n            const origSpecial = $.event.special[handleObj.origType];\n            let handler;\n            if (origSpecial && origSpecial.handle) {\n                handler = origSpecial.handle;\n            } else {\n                handler = handleObj.handler;\n            }\n\n            const ret = handler.apply(matched.elem, args);\n            if (ret !== undefined) {\n                if ((event.result = ret) === false) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                }\n            }\n        }\n    }\n\n    // Call the postDispatch hook for the mapped type\n    if (special && special.postDispatch) {\n        special.postDispatch.call(elem, event);\n    }\n\n    return event.result;\n};\n\n$.event.handlers = function(event, handlers) {\n\n    const delegateCount = handlers.delegateCount;\n    const handlerQueue = [];\n\n    // Find delegate handlers\n    if (\n        delegateCount &&\n            // Support: Firefox <=42 - 66+\n            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n            // Support: IE 11+\n            // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n            !(event.type === 'click' && event.button >= 1)\n    ) {\n        for (let cur = event.target; cur !== this; cur = cur.parentNode || this) {\n            // Don't check non-elements (trac-13208)\n            // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n            if (\n                cur.nodeType === 1 &&\n                    !(event.type === 'click' && cur.disabled === true)\n            ) {\n                const matchedHandlers = [];\n                const matchedSelectors = {};\n                for (let i = 0; i < delegateCount; i++) {\n                    const handleObj = handlers[i];\n                    // Don't conflict with Object.prototype properties (trac-13203)\n                    const sel = handleObj.selector + ' ';\n                    if (matchedSelectors[sel] === undefined) {\n                        matchedSelectors[sel] = cur.matches(sel);\n                    }\n                    if (matchedSelectors[sel]) {\n                        matchedHandlers.push(handleObj);\n                    }\n                }\n                if (matchedHandlers.length) {\n                    handlerQueue.push({\n                        elem: cur,\n                        handlers: matchedHandlers,\n                    });\n                }\n            }\n        }\n    }\n\n    // Add the remaining (directly-bound) handlers\n    if (delegateCount < handlers.length) {\n        handlerQueue.push({\n            elem: this,\n            handlers: handlers.slice(delegateCount),\n        });\n    }\n\n    return handlerQueue;\n};\n\n$.event.fix = function(originalEvent) {\n    return originalEvent.envelope ? originalEvent : new Event(originalEvent);\n};\n\n// A central reference to the root $(document)\nconst $root = $(document);\n\nexport { $ as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}