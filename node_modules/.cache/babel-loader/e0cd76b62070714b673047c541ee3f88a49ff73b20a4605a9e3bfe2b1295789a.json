{"ast":null,"code":"import V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\nconst MASK_CLIP = 20;\nfunction forEachDescendant(vel, fn) {\n  const descendants = vel.children();\n  while (descendants.length > 0) {\n    const descendant = descendants.shift();\n    if (fn(descendant)) {\n      descendants.push(...descendant.children());\n    }\n  }\n}\nexport const mask = HighlighterView.extend({\n  tagName: 'rect',\n  className: 'highlight-mask',\n  attributes: {\n    'pointer-events': 'none'\n  },\n  options: {\n    padding: 3,\n    maskClip: MASK_CLIP,\n    deep: false,\n    attrs: {\n      'stroke': '#FEB663',\n      'stroke-width': 3,\n      'stroke-linecap': 'butt',\n      'stroke-linejoin': 'miter'\n    }\n  },\n  VISIBLE: 'white',\n  INVISIBLE: 'black',\n  MASK_ROOT_ATTRIBUTE_BLACKLIST: ['marker-start', 'marker-end', 'marker-mid', 'transform', 'stroke-dasharray', 'class'],\n  MASK_CHILD_ATTRIBUTE_BLACKLIST: ['stroke', 'fill', 'stroke-width', 'stroke-opacity', 'stroke-dasharray', 'fill-opacity', 'marker-start', 'marker-end', 'marker-mid', 'class'],\n  // TODO: change the list to a function callback\n  MASK_REPLACE_TAGS: ['FOREIGNOBJECT', 'IMAGE', 'USE', 'TEXT', 'TSPAN', 'TEXTPATH'],\n  // TODO: change the list to a function callback\n  MASK_REMOVE_TAGS: ['TEXT', 'TSPAN', 'TEXTPATH'],\n  transformMaskChild(cellView, childEl) {\n    const {\n      MASK_CHILD_ATTRIBUTE_BLACKLIST,\n      MASK_REPLACE_TAGS,\n      MASK_REMOVE_TAGS\n    } = this;\n    const childTagName = childEl.tagName();\n    // Do not include the element in the mask's image\n    if (!V.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n      childEl.remove();\n      return false;\n    }\n    // Replace the element with a rectangle\n    if (MASK_REPLACE_TAGS.includes(childTagName)) {\n      // Note: clone() method does not change the children ids\n      const originalChild = cellView.vel.findOne(`#${childEl.id}`);\n      if (originalChild) {\n        const {\n          node: originalNode\n        } = originalChild;\n        let childBBox = cellView.getNodeBoundingRect(originalNode);\n        if (cellView.model.isElement()) {\n          childBBox = V.transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n        }\n        const replacement = V('rect', childBBox.toJSON());\n        const {\n          x: ox,\n          y: oy\n        } = childBBox.center();\n        const {\n          angle,\n          cx = ox,\n          cy = oy\n        } = originalChild.rotate();\n        if (angle) replacement.rotate(angle, cx, cy);\n        // Note: it's not important to keep the same sibling index since all subnodes are filled\n        childEl.parent().append(replacement);\n      }\n      childEl.remove();\n      return false;\n    }\n    // Keep the element, but clean it from certain attributes\n    MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n      if (attrName === 'fill' && childEl.attr('fill') === 'none') return;\n      childEl.removeAttr(attrName);\n    });\n    return true;\n  },\n  transformMaskRoot(_cellView, rootEl) {\n    const {\n      MASK_ROOT_ATTRIBUTE_BLACKLIST\n    } = this;\n    MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n      rootEl.removeAttr(attrName);\n    });\n  },\n  getMaskShape(cellView, vel) {\n    const {\n      options,\n      MASK_REPLACE_TAGS\n    } = this;\n    const {\n      deep\n    } = options;\n    const tagName = vel.tagName();\n    let maskRoot;\n    if (tagName === 'G') {\n      if (!deep) return null;\n      maskRoot = vel.clone();\n      forEachDescendant(maskRoot, maskChild => this.transformMaskChild(cellView, maskChild));\n    } else {\n      if (MASK_REPLACE_TAGS.includes(tagName)) return null;\n      maskRoot = vel.clone();\n    }\n    this.transformMaskRoot(cellView, maskRoot);\n    return maskRoot;\n  },\n  getMaskId() {\n    return `highlight-mask-${this.cid}`;\n  },\n  getMask(cellView, vNode) {\n    const {\n      VISIBLE,\n      INVISIBLE,\n      options\n    } = this;\n    const {\n      padding,\n      attrs\n    } = options;\n    // support both `strokeWidth` and `stroke-width` attribute names\n    const strokeWidth = parseFloat(V('g').attr(attrs).attr('stroke-width'));\n    const hasNodeFill = vNode.attr('fill') !== 'none';\n    let magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));\n    if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;\n    // stroke of the invisible shape\n    const minStrokeWidth = magnetStrokeWidth + padding * 2;\n    // stroke of the visible shape\n    const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n    let maskEl = this.getMaskShape(cellView, vNode);\n    if (!maskEl) {\n      const nodeBBox = cellView.getNodeBoundingRect(vNode.node);\n      // Make sure the rect is visible\n      nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n      maskEl = V('rect', nodeBBox.toJSON());\n    }\n    maskEl.attr(attrs);\n    return V('mask', {\n      'id': this.getMaskId()\n    }).append([maskEl.clone().attr({\n      'fill': hasNodeFill ? VISIBLE : 'none',\n      'stroke': VISIBLE,\n      'stroke-width': maxStrokeWidth\n    }), maskEl.clone().attr({\n      'fill': hasNodeFill ? INVISIBLE : 'none',\n      'stroke': INVISIBLE,\n      'stroke-width': minStrokeWidth\n    })]);\n  },\n  removeMask(paper) {\n    const maskNode = paper.svg.getElementById(this.getMaskId());\n    if (maskNode) {\n      paper.defs.removeChild(maskNode);\n    }\n  },\n  addMask(paper, maskEl) {\n    paper.defs.appendChild(maskEl.node);\n  },\n  highlight(cellView, node) {\n    const {\n      options,\n      vel\n    } = this;\n    const {\n      padding,\n      attrs,\n      maskClip = MASK_CLIP,\n      layer\n    } = options;\n    const color = 'stroke' in attrs ? attrs['stroke'] : '#000000';\n    if (!layer && node === cellView.el) {\n      // If the highlighter is appended to the cellView\n      // and we measure the size of the cellView wrapping group\n      // it's necessary to remove the highlighter first\n      vel.remove();\n    }\n    const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n    const highlightMatrix = this.getNodeMatrix(cellView, node);\n    const maskEl = this.getMask(cellView, V(node));\n    this.addMask(cellView.paper, maskEl);\n    vel.attr(highlighterBBox.toJSON());\n    vel.attr({\n      'transform': V.matrixToTransformString(highlightMatrix),\n      'mask': `url(#${maskEl.id})`,\n      'fill': color\n    });\n  },\n  unhighlight(cellView) {\n    this.removeMask(cellView.paper);\n  }\n});","map":{"version":3,"names":["V","HighlighterView","MASK_CLIP","forEachDescendant","vel","fn","descendants","children","length","descendant","shift","push","mask","extend","tagName","className","attributes","options","padding","maskClip","deep","attrs","VISIBLE","INVISIBLE","MASK_ROOT_ATTRIBUTE_BLACKLIST","MASK_CHILD_ATTRIBUTE_BLACKLIST","MASK_REPLACE_TAGS","MASK_REMOVE_TAGS","transformMaskChild","cellView","childEl","childTagName","isSVGGraphicsElement","includes","remove","originalChild","findOne","id","node","originalNode","childBBox","getNodeBoundingRect","model","isElement","transformRect","getNodeMatrix","replacement","toJSON","x","ox","y","oy","center","angle","cx","cy","rotate","parent","append","forEach","attrName","attr","removeAttr","transformMaskRoot","_cellView","rootEl","getMaskShape","maskRoot","clone","maskChild","getMaskId","cid","getMask","vNode","strokeWidth","parseFloat","hasNodeFill","magnetStrokeWidth","isNaN","minStrokeWidth","maxStrokeWidth","maskEl","nodeBBox","inflate","width","height","removeMask","paper","maskNode","svg","getElementById","defs","removeChild","addMask","appendChild","highlight","layer","color","el","highlighterBBox","highlightMatrix","matrixToTransformString","unhighlight"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/highlighters/mask.mjs"],"sourcesContent":["import V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\n\nconst MASK_CLIP = 20;\n\nfunction forEachDescendant(vel, fn) {\n    const descendants = vel.children();\n    while (descendants.length > 0) {\n        const descendant = descendants.shift();\n        if (fn(descendant)) {\n            descendants.push(...descendant.children());\n        }\n    }\n}\n\nexport const mask = HighlighterView.extend({\n\n    tagName: 'rect',\n    className: 'highlight-mask',\n    attributes: {\n        'pointer-events': 'none'\n    },\n\n    options: {\n        padding: 3,\n        maskClip: MASK_CLIP,\n        deep: false,\n        attrs: {\n            'stroke': '#FEB663',\n            'stroke-width': 3,\n            'stroke-linecap': 'butt',\n            'stroke-linejoin': 'miter',\n        }\n    },\n\n    VISIBLE: 'white',\n    INVISIBLE: 'black',\n\n    MASK_ROOT_ATTRIBUTE_BLACKLIST: [\n        'marker-start',\n        'marker-end',\n        'marker-mid',\n        'transform',\n        'stroke-dasharray',\n        'class',\n    ],\n\n    MASK_CHILD_ATTRIBUTE_BLACKLIST: [\n        'stroke',\n        'fill',\n        'stroke-width',\n        'stroke-opacity',\n        'stroke-dasharray',\n        'fill-opacity',\n        'marker-start',\n        'marker-end',\n        'marker-mid',\n        'class',\n    ],\n\n    // TODO: change the list to a function callback\n    MASK_REPLACE_TAGS: [\n        'FOREIGNOBJECT',\n        'IMAGE',\n        'USE',\n        'TEXT',\n        'TSPAN',\n        'TEXTPATH'\n    ],\n\n    // TODO: change the list to a function callback\n    MASK_REMOVE_TAGS: [\n        'TEXT',\n        'TSPAN',\n        'TEXTPATH'\n    ],\n\n    transformMaskChild(cellView, childEl) {\n        const {\n            MASK_CHILD_ATTRIBUTE_BLACKLIST,\n            MASK_REPLACE_TAGS,\n            MASK_REMOVE_TAGS\n        } = this;\n        const childTagName = childEl.tagName();\n        // Do not include the element in the mask's image\n        if (!V.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n            childEl.remove();\n            return false;\n        }\n        // Replace the element with a rectangle\n        if (MASK_REPLACE_TAGS.includes(childTagName)) {\n            // Note: clone() method does not change the children ids\n            const originalChild = cellView.vel.findOne(`#${childEl.id}`);\n            if (originalChild) {\n                const { node: originalNode } = originalChild;\n                let childBBox = cellView.getNodeBoundingRect(originalNode);\n                if (cellView.model.isElement()) {\n                    childBBox = V.transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n                }\n                const replacement = V('rect', childBBox.toJSON());\n                const { x: ox, y: oy } = childBBox.center();\n                const { angle, cx = ox, cy = oy } = originalChild.rotate();\n                if (angle) replacement.rotate(angle, cx, cy);\n                // Note: it's not important to keep the same sibling index since all subnodes are filled\n                childEl.parent().append(replacement);\n            }\n            childEl.remove();\n            return false;\n        }\n        // Keep the element, but clean it from certain attributes\n        MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n            if (attrName === 'fill' && childEl.attr('fill') === 'none') return;\n            childEl.removeAttr(attrName);\n        });\n        return true;\n    },\n\n    transformMaskRoot(_cellView, rootEl) {\n        const { MASK_ROOT_ATTRIBUTE_BLACKLIST } = this;\n        MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n            rootEl.removeAttr(attrName);\n        });\n    },\n\n    getMaskShape(cellView, vel) {\n        const { options, MASK_REPLACE_TAGS } = this;\n        const { deep } = options;\n        const tagName = vel.tagName();\n        let maskRoot;\n        if (tagName === 'G') {\n            if (!deep) return null;\n            maskRoot = vel.clone();\n            forEachDescendant(maskRoot, maskChild => this.transformMaskChild(cellView, maskChild));\n        } else {\n            if (MASK_REPLACE_TAGS.includes(tagName)) return null;\n            maskRoot = vel.clone();\n        }\n        this.transformMaskRoot(cellView, maskRoot);\n        return maskRoot;\n    },\n\n    getMaskId() {\n        return `highlight-mask-${this.cid}`;\n    },\n\n    getMask(cellView, vNode) {\n\n        const { VISIBLE, INVISIBLE, options } = this;\n        const { padding, attrs } = options;\n        // support both `strokeWidth` and `stroke-width` attribute names\n        const strokeWidth = parseFloat(V('g').attr(attrs).attr('stroke-width'));\n        const hasNodeFill = vNode.attr('fill') !== 'none';\n        let magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));\n        if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;\n        // stroke of the invisible shape\n        const minStrokeWidth = magnetStrokeWidth + padding * 2;\n        // stroke of the visible shape\n        const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n        let maskEl = this.getMaskShape(cellView, vNode);\n        if (!maskEl) {\n            const nodeBBox = cellView.getNodeBoundingRect(vNode.node);\n            // Make sure the rect is visible\n            nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n            maskEl =  V('rect', nodeBBox.toJSON());\n        }\n        maskEl.attr(attrs);\n        return V('mask', {\n            'id': this.getMaskId()\n        }).append([\n            maskEl.clone().attr({\n                'fill': hasNodeFill ? VISIBLE : 'none',\n                'stroke': VISIBLE,\n                'stroke-width': maxStrokeWidth\n            }),\n            maskEl.clone().attr({\n                'fill': hasNodeFill ? INVISIBLE : 'none',\n                'stroke': INVISIBLE,\n                'stroke-width': minStrokeWidth\n            })\n        ]);\n    },\n\n    removeMask(paper) {\n        const maskNode = paper.svg.getElementById(this.getMaskId());\n        if (maskNode) {\n            paper.defs.removeChild(maskNode);\n        }\n    },\n\n    addMask(paper, maskEl) {\n        paper.defs.appendChild(maskEl.node);\n    },\n\n    highlight(cellView, node) {\n        const { options, vel } = this;\n        const { padding, attrs, maskClip = MASK_CLIP, layer } = options;\n        const color = ('stroke' in attrs) ? attrs['stroke'] : '#000000';\n        if (!layer && node === cellView.el) {\n            // If the highlighter is appended to the cellView\n            // and we measure the size of the cellView wrapping group\n            // it's necessary to remove the highlighter first\n            vel.remove();\n        }\n        const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n        const highlightMatrix = this.getNodeMatrix(cellView, node);\n        const maskEl = this.getMask(cellView, V(node));\n        this.addMask(cellView.paper, maskEl);\n        vel.attr(highlighterBBox.toJSON());\n        vel.attr({\n            'transform': V.matrixToTransformString(highlightMatrix),\n            'mask': `url(#${maskEl.id})`,\n            'fill': color\n        });\n    },\n\n    unhighlight(cellView) {\n        this.removeMask(cellView.paper);\n    }\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}