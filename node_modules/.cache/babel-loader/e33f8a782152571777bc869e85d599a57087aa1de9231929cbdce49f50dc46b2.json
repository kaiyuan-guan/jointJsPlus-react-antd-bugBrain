{"ast":null,"code":"import { evalCalcAttribute, isCalcAttribute } from '../../dia/attributes/calc.mjs';\nimport * as g from '../../g/index.mjs';\nimport * as util from '../../util/index.mjs';\nfunction portTransformAttrs(point, angle, opt) {\n  var trans = point.toJSON();\n  trans.angle = angle || 0;\n  return util.defaults({}, opt, trans);\n}\nfunction lineLayout(ports, p1, p2, elBBox) {\n  return ports.map(function (port, index, ports) {\n    var p = this.pointAt((index + 0.5) / ports.length);\n    // `dx`,`dy` per port offset option\n    if (port.dx || port.dy) {\n      p.offset(port.dx || 0, port.dy || 0);\n    }\n    return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));\n  }, g.line(p1, p2));\n}\nfunction ellipseLayout(ports, elBBox, startAngle, stepFn) {\n  var center = elBBox.center();\n  var ratio = elBBox.width / elBBox.height;\n  var p1 = elBBox.topMiddle();\n  var ellipse = g.Ellipse.fromRect(elBBox);\n  return ports.map(function (port, index, ports) {\n    var angle = startAngle + stepFn(index, ports.length);\n    var p2 = p1.clone().rotate(center, -angle).scale(ratio, 1, center);\n    var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;\n\n    // `dx`,`dy` per port offset option\n    if (port.dx || port.dy) {\n      p2.offset(port.dx || 0, port.dy || 0);\n    }\n\n    // `dr` delta radius option\n    if (port.dr) {\n      p2.move(center, port.dr);\n    }\n    return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));\n  });\n}\nfunction argTransform(bbox, args) {\n  let {\n    x,\n    y,\n    angle\n  } = args;\n  if (util.isPercentage(x)) {\n    x = parseFloat(x) / 100 * bbox.width;\n  } else if (isCalcAttribute(x)) {\n    x = Number(evalCalcAttribute(x, bbox));\n  }\n  if (util.isPercentage(y)) {\n    y = parseFloat(y) / 100 * bbox.height;\n  } else if (isCalcAttribute(y)) {\n    y = Number(evalCalcAttribute(y, bbox));\n  }\n  return {\n    x,\n    y,\n    angle\n  };\n}\n\n// Creates a point stored in arguments\nfunction argPoint(bbox, args) {\n  const {\n    x,\n    y\n  } = argTransform(bbox, args);\n  return new g.Point(x || 0, y || 0);\n}\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const absolute = function (ports, elBBox) {\n  return ports.map(port => {\n    const transformation = argPoint(elBBox, port).round().toJSON();\n    transformation.angle = port.angle || 0;\n    return transformation;\n  });\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const fn = function (ports, elBBox, opt) {\n  return opt.fn(ports, elBBox, opt);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const line = function (ports, elBBox, opt) {\n  var start = argPoint(elBBox, opt.start || elBBox.origin());\n  var end = argPoint(elBBox, opt.end || elBBox.corner());\n  return lineLayout(ports, start, end, elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const left = function (ports, elBBox, opt) {\n  return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const right = function (ports, elBBox, opt) {\n  return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const top = function (ports, elBBox, opt) {\n  return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const bottom = function (ports, elBBox, opt) {\n  return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt Group options\n * @returns {Array<g.Point>}\n */\nexport const ellipseSpread = function (ports, elBBox, opt) {\n  var startAngle = opt.startAngle || 0;\n  var stepAngle = opt.step || 360 / ports.length;\n  return ellipseLayout(ports, elBBox, startAngle, function (index) {\n    return index * stepAngle;\n  });\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt Group options\n * @returns {Array<g.Point>}\n */\nexport const ellipse = function (ports, elBBox, opt) {\n  var startAngle = opt.startAngle || 0;\n  var stepAngle = opt.step || 20;\n  return ellipseLayout(ports, elBBox, startAngle, function (index, count) {\n    return (index + 0.5 - count / 2) * stepAngle;\n  });\n};","map":{"version":3,"names":["evalCalcAttribute","isCalcAttribute","g","util","portTransformAttrs","point","angle","opt","trans","toJSON","defaults","lineLayout","ports","p1","p2","elBBox","map","port","index","p","pointAt","length","dx","dy","offset","round","argTransform","line","ellipseLayout","startAngle","stepFn","center","ratio","width","height","topMiddle","ellipse","Ellipse","fromRect","clone","rotate","scale","theta","compensateRotation","tangentTheta","dr","move","bbox","args","x","y","isPercentage","parseFloat","Number","argPoint","Point","absolute","transformation","fn","start","origin","end","corner","left","bottomLeft","right","topRight","top","bottom","ellipseSpread","stepAngle","step","count"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/layout/ports/port.mjs"],"sourcesContent":["import { evalCalcAttribute, isCalcAttribute } from '../../dia/attributes/calc.mjs';\nimport * as g from '../../g/index.mjs';\nimport * as util from '../../util/index.mjs';\n\nfunction portTransformAttrs(point, angle, opt) {\n\n    var trans = point.toJSON();\n\n    trans.angle = angle || 0;\n\n    return util.defaults({}, opt, trans);\n}\n\nfunction lineLayout(ports, p1, p2, elBBox) {\n    return ports.map(function(port, index, ports) {\n        var p = this.pointAt(((index + 0.5) / ports.length));\n        // `dx`,`dy` per port offset option\n        if (port.dx || port.dy) {\n            p.offset(port.dx || 0, port.dy || 0);\n        }\n        return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));\n    }, g.line(p1, p2));\n}\n\nfunction ellipseLayout(ports, elBBox, startAngle, stepFn) {\n\n    var center = elBBox.center();\n    var ratio = elBBox.width / elBBox.height;\n    var p1 = elBBox.topMiddle();\n\n    var ellipse = g.Ellipse.fromRect(elBBox);\n\n    return ports.map(function(port, index, ports) {\n\n        var angle = startAngle + stepFn(index, ports.length);\n        var p2 = p1.clone()\n            .rotate(center, -angle)\n            .scale(ratio, 1, center);\n\n        var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;\n\n        // `dx`,`dy` per port offset option\n        if (port.dx || port.dy) {\n            p2.offset(port.dx || 0, port.dy || 0);\n        }\n\n        // `dr` delta radius option\n        if (port.dr) {\n            p2.move(center, port.dr);\n        }\n\n        return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));\n    });\n}\n\n\nfunction argTransform(bbox, args) {\n    let { x, y, angle } = args;\n    if (util.isPercentage(x)) {\n        x = parseFloat(x) / 100 * bbox.width;\n    } else if (isCalcAttribute(x)) {\n        x = Number(evalCalcAttribute(x, bbox));\n    }\n    if (util.isPercentage(y)) {\n        y = parseFloat(y) / 100 * bbox.height;\n    } else if (isCalcAttribute(y)) {\n        y = Number(evalCalcAttribute(y, bbox));\n    }\n    return { x, y, angle };\n}\n\n// Creates a point stored in arguments\nfunction argPoint(bbox, args) {\n    const { x, y } = argTransform(bbox, args);\n    return new g.Point(x || 0, y || 0);\n}\n\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const absolute = function(ports, elBBox) {\n    return ports.map(port => {\n        const transformation = argPoint(elBBox, port).round().toJSON();\n        transformation.angle = port.angle || 0;\n        return transformation;\n    });\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const fn = function(ports, elBBox, opt) {\n    return opt.fn(ports, elBBox, opt);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const line = function(ports, elBBox, opt) {\n\n    var start = argPoint(elBBox, opt.start || elBBox.origin());\n    var end = argPoint(elBBox, opt.end || elBBox.corner());\n\n    return lineLayout(ports, start, end, elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const left = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const right = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const top = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nexport const bottom = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt Group options\n * @returns {Array<g.Point>}\n */\nexport const ellipseSpread = function(ports, elBBox, opt) {\n\n    var startAngle = opt.startAngle || 0;\n    var stepAngle = opt.step || 360 / ports.length;\n\n    return ellipseLayout(ports, elBBox, startAngle, function(index) {\n        return index * stepAngle;\n    });\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt Group options\n * @returns {Array<g.Point>}\n */\nexport const ellipse = function(ports, elBBox, opt) {\n\n    var startAngle = opt.startAngle || 0;\n    var stepAngle = opt.step || 20;\n\n    return ellipseLayout(ports, elBBox, startAngle, function(index, count) {\n        return (index + 0.5 - count / 2) * stepAngle;\n    });\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}