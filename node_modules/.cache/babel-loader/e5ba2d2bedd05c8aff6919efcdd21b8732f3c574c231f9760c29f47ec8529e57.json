{"ast":null,"code":"import * as g from '../g/index.mjs';\nexport const smooth = function (sourcePoint, targetPoint, route, opt) {\n  var raw = opt && opt.raw;\n  var path;\n  if (route && route.length !== 0) {\n    var points = [sourcePoint].concat(route).concat([targetPoint]);\n    var curves = g.Curve.throughPoints(points);\n    path = new g.Path(curves);\n  } else {\n    // if we have no route, use a default cubic bezier curve\n    // cubic bezier requires two control points\n    // the control points have `x` midway between source and target\n    // this produces an S-like curve\n\n    path = new g.Path();\n    var segment;\n    segment = g.Path.createSegment('M', sourcePoint);\n    path.appendSegment(segment);\n    if (Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y)) {\n      var controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n      segment = g.Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);\n      path.appendSegment(segment);\n    } else {\n      var controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n      segment = g.Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);\n      path.appendSegment(segment);\n    }\n  }\n  return raw ? path : path.serialize();\n};","map":{"version":3,"names":["g","smooth","sourcePoint","targetPoint","route","opt","raw","path","length","points","concat","curves","Curve","throughPoints","Path","segment","createSegment","appendSegment","Math","abs","x","y","controlPointX","controlPointY","serialize"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/connectors/smooth.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\n\nexport const smooth = function(sourcePoint, targetPoint, route, opt) {\n\n    var raw = opt && opt.raw;\n    var path;\n\n    if (route && route.length !== 0) {\n\n        var points = [sourcePoint].concat(route).concat([targetPoint]);\n        var curves = g.Curve.throughPoints(points);\n\n        path = new g.Path(curves);\n\n    } else {\n        // if we have no route, use a default cubic bezier curve\n        // cubic bezier requires two control points\n        // the control points have `x` midway between source and target\n        // this produces an S-like curve\n\n        path = new g.Path();\n\n        var segment;\n\n        segment = g.Path.createSegment('M', sourcePoint);\n        path.appendSegment(segment);\n\n        if ((Math.abs(sourcePoint.x - targetPoint.x)) >= (Math.abs(sourcePoint.y - targetPoint.y))) {\n            var controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n\n            segment = g.Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);\n            path.appendSegment(segment);\n\n        } else {\n            var controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n\n            segment = g.Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);\n            path.appendSegment(segment);\n\n        }\n    }\n\n    return (raw) ? path : path.serialize();\n};\n"],"mappings":"AAAA,OAAO,KAAKA,CAAC,MAAM,gBAAgB;AAEnC,OAAO,MAAMC,MAAM,GAAG,SAAAA,CAASC,WAAW,EAAEC,WAAW,EAAEC,KAAK,EAAEC,GAAG,EAAE;EAEjE,IAAIC,GAAG,GAAGD,GAAG,IAAIA,GAAG,CAACC,GAAG;EACxB,IAAIC,IAAI;EAER,IAAIH,KAAK,IAAIA,KAAK,CAACI,MAAM,KAAK,CAAC,EAAE;IAE7B,IAAIC,MAAM,GAAG,CAACP,WAAW,CAAC,CAACQ,MAAM,CAACN,KAAK,CAAC,CAACM,MAAM,CAAC,CAACP,WAAW,CAAC,CAAC;IAC9D,IAAIQ,MAAM,GAAGX,CAAC,CAACY,KAAK,CAACC,aAAa,CAACJ,MAAM,CAAC;IAE1CF,IAAI,GAAG,IAAIP,CAAC,CAACc,IAAI,CAACH,MAAM,CAAC;EAE7B,CAAC,MAAM;IACH;IACA;IACA;IACA;;IAEAJ,IAAI,GAAG,IAAIP,CAAC,CAACc,IAAI,CAAC,CAAC;IAEnB,IAAIC,OAAO;IAEXA,OAAO,GAAGf,CAAC,CAACc,IAAI,CAACE,aAAa,CAAC,GAAG,EAAEd,WAAW,CAAC;IAChDK,IAAI,CAACU,aAAa,CAACF,OAAO,CAAC;IAE3B,IAAKG,IAAI,CAACC,GAAG,CAACjB,WAAW,CAACkB,CAAC,GAAGjB,WAAW,CAACiB,CAAC,CAAC,IAAMF,IAAI,CAACC,GAAG,CAACjB,WAAW,CAACmB,CAAC,GAAGlB,WAAW,CAACkB,CAAC,CAAE,EAAE;MACxF,IAAIC,aAAa,GAAG,CAACpB,WAAW,CAACkB,CAAC,GAAGjB,WAAW,CAACiB,CAAC,IAAI,CAAC;MAEvDL,OAAO,GAAGf,CAAC,CAACc,IAAI,CAACE,aAAa,CAAC,GAAG,EAAEM,aAAa,EAAEpB,WAAW,CAACmB,CAAC,EAAEC,aAAa,EAAEnB,WAAW,CAACkB,CAAC,EAAElB,WAAW,CAACiB,CAAC,EAAEjB,WAAW,CAACkB,CAAC,CAAC;MAC7Hd,IAAI,CAACU,aAAa,CAACF,OAAO,CAAC;IAE/B,CAAC,MAAM;MACH,IAAIQ,aAAa,GAAG,CAACrB,WAAW,CAACmB,CAAC,GAAGlB,WAAW,CAACkB,CAAC,IAAI,CAAC;MAEvDN,OAAO,GAAGf,CAAC,CAACc,IAAI,CAACE,aAAa,CAAC,GAAG,EAAEd,WAAW,CAACkB,CAAC,EAAEG,aAAa,EAAEpB,WAAW,CAACiB,CAAC,EAAEG,aAAa,EAAEpB,WAAW,CAACiB,CAAC,EAAEjB,WAAW,CAACkB,CAAC,CAAC;MAC7Hd,IAAI,CAACU,aAAa,CAACF,OAAO,CAAC;IAE/B;EACJ;EAEA,OAAQT,GAAG,GAAIC,IAAI,GAAGA,IAAI,CAACiB,SAAS,CAAC,CAAC;AAC1C,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}