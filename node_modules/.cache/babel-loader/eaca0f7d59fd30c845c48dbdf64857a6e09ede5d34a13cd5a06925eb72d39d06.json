{"ast":null,"code":"import { Path } from './path.mjs';\nimport { Curve } from './curve.mjs';\nimport { Point } from './point.mjs';\nexport const bezier = {\n  // Cubic Bezier curve path through points.\n  // @deprecated\n  // @param {array} points Array of points through which the smooth line will go.\n  // @return {array} SVG Path commands as an array\n  curveThroughPoints: function (points) {\n    console.warn('deprecated');\n    return new Path(Curve.throughPoints(points)).serialize();\n  },\n  // Get open-ended Bezier Spline Control Points.\n  // @deprecated\n  // @param knots Input Knot Bezier spline points (At least two points!).\n  // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n  // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n  getCurveControlPoints: function (knots) {\n    console.warn('deprecated');\n    var firstControlPoints = [];\n    var secondControlPoints = [];\n    var n = knots.length - 1;\n    var i;\n\n    // Special case: Bezier curve should be a straight line.\n    if (n == 1) {\n      // 3P1 = 2P0 + P3\n      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);\n\n      // P2 = 2P1 – P0\n      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n      return [firstControlPoints, secondControlPoints];\n    }\n\n    // Calculate first Bezier control points.\n    // Right hand side vector.\n    var rhs = [];\n\n    // Set right hand side X values.\n    for (i = 1; i < n - 1; i++) {\n      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n    }\n    rhs[0] = knots[0].x + 2 * knots[1].x;\n    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n    // Get first control points X-values.\n    var x = this.getFirstControlPoints(rhs);\n\n    // Set right hand side Y values.\n    for (i = 1; i < n - 1; ++i) {\n      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n    }\n    rhs[0] = knots[0].y + 2 * knots[1].y;\n    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n    // Get first control points Y-values.\n    var y = this.getFirstControlPoints(rhs);\n\n    // Fill output arrays.\n    for (i = 0; i < n; i++) {\n      // First control point.\n      firstControlPoints.push(new Point(x[i], y[i]));\n\n      // Second control point.\n      if (i < n - 1) {\n        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n      } else {\n        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n      }\n    }\n    return [firstControlPoints, secondControlPoints];\n  },\n  // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n  // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n  // @deprecated\n  // @param control points (start, control start, control end, end)\n  // @return a function that accepts t and returns 2 curves.\n  getCurveDivider: function (p0, p1, p2, p3) {\n    console.warn('deprecated');\n    var curve = new Curve(p0, p1, p2, p3);\n    return function divideCurve(t) {\n      var divided = curve.divide(t);\n      return [{\n        p0: divided[0].start,\n        p1: divided[0].controlPoint1,\n        p2: divided[0].controlPoint2,\n        p3: divided[0].end\n      }, {\n        p0: divided[1].start,\n        p1: divided[1].controlPoint1,\n        p2: divided[1].controlPoint2,\n        p3: divided[1].end\n      }];\n    };\n  },\n  // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n  // @deprecated\n  // @param rhs Right hand side vector.\n  // @return Solution vector.\n  getFirstControlPoints: function (rhs) {\n    console.warn('deprecated');\n    var n = rhs.length;\n    // `x` is a solution vector.\n    var x = [];\n    var tmp = [];\n    var b = 2.0;\n    x[0] = rhs[0] / b;\n\n    // Decomposition and forward substitution.\n    for (var i = 1; i < n; i++) {\n      tmp[i] = 1 / b;\n      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n      x[i] = (rhs[i] - x[i - 1]) / b;\n    }\n    for (i = 1; i < n; i++) {\n      // Backsubstitution.\n      x[n - i - 1] -= tmp[n - i] * x[n - i];\n    }\n    return x;\n  },\n  // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n  // a parametric curve x = x(t)/w(t), y = y(t)/w(t), ﬁnd the parameter value t\n  // which corresponds to that point.\n  // @deprecated\n  // @param control points (start, control start, control end, end)\n  // @return a function that accepts a point and returns t.\n  getInversionSolver: function (p0, p1, p2, p3) {\n    console.warn('deprecated');\n    var curve = new Curve(p0, p1, p2, p3);\n    return function solveInversion(p) {\n      return curve.closestPointT(p);\n    };\n  }\n};","map":{"version":3,"names":["Path","Curve","Point","bezier","curveThroughPoints","points","console","warn","throughPoints","serialize","getCurveControlPoints","knots","firstControlPoints","secondControlPoints","n","length","i","x","y","rhs","getFirstControlPoints","push","getCurveDivider","p0","p1","p2","p3","curve","divideCurve","t","divided","divide","start","controlPoint1","controlPoint2","end","tmp","b","getInversionSolver","solveInversion","p","closestPointT"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/g/bezier.mjs"],"sourcesContent":["import { Path } from './path.mjs';\nimport { Curve } from './curve.mjs';\nimport { Point } from './point.mjs';\n\nexport const bezier = {\n\n    // Cubic Bezier curve path through points.\n    // @deprecated\n    // @param {array} points Array of points through which the smooth line will go.\n    // @return {array} SVG Path commands as an array\n    curveThroughPoints: function(points) {\n\n        console.warn('deprecated');\n\n        return new Path(Curve.throughPoints(points)).serialize();\n    },\n\n    // Get open-ended Bezier Spline Control Points.\n    // @deprecated\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    getCurveControlPoints: function(knots) {\n\n        console.warn('deprecated');\n\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new Point(\n                (2 * knots[0].x + knots[1].x) / 3,\n                (2 * knots[0].y + knots[1].y) / 3\n            );\n\n            // P2 = 2P1 – P0\n            secondControlPoints[0] = new Point(\n                2 * firstControlPoints[0].x - knots[0].x,\n                2 * firstControlPoints[0].y - knots[0].y\n            );\n\n            return [firstControlPoints, secondControlPoints];\n        }\n\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n\n        // Set right hand side X values.\n        for (i = 1; i < n - 1; i++) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n        // Get first control points X-values.\n        var x = this.getFirstControlPoints(rhs);\n\n        // Set right hand side Y values.\n        for (i = 1; i < n - 1; ++i) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n        // Get first control points Y-values.\n        var y = this.getFirstControlPoints(rhs);\n\n        // Fill output arrays.\n        for (i = 0; i < n; i++) {\n            // First control point.\n            firstControlPoints.push(new Point(x[i], y[i]));\n\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new Point(\n                    2 * knots [i + 1].x - x[i + 1],\n                    2 * knots[i + 1].y - y[i + 1]\n                ));\n\n            } else {\n                secondControlPoints.push(new Point(\n                    (knots[n].x + x[n - 1]) / 2,\n                    (knots[n].y + y[n - 1]) / 2)\n                );\n            }\n        }\n\n        return [firstControlPoints, secondControlPoints];\n    },\n\n    // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n    // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts t and returns 2 curves.\n    getCurveDivider: function(p0, p1, p2, p3) {\n\n        console.warn('deprecated');\n\n        var curve = new Curve(p0, p1, p2, p3);\n\n        return function divideCurve(t) {\n\n            var divided = curve.divide(t);\n\n            return [{\n                p0: divided[0].start,\n                p1: divided[0].controlPoint1,\n                p2: divided[0].controlPoint2,\n                p3: divided[0].end\n            }, {\n                p0: divided[1].start,\n                p1: divided[1].controlPoint1,\n                p2: divided[1].controlPoint2,\n                p3: divided[1].end\n            }];\n        };\n    },\n\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @deprecated\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    getFirstControlPoints: function(rhs) {\n\n        console.warn('deprecated');\n\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n\n        x[0] = rhs[0] / b;\n\n        // Decomposition and forward substitution.\n        for (var i = 1; i < n; i++) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (i = 1; i < n; i++) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n\n        return x;\n    },\n\n    // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n    // a parametric curve x = x(t)/w(t), y = y(t)/w(t), ﬁnd the parameter value t\n    // which corresponds to that point.\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts a point and returns t.\n    getInversionSolver: function(p0, p1, p2, p3) {\n\n        console.warn('deprecated');\n\n        var curve = new Curve(p0, p1, p2, p3);\n\n        return function solveInversion(p) {\n\n            return curve.closestPointT(p);\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}