{"ast":null,"code":"import { toRad } from './geometry.helpers.mjs';\nimport { Line } from './line.mjs';\nimport { Point } from './point.mjs';\nimport { Ellipse } from './ellipse.mjs';\nimport { types } from './types.mjs';\nconst {\n  abs,\n  cos,\n  sin,\n  min,\n  max,\n  round,\n  pow\n} = Math;\nexport const Rect = function (x, y, w, h) {\n  if (!(this instanceof Rect)) {\n    return new Rect(x, y, w, h);\n  }\n  if (Object(x) === x) {\n    y = x.y;\n    w = x.width;\n    h = x.height;\n    x = x.x;\n  }\n  this.x = x === undefined ? 0 : x;\n  this.y = y === undefined ? 0 : y;\n  this.width = w === undefined ? 0 : w;\n  this.height = h === undefined ? 0 : h;\n};\nRect.fromEllipse = function (e) {\n  e = new Ellipse(e);\n  return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n};\nRect.fromPointUnion = function (...points) {\n  if (points.length === 0) return null;\n  const p = new Point();\n  let minX, minY, maxX, maxY;\n  minX = minY = Infinity;\n  maxX = maxY = -Infinity;\n  for (let i = 0; i < points.length; i++) {\n    p.update(points[i]);\n    const x = p.x;\n    const y = p.y;\n    if (x < minX) minX = x;\n    if (x > maxX) maxX = x;\n    if (y < minY) minY = y;\n    if (y > maxY) maxY = y;\n  }\n  return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\nRect.fromRectUnion = function (...rects) {\n  if (rects.length === 0) return null;\n  const r = new Rect();\n  let minX, minY, maxX, maxY;\n  minX = minY = Infinity;\n  maxX = maxY = -Infinity;\n  for (let i = 0; i < rects.length; i++) {\n    r.update(rects[i]);\n    const x = r.x;\n    const y = r.y;\n    const mX = x + r.width;\n    const mY = y + r.height;\n    if (x < minX) minX = x;\n    if (mX > maxX) maxX = mX;\n    if (y < minY) minY = y;\n    if (mY > maxY) maxY = mY;\n  }\n  return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\nRect.prototype = {\n  type: types.Rect,\n  // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n  // @return r {rectangle} representing a bounding box\n  bbox: function (angle) {\n    return this.clone().rotateAroundCenter(angle);\n  },\n  rotateAroundCenter: function (angle) {\n    if (!angle) return this;\n    const {\n      width,\n      height\n    } = this;\n    const theta = toRad(angle);\n    const st = abs(sin(theta));\n    const ct = abs(cos(theta));\n    const w = width * ct + height * st;\n    const h = width * st + height * ct;\n    this.x += (width - w) / 2;\n    this.y += (height - h) / 2;\n    this.width = w;\n    this.height = h;\n    return this;\n  },\n  bottomLeft: function () {\n    return new Point(this.x, this.y + this.height);\n  },\n  bottomLine: function () {\n    return new Line(this.bottomLeft(), this.bottomRight());\n  },\n  bottomMiddle: function () {\n    return new Point(this.x + this.width / 2, this.y + this.height);\n  },\n  center: function () {\n    return new Point(this.x + this.width / 2, this.y + this.height / 2);\n  },\n  clone: function () {\n    return new Rect(this);\n  },\n  // @return {bool} true if point p is inside me.\n  containsPoint: function (p) {\n    if (!(p instanceof Point)) {\n      p = new Point(p);\n    }\n    return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;\n  },\n  // @return {bool} true if rectangle `r` is inside me.\n  containsRect: function (r) {\n    var r0 = new Rect(this).normalize();\n    var r1 = new Rect(r).normalize();\n    var w0 = r0.width;\n    var h0 = r0.height;\n    var w1 = r1.width;\n    var h1 = r1.height;\n    if (!w0 || !h0 || !w1 || !h1) {\n      // At least one of the dimensions is 0\n      return false;\n    }\n    var x0 = r0.x;\n    var y0 = r0.y;\n    var x1 = r1.x;\n    var y1 = r1.y;\n    w1 += x1;\n    w0 += x0;\n    h1 += y1;\n    h0 += y0;\n    return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n  },\n  corner: function () {\n    return new Point(this.x + this.width, this.y + this.height);\n  },\n  // @return {boolean} true if rectangles are equal.\n  equals: function (r) {\n    var mr = new Rect(this).normalize();\n    var nr = new Rect(r).normalize();\n    return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n  },\n  // inflate by dx and dy, recompute origin [x, y]\n  // @param dx {delta_x} representing additional size to x\n  // @param dy {delta_y} representing additional size to y -\n  // dy param is not required -> in that case y is sized by dx\n  inflate: function (dx, dy) {\n    if (dx === undefined) {\n      dx = 0;\n    }\n    if (dy === undefined) {\n      dy = dx;\n    }\n    this.x -= dx;\n    this.y -= dy;\n    this.width += 2 * dx;\n    this.height += 2 * dy;\n    return this;\n  },\n  // @return {rect} if rectangles intersect, {null} if not.\n  intersect: function (r) {\n    var myOrigin = this.origin();\n    var myCorner = this.corner();\n    var rOrigin = r.origin();\n    var rCorner = r.corner();\n\n    // No intersection found\n    if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) return null;\n    var x = max(myOrigin.x, rOrigin.x);\n    var y = max(myOrigin.y, rOrigin.y);\n    return new Rect(x, y, min(myCorner.x, rCorner.x) - x, min(myCorner.y, rCorner.y) - y);\n  },\n  intersectionWithLine: function (line) {\n    var r = this;\n    var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];\n    var points = [];\n    var dedupeArr = [];\n    var pt, i;\n    var n = rectLines.length;\n    for (i = 0; i < n; i++) {\n      pt = line.intersect(rectLines[i]);\n      if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n        points.push(pt);\n        dedupeArr.push(pt.toString());\n      }\n    }\n    return points.length > 0 ? points : null;\n  },\n  // Find point on my boundary where line starting\n  // from my center ending in point p intersects me.\n  // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n  intersectionWithLineFromCenterToPoint: function (p, angle) {\n    p = new Point(p);\n    var center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n    var result;\n    if (angle) p.rotate(center, angle);\n\n    // (clockwise, starting from the top side)\n    var sides = [this.topLine(), this.rightLine(), this.bottomLine(), this.leftLine()];\n    var connector = new Line(center, p);\n    for (var i = sides.length - 1; i >= 0; --i) {\n      var intersection = sides[i].intersection(connector);\n      if (intersection !== null) {\n        result = intersection;\n        break;\n      }\n    }\n    if (result && angle) result.rotate(center, -angle);\n    return result;\n  },\n  leftLine: function () {\n    return new Line(this.topLeft(), this.bottomLeft());\n  },\n  leftMiddle: function () {\n    return new Point(this.x, this.y + this.height / 2);\n  },\n  maxRectScaleToFit: function (rect, origin) {\n    rect = new Rect(rect);\n    origin || (origin = rect.center());\n    var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n    var ox = origin.x;\n    var oy = origin.y;\n\n    // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n    // so when the scale is applied the point is still inside the rectangle.\n\n    sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\n\n    // Top Left\n    var p1 = rect.topLeft();\n    if (p1.x < ox) {\n      sx1 = (this.x - ox) / (p1.x - ox);\n    }\n    if (p1.y < oy) {\n      sy1 = (this.y - oy) / (p1.y - oy);\n    }\n    // Bottom Right\n    var p2 = rect.bottomRight();\n    if (p2.x > ox) {\n      sx2 = (this.x + this.width - ox) / (p2.x - ox);\n    }\n    if (p2.y > oy) {\n      sy2 = (this.y + this.height - oy) / (p2.y - oy);\n    }\n    // Top Right\n    var p3 = rect.topRight();\n    if (p3.x > ox) {\n      sx3 = (this.x + this.width - ox) / (p3.x - ox);\n    }\n    if (p3.y < oy) {\n      sy3 = (this.y - oy) / (p3.y - oy);\n    }\n    // Bottom Left\n    var p4 = rect.bottomLeft();\n    if (p4.x < ox) {\n      sx4 = (this.x - ox) / (p4.x - ox);\n    }\n    if (p4.y > oy) {\n      sy4 = (this.y + this.height - oy) / (p4.y - oy);\n    }\n    return {\n      sx: min(sx1, sx2, sx3, sx4),\n      sy: min(sy1, sy2, sy3, sy4)\n    };\n  },\n  maxRectUniformScaleToFit: function (rect, origin) {\n    var scale = this.maxRectScaleToFit(rect, origin);\n    return min(scale.sx, scale.sy);\n  },\n  // Move and expand me.\n  // @param r {rectangle} representing deltas\n  moveAndExpand: function (r) {\n    this.x += r.x || 0;\n    this.y += r.y || 0;\n    this.width += r.width || 0;\n    this.height += r.height || 0;\n    return this;\n  },\n  // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n  // If width < 0 the function swaps the left and right corners,\n  // and it swaps the top and bottom corners if height < 0\n  // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n  normalize: function () {\n    var newx = this.x;\n    var newy = this.y;\n    var newwidth = this.width;\n    var newheight = this.height;\n    if (this.width < 0) {\n      newx = this.x + this.width;\n      newwidth = -this.width;\n    }\n    if (this.height < 0) {\n      newy = this.y + this.height;\n      newheight = -this.height;\n    }\n    this.x = newx;\n    this.y = newy;\n    this.width = newwidth;\n    this.height = newheight;\n    return this;\n  },\n  // Offset me by the specified amount.\n  offset: function (dx, dy) {\n    // pretend that this is a point and call offset()\n    // rewrites x and y according to dx and dy\n    return Point.prototype.offset.call(this, dx, dy);\n  },\n  origin: function () {\n    return new Point(this.x, this.y);\n  },\n  // @return {point} a point on my boundary nearest to the given point.\n  // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n  pointNearestToPoint: function (point) {\n    point = new Point(point);\n    if (this.containsPoint(point)) {\n      var side = this.sideNearestToPoint(point);\n      switch (side) {\n        case 'right':\n          return new Point(this.x + this.width, point.y);\n        case 'left':\n          return new Point(this.x, point.y);\n        case 'bottom':\n          return new Point(point.x, this.y + this.height);\n        case 'top':\n          return new Point(point.x, this.y);\n      }\n    }\n    return point.adhereToRect(this);\n  },\n  rightLine: function () {\n    return new Line(this.topRight(), this.bottomRight());\n  },\n  rightMiddle: function () {\n    return new Point(this.x + this.width, this.y + this.height / 2);\n  },\n  round: function (precision) {\n    let f = 1; // case 0\n    if (precision) {\n      switch (precision) {\n        case 1:\n          f = 10;\n          break;\n        case 2:\n          f = 100;\n          break;\n        case 3:\n          f = 1000;\n          break;\n        default:\n          f = pow(10, precision);\n          break;\n      }\n    }\n    this.x = round(this.x * f) / f;\n    this.y = round(this.y * f) / f;\n    this.width = round(this.width * f) / f;\n    this.height = round(this.height * f) / f;\n    return this;\n  },\n  // Scale rectangle with origin.\n  scale: function (sx, sy, origin) {\n    origin = this.origin().scale(sx, sy, origin);\n    this.x = origin.x;\n    this.y = origin.y;\n    this.width *= sx;\n    this.height *= sy;\n    return this;\n  },\n  // @return {string} (left|right|top|bottom) side which is nearest to point\n  // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n  sideNearestToPoint: function (point) {\n    point = new Point(point);\n    var distToLeft = point.x - this.x;\n    var distToRight = this.x + this.width - point.x;\n    var distToTop = point.y - this.y;\n    var distToBottom = this.y + this.height - point.y;\n    var closest = distToLeft;\n    var side = 'left';\n    if (distToRight < closest) {\n      closest = distToRight;\n      side = 'right';\n    }\n    if (distToTop < closest) {\n      closest = distToTop;\n      side = 'top';\n    }\n    if (distToBottom < closest) {\n      // closest = distToBottom;\n      side = 'bottom';\n    }\n    return side;\n  },\n  snapToGrid: function (gx, gy) {\n    var origin = this.origin().snapToGrid(gx, gy);\n    var corner = this.corner().snapToGrid(gx, gy);\n    this.x = origin.x;\n    this.y = origin.y;\n    this.width = corner.x - origin.x;\n    this.height = corner.y - origin.y;\n    return this;\n  },\n  toJSON: function () {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  },\n  topLine: function () {\n    return new Line(this.topLeft(), this.topRight());\n  },\n  topMiddle: function () {\n    return new Point(this.x + this.width / 2, this.y);\n  },\n  topRight: function () {\n    return new Point(this.x + this.width, this.y);\n  },\n  toString: function () {\n    return this.origin().toString() + ' ' + this.corner().toString();\n  },\n  // @return {rect} representing the union of both rectangles.\n  union: function (rect) {\n    return Rect.fromRectUnion(this, rect);\n  },\n  update: function (x, y, w, h) {\n    if (Object(x) === x) {\n      y = x.y;\n      w = x.width;\n      h = x.height;\n      x = x.x;\n    }\n    this.x = x || 0;\n    this.y = y || 0;\n    this.width = w || 0;\n    this.height = h || 0;\n    return this;\n  }\n};\nRect.prototype.bottomRight = Rect.prototype.corner;\nRect.prototype.topLeft = Rect.prototype.origin;\nRect.prototype.translate = Rect.prototype.offset;\n\n// For backwards compatibility:\nexport const rect = Rect;","map":{"version":3,"names":["toRad","Line","Point","Ellipse","types","abs","cos","sin","min","max","round","pow","Math","Rect","x","y","w","h","Object","width","height","undefined","fromEllipse","e","a","b","fromPointUnion","points","length","p","minX","minY","maxX","maxY","Infinity","i","update","fromRectUnion","rects","r","mX","mY","prototype","type","bbox","angle","clone","rotateAroundCenter","theta","st","ct","bottomLeft","bottomLine","bottomRight","bottomMiddle","center","containsPoint","containsRect","r0","normalize","r1","w0","h0","w1","h1","x0","y0","x1","y1","corner","equals","mr","nr","inflate","dx","dy","intersect","myOrigin","origin","myCorner","rOrigin","rCorner","intersectionWithLine","line","rectLines","topLine","rightLine","leftLine","dedupeArr","pt","n","indexOf","toString","push","intersectionWithLineFromCenterToPoint","result","rotate","sides","connector","intersection","topLeft","leftMiddle","maxRectScaleToFit","rect","sx1","sx2","sx3","sx4","sy1","sy2","sy3","sy4","ox","oy","p1","p2","p3","topRight","p4","sx","sy","maxRectUniformScaleToFit","scale","moveAndExpand","newx","newy","newwidth","newheight","offset","call","pointNearestToPoint","point","side","sideNearestToPoint","adhereToRect","rightMiddle","precision","f","distToLeft","distToRight","distToTop","distToBottom","closest","snapToGrid","gx","gy","toJSON","topMiddle","union","translate"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/g/rect.mjs"],"sourcesContent":["import { toRad } from './geometry.helpers.mjs';\nimport { Line } from './line.mjs';\nimport { Point } from './point.mjs';\nimport { Ellipse } from './ellipse.mjs';\nimport { types } from './types.mjs';\n\nconst {\n    abs,\n    cos,\n    sin,\n    min,\n    max,\n    round,\n    pow\n} = Math;\n\nexport const Rect = function(x, y, w, h) {\n\n    if (!(this instanceof Rect)) {\n        return new Rect(x, y, w, h);\n    }\n\n    if ((Object(x) === x)) {\n        y = x.y;\n        w = x.width;\n        h = x.height;\n        x = x.x;\n    }\n\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n    this.width = w === undefined ? 0 : w;\n    this.height = h === undefined ? 0 : h;\n};\n\nRect.fromEllipse = function(e) {\n\n    e = new Ellipse(e);\n    return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n};\n\nRect.fromPointUnion = function(...points) {\n\n    if (points.length === 0) return null;\n\n    const p = new Point();\n    let minX, minY, maxX, maxY;\n    minX = minY = Infinity;\n    maxX = maxY = -Infinity;\n\n    for (let i = 0; i < points.length; i++) {\n        p.update(points[i]);\n        const x = p.x;\n        const y = p.y;\n\n        if (x < minX) minX = x;\n        if (x > maxX) maxX = x;\n        if (y < minY) minY = y;\n        if (y > maxY) maxY = y;\n    }\n\n    return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\n\nRect.fromRectUnion = function(...rects) {\n\n    if (rects.length === 0) return null;\n\n    const r = new Rect();\n    let minX, minY, maxX, maxY;\n    minX = minY = Infinity;\n    maxX = maxY = -Infinity;\n\n    for (let i = 0; i < rects.length; i++) {\n        r.update(rects[i]);\n        const x = r.x;\n        const y = r.y;\n        const mX = x + r.width;\n        const mY = y + r.height;\n\n        if (x < minX) minX = x;\n        if (mX > maxX) maxX = mX;\n        if (y < minY) minY = y;\n        if (mY > maxY) maxY = mY;\n    }\n\n    return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\n\nRect.prototype = {\n\n    type: types.Rect,\n\n    // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n    // @return r {rectangle} representing a bounding box\n    bbox: function(angle) {\n        return this.clone().rotateAroundCenter(angle);\n    },\n\n    rotateAroundCenter: function(angle) {\n        if (!angle) return this;\n        const { width, height } = this;\n        const theta = toRad(angle);\n        const st = abs(sin(theta));\n        const ct = abs(cos(theta));\n        const w = width * ct + height * st;\n        const h = width * st + height * ct;\n        this.x += (width - w) / 2;\n        this.y += (height - h) / 2;\n        this.width = w;\n        this.height = h;\n        return this;\n    },\n\n    bottomLeft: function() {\n\n        return new Point(this.x, this.y + this.height);\n    },\n\n    bottomLine: function() {\n\n        return new Line(this.bottomLeft(), this.bottomRight());\n    },\n\n    bottomMiddle: function() {\n\n        return new Point(this.x + this.width / 2, this.y + this.height);\n    },\n\n    center: function() {\n\n        return new Point(this.x + this.width / 2, this.y + this.height / 2);\n    },\n\n    clone: function() {\n\n        return new Rect(this);\n    },\n\n    // @return {bool} true if point p is inside me.\n    containsPoint: function(p) {\n        \n        if (!(p instanceof Point)) {\n            p = new Point(p);\n        }\n        return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;\n    },\n\n    // @return {bool} true if rectangle `r` is inside me.\n    containsRect: function(r) {\n\n        var r0 = new Rect(this).normalize();\n        var r1 = new Rect(r).normalize();\n        var w0 = r0.width;\n        var h0 = r0.height;\n        var w1 = r1.width;\n        var h1 = r1.height;\n\n        if (!w0 || !h0 || !w1 || !h1) {\n            // At least one of the dimensions is 0\n            return false;\n        }\n\n        var x0 = r0.x;\n        var y0 = r0.y;\n        var x1 = r1.x;\n        var y1 = r1.y;\n\n        w1 += x1;\n        w0 += x0;\n        h1 += y1;\n        h0 += y0;\n\n        return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n    },\n\n    corner: function() {\n\n        return new Point(this.x + this.width, this.y + this.height);\n    },\n\n    // @return {boolean} true if rectangles are equal.\n    equals: function(r) {\n\n        var mr = (new Rect(this)).normalize();\n        var nr = (new Rect(r)).normalize();\n        return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n    },\n\n    // inflate by dx and dy, recompute origin [x, y]\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n\n        if (dx === undefined) {\n            dx = 0;\n        }\n\n        if (dy === undefined) {\n            dy = dx;\n        }\n\n        this.x -= dx;\n        this.y -= dy;\n        this.width += 2 * dx;\n        this.height += 2 * dy;\n\n        return this;\n    },\n\n    // @return {rect} if rectangles intersect, {null} if not.\n    intersect: function(r) {\n\n        var myOrigin = this.origin();\n        var myCorner = this.corner();\n        var rOrigin = r.origin();\n        var rCorner = r.corner();\n\n        // No intersection found\n        if (rCorner.x <= myOrigin.x ||\n            rCorner.y <= myOrigin.y ||\n            rOrigin.x >= myCorner.x ||\n            rOrigin.y >= myCorner.y) return null;\n\n        var x = max(myOrigin.x, rOrigin.x);\n        var y = max(myOrigin.y, rOrigin.y);\n\n        return new Rect(x, y, min(myCorner.x, rCorner.x) - x, min(myCorner.y, rCorner.y) - y);\n    },\n\n    intersectionWithLine: function(line) {\n\n        var r = this;\n        var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];\n        var points = [];\n        var dedupeArr = [];\n        var pt, i;\n\n        var n = rectLines.length;\n        for (i = 0; i < n; i++) {\n\n            pt = line.intersect(rectLines[i]);\n            if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n                points.push(pt);\n                dedupeArr.push(pt.toString());\n            }\n        }\n\n        return points.length > 0 ? points : null;\n    },\n\n    // Find point on my boundary where line starting\n    // from my center ending in point p intersects me.\n    // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n        p = new Point(p);\n        var center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n        var result;\n\n        if (angle) p.rotate(center, angle);\n\n        // (clockwise, starting from the top side)\n        var sides = [\n            this.topLine(),\n            this.rightLine(),\n            this.bottomLine(),\n            this.leftLine()\n        ];\n        var connector = new Line(center, p);\n\n        for (var i = sides.length - 1; i >= 0; --i) {\n            var intersection = sides[i].intersection(connector);\n            if (intersection !== null) {\n                result = intersection;\n                break;\n            }\n        }\n        if (result && angle) result.rotate(center, -angle);\n        return result;\n    },\n\n    leftLine: function() {\n\n        return new Line(this.topLeft(), this.bottomLeft());\n    },\n\n    leftMiddle: function() {\n\n        return new Point(this.x, this.y + this.height / 2);\n    },\n\n    maxRectScaleToFit: function(rect, origin) {\n\n        rect = new Rect(rect);\n        origin || (origin = rect.center());\n\n        var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n        var ox = origin.x;\n        var oy = origin.y;\n\n        // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n        // so when the scale is applied the point is still inside the rectangle.\n\n        sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\n\n        // Top Left\n        var p1 = rect.topLeft();\n        if (p1.x < ox) {\n            sx1 = (this.x - ox) / (p1.x - ox);\n        }\n        if (p1.y < oy) {\n            sy1 = (this.y - oy) / (p1.y - oy);\n        }\n        // Bottom Right\n        var p2 = rect.bottomRight();\n        if (p2.x > ox) {\n            sx2 = (this.x + this.width - ox) / (p2.x - ox);\n        }\n        if (p2.y > oy) {\n            sy2 = (this.y + this.height - oy) / (p2.y - oy);\n        }\n        // Top Right\n        var p3 = rect.topRight();\n        if (p3.x > ox) {\n            sx3 = (this.x + this.width - ox) / (p3.x - ox);\n        }\n        if (p3.y < oy) {\n            sy3 = (this.y - oy) / (p3.y - oy);\n        }\n        // Bottom Left\n        var p4 = rect.bottomLeft();\n        if (p4.x < ox) {\n            sx4 = (this.x - ox) / (p4.x - ox);\n        }\n        if (p4.y > oy) {\n            sy4 = (this.y + this.height - oy) / (p4.y - oy);\n        }\n\n        return {\n            sx: min(sx1, sx2, sx3, sx4),\n            sy: min(sy1, sy2, sy3, sy4)\n        };\n    },\n\n    maxRectUniformScaleToFit: function(rect, origin) {\n\n        var scale = this.maxRectScaleToFit(rect, origin);\n        return min(scale.sx, scale.sy);\n    },\n\n    // Move and expand me.\n    // @param r {rectangle} representing deltas\n    moveAndExpand: function(r) {\n\n        this.x += r.x || 0;\n        this.y += r.y || 0;\n        this.width += r.width || 0;\n        this.height += r.height || 0;\n        return this;\n    },\n\n    // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n    // If width < 0 the function swaps the left and right corners,\n    // and it swaps the top and bottom corners if height < 0\n    // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n    normalize: function() {\n\n        var newx = this.x;\n        var newy = this.y;\n        var newwidth = this.width;\n        var newheight = this.height;\n        if (this.width < 0) {\n            newx = this.x + this.width;\n            newwidth = -this.width;\n        }\n        if (this.height < 0) {\n            newy = this.y + this.height;\n            newheight = -this.height;\n        }\n        this.x = newx;\n        this.y = newy;\n        this.width = newwidth;\n        this.height = newheight;\n        return this;\n    },\n\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n\n        // pretend that this is a point and call offset()\n        // rewrites x and y according to dx and dy\n        return Point.prototype.offset.call(this, dx, dy);\n    },\n\n    origin: function() {\n\n        return new Point(this.x, this.y);\n    },\n\n    // @return {point} a point on my boundary nearest to the given point.\n    // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n    pointNearestToPoint: function(point) {\n\n        point = new Point(point);\n        if (this.containsPoint(point)) {\n            var side = this.sideNearestToPoint(point);\n            switch (side) {\n                case 'right':\n                    return new Point(this.x + this.width, point.y);\n                case 'left':\n                    return new Point(this.x, point.y);\n                case 'bottom':\n                    return new Point(point.x, this.y + this.height);\n                case 'top':\n                    return new Point(point.x, this.y);\n            }\n        }\n        return point.adhereToRect(this);\n    },\n\n    rightLine: function() {\n\n        return new Line(this.topRight(), this.bottomRight());\n    },\n\n    rightMiddle: function() {\n\n        return new Point(this.x + this.width, this.y + this.height / 2);\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.width = round(this.width * f) / f;\n        this.height = round(this.height * f) / f;\n        return this;\n    },\n\n    // Scale rectangle with origin.\n    scale: function(sx, sy, origin) {\n\n        origin = this.origin().scale(sx, sy, origin);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width *= sx;\n        this.height *= sy;\n        return this;\n    },\n\n    // @return {string} (left|right|top|bottom) side which is nearest to point\n    // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n    sideNearestToPoint: function(point) {\n\n        point = new Point(point);\n        var distToLeft = point.x - this.x;\n        var distToRight = (this.x + this.width) - point.x;\n        var distToTop = point.y - this.y;\n        var distToBottom = (this.y + this.height) - point.y;\n        var closest = distToLeft;\n        var side = 'left';\n\n        if (distToRight < closest) {\n            closest = distToRight;\n            side = 'right';\n        }\n        if (distToTop < closest) {\n            closest = distToTop;\n            side = 'top';\n        }\n        if (distToBottom < closest) {\n            // closest = distToBottom;\n            side = 'bottom';\n        }\n        return side;\n    },\n\n    snapToGrid: function(gx, gy) {\n\n        var origin = this.origin().snapToGrid(gx, gy);\n        var corner = this.corner().snapToGrid(gx, gy);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width = corner.x - origin.x;\n        this.height = corner.y - origin.y;\n        return this;\n    },\n\n    toJSON: function() {\n\n        return { x: this.x, y: this.y, width: this.width, height: this.height };\n    },\n\n    topLine: function() {\n\n        return new Line(this.topLeft(), this.topRight());\n    },\n\n    topMiddle: function() {\n\n        return new Point(this.x + this.width / 2, this.y);\n    },\n\n    topRight: function() {\n\n        return new Point(this.x + this.width, this.y);\n    },\n\n    toString: function() {\n\n        return this.origin().toString() + ' ' + this.corner().toString();\n    },\n\n    // @return {rect} representing the union of both rectangles.\n    union: function(rect) {\n\n        return Rect.fromRectUnion(this, rect);\n    },\n\n    update: function(x, y, w, h) {\n\n        if ((Object(x) === x)) {\n            y = x.y;\n            w = x.width;\n            h = x.height;\n            x = x.x;\n        }\n\n        this.x = x || 0;\n        this.y = y || 0;\n        this.width = w || 0;\n        this.height = h || 0;\n        return this;\n    }\n};\n\nRect.prototype.bottomRight = Rect.prototype.corner;\n\nRect.prototype.topLeft = Rect.prototype.origin;\n\nRect.prototype.translate = Rect.prototype.offset;\n\n// For backwards compatibility:\nexport const rect = Rect;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}