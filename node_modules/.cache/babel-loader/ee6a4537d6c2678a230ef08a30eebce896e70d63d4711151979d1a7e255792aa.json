{"ast":null,"code":"import { Line, Point } from '../g/index.mjs';\nimport { isPercentage } from '../util/index.mjs';\nfunction connectionRatio(view, _magnet, _refPoint, opt) {\n  var ratio = 'ratio' in opt ? opt.ratio : 0.5;\n  return view.getPointAtRatio(ratio);\n}\nfunction connectionLength(view, _magnet, _refPoint, opt) {\n  var length = 'length' in opt ? opt.length : 20;\n  return view.getPointAtLength(length);\n}\nfunction _connectionPerpendicular(view, _magnet, refPoint, opt) {\n  var OFFSET = 1e6;\n  var path = view.getConnection();\n  var segmentSubdivisions = view.getConnectionSubdivisions();\n  var verticalLine = new Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));\n  var horizontalLine = new Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));\n  var verticalIntersections = verticalLine.intersect(path, {\n    segmentSubdivisions: segmentSubdivisions\n  });\n  var horizontalIntersections = horizontalLine.intersect(path, {\n    segmentSubdivisions: segmentSubdivisions\n  });\n  var intersections = [];\n  if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);\n  if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);\n  if (intersections.length > 0) return refPoint.chooseClosest(intersections);\n  if ('fallbackAt' in opt) {\n    return getPointAtLink(view, opt.fallbackAt);\n  }\n  return connectionClosest(view, _magnet, refPoint, opt);\n}\nfunction _connectionClosest(view, _magnet, refPoint, _opt) {\n  var closestPoint = view.getClosestPoint(refPoint);\n  if (!closestPoint) return new Point();\n  return closestPoint;\n}\nexport function resolveRef(fn) {\n  return function (view, magnet, ref, opt) {\n    if (ref instanceof Element) {\n      var refView = this.paper.findView(ref);\n      var refPoint;\n      if (refView) {\n        if (refView.isNodeConnection(ref)) {\n          var distance = 'fixedAt' in opt ? opt.fixedAt : '50%';\n          refPoint = getPointAtLink(refView, distance);\n        } else {\n          refPoint = refView.getNodeBBox(ref).center();\n        }\n      } else {\n        // Something went wrong\n        refPoint = new Point();\n      }\n      return fn.call(this, view, magnet, refPoint, opt);\n    }\n    return fn.apply(this, arguments);\n  };\n}\nfunction getPointAtLink(view, value) {\n  var parsedValue = parseFloat(value);\n  if (isPercentage(value)) {\n    return view.getPointAtRatio(parsedValue / 100);\n  } else {\n    return view.getPointAtLength(parsedValue);\n  }\n}\n\n// joint.linkAnchors\nexport { connectionRatio, connectionLength };\nexport const connectionPerpendicular = resolveRef(_connectionPerpendicular);\nexport const connectionClosest = resolveRef(_connectionClosest);","map":{"version":3,"names":["Line","Point","isPercentage","connectionRatio","view","_magnet","_refPoint","opt","ratio","getPointAtRatio","connectionLength","length","getPointAtLength","_connectionPerpendicular","refPoint","OFFSET","path","getConnection","segmentSubdivisions","getConnectionSubdivisions","verticalLine","clone","offset","horizontalLine","verticalIntersections","intersect","horizontalIntersections","intersections","Array","prototype","push","apply","chooseClosest","getPointAtLink","fallbackAt","connectionClosest","_connectionClosest","_opt","closestPoint","getClosestPoint","resolveRef","fn","magnet","ref","Element","refView","paper","findView","isNodeConnection","distance","fixedAt","getNodeBBox","center","call","arguments","value","parsedValue","parseFloat","connectionPerpendicular"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/linkAnchors/index.mjs"],"sourcesContent":["import { Line, Point } from '../g/index.mjs';\nimport { isPercentage } from '../util/index.mjs';\n\nfunction connectionRatio(view, _magnet, _refPoint, opt) {\n\n    var ratio = ('ratio' in opt) ? opt.ratio : 0.5;\n    return view.getPointAtRatio(ratio);\n}\n\nfunction connectionLength(view, _magnet, _refPoint, opt) {\n\n    var length = ('length' in opt) ? opt.length : 20;\n    return view.getPointAtLength(length);\n}\n\nfunction _connectionPerpendicular(view, _magnet, refPoint, opt) {\n\n    var OFFSET = 1e6;\n    var path = view.getConnection();\n    var segmentSubdivisions = view.getConnectionSubdivisions();\n    var verticalLine = new Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));\n    var horizontalLine = new Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));\n    var verticalIntersections = verticalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n    var horizontalIntersections = horizontalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n    var intersections = [];\n    if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);\n    if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);\n    if (intersections.length > 0) return refPoint.chooseClosest(intersections);\n    if ('fallbackAt' in opt) {\n        return getPointAtLink(view, opt.fallbackAt);\n    }\n    return connectionClosest(view, _magnet, refPoint, opt);\n}\n\nfunction _connectionClosest(view, _magnet, refPoint, _opt) {\n\n    var closestPoint = view.getClosestPoint(refPoint);\n    if (!closestPoint) return new Point();\n    return closestPoint;\n}\n\nexport function resolveRef(fn) {\n    return function(view, magnet, ref, opt) {\n        if (ref instanceof Element) {\n            var refView = this.paper.findView(ref);\n            var refPoint;\n            if (refView) {\n                if (refView.isNodeConnection(ref)) {\n                    var distance = ('fixedAt' in opt) ? opt.fixedAt : '50%';\n                    refPoint = getPointAtLink(refView, distance);\n                } else {\n                    refPoint = refView.getNodeBBox(ref).center();\n                }\n            } else {\n                // Something went wrong\n                refPoint = new Point();\n            }\n            return fn.call(this, view, magnet, refPoint, opt);\n        }\n        return fn.apply(this, arguments);\n    };\n}\n\nfunction getPointAtLink(view, value) {\n    var parsedValue = parseFloat(value);\n    if (isPercentage(value)) {\n        return view.getPointAtRatio(parsedValue / 100);\n    } else {\n        return view.getPointAtLength(parsedValue);\n    }\n}\n\n// joint.linkAnchors\nexport { connectionRatio, connectionLength };\nexport const connectionPerpendicular = resolveRef(_connectionPerpendicular);\nexport const connectionClosest = resolveRef(_connectionClosest);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}