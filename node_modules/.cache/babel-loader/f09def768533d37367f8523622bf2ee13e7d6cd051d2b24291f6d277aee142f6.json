{"ast":null,"code":"import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\n\n// bearing -> opposite bearing\nvar opposites = {\n  N: 'S',\n  S: 'N',\n  E: 'W',\n  W: 'E'\n};\n\n// bearing -> radians\nvar radians = {\n  N: -Math.PI / 2 * 3,\n  S: -Math.PI / 2,\n  E: 0,\n  W: Math.PI\n};\n\n// HELPERS //\n\n// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\n// in the given box\nfunction freeJoin(p1, p2, bbox) {\n  var p = new g.Point(p1.x, p2.y);\n  if (bbox.containsPoint(p)) p = new g.Point(p2.x, p1.y);\n  // kept for reference\n  // if (bbox.containsPoint(p)) p = null;\n\n  return p;\n}\n\n// returns either width or height of a bbox based on the given bearing\nfunction getBBoxSize(bbox, bearing) {\n  return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];\n}\n\n// simple bearing method (calculates only orthogonal cardinals)\nfunction getBearing(from, to) {\n  if (from.x === to.x) return from.y > to.y ? 'N' : 'S';\n  if (from.y === to.y) return from.x > to.x ? 'W' : 'E';\n  return null;\n}\n\n// transform point to a rect\nfunction getPointBox(p) {\n  return new g.Rect(p.x, p.y, 0, 0);\n}\nfunction getPaddingBox(opt) {\n  // if both provided, opt.padding wins over opt.elementPadding\n  var sides = util.normalizeSides(opt.padding || opt.elementPadding || 20);\n  return {\n    x: -sides.left,\n    y: -sides.top,\n    width: sides.left + sides.right,\n    height: sides.top + sides.bottom\n  };\n}\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n  return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n  return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n  if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n  // fallback: center of bbox\n  var sourceBBox = getSourceBBox(linkView, opt);\n  return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n  if (linkView.targetAnchor) return linkView.targetAnchor;\n\n  // fallback: center of bbox\n  var targetBBox = getTargetBBox(linkView, opt);\n  return targetBBox.center(); // default\n}\n\n// PARTIAL ROUTERS //\n\nfunction vertexVertex(from, to, bearing) {\n  var p1 = new g.Point(from.x, to.y);\n  var p2 = new g.Point(to.x, from.y);\n  var d1 = getBearing(from, p1);\n  var d2 = getBearing(from, p2);\n  var opposite = opposites[bearing];\n  var p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;\n  return {\n    points: [p],\n    direction: getBearing(p, to)\n  };\n}\nfunction elementVertex(from, to, fromBBox) {\n  var p = freeJoin(from, to, fromBBox);\n  return {\n    points: [p],\n    direction: getBearing(p, to)\n  };\n}\nfunction vertexElement(from, to, toBBox, bearing) {\n  var route = {};\n  var points = [new g.Point(from.x, to.y), new g.Point(to.x, from.y)];\n  var freePoints = points.filter(function (pt) {\n    return !toBBox.containsPoint(pt);\n  });\n  var freeBearingPoints = freePoints.filter(function (pt) {\n    return getBearing(pt, from) !== bearing;\n  });\n  var p;\n  if (freeBearingPoints.length > 0) {\n    // Try to pick a point which bears the same direction as the previous segment.\n\n    p = freeBearingPoints.filter(function (pt) {\n      return getBearing(from, pt) === bearing;\n    }).pop();\n    p = p || freeBearingPoints[0];\n    route.points = [p];\n    route.direction = getBearing(p, to);\n  } else {\n    // Here we found only points which are either contained in the element or they would create\n    // a link segment going in opposite direction from the previous one.\n    // We take the point inside element and move it outside the element in the direction the\n    // route is going. Now we can join this point with the current end (using freeJoin).\n\n    p = util.difference(points, freePoints)[0];\n    var p2 = new g.Point(to).move(p, -getBBoxSize(toBBox, bearing) / 2);\n    var p1 = freeJoin(p2, from, toBBox);\n    route.points = [p1, p2];\n    route.direction = getBearing(p2, to);\n  }\n  return route;\n}\nfunction elementElement(from, to, fromBBox, toBBox) {\n  var route = elementVertex(to, from, toBBox);\n  var p1 = route.points[0];\n  if (fromBBox.containsPoint(p1)) {\n    route = elementVertex(from, to, fromBBox);\n    var p2 = route.points[0];\n    if (toBBox.containsPoint(p2)) {\n      var fromBorder = new g.Point(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n      var toBorder = new g.Point(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n      var mid = new g.Line(fromBorder, toBorder).midpoint();\n      var startRoute = elementVertex(from, mid, fromBBox);\n      var endRoute = vertexVertex(mid, to, startRoute.direction);\n      route.points = [startRoute.points[0], endRoute.points[0]];\n      route.direction = endRoute.direction;\n    }\n  }\n  return route;\n}\n\n// Finds route for situations where one element is inside the other.\n// Typically the route is directed outside the outer element first and\n// then back towards the inner element.\nfunction insideElement(from, to, fromBBox, toBBox, bearing) {\n  var route = {};\n  var boundary = fromBBox.union(toBBox).inflate(1);\n\n  // start from the point which is closer to the boundary\n  var reversed = boundary.center().distance(to) > boundary.center().distance(from);\n  var start = reversed ? to : from;\n  var end = reversed ? from : to;\n  var p1, p2, p3;\n  if (bearing) {\n    // Points on circle with radius equals 'W + H` are always outside the rectangle\n    // with width W and height H if the center of that circle is the center of that rectangle.\n    p1 = g.Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n    p1 = boundary.pointNearestToPoint(p1).move(p1, -1);\n  } else {\n    p1 = boundary.pointNearestToPoint(start).move(start, 1);\n  }\n  p2 = freeJoin(p1, end, boundary);\n  if (p1.round().equals(p2.round())) {\n    p2 = g.Point.fromPolar(boundary.width + boundary.height, g.toRad(p1.theta(start)) + Math.PI / 2, end);\n    p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();\n    p3 = freeJoin(p1, p2, boundary);\n    route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n  } else {\n    route.points = reversed ? [p2, p1] : [p1, p2];\n  }\n  route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n  return route;\n}\n\n// MAIN ROUTER //\n\n// Return points through which a connection needs to be drawn in order to obtain an orthogonal link\n// routing from source to target going through `vertices`.\nexport function orthogonal(vertices, opt, linkView) {\n  var sourceBBox = getSourceBBox(linkView, opt);\n  var targetBBox = getTargetBBox(linkView, opt);\n  var sourceAnchor = getSourceAnchor(linkView, opt);\n  var targetAnchor = getTargetAnchor(linkView, opt);\n\n  // if anchor lies outside of bbox, the bbox expands to include it\n  sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));\n  targetBBox = targetBBox.union(getPointBox(targetAnchor));\n  vertices = util.toArray(vertices).map(g.Point);\n  vertices.unshift(sourceAnchor);\n  vertices.push(targetAnchor);\n  var bearing; // bearing of previous route segment\n\n  var orthogonalVertices = []; // the array of found orthogonal vertices to be returned\n  for (var i = 0, max = vertices.length - 1; i < max; i++) {\n    var route = null;\n    var from = vertices[i];\n    var to = vertices[i + 1];\n    var isOrthogonal = !!getBearing(from, to);\n    if (i === 0) {\n      // source\n\n      if (i + 1 === max) {\n        // route source -> target\n\n        // Expand one of the elements by 1px to detect situations when the two\n        // elements are positioned next to each other with no gap in between.\n        if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {\n          route = insideElement(from, to, sourceBBox, targetBBox);\n        } else if (!isOrthogonal) {\n          route = elementElement(from, to, sourceBBox, targetBBox);\n        }\n      } else {\n        // route source -> vertex\n\n        if (sourceBBox.containsPoint(to)) {\n          route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));\n        } else if (!isOrthogonal) {\n          route = elementVertex(from, to, sourceBBox);\n        }\n      }\n    } else if (i + 1 === max) {\n      // route vertex -> target\n\n      // prevent overlaps with previous line segment\n      var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;\n      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n        route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);\n      } else if (!isOrthogonal) {\n        route = vertexElement(from, to, targetBBox, bearing);\n      }\n    } else if (!isOrthogonal) {\n      // route vertex -> vertex\n      route = vertexVertex(from, to, bearing);\n    }\n\n    // applicable to all routes:\n\n    // set bearing for next iteration\n    if (route) {\n      Array.prototype.push.apply(orthogonalVertices, route.points);\n      bearing = route.direction;\n    } else {\n      // orthogonal route and not looped\n      bearing = getBearing(from, to);\n    }\n\n    // push `to` point to identified orthogonal vertices array\n    if (i + 1 < max) {\n      orthogonalVertices.push(to);\n    }\n  }\n  return orthogonalVertices;\n}","map":{"version":3,"names":["g","util","opposites","N","S","E","W","radians","Math","PI","freeJoin","p1","p2","bbox","p","Point","x","y","containsPoint","getBBoxSize","bearing","getBearing","from","to","getPointBox","Rect","getPaddingBox","opt","sides","normalizeSides","padding","elementPadding","left","top","width","right","height","bottom","getSourceBBox","linkView","sourceBBox","clone","moveAndExpand","getTargetBBox","targetBBox","getSourceAnchor","sourceAnchor","center","getTargetAnchor","targetAnchor","vertexVertex","d1","d2","opposite","points","direction","elementVertex","fromBBox","vertexElement","toBBox","route","freePoints","filter","pt","freeBearingPoints","length","pop","difference","move","elementElement","fromBorder","toBorder","mid","Line","midpoint","startRoute","endRoute","insideElement","boundary","union","inflate","reversed","distance","start","end","p3","fromPolar","pointNearestToPoint","round","equals","toRad","theta","orthogonal","vertices","toArray","map","unshift","push","orthogonalVertices","i","max","isOrthogonal","intersect","isOrthogonalLoop","Array","prototype","apply"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/routers/orthogonal.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\n\n// bearing -> opposite bearing\nvar opposites = {\n    N: 'S',\n    S: 'N',\n    E: 'W',\n    W: 'E'\n};\n\n// bearing -> radians\nvar radians = {\n    N: -Math.PI / 2 * 3,\n    S: -Math.PI / 2,\n    E: 0,\n    W: Math.PI\n};\n\n// HELPERS //\n\n// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\n// in the given box\nfunction freeJoin(p1, p2, bbox) {\n\n    var p = new g.Point(p1.x, p2.y);\n    if (bbox.containsPoint(p)) p = new g.Point(p2.x, p1.y);\n    // kept for reference\n    // if (bbox.containsPoint(p)) p = null;\n\n    return p;\n}\n\n// returns either width or height of a bbox based on the given bearing\nfunction getBBoxSize(bbox, bearing) {\n\n    return bbox[(bearing === 'W' || bearing === 'E') ? 'width' : 'height'];\n}\n\n// simple bearing method (calculates only orthogonal cardinals)\nfunction getBearing(from, to) {\n\n    if (from.x === to.x) return (from.y > to.y) ? 'N' : 'S';\n    if (from.y === to.y) return (from.x > to.x) ? 'W' : 'E';\n    return null;\n}\n\n// transform point to a rect\nfunction getPointBox(p) {\n\n    return new g.Rect(p.x, p.y, 0, 0);\n}\n\nfunction getPaddingBox(opt) {\n\n    // if both provided, opt.padding wins over opt.elementPadding\n    var sides = util.normalizeSides(opt.padding || opt.elementPadding || 20);\n\n    return {\n        x: -sides.left,\n        y: -sides.top,\n        width: sides.left + sides.right,\n        height: sides.top + sides.bottom\n    };\n}\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n\n    return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n\n    return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n\n// PARTIAL ROUTERS //\n\nfunction vertexVertex(from, to, bearing) {\n\n    var p1 = new g.Point(from.x, to.y);\n    var p2 = new g.Point(to.x, from.y);\n    var d1 = getBearing(from, p1);\n    var d2 = getBearing(from, p2);\n    var opposite = opposites[bearing];\n\n    var p = (d1 === bearing || (d1 !== opposite && (d2 === opposite || d2 !== bearing))) ? p1 : p2;\n\n    return { points: [p], direction: getBearing(p, to) };\n}\n\nfunction elementVertex(from, to, fromBBox) {\n\n    var p = freeJoin(from, to, fromBBox);\n\n    return { points: [p], direction: getBearing(p, to) };\n}\n\nfunction vertexElement(from, to, toBBox, bearing) {\n\n    var route = {};\n\n    var points = [new g.Point(from.x, to.y), new g.Point(to.x, from.y)];\n    var freePoints = points.filter(function(pt) {\n        return !toBBox.containsPoint(pt);\n    });\n    var freeBearingPoints = freePoints.filter(function(pt) {\n        return getBearing(pt, from) !== bearing;\n    });\n\n    var p;\n\n    if (freeBearingPoints.length > 0) {\n        // Try to pick a point which bears the same direction as the previous segment.\n\n        p = freeBearingPoints.filter(function(pt) {\n            return getBearing(from, pt) === bearing;\n        }).pop();\n        p = p || freeBearingPoints[0];\n\n        route.points = [p];\n        route.direction = getBearing(p, to);\n\n    } else {\n        // Here we found only points which are either contained in the element or they would create\n        // a link segment going in opposite direction from the previous one.\n        // We take the point inside element and move it outside the element in the direction the\n        // route is going. Now we can join this point with the current end (using freeJoin).\n\n        p = util.difference(points, freePoints)[0];\n\n        var p2 = (new g.Point(to)).move(p, -getBBoxSize(toBBox, bearing) / 2);\n        var p1 = freeJoin(p2, from, toBBox);\n\n        route.points = [p1, p2];\n        route.direction = getBearing(p2, to);\n    }\n\n    return route;\n}\n\nfunction elementElement(from, to, fromBBox, toBBox) {\n\n    var route = elementVertex(to, from, toBBox);\n    var p1 = route.points[0];\n\n    if (fromBBox.containsPoint(p1)) {\n\n        route = elementVertex(from, to, fromBBox);\n        var p2 = route.points[0];\n\n        if (toBBox.containsPoint(p2)) {\n\n            var fromBorder = (new g.Point(from)).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n            var toBorder = (new g.Point(to)).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n            var mid = (new g.Line(fromBorder, toBorder)).midpoint();\n\n            var startRoute = elementVertex(from, mid, fromBBox);\n            var endRoute = vertexVertex(mid, to, startRoute.direction);\n\n            route.points = [startRoute.points[0], endRoute.points[0]];\n            route.direction = endRoute.direction;\n        }\n    }\n\n    return route;\n}\n\n// Finds route for situations where one element is inside the other.\n// Typically the route is directed outside the outer element first and\n// then back towards the inner element.\nfunction insideElement(from, to, fromBBox, toBBox, bearing) {\n\n    var route = {};\n    var boundary = fromBBox.union(toBBox).inflate(1);\n\n    // start from the point which is closer to the boundary\n    var reversed = boundary.center().distance(to) > boundary.center().distance(from);\n    var start = reversed ? to : from;\n    var end = reversed ? from : to;\n\n    var p1, p2, p3;\n\n    if (bearing) {\n        // Points on circle with radius equals 'W + H` are always outside the rectangle\n        // with width W and height H if the center of that circle is the center of that rectangle.\n        p1 = g.Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n        p1 = boundary.pointNearestToPoint(p1).move(p1, -1);\n\n    } else {\n        p1 = boundary.pointNearestToPoint(start).move(start, 1);\n    }\n\n    p2 = freeJoin(p1, end, boundary);\n\n    if (p1.round().equals(p2.round())) {\n        p2 = g.Point.fromPolar(boundary.width + boundary.height, g.toRad(p1.theta(start)) + Math.PI / 2, end);\n        p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();\n        p3 = freeJoin(p1, p2, boundary);\n        route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n\n    } else {\n        route.points = reversed ? [p2, p1] : [p1, p2];\n    }\n\n    route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n\n    return route;\n}\n\n// MAIN ROUTER //\n\n// Return points through which a connection needs to be drawn in order to obtain an orthogonal link\n// routing from source to target going through `vertices`.\nexport function orthogonal(vertices, opt, linkView) {\n\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    var targetAnchor = getTargetAnchor(linkView, opt);\n\n    // if anchor lies outside of bbox, the bbox expands to include it\n    sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));\n    targetBBox = targetBBox.union(getPointBox(targetAnchor));\n\n    vertices = util.toArray(vertices).map(g.Point);\n    vertices.unshift(sourceAnchor);\n    vertices.push(targetAnchor);\n\n    var bearing; // bearing of previous route segment\n\n    var orthogonalVertices = []; // the array of found orthogonal vertices to be returned\n    for (var i = 0, max = vertices.length - 1; i < max; i++) {\n\n        var route = null;\n\n        var from = vertices[i];\n        var to = vertices[i + 1];\n\n        var isOrthogonal = !!getBearing(from, to);\n\n        if (i === 0) { // source\n\n            if (i + 1 === max) { // route source -> target\n\n                // Expand one of the elements by 1px to detect situations when the two\n                // elements are positioned next to each other with no gap in between.\n                if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {\n                    route = insideElement(from, to, sourceBBox, targetBBox);\n\n                } else if (!isOrthogonal) {\n                    route = elementElement(from, to, sourceBBox, targetBBox);\n                }\n\n            } else { // route source -> vertex\n\n                if (sourceBBox.containsPoint(to)) {\n                    route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));\n\n                } else if (!isOrthogonal) {\n                    route = elementVertex(from, to, sourceBBox);\n                }\n            }\n\n        } else if (i + 1 === max) { // route vertex -> target\n\n            // prevent overlaps with previous line segment\n            var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;\n\n            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n                route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);\n\n            } else if (!isOrthogonal) {\n                route = vertexElement(from, to, targetBBox, bearing);\n            }\n\n        } else if (!isOrthogonal) { // route vertex -> vertex\n            route = vertexVertex(from, to, bearing);\n        }\n\n        // applicable to all routes:\n\n        // set bearing for next iteration\n        if (route) {\n            Array.prototype.push.apply(orthogonalVertices, route.points);\n            bearing = route.direction;\n\n        } else {\n            // orthogonal route and not looped\n            bearing = getBearing(from, to);\n        }\n\n        // push `to` point to identified orthogonal vertices array\n        if (i + 1 < max) {\n            orthogonalVertices.push(to);\n        }\n    }\n\n    return orthogonalVertices;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}