{"ast":null,"code":"import { uniq, toArray, isEmpty } from './util.mjs';\n\n// Clone `cells` returning an object that maps the original cell ID to the clone. The number\n// of clones is exactly the same as the `cells.length`.\n// This function simply clones all the `cells`. However, it also reconstructs\n// all the `source/target` and `parent/embed` references within the `cells`.\n// This is the main difference from the `cell.clone()` method. The\n// `cell.clone()` method works on one single cell only.\n// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n// the source and target of the link `L2` is changed to point to `A2` and `B2`.\nexport function cloneCells(cells) {\n  cells = uniq(cells);\n\n  // A map of the form [original cell ID] -> [clone] helping\n  // us to reconstruct references for source/target and parent/embeds.\n  // This is also the returned value.\n  const cloneMap = toArray(cells).reduce(function (map, cell) {\n    map[cell.id] = cell.clone();\n    return map;\n  }, {});\n  toArray(cells).forEach(function (cell) {\n    const clone = cloneMap[cell.id];\n    // assert(clone exists)\n\n    if (clone.isLink()) {\n      const source = clone.source();\n      const target = clone.target();\n      if (source.id && cloneMap[source.id]) {\n        // Source points to an element and the element is among the clones.\n        // => Update the source of the cloned link.\n        clone.prop('source/id', cloneMap[source.id].id);\n      }\n      if (target.id && cloneMap[target.id]) {\n        // Target points to an element and the element is among the clones.\n        // => Update the target of the cloned link.\n        clone.prop('target/id', cloneMap[target.id].id);\n      }\n    }\n\n    // Find the parent of the original cell\n    const parent = cell.get('parent');\n    if (parent && cloneMap[parent]) {\n      clone.set('parent', cloneMap[parent].id);\n    }\n\n    // Find the embeds of the original cell\n    const embeds = toArray(cell.get('embeds')).reduce(function (newEmbeds, embed) {\n      // Embedded cells that are not being cloned can not be carried\n      // over with other embedded cells.\n      if (cloneMap[embed]) {\n        newEmbeds.push(cloneMap[embed].id);\n      }\n      return newEmbeds;\n    }, []);\n    if (!isEmpty(embeds)) {\n      clone.set('embeds', embeds);\n    }\n  });\n  return cloneMap;\n}","map":{"version":3,"names":["uniq","toArray","isEmpty","cloneCells","cells","cloneMap","reduce","map","cell","id","clone","forEach","isLink","source","target","prop","parent","get","set","embeds","newEmbeds","embed","push"],"sources":["/Users/guankaiyuan/ReactTs/node_modules/.pnpm/@joint+core@4.0.1/node_modules/@joint/core/src/util/cloneCells.mjs"],"sourcesContent":["import { uniq, toArray, isEmpty } from './util.mjs';\n\n// Clone `cells` returning an object that maps the original cell ID to the clone. The number\n// of clones is exactly the same as the `cells.length`.\n// This function simply clones all the `cells`. However, it also reconstructs\n// all the `source/target` and `parent/embed` references within the `cells`.\n// This is the main difference from the `cell.clone()` method. The\n// `cell.clone()` method works on one single cell only.\n// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n// the source and target of the link `L2` is changed to point to `A2` and `B2`.\nexport function cloneCells(cells) {\n\n    cells = uniq(cells);\n\n    // A map of the form [original cell ID] -> [clone] helping\n    // us to reconstruct references for source/target and parent/embeds.\n    // This is also the returned value.\n    const cloneMap = toArray(cells).reduce(function(map, cell) {\n        map[cell.id] = cell.clone();\n        return map;\n    }, {});\n\n    toArray(cells).forEach(function(cell) {\n\n        const clone = cloneMap[cell.id];\n        // assert(clone exists)\n\n        if (clone.isLink()) {\n            const source = clone.source();\n            const target = clone.target();\n            if (source.id && cloneMap[source.id]) {\n                // Source points to an element and the element is among the clones.\n                // => Update the source of the cloned link.\n                clone.prop('source/id', cloneMap[source.id].id);\n            }\n            if (target.id && cloneMap[target.id]) {\n                // Target points to an element and the element is among the clones.\n                // => Update the target of the cloned link.\n                clone.prop('target/id', cloneMap[target.id].id);\n            }\n        }\n\n        // Find the parent of the original cell\n        const parent = cell.get('parent');\n        if (parent && cloneMap[parent]) {\n            clone.set('parent', cloneMap[parent].id);\n        }\n\n        // Find the embeds of the original cell\n        const embeds = toArray(cell.get('embeds')).reduce(function(newEmbeds, embed) {\n            // Embedded cells that are not being cloned can not be carried\n            // over with other embedded cells.\n            if (cloneMap[embed]) {\n                newEmbeds.push(cloneMap[embed].id);\n            }\n            return newEmbeds;\n        }, []);\n\n        if (!isEmpty(embeds)) {\n            clone.set('embeds', embeds);\n        }\n    });\n\n    return cloneMap;\n}\n\n"],"mappings":"AAAA,SAASA,IAAI,EAAEC,OAAO,EAAEC,OAAO,QAAQ,YAAY;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAUA,CAACC,KAAK,EAAE;EAE9BA,KAAK,GAAGJ,IAAI,CAACI,KAAK,CAAC;;EAEnB;EACA;EACA;EACA,MAAMC,QAAQ,GAAGJ,OAAO,CAACG,KAAK,CAAC,CAACE,MAAM,CAAC,UAASC,GAAG,EAAEC,IAAI,EAAE;IACvDD,GAAG,CAACC,IAAI,CAACC,EAAE,CAAC,GAAGD,IAAI,CAACE,KAAK,CAAC,CAAC;IAC3B,OAAOH,GAAG;EACd,CAAC,EAAE,CAAC,CAAC,CAAC;EAENN,OAAO,CAACG,KAAK,CAAC,CAACO,OAAO,CAAC,UAASH,IAAI,EAAE;IAElC,MAAME,KAAK,GAAGL,QAAQ,CAACG,IAAI,CAACC,EAAE,CAAC;IAC/B;;IAEA,IAAIC,KAAK,CAACE,MAAM,CAAC,CAAC,EAAE;MAChB,MAAMC,MAAM,GAAGH,KAAK,CAACG,MAAM,CAAC,CAAC;MAC7B,MAAMC,MAAM,GAAGJ,KAAK,CAACI,MAAM,CAAC,CAAC;MAC7B,IAAID,MAAM,CAACJ,EAAE,IAAIJ,QAAQ,CAACQ,MAAM,CAACJ,EAAE,CAAC,EAAE;QAClC;QACA;QACAC,KAAK,CAACK,IAAI,CAAC,WAAW,EAAEV,QAAQ,CAACQ,MAAM,CAACJ,EAAE,CAAC,CAACA,EAAE,CAAC;MACnD;MACA,IAAIK,MAAM,CAACL,EAAE,IAAIJ,QAAQ,CAACS,MAAM,CAACL,EAAE,CAAC,EAAE;QAClC;QACA;QACAC,KAAK,CAACK,IAAI,CAAC,WAAW,EAAEV,QAAQ,CAACS,MAAM,CAACL,EAAE,CAAC,CAACA,EAAE,CAAC;MACnD;IACJ;;IAEA;IACA,MAAMO,MAAM,GAAGR,IAAI,CAACS,GAAG,CAAC,QAAQ,CAAC;IACjC,IAAID,MAAM,IAAIX,QAAQ,CAACW,MAAM,CAAC,EAAE;MAC5BN,KAAK,CAACQ,GAAG,CAAC,QAAQ,EAAEb,QAAQ,CAACW,MAAM,CAAC,CAACP,EAAE,CAAC;IAC5C;;IAEA;IACA,MAAMU,MAAM,GAAGlB,OAAO,CAACO,IAAI,CAACS,GAAG,CAAC,QAAQ,CAAC,CAAC,CAACX,MAAM,CAAC,UAASc,SAAS,EAAEC,KAAK,EAAE;MACzE;MACA;MACA,IAAIhB,QAAQ,CAACgB,KAAK,CAAC,EAAE;QACjBD,SAAS,CAACE,IAAI,CAACjB,QAAQ,CAACgB,KAAK,CAAC,CAACZ,EAAE,CAAC;MACtC;MACA,OAAOW,SAAS;IACpB,CAAC,EAAE,EAAE,CAAC;IAEN,IAAI,CAAClB,OAAO,CAACiB,MAAM,CAAC,EAAE;MAClBT,KAAK,CAACQ,GAAG,CAAC,QAAQ,EAAEC,MAAM,CAAC;IAC/B;EACJ,CAAC,CAAC;EAEF,OAAOd,QAAQ;AACnB"},"metadata":{},"sourceType":"module","externalDependencies":[]}